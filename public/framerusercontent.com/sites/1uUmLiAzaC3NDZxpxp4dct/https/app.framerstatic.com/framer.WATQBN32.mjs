import {
  AnimatePresence,
  AsyncMotionValueAnimation,
  DOMKeyframesResolver,
  DeprecatedLayoutGroupContext,
  DragControls,
  GroupAnimation,
  GroupAnimationWithThen,
  JSAnimation,
  KeyframeResolver,
  LayoutGroup,
  LazyMotion,
  MotionConfig,
  MotionConfigContext,
  MotionContext,
  MotionGlobalConfig,
  MotionValue,
  NativeAnimation,
  NativeAnimationExtended,
  NativeAnimationWrapper,
  PopChild,
  PresenceChild,
  PresenceContext,
  SubscriptionManager,
  SwitchLayoutGroupContext,
  ViewTransitionBuilder,
  VisualElement,
  WillChangeMotionValue,
  acceleratedValues,
  activeAnimations,
  addAttrValue,
  addPointerEvent,
  addPointerInfo,
  addScaleCorrector,
  addStyleValue,
  addUniqueItem,
  alpha,
  analyseComplexValue,
  animate,
  animateMini,
  animateValue,
  animateView,
  animateVisualElement,
  animationControls,
  animationMapKey,
  animations,
  anticipate,
  applyGeneratorOptions,
  applyPxDefaults,
  attachSpring,
  attrEffect,
  backIn,
  backInOut,
  backOut,
  buildTransform,
  calcGeneratorDuration,
  calcLength,
  cancelFrame,
  cancelMicrotask,
  cancelSync,
  circIn,
  circInOut,
  circOut,
  clamp,
  collectMotionValues,
  color,
  complex,
  convertOffsetToTimes,
  createBox,
  createGeneratorEasing,
  createRenderBatcher,
  createScopedAnimate,
  cubicBezier,
  cubicBezierAsString,
  defaultEasing,
  defaultOffset,
  defaultTransformValue,
  defaultValueTypes,
  degrees,
  delay,
  dimensionValueTypes,
  disableInstantTransitions,
  distance,
  distance2D,
  domAnimation,
  domMax,
  domMin,
  easeIn,
  easeInOut,
  easeOut,
  easingDefinitionToFunction,
  fillOffset,
  fillWildcards,
  filterProps,
  findDimensionValueType,
  findValueType,
  flushKeyframeResolvers,
  frame,
  frameData,
  frameSteps,
  generateLinearEasing,
  getAnimatableNone,
  getAnimationMap,
  getComputedStyle as getComputedStyle2,
  getDefaultValueType,
  getEasingForSegment,
  getMixer,
  getOriginIndex,
  getValueAsType,
  getValueTransition,
  getVariableValue,
  getViewAnimationLayerInfo,
  getViewAnimations,
  hasWarned,
  hex,
  hover,
  hsla,
  hslaToRgba,
  inView,
  inertia,
  interpolate,
  invariant,
  invisibleValues,
  isBezierDefinition,
  isBrowser,
  isCSSVariableName,
  isCSSVariableToken,
  isDragActive,
  isDragging,
  isEasingArray,
  isGenerator,
  isHTMLElement,
  isMotionComponent,
  isMotionValue,
  isNodeOrChild,
  isNumericalString,
  isObject,
  isPrimaryPointer,
  isSVGElement,
  isSVGSVGElement,
  isValidMotionProp,
  isWaapiSupportedEasing,
  isZeroValueString,
  keyframes,
  m,
  makeAnimationInstant,
  makeUseVisualState,
  mapEasingToNativeEasing,
  mapValue,
  maxGeneratorDuration,
  memo,
  microtask,
  millisecondsToSeconds,
  mirrorEasing,
  mix,
  mixArray,
  mixColor,
  mixComplex,
  mixImmediate,
  mixLinearColor,
  mixNumber,
  mixObject,
  mixVisibility,
  motion,
  motionValue,
  moveItem,
  namespace_exports,
  noop,
  number,
  numberValueTypes,
  observeTimeline,
  optimizedAppearDataAttribute,
  parseCSSVariable,
  parseValueFromTransform,
  percent,
  pipe,
  positionalKeys,
  press,
  progress,
  progressPercentage,
  propEffect,
  px,
  readTransformValue,
  recordStats,
  removeItem,
  resize,
  resolveElements,
  resolveMotionValue,
  reverseEasing,
  rgbUnit,
  rgba,
  scale,
  scroll,
  scrollInfo,
  secondsToMilliseconds,
  setDragLock,
  setStyle,
  spring,
  springValue,
  stagger,
  startOptimizedAppearAnimation,
  startWaapiAnimation,
  statsBuffer,
  steps,
  styleEffect,
  supportedWaapiEasing,
  supportsBrowserAnimation,
  supportsFlags,
  supportsLinearEasing,
  supportsPartialKeyframes,
  supportsScrollTimeline,
  svgEffect,
  sync,
  testValueType,
  time,
  transform,
  transformPropOrder,
  transformProps,
  transformValue,
  transformValueTypes,
  unwrapMotionComponent,
  useAnimate,
  useAnimateMini,
  useAnimatedState,
  useAnimation,
  useAnimationControls,
  useAnimationFrame,
  useComposedRefs,
  useCycle,
  useDomEvent,
  useDragControls,
  useElementScroll,
  useForceUpdate,
  useInView,
  useInstantLayoutTransition,
  useInstantTransition,
  useInvertedScale,
  useIsPresent,
  useIsomorphicLayoutEffect,
  useMotionTemplate,
  useMotionValue,
  useMotionValueEvent,
  usePageInView,
  usePresence,
  usePresenceData,
  useReducedMotion,
  useReducedMotionConfig,
  useResetProjection,
  useScroll,
  useSpring,
  useTime,
  useTransform,
  useUnmountEffect,
  useVelocity,
  useViewportScroll,
  useWillChange,
  velocityPerSecond,
  vh,
  visualElementStore,
  vw,
  warnOnce,
  warning,
  wrap
} from "./chunk-QUOCKOA6.mjs";
import {
  __commonJS,
  __decorateElement,
  __decoratorMetadata,
  __decoratorStart,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __runInitializers,
  __toESM
} from "./chunk-QODBXAUS.mjs";

// ../../../node_modules/hsluv/dist/hsluv.cjs
var require_hsluv = __commonJS({
  "../../../node_modules/hsluv/dist/hsluv.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hsluv = void 0;
    var Hsluv2 = class _Hsluv {
      constructor() {
        this.hex = "#000000";
        this.rgb_r = 0;
        this.rgb_g = 0;
        this.rgb_b = 0;
        this.xyz_x = 0;
        this.xyz_y = 0;
        this.xyz_z = 0;
        this.luv_l = 0;
        this.luv_u = 0;
        this.luv_v = 0;
        this.lch_l = 0;
        this.lch_c = 0;
        this.lch_h = 0;
        this.hsluv_h = 0;
        this.hsluv_s = 0;
        this.hsluv_l = 0;
        this.hpluv_h = 0;
        this.hpluv_p = 0;
        this.hpluv_l = 0;
        this.r0s = 0;
        this.r0i = 0;
        this.r1s = 0;
        this.r1i = 0;
        this.g0s = 0;
        this.g0i = 0;
        this.g1s = 0;
        this.g1i = 0;
        this.b0s = 0;
        this.b0i = 0;
        this.b1s = 0;
        this.b1i = 0;
      }
      static fromLinear(c) {
        if (c <= 31308e-7) {
          return 12.92 * c;
        } else {
          return 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
        }
      }
      static toLinear(c) {
        if (c > 0.04045) {
          return Math.pow((c + 0.055) / 1.055, 2.4);
        } else {
          return c / 12.92;
        }
      }
      static yToL(Y) {
        if (Y <= _Hsluv.epsilon) {
          return Y / _Hsluv.refY * _Hsluv.kappa;
        } else {
          return 116 * Math.pow(Y / _Hsluv.refY, 1 / 3) - 16;
        }
      }
      static lToY(L) {
        if (L <= 8) {
          return _Hsluv.refY * L / _Hsluv.kappa;
        } else {
          return _Hsluv.refY * Math.pow((L + 16) / 116, 3);
        }
      }
      static rgbChannelToHex(chan) {
        const c = Math.round(chan * 255);
        const digit2 = c % 16;
        const digit1 = (c - digit2) / 16 | 0;
        return _Hsluv.hexChars.charAt(digit1) + _Hsluv.hexChars.charAt(digit2);
      }
      static hexToRgbChannel(hex2, offset) {
        const digit1 = _Hsluv.hexChars.indexOf(hex2.charAt(offset));
        const digit2 = _Hsluv.hexChars.indexOf(hex2.charAt(offset + 1));
        const n = digit1 * 16 + digit2;
        return n / 255;
      }
      static distanceFromOriginAngle(slope, intercept, angle) {
        const d = intercept / (Math.sin(angle) - slope * Math.cos(angle));
        if (d < 0) {
          return Infinity;
        } else {
          return d;
        }
      }
      static distanceFromOrigin(slope, intercept) {
        return Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
      }
      static min6(f1, f2, f3, f4, f5, f6) {
        return Math.min(f1, Math.min(f2, Math.min(f3, Math.min(f4, Math.min(f5, f6)))));
      }
      rgbToHex() {
        this.hex = "#";
        this.hex += _Hsluv.rgbChannelToHex(this.rgb_r);
        this.hex += _Hsluv.rgbChannelToHex(this.rgb_g);
        this.hex += _Hsluv.rgbChannelToHex(this.rgb_b);
      }
      hexToRgb() {
        this.hex = this.hex.toLowerCase();
        this.rgb_r = _Hsluv.hexToRgbChannel(this.hex, 1);
        this.rgb_g = _Hsluv.hexToRgbChannel(this.hex, 3);
        this.rgb_b = _Hsluv.hexToRgbChannel(this.hex, 5);
      }
      xyzToRgb() {
        this.rgb_r = _Hsluv.fromLinear(_Hsluv.m_r0 * this.xyz_x + _Hsluv.m_r1 * this.xyz_y + _Hsluv.m_r2 * this.xyz_z);
        this.rgb_g = _Hsluv.fromLinear(_Hsluv.m_g0 * this.xyz_x + _Hsluv.m_g1 * this.xyz_y + _Hsluv.m_g2 * this.xyz_z);
        this.rgb_b = _Hsluv.fromLinear(_Hsluv.m_b0 * this.xyz_x + _Hsluv.m_b1 * this.xyz_y + _Hsluv.m_b2 * this.xyz_z);
      }
      rgbToXyz() {
        const lr = _Hsluv.toLinear(this.rgb_r);
        const lg = _Hsluv.toLinear(this.rgb_g);
        const lb = _Hsluv.toLinear(this.rgb_b);
        this.xyz_x = 0.41239079926595 * lr + 0.35758433938387 * lg + 0.18048078840183 * lb;
        this.xyz_y = 0.21263900587151 * lr + 0.71516867876775 * lg + 0.072192315360733 * lb;
        this.xyz_z = 0.019330818715591 * lr + 0.11919477979462 * lg + 0.95053215224966 * lb;
      }
      xyzToLuv() {
        const divider = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z;
        let varU = 4 * this.xyz_x;
        let varV = 9 * this.xyz_y;
        if (divider !== 0) {
          varU /= divider;
          varV /= divider;
        } else {
          varU = NaN;
          varV = NaN;
        }
        this.luv_l = _Hsluv.yToL(this.xyz_y);
        if (this.luv_l === 0) {
          this.luv_u = 0;
          this.luv_v = 0;
        } else {
          this.luv_u = 13 * this.luv_l * (varU - _Hsluv.refU);
          this.luv_v = 13 * this.luv_l * (varV - _Hsluv.refV);
        }
      }
      luvToXyz() {
        if (this.luv_l === 0) {
          this.xyz_x = 0;
          this.xyz_y = 0;
          this.xyz_z = 0;
          return;
        }
        const varU = this.luv_u / (13 * this.luv_l) + _Hsluv.refU;
        const varV = this.luv_v / (13 * this.luv_l) + _Hsluv.refV;
        this.xyz_y = _Hsluv.lToY(this.luv_l);
        this.xyz_x = 0 - 9 * this.xyz_y * varU / ((varU - 4) * varV - varU * varV);
        this.xyz_z = (9 * this.xyz_y - 15 * varV * this.xyz_y - varV * this.xyz_x) / (3 * varV);
      }
      luvToLch() {
        this.lch_l = this.luv_l;
        this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v);
        if (this.lch_c < 1e-8) {
          this.lch_h = 0;
        } else {
          const hrad = Math.atan2(this.luv_v, this.luv_u);
          this.lch_h = hrad * 180 / Math.PI;
          if (this.lch_h < 0) {
            this.lch_h = 360 + this.lch_h;
          }
        }
      }
      lchToLuv() {
        const hrad = this.lch_h / 180 * Math.PI;
        this.luv_l = this.lch_l;
        this.luv_u = Math.cos(hrad) * this.lch_c;
        this.luv_v = Math.sin(hrad) * this.lch_c;
      }
      calculateBoundingLines(l) {
        const sub1 = Math.pow(l + 16, 3) / 1560896;
        const sub2 = sub1 > _Hsluv.epsilon ? sub1 : l / _Hsluv.kappa;
        const s1r = sub2 * (284517 * _Hsluv.m_r0 - 94839 * _Hsluv.m_r2);
        const s2r = sub2 * (838422 * _Hsluv.m_r2 + 769860 * _Hsluv.m_r1 + 731718 * _Hsluv.m_r0);
        const s3r = sub2 * (632260 * _Hsluv.m_r2 - 126452 * _Hsluv.m_r1);
        const s1g = sub2 * (284517 * _Hsluv.m_g0 - 94839 * _Hsluv.m_g2);
        const s2g = sub2 * (838422 * _Hsluv.m_g2 + 769860 * _Hsluv.m_g1 + 731718 * _Hsluv.m_g0);
        const s3g = sub2 * (632260 * _Hsluv.m_g2 - 126452 * _Hsluv.m_g1);
        const s1b = sub2 * (284517 * _Hsluv.m_b0 - 94839 * _Hsluv.m_b2);
        const s2b = sub2 * (838422 * _Hsluv.m_b2 + 769860 * _Hsluv.m_b1 + 731718 * _Hsluv.m_b0);
        const s3b = sub2 * (632260 * _Hsluv.m_b2 - 126452 * _Hsluv.m_b1);
        this.r0s = s1r / s3r;
        this.r0i = s2r * l / s3r;
        this.r1s = s1r / (s3r + 126452);
        this.r1i = (s2r - 769860) * l / (s3r + 126452);
        this.g0s = s1g / s3g;
        this.g0i = s2g * l / s3g;
        this.g1s = s1g / (s3g + 126452);
        this.g1i = (s2g - 769860) * l / (s3g + 126452);
        this.b0s = s1b / s3b;
        this.b0i = s2b * l / s3b;
        this.b1s = s1b / (s3b + 126452);
        this.b1i = (s2b - 769860) * l / (s3b + 126452);
      }
      calcMaxChromaHpluv() {
        const r0 = _Hsluv.distanceFromOrigin(this.r0s, this.r0i);
        const r1 = _Hsluv.distanceFromOrigin(this.r1s, this.r1i);
        const g0 = _Hsluv.distanceFromOrigin(this.g0s, this.g0i);
        const g1 = _Hsluv.distanceFromOrigin(this.g1s, this.g1i);
        const b0 = _Hsluv.distanceFromOrigin(this.b0s, this.b0i);
        const b1 = _Hsluv.distanceFromOrigin(this.b1s, this.b1i);
        return _Hsluv.min6(r0, r1, g0, g1, b0, b1);
      }
      calcMaxChromaHsluv(h) {
        const hueRad = h / 360 * Math.PI * 2;
        const r0 = _Hsluv.distanceFromOriginAngle(this.r0s, this.r0i, hueRad);
        const r1 = _Hsluv.distanceFromOriginAngle(this.r1s, this.r1i, hueRad);
        const g0 = _Hsluv.distanceFromOriginAngle(this.g0s, this.g0i, hueRad);
        const g1 = _Hsluv.distanceFromOriginAngle(this.g1s, this.g1i, hueRad);
        const b0 = _Hsluv.distanceFromOriginAngle(this.b0s, this.b0i, hueRad);
        const b1 = _Hsluv.distanceFromOriginAngle(this.b1s, this.b1i, hueRad);
        return _Hsluv.min6(r0, r1, g0, g1, b0, b1);
      }
      hsluvToLch() {
        if (this.hsluv_l > 99.9999999) {
          this.lch_l = 100;
          this.lch_c = 0;
        } else if (this.hsluv_l < 1e-8) {
          this.lch_l = 0;
          this.lch_c = 0;
        } else {
          this.lch_l = this.hsluv_l;
          this.calculateBoundingLines(this.hsluv_l);
          const max = this.calcMaxChromaHsluv(this.hsluv_h);
          this.lch_c = max / 100 * this.hsluv_s;
        }
        this.lch_h = this.hsluv_h;
      }
      lchToHsluv() {
        if (this.lch_l > 99.9999999) {
          this.hsluv_s = 0;
          this.hsluv_l = 100;
        } else if (this.lch_l < 1e-8) {
          this.hsluv_s = 0;
          this.hsluv_l = 0;
        } else {
          this.calculateBoundingLines(this.lch_l);
          const max = this.calcMaxChromaHsluv(this.lch_h);
          this.hsluv_s = this.lch_c / max * 100;
          this.hsluv_l = this.lch_l;
        }
        this.hsluv_h = this.lch_h;
      }
      hpluvToLch() {
        if (this.hpluv_l > 99.9999999) {
          this.lch_l = 100;
          this.lch_c = 0;
        } else if (this.hpluv_l < 1e-8) {
          this.lch_l = 0;
          this.lch_c = 0;
        } else {
          this.lch_l = this.hpluv_l;
          this.calculateBoundingLines(this.hpluv_l);
          const max = this.calcMaxChromaHpluv();
          this.lch_c = max / 100 * this.hpluv_p;
        }
        this.lch_h = this.hpluv_h;
      }
      lchToHpluv() {
        if (this.lch_l > 99.9999999) {
          this.hpluv_p = 0;
          this.hpluv_l = 100;
        } else if (this.lch_l < 1e-8) {
          this.hpluv_p = 0;
          this.hpluv_l = 0;
        } else {
          this.calculateBoundingLines(this.lch_l);
          const max = this.calcMaxChromaHpluv();
          this.hpluv_p = this.lch_c / max * 100;
          this.hpluv_l = this.lch_l;
        }
        this.hpluv_h = this.lch_h;
      }
      hsluvToRgb() {
        this.hsluvToLch();
        this.lchToLuv();
        this.luvToXyz();
        this.xyzToRgb();
      }
      hpluvToRgb() {
        this.hpluvToLch();
        this.lchToLuv();
        this.luvToXyz();
        this.xyzToRgb();
      }
      hsluvToHex() {
        this.hsluvToRgb();
        this.rgbToHex();
      }
      hpluvToHex() {
        this.hpluvToRgb();
        this.rgbToHex();
      }
      rgbToHsluv() {
        this.rgbToXyz();
        this.xyzToLuv();
        this.luvToLch();
        this.lchToHpluv();
        this.lchToHsluv();
      }
      rgbToHpluv() {
        this.rgbToXyz();
        this.xyzToLuv();
        this.luvToLch();
        this.lchToHpluv();
        this.lchToHpluv();
      }
      hexToHsluv() {
        this.hexToRgb();
        this.rgbToHsluv();
      }
      hexToHpluv() {
        this.hexToRgb();
        this.rgbToHpluv();
      }
    };
    exports.Hsluv = Hsluv2;
    Hsluv2.hexChars = "0123456789abcdef";
    Hsluv2.refY = 1;
    Hsluv2.refU = 0.19783000664283;
    Hsluv2.refV = 0.46831999493879;
    Hsluv2.kappa = 903.2962962;
    Hsluv2.epsilon = 0.0088564516;
    Hsluv2.m_r0 = 3.240969941904521;
    Hsluv2.m_r1 = -1.537383177570093;
    Hsluv2.m_r2 = -0.498610760293;
    Hsluv2.m_g0 = -0.96924363628087;
    Hsluv2.m_g1 = 1.87596750150772;
    Hsluv2.m_g2 = 0.041555057407175;
    Hsluv2.m_b0 = 0.055630079696993;
    Hsluv2.m_b1 = -0.20397695888897;
    Hsluv2.m_b2 = 1.056971514242878;
  }
});

// ../../../node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../../node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix3 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix3 = false;
    }
    function EE(fn, context, once2) {
      this.fn = fn;
      this.context = context;
      this.once = once2 || false;
    }
    function addListener(emitter, event, fn, context, once2) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once2), evt = prefix3 ? prefix3 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix3 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix3 ? prefix3 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix3 ? prefix3 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix3 ? prefix3 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once2(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once2) {
      var evt = prefix3 ? prefix3 + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once2 && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix3 ? prefix3 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix3;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// ../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS({
  "../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js"(exports) {
    "use strict";
    var b = "function" === typeof Symbol && Symbol.for;
    var c = b ? Symbol.for("react.element") : 60103;
    var d = b ? Symbol.for("react.portal") : 60106;
    var e = b ? Symbol.for("react.fragment") : 60107;
    var f = b ? Symbol.for("react.strict_mode") : 60108;
    var g = b ? Symbol.for("react.profiler") : 60114;
    var h = b ? Symbol.for("react.provider") : 60109;
    var k = b ? Symbol.for("react.context") : 60110;
    var l = b ? Symbol.for("react.async_mode") : 60111;
    var m2 = b ? Symbol.for("react.concurrent_mode") : 60111;
    var n = b ? Symbol.for("react.forward_ref") : 60112;
    var p = b ? Symbol.for("react.suspense") : 60113;
    var q = b ? Symbol.for("react.suspense_list") : 60120;
    var r = b ? Symbol.for("react.memo") : 60115;
    var t = b ? Symbol.for("react.lazy") : 60116;
    var v = b ? Symbol.for("react.block") : 60121;
    var w = b ? Symbol.for("react.fundamental") : 60117;
    var x = b ? Symbol.for("react.responder") : 60118;
    var y = b ? Symbol.for("react.scope") : 60119;
    function z(a) {
      if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch (u) {
          case c:
            switch (a = a.type, a) {
              case l:
              case m2:
              case e:
              case g:
              case f:
              case p:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case n:
                  case t:
                  case r:
                  case h:
                    return a;
                  default:
                    return u;
                }
            }
          case d:
            return u;
        }
      }
    }
    function A(a) {
      return z(a) === m2;
    }
    exports.AsyncMode = l;
    exports.ConcurrentMode = m2;
    exports.ContextConsumer = k;
    exports.ContextProvider = h;
    exports.Element = c;
    exports.ForwardRef = n;
    exports.Fragment = e;
    exports.Lazy = t;
    exports.Memo = r;
    exports.Portal = d;
    exports.Profiler = g;
    exports.StrictMode = f;
    exports.Suspense = p;
    exports.isAsyncMode = function(a) {
      return A(a) || z(a) === l;
    };
    exports.isConcurrentMode = A;
    exports.isContextConsumer = function(a) {
      return z(a) === k;
    };
    exports.isContextProvider = function(a) {
      return z(a) === h;
    };
    exports.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c;
    };
    exports.isForwardRef = function(a) {
      return z(a) === n;
    };
    exports.isFragment = function(a) {
      return z(a) === e;
    };
    exports.isLazy = function(a) {
      return z(a) === t;
    };
    exports.isMemo = function(a) {
      return z(a) === r;
    };
    exports.isPortal = function(a) {
      return z(a) === d;
    };
    exports.isProfiler = function(a) {
      return z(a) === g;
    };
    exports.isStrictMode = function(a) {
      return z(a) === f;
    };
    exports.isSuspense = function(a) {
      return z(a) === p;
    };
    exports.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e || a === m2 || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
    };
    exports.typeOf = z;
  }
});

// ../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (true) {
      module.exports = require_react_is_production_min();
    } else {
      module.exports = null;
    }
  }
});

// ../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys3 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys3 = keys3.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys3.length; ++i) {
          var key7 = keys3[i];
          if (!KNOWN_STATICS[key7] && !(blacklist && blacklist[key7]) && !(sourceStatics && sourceStatics[key7]) && !(targetStatics && targetStatics[key7])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key7);
            try {
              defineProperty(targetComponent, key7, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics;
  }
});

// ../../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js
var require_fontfaceobserver_standalone = __commonJS({
  "../../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js"(exports, module) {
    "use strict";
    (function() {
      function p(a, c) {
        document.addEventListener ? a.addEventListener("scroll", c, false) : a.attachEvent("scroll", c);
      }
      function u(a) {
        document.body ? a() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function b() {
          document.removeEventListener("DOMContentLoaded", b);
          a();
        }) : document.attachEvent("onreadystatechange", function g() {
          if ("interactive" == document.readyState || "complete" == document.readyState) document.detachEvent("onreadystatechange", g), a();
        });
      }
      ;
      function w(a) {
        this.g = document.createElement("div");
        this.g.setAttribute("aria-hidden", "true");
        this.g.appendChild(document.createTextNode(a));
        this.h = document.createElement("span");
        this.i = document.createElement("span");
        this.m = document.createElement("span");
        this.j = document.createElement("span");
        this.l = -1;
        this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
        this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
        this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
        this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;";
        this.h.appendChild(this.m);
        this.i.appendChild(this.j);
        this.g.appendChild(this.h);
        this.g.appendChild(this.i);
      }
      function x(a, c) {
        a.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + c + ";";
      }
      function B(a) {
        var c = a.g.offsetWidth, b = c + 100;
        a.j.style.width = b + "px";
        a.i.scrollLeft = b;
        a.h.scrollLeft = a.h.scrollWidth + 100;
        return a.l !== c ? (a.l = c, true) : false;
      }
      function C(a, c) {
        function b() {
          var e = g;
          B(e) && null !== e.g.parentNode && c(e.l);
        }
        var g = a;
        p(a.h, b);
        p(a.i, b);
        B(a);
      }
      ;
      function D(a, c, b) {
        c = c || {};
        b = b || window;
        this.family = a;
        this.style = c.style || "normal";
        this.weight = c.weight || "normal";
        this.stretch = c.stretch || "normal";
        this.context = b;
      }
      var E = null, F = null, G = null, H = null;
      function I(a) {
        null === F && (M(a) && /Apple/.test(window.navigator.vendor) ? (a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent), F = !!a && 603 > parseInt(a[1], 10)) : F = false);
        return F;
      }
      function M(a) {
        null === H && (H = !!a.document.fonts);
        return H;
      }
      function N(a, c) {
        var b = a.style, g = a.weight;
        if (null === G) {
          var e = document.createElement("div");
          try {
            e.style.font = "condensed 100px sans-serif";
          } catch (q) {
          }
          G = "" !== e.style.font;
        }
        return [b, g, G ? a.stretch : "", "100px", c].join(" ");
      }
      D.prototype.load = function(a, c) {
        var b = this, g = a || "BESbswy", e = 0, q = c || 3e3, J = (/* @__PURE__ */ new Date()).getTime();
        return new Promise(function(K, L) {
          if (M(b.context) && !I(b.context)) {
            var O = new Promise(function(r, t) {
              function h() {
                (/* @__PURE__ */ new Date()).getTime() - J >= q ? t(Error("" + q + "ms timeout exceeded")) : b.context.document.fonts.load(N(b, '"' + b.family + '"'), g).then(function(n) {
                  1 <= n.length ? r() : setTimeout(h, 25);
                }, t);
              }
              h();
            }), P = new Promise(function(r, t) {
              e = setTimeout(function() {
                t(Error("" + q + "ms timeout exceeded"));
              }, q);
            });
            Promise.race([P, O]).then(function() {
              clearTimeout(e);
              K(b);
            }, L);
          } else u(function() {
            function r() {
              var d;
              if (d = -1 != k && -1 != l || -1 != k && -1 != m2 || -1 != l && -1 != m2) (d = k != l && k != m2 && l != m2) || (null === E && (d = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), E = !!d && (536 > parseInt(d[1], 10) || 536 === parseInt(d[1], 10) && 11 >= parseInt(d[2], 10))), d = E && (k == y && l == y && m2 == y || k == z && l == z && m2 == z || k == A && l == A && m2 == A)), d = !d;
              d && (null !== f.parentNode && f.parentNode.removeChild(f), clearTimeout(e), K(b));
            }
            function t() {
              if ((/* @__PURE__ */ new Date()).getTime() - J >= q) null !== f.parentNode && f.parentNode.removeChild(f), L(Error("" + q + "ms timeout exceeded"));
              else {
                var d = b.context.document.hidden;
                if (true === d || void 0 === d) k = h.g.offsetWidth, l = n.g.offsetWidth, m2 = v.g.offsetWidth, r();
                e = setTimeout(t, 50);
              }
            }
            var h = new w(g), n = new w(g), v = new w(g), k = -1, l = -1, m2 = -1, y = -1, z = -1, A = -1, f = document.createElement("div");
            f.dir = "ltr";
            x(h, N(b, "sans-serif"));
            x(n, N(b, "serif"));
            x(v, N(b, "monospace"));
            f.appendChild(h.g);
            f.appendChild(n.g);
            f.appendChild(v.g);
            b.context.document.body.appendChild(f);
            y = h.g.offsetWidth;
            z = n.g.offsetWidth;
            A = v.g.offsetWidth;
            t();
            C(h, function(d) {
              k = d;
              r();
            });
            x(h, N(b, '"' + b.family + '",sans-serif'));
            C(n, function(d) {
              l = d;
              r();
            });
            x(n, N(b, '"' + b.family + '",serif'));
            C(v, function(d) {
              m2 = d;
              r();
            });
            x(v, N(b, '"' + b.family + '",monospace'));
          });
        });
      };
      "object" === typeof module ? module.exports = D : (window.FontFaceObserver = D, window.FontFaceObserver.prototype.load = D.prototype.load);
    })();
  }
});

// ../../library/src/router/lazy.tsx
import { forwardRef, isValidElement, useEffect } from "react";

// ../../library/src/utils/utils.ts
function isFunction(value) {
  return typeof value === "function";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return Number.isFinite(value);
}
function isArray(value) {
  return Array.isArray(value);
}
function isObject2(value) {
  return value !== null && typeof value === "object" && !isArray(value);
}
function isEmptyObject(object) {
  for (const _ in object) return false;
  return true;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isNull(value) {
  return value === null;
}
function isNullish(value) {
  return value == null;
}
function isValidDate(value) {
  return value instanceof Date && !Number.isNaN(value.getTime());
}
function isGenerator2(value) {
  return isObject2(value) && isFunction(value.return);
}
function isPromiseLike(value) {
  return isObject2(value) && isFunction(value.then);
}
function isPromise(value) {
  return value instanceof Promise;
}
var noop2 = () => {
};
var isWindow = typeof window !== "undefined";
var isBot = /* @__PURE__ */ (() => isWindow && (navigator.webdriver || /bot|-google|google-|yandex|ia_archiver|crawl|spider/iu.test(navigator.userAgent)))();
var supportsRequestIdleCallback = isWindow && typeof window.requestIdleCallback === "function";
var requestIdleCallback = /* @__PURE__ */ (() => (
  // eslint-disable-next-line compat/compat,framer-studio/tscompat
  supportsRequestIdleCallback ? window.requestIdleCallback : setTimeout
))();
function encodeSVGForCSS(svg) {
  return `url('data:image/svg+xml,${svg.replaceAll("#", "%23").replaceAll("'", "%27")}')`;
}
function getPleaseReportMessage(message, error) {
  return `${message ? `${message}
` : ""}In case the issue persists, report this to the Framer team via https://www.framer.com/contact/${error ? ":\n" : "."}`;
}

// ../../library/src/router/lazyModulesCache.ts
var lazyModulesCache = /* @__PURE__ */ new Map();
function initLazyModulesCache() {
  if (!isWindow) return;
  const lazyPreloadLinks = document.querySelectorAll('[rel="modulepreload"][data-framer-lazy]');
  for (const link of lazyPreloadLinks) {
    const hash2 = link.getAttribute("data-framer-lazy");
    const url = link.getAttribute("href");
    if (!hash2 || !url) continue;
    const promise = import(url).then((module) => {
      lazyModulesCache.set(hash2, module);
      return module;
    }).catch((error) => {
      lazyModulesCache.delete(hash2);
      console.warn(`Failed to import lazy module: ${url}`, error);
      throw error;
    });
    promise.catch(noop2);
    lazyModulesCache.set(hash2, promise);
  }
}

// ../../library/src/router/lazyModulesCollector.ts
var lazyModulesCollector = isWindow ? void 0 : /* @__PURE__ */ new Set();

// ../../library/src/router/lazy.tsx
import { jsx } from "react/jsx-runtime";
var preloadKey = "preload";
function isLazyComponentType(componentType) {
  return typeof componentType === "object" && componentType !== null && !isValidElement(componentType) && preloadKey in componentType;
}
function getLoadedComponent(module, moduleName) {
  if (moduleName in module) {
    return module[moduleName];
  }
  throw new Error(`Module does not contain export '${moduleName}'`);
}
function lazy(factory, moduleName = "default", cacheHash) {
  let factoryPromise;
  let LoadedComponent;
  let error;
  const updateFromCache = () => {
    if (LoadedComponent || !cacheHash || !lazyModulesCache.has(cacheHash)) return;
    const maybeModule = lazyModulesCache.get(cacheHash);
    if (isPromise(maybeModule)) {
      void load(() => maybeModule);
    } else {
      LoadedComponent = getLoadedComponent(maybeModule, moduleName);
    }
  };
  const load = (factoryFn) => {
    if (LoadedComponent) return Promise.resolve(LoadedComponent);
    if (!factoryPromise) {
      factoryPromise = factoryFn().then((module) => {
        const component = getLoadedComponent(module, moduleName);
        LoadedComponent = component;
        return component;
      }).catch((err) => {
        error = err;
      });
    }
    return factoryPromise;
  };
  let hasRendered = false;
  const Component18 = forwardRef(function LazyWithPreload(props, ref) {
    useEffect(() => {
      hasRendered = true;
    }, []);
    if (error) {
      throw error;
    }
    updateFromCache();
    if (cacheHash !== void 0 && lazyModulesCollector !== void 0) {
      lazyModulesCollector.add(cacheHash);
    }
    if (!LoadedComponent) {
      throw load(factory);
    }
    return /* @__PURE__ */ jsx(LoadedComponent, { ref, ...props });
  });
  Component18.preload = () => {
    updateFromCache();
    return load(factory);
  };
  Component18.getStatus = () => {
    return {
      hasLoaded: LoadedComponent !== void 0,
      hasRendered
    };
  };
  return Component18;
}

// ../../library/src/router/useRouteElementId.ts
import React4 from "react";

// ../../library/src/router/useCurrentRoute.tsx
import React3, { useContext, useMemo as useMemo2 } from "react";

// ../../library/src/utils/objectKeys.ts
var objectKeys = Object.keys;

// ../../library/src/render/utils/isEqual.ts
function hasProp(o, prop) {
  return Object.prototype.hasOwnProperty.call(o, prop);
}
var equalsKey = "equals";
function withEquals(o) {
  if (o === null) return false;
  if (!(equalsKey in o)) return false;
  return typeof o.equals === "function";
}
function valueEqual(a, b) {
  if (a === b) return true;
  return a !== a && b !== b;
}
function arrayShallowEqual(a, b) {
  const length = a.length;
  if (length !== b.length) return false;
  for (let i = length; i-- !== 0; ) {
    if (!valueEqual(a[i], b[i])) return false;
  }
  return true;
}
function arrayDeepEqual(a, b) {
  const length = a.length;
  if (length !== b.length) return false;
  for (let i = length; i-- !== 0; ) {
    if (!equal(a[i], b[i], true)) return false;
  }
  return true;
}
function mapShallowEqual(a, b) {
  if (a.size !== b.size) return false;
  for (const [key7, aValue] of a.entries()) {
    if (!valueEqual(aValue, b.get(key7))) return false;
  }
  return true;
}
function mapDeepEqual(a, b) {
  if (a.size !== b.size) return false;
  for (const [key7, aValue] of a.entries()) {
    if (!equal(aValue, b.get(key7), true)) return false;
  }
  return true;
}
function setEqual(a, b) {
  if (a.size !== b.size) return false;
  for (const aValue of a.keys()) {
    if (!b.has(aValue)) return false;
  }
  return true;
}
function objectShallowEqual(a, b) {
  const keys3 = objectKeys(a);
  if (keys3.length !== objectKeys(b).length) return false;
  for (const key7 of keys3) {
    if (!hasProp(b, key7)) return false;
    if (key7 === "_owner" && hasProp(a, "$$typeof") && a.$$typeof) {
      continue;
    }
    if (!valueEqual(a[key7], b[key7])) return false;
  }
  return true;
}
function objectDeepEqual(a, b) {
  const keys3 = objectKeys(a);
  if (keys3.length !== objectKeys(b).length) return false;
  for (const key7 of keys3) {
    if (!hasProp(b, key7)) return false;
    if (key7 === "_owner" && hasProp(a, "$$typeof") && a.$$typeof) {
      continue;
    }
    if (!equal(a[key7], b[key7], true)) return false;
  }
  return true;
}
function equal(a, b, deep) {
  if (a === b) return true;
  if (!a || !b) return a !== a && b !== b;
  const typeA = typeof a;
  const typeB = typeof b;
  if (typeA !== typeB) return false;
  if (typeA !== "object") return false;
  const aIsArray = Array.isArray(a);
  const bIsArray = Array.isArray(b);
  if (aIsArray && bIsArray) {
    if (deep) {
      return arrayDeepEqual(a, b);
    } else {
      return arrayShallowEqual(a, b);
    }
  } else if (aIsArray !== bIsArray) {
    return false;
  }
  const aIsMap = a instanceof Map;
  const bIsMap = b instanceof Map;
  if (aIsMap && bIsMap) {
    if (deep) {
      return mapDeepEqual(a, b);
    } else {
      return mapShallowEqual(a, b);
    }
  } else if (aIsMap !== bIsMap) {
    return false;
  }
  const aIsSet = a instanceof Set;
  const bIsSet = b instanceof Set;
  if (aIsSet && bIsSet) {
    return setEqual(a, b);
  } else if (aIsSet !== bIsSet) {
    return false;
  }
  const dateA = a instanceof Date;
  const dateB = b instanceof Date;
  if (dateA && dateB) {
    return a.getTime() === b.getTime();
  } else if (dateA !== dateB) {
    return false;
  }
  const regexpA = a instanceof RegExp;
  const regexpB = b instanceof RegExp;
  if (regexpA && regexpB) {
    return a.toString() === b.toString();
  } else if (regexpA !== regexpB) {
    return false;
  }
  if (withEquals(a) && withEquals(b)) {
    return a.equals(b);
  }
  if (deep) {
    return objectDeepEqual(a, b);
  } else {
    return objectShallowEqual(a, b);
  }
}
function isEqual(a, b, deep = true) {
  try {
    return equal(a, b, deep);
  } catch (error) {
    if (error instanceof Error && /stack|recursion/iu.exec(error.message)) {
      console.warn("Warning: isEqual does not handle circular references.", error.name, error.message);
      return false;
    }
    throw error;
  }
}

// ../../library/src/router/RouterContext.tsx
import React2, { useMemo } from "react";

// ../../library/src/router/useGetRouteCallback.ts
import React from "react";
function useGetRouteCallback(routes) {
  return React.useCallback((routeId) => routes[routeId], [routes]);
}

// ../../library/src/router/RouterContext.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var RouterContext = /* @__PURE__ */ (() => React2.createContext({}))();
function RouterAPIProvider({ api, children }) {
  return /* @__PURE__ */ jsx2(RouterContext.Provider, { value: api, children });
}
function useRouter() {
  return React2.useContext(RouterContext);
}
function RoutesProvider({ routes, children }) {
  const getRoute = useGetRouteCallback(routes);
  const api = useMemo(() => ({ getRoute }), [getRoute]);
  return /* @__PURE__ */ jsx2(RouterContext.Provider, { value: api, children });
}

// ../../library/src/router/useCurrentRoute.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
var CurrentRouteContext = /* @__PURE__ */ (() => React3.createContext({}))();
function useCurrentRoute() {
  const router = useRouter();
  const override = useContext(CurrentRouteContext);
  const id = override?.routeId ?? router.currentRouteId;
  const pathVariables = override?.routeId ? override.pathVariables : router.currentPathVariables;
  const route = id ? router.getRoute?.(id) : void 0;
  return useMemo2(() => {
    if (!id || !route) return void 0;
    return {
      ...route,
      id,
      pathVariables
    };
  }, [id, pathVariables, route]);
}
function useCurrentRouteKey() {
  const currentRoute = useCurrentRoute();
  if (!currentRoute) return void 0;
  return `${currentRoute.id}-${JSON.stringify(currentRoute.pathVariables)}`;
}
function useCurrentRouteId() {
  return useCurrentRoute()?.id;
}
function useOnRouteChange(cb) {
  const currentRoute = useCurrentRoute();
  const lastRoute = React3.useRef(currentRoute);
  if (isEqual(lastRoute.current, currentRoute) || !currentRoute) return;
  lastRoute.current = currentRoute;
  cb(currentRoute);
}

// ../../library/src/router/useRoute.ts
function useRoute(routeId) {
  const routerAPI = useRouter();
  if (!routeId) return void 0;
  return routerAPI.getRoute?.(routeId);
}

// ../../library/src/router/utils.ts
function getRouteElementId(route, hash2) {
  if (hash2 && route) {
    if (route.elements && hash2 in route.elements) {
      return route.elements[hash2];
    } else {
      return hash2;
    }
  }
  return void 0;
}
var EMPTY_ARRAY = [];
function monitorINPRelatedInputs(signal) {
  const inpRelatedInputs = ["pointerdown", "pointerup", "keydown", "keyup"];
  const inpRelatedInputHandler = (event) => {
    const type = event.type;
    if (!inpRelatedInputs.includes(type)) return;
    performance.mark(`framer-navigation-input`, {
      detail: {
        type
      }
    });
  };
  for (let i = 0; i < inpRelatedInputs.length; i++) {
    document.addEventListener(inpRelatedInputs[i], inpRelatedInputHandler, { signal });
  }
  return () => {
    for (let i = 0; i < inpRelatedInputs.length; i++) {
      document.removeEventListener(inpRelatedInputs[i], inpRelatedInputHandler);
    }
  };
}

// ../../library/src/router/useRouteElementId.ts
function useRouteElementId(id, targetRouteId) {
  const currentRoute = useCurrentRoute();
  const route = useRoute(targetRouteId) ?? currentRoute;
  return React4.useMemo(() => {
    if (!route) return id;
    return getRouteElementId(route, id);
  }, [id, route]);
}

// ../../library/src/router/useCurrentPathVariables.tsx
function useCurrentPathVariables() {
  return useCurrentRoute()?.pathVariables;
}

// ../../library/src/router/useRouteHandler.ts
import React5 from "react";

// ../../library/src/router/useRoutePreloader.ts
import { useEffect as useEffect2 } from "react";

// ../../library/src/utils/safeWindow.ts
var mockWindow = {
  addEventListener: () => {
  },
  removeEventListener: () => {
  },
  dispatchEvent: () => false,
  ResizeObserver: void 0,
  onpointerdown: false,
  onpointermove: false,
  onpointerup: false,
  ontouchstart: false,
  ontouchmove: false,
  ontouchend: false,
  onmousedown: false,
  onmousemove: false,
  onmouseup: false,
  devicePixelRatio: 1,
  scrollX: 0,
  scrollY: 0,
  location: {
    hash: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    search: ""
  },
  document: {
    baseURI: "",
    cookie: "",
    referrer: null
  },
  setTimeout: () => 0,
  clearTimeout: () => {
  },
  setInterval: () => 0,
  clearInterval: () => {
  },
  requestAnimationFrame: () => 0,
  cancelAnimationFrame: () => {
  },
  requestIdleCallback: () => 0,
  getSelection: () => null,
  matchMedia: (query) => {
    return {
      matches: false,
      media: query,
      onchange: () => {
      },
      addEventListener: () => {
      },
      removeEventListener: () => {
      },
      addListener: () => {
      },
      removeListener: () => {
      },
      dispatchEvent: () => false
    };
  },
  innerHeight: 0,
  innerWidth: 0,
  SVGSVGElement: {},
  scheduler: void 0,
  open: function(_url, _target, _features) {
  },
  __framer_events: []
};
var safeWindow = !isWindow ? mockWindow : window;

// ../../library/src/utils/yield.ts
var canUseYield = /* @__PURE__ */ (() => safeWindow.scheduler && "yield" in safeWindow.scheduler)();
var canUsePostTask = /* @__PURE__ */ (() => safeWindow.scheduler && "postTask" in safeWindow.scheduler)();
var pendingResolvers = /* @__PURE__ */ new Set();
function resolvePendingPromises() {
  for (const resolve of pendingResolvers) resolve();
  pendingResolvers.clear();
}
function yieldUnlessUrgent(options) {
  return new Promise((resolve) => {
    pendingResolvers.add(resolve);
    if (document.hidden) {
      resolvePendingPromises();
      return;
    }
    document.addEventListener("visibilitychange", resolvePendingPromises);
    document.addEventListener("pagehide", resolvePendingPromises);
    frame.read(() => {
      const resolveFn = () => {
        pendingResolvers.delete(resolve);
        if (options?.signal?.aborted) return;
        resolve();
      };
      void schedulerYield(options).then(resolveFn);
    });
    return;
  });
}
function interactionResponse(options) {
  return new Promise((resolve) => {
    setTimeout(resolve, 100);
    frame.read(
      () => {
        void schedulerYield(options).then(resolve);
      },
      false,
      // In some cases, interactionResponse might be called in a rAF. This means, we should right away call `schedulerYield`, as the next paint follows immediately.
      true
    );
  });
}
function schedulerYield(options) {
  const priority = options?.priority;
  const canUseModernAPI = canUseYield || canUsePostTask;
  if (!canUseModernAPI) {
    if (priority === "user-blocking") {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      setTimeout(resolve, priority === "background" ? 1 : 0);
    });
  }
  if (priority === "background") {
    return new Promise((resolve) => {
      setTimeout(resolve, 1);
    });
  }
  if (canUseYield) {
    return safeWindow.scheduler.yield(options).catch(noop2);
  }
  return safeWindow.scheduler.postTask(() => {
  }, options).catch(noop2);
}
function yieldToMain(options) {
  const { continueAfter, ensureContinueBeforeUnload, ...schedulerOptions } = options ?? {};
  if (ensureContinueBeforeUnload) {
    return yieldUnlessUrgent(schedulerOptions);
  }
  if (continueAfter === "paint") {
    return interactionResponse(schedulerOptions);
  }
  return schedulerYield(schedulerOptions);
}

// ../../library/src/router/useRoutePreloader.ts
var shouldPreloadBasedOnUA = !isBot;
function useRoutePreloader(routeIds, enabled = true) {
  const { getRoute } = useRouter();
  useEffect2(() => {
    if (!getRoute || !enabled || !shouldPreloadBasedOnUA) return;
    for (const routeId of routeIds) {
      void preloadRoute(getRoute(routeId));
    }
  }, [routeIds, getRoute, enabled]);
}
async function preloadRoute(route) {
  if (!shouldPreloadBasedOnUA || !route) return;
  const component = route.page;
  if (!component || !isLazyComponentType(component)) return;
  await yieldToMain();
  try {
    await component.preload();
  } catch (e) {
    if (false) console.warn("Preload failed", route, e);
  }
}

// ../../library/src/router/useRouteHandler.ts
function useRouteHandler(routeId, preload = false, elementId) {
  const { navigate } = useRouter();
  useRoutePreloader([routeId], preload);
  const handler = React5.useCallback(() => navigate?.(routeId, elementId), [navigate, elementId, routeId]);
  return handler;
}

// ../../library/src/router/history.ts
import { useCallback as useCallback3, useEffect as useEffect4, useLayoutEffect as useLayoutEffect2, useRef as useRef3 } from "react";

// ../../library/src/modules/cms/CollectionUtilsCache.tsx
import { createContext, useContext as useContext2, useMemo as useMemo3 } from "react";

// ../../library/src/router/types.ts
var defaultLocaleId = "default";

// ../../library/src/utils/assert.ts
function assert(condition, ...msg) {
  if (condition) return;
  const e = Error("Assertion Error" + (msg.length > 0 ? ": " + msg.join(" ") : ""));
  if (e.stack) {
    try {
      const lines = e.stack.split("\n");
      if (lines[1]?.includes("assert")) {
        lines.splice(1, 1);
        e.stack = lines.join("\n");
      } else if (lines[0]?.includes("assert")) {
        lines.splice(0, 1);
        e.stack = lines.join("\n");
      }
    } catch {
    }
  }
  throw e;
}
function assertNever(x, error) {
  throw error || new Error(x ? `Unexpected value: ${x}` : "Application entered invalid state");
}

// ../../library/src/modules/LazyValue.ts
var PromiseState = {
  Pending: "pending",
  Fulfilled: "fulfilled",
  Rejected: "rejected"
};
var LazyValue = class _LazyValue {
  /**
   * @param resolver Function that returns the value or promise
   * @param cacheHash Optional hash of the module filename, used for cache optimization. During build, this is automatically injected as a compact hash of the filename extracted from the original HTTPS URL (e.g., "YouTube.js"  hash).
   */
  constructor(resolver, cacheHash) {
    this.resolver = resolver;
    this.cacheHash = cacheHash;
    __publicField(this, "promiseState", PromiseState.Pending);
    __publicField(this, "preloadPromise");
    __publicField(this, "value");
    __publicField(this, "reason");
    /** Synchronously read the value after calling preload() before. */
    __publicField(this, "read", () => {
      if (this.promiseState === PromiseState.Fulfilled) {
        return this.value;
      }
      if (this.promiseState === PromiseState.Rejected) {
        throw this.reason;
      }
      throw new Error("Need to call preload() before read()");
    });
  }
  static is(value) {
    return value instanceof _LazyValue;
  }
  /**
   * Gets the status and preloads the value if it's not already preloaded.
   */
  get status() {
    void this.preload();
    return this.state;
  }
  get state() {
    return this.promiseState;
  }
  // biome-ignore lint/suspicious/noThenProperty: This is a PromiseLike class.
  then(onfulfilled, onrejected) {
    if (this.promiseState === PromiseState.Fulfilled) {
      return Promise.resolve(this.value).then(onfulfilled, onrejected);
    }
    if (this.promiseState === PromiseState.Rejected) {
      return Promise.reject(this.reason).then(onfulfilled, onrejected);
    }
    return this.readAsync().then(onfulfilled, onrejected);
  }
  /**
   * Preload the value so it can be read() later.
   *
   * @returns The promise that resolves or rejects. `undefined` if the value has already been preloaded or is synchronously readable.
   */
  preload() {
    if (this.promiseState !== PromiseState.Pending) return;
    if (this.preloadPromise) return this.preloadPromise;
    if (this.cacheHash !== void 0 && lazyModulesCollector !== void 0) {
      lazyModulesCollector.add(this.cacheHash);
    }
    const fulfill = (value) => {
      this.promiseState = PromiseState.Fulfilled;
      this.value = value;
    };
    const reject = (reason) => {
      this.promiseState = PromiseState.Rejected;
      this.reason = reason;
    };
    let maybeValue;
    try {
      maybeValue = this.cacheHash && lazyModulesCache.has(this.cacheHash) ? lazyModulesCache.get(this.cacheHash) : this.resolver();
    } catch (e) {
      reject(e);
      return;
    }
    if (!isPromise(maybeValue)) {
      fulfill(maybeValue);
      return;
    }
    const valuePromise = maybeValue.then(fulfill, reject);
    this.preloadPromise = valuePromise;
    return valuePromise;
  }
  /**
   * @deprecated Use readMaybeAsync() instead.
   * @important Don't remove it - was used in code-gen before October 2025.
   */
  async readAsync() {
    return this.readMaybeAsync();
  }
  /**
   * Loads the value if it's not already loaded.
   *
   * @returns The value or a promise that resolves to the value.
   */
  readMaybeAsync() {
    const preloadPromise = this.preload();
    if (preloadPromise) return preloadPromise.then(this.read);
    return this.read();
  }
  /**
   * FIXME: With React 19, mark this as deprecated and use the official `use` hook instead (just pass in the LazyValue instance).
   */
  use() {
    const promise = this.preload();
    if (promise) throw promise;
    return this.read();
  }
};

// ../../../node_modules/devalue/src/utils.js
var DevalueError = class extends Error {
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys3) {
    super(message);
    this.name = "DevalueError";
    this.path = keys3.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i = 0; i < len; i += 1) {
    const char = str[i];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i) + replacement;
      last_pos = i + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
var is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key7) {
  return is_identifier.test(key7) ? "." + key7 : "[" + JSON.stringify(key7) + "]";
}

// ../../../node_modules/devalue/src/base64.js
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    binaryString += String.fromCharCode(dv.getUint8(i));
  }
  return binaryToAscii(binaryString);
}
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    dv.setUint8(i, binaryString.charCodeAt(i));
  }
  return arraybuffer;
}
var KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(data2) {
  if (data2.length % 4 === 0) {
    data2 = data2.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i = 0; i < data2.length; i++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data2[i]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
function binaryToAscii(str) {
  let out = "";
  for (let i = 0; i < str.length; i += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i) & 3) << 4;
    if (str.length > i + 1) {
      groupsOfSix[1] |= str.charCodeAt(i + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i + 1) & 15) << 2;
    }
    if (str.length > i + 2) {
      groupsOfSix[2] |= str.charCodeAt(i + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i + 2) & 63;
    }
    for (let j = 0; j < groupsOfSix.length; j++) {
      if (typeof groupsOfSix[j] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j]];
      }
    }
  }
  return out;
}

// ../../../node_modules/devalue/src/constants.js
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;

// ../../../node_modules/devalue/src/parse.js
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate(index, standalone = false) {
    if (index === UNDEFINED) return void 0;
    if (index === NAN) return NaN;
    if (index === POSITIVE_INFINITY) return Infinity;
    if (index === NEGATIVE_INFINITY) return -Infinity;
    if (index === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index in hydrated) return hydrated[index];
    const value = values[index];
    if (!value || typeof value !== "object") {
      hydrated[index] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          let i = value[1];
          if (typeof i !== "number") {
            i = values.push(value[1]) - 1;
          }
          return hydrated[index] = reviver(hydrate(i));
        }
        switch (type) {
          case "Date":
            hydrated[index] = new Date(value[1]);
            break;
          case "Set":
            const set = /* @__PURE__ */ new Set();
            hydrated[index] = set;
            for (let i = 1; i < value.length; i += 1) {
              set.add(hydrate(value[i]));
            }
            break;
          case "Map":
            const map2 = /* @__PURE__ */ new Map();
            hydrated[index] = map2;
            for (let i = 1; i < value.length; i += 2) {
              map2.set(hydrate(value[i]), hydrate(value[i + 1]));
            }
            break;
          case "RegExp":
            hydrated[index] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index] = obj;
            for (let i = 1; i < value.length; i += 2) {
              obj[value[i]] = hydrate(value[i + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate(value[1]));
            hydrated[index] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base64 = value[1];
            const arraybuffer = decode64(base64);
            hydrated[index] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url = new URL(value[1]);
            hydrated[index] = url;
            break;
          }
          case "URLSearchParams": {
            const url = new URLSearchParams(value[1]);
            hydrated[index] = url;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array = new Array(value.length);
        hydrated[index] = array;
        for (let i = 0; i < value.length; i += 1) {
          const n = value[i];
          if (n === HOLE) continue;
          array[i] = hydrate(n);
        }
      }
    } else {
      const object = {};
      hydrated[index] = object;
      for (const key7 in value) {
        if (key7 === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n = value[key7];
        object[key7] = hydrate(n);
      }
    }
    return hydrated[index];
  }
  return hydrate(0);
}

// ../../../node_modules/devalue/src/stringify.js
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom = [];
  if (reducers) {
    for (const key7 of Object.getOwnPropertyNames(reducers)) {
      custom.push({ key: key7, fn: reducers[key7] });
    }
  }
  const keys3 = [];
  let p = 0;
  function flatten(thing) {
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index2 = p++;
    indexes.set(thing, index2);
    for (const { key: key7, fn } of custom) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index2] = `["${key7}",${flatten(value2)}]`;
        return index2;
      }
    }
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys3);
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source)},"${flags}"]` : `["RegExp",${stringify_string(source)}]`;
          break;
        case "Array":
          str = "[";
          for (let i = 0; i < thing.length; i += 1) {
            if (i > 0) str += ",";
            if (i in thing) {
              keys3.push(`[${i}]`);
              str += flatten(thing[i]);
              keys3.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key7, value2] of thing) {
            keys3.push(
              `.get(${is_primitive(key7) ? stringify_primitive(key7) : "..."})`
            );
            str += `,${flatten(key7)},${flatten(value2)}`;
            keys3.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a = thing.byteOffset;
          const b = a + thing.byteLength;
          if (a > 0 || b !== typedArray.buffer.byteLength) {
            const m2 = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a / m2},${b / m2}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base64 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base64}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys3
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys3
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key7 in thing) {
              keys3.push(stringify_key(key7));
              str += `,${stringify_string(key7)},${flatten(thing[key7])}`;
              keys3.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key7 in thing) {
              if (started) str += ",";
              started = true;
              keys3.push(stringify_key(key7));
              str += `${stringify_string(key7)}:${flatten(thing[key7])}`;
              keys3.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index2] = str;
    return index2;
  }
  const index = flatten(value);
  if (index < 0) return `${index}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}

// ../../library/src/utils/sendTrackingEvent.ts
var pageviewEventVersion = 2;
function sendTrackingEvent(eventType, eventData, sendOn = "lazy") {
  safeWindow.__framer_events?.push([eventType, eventData, sendOn]);
  switch (eventType) {
    case "published_site_click": {
      const { trackingId, href } = eventData;
      if (trackingId) {
        document.dispatchEvent(new CustomEvent("framer:click", { detail: { trackingId, href } }));
      }
      break;
    }
    case "published_site_form_submit": {
      const { trackingId } = eventData;
      if (trackingId) {
        document.dispatchEvent(new CustomEvent("framer:formsubmit", { detail: { trackingId } }));
      }
      break;
    }
    // NOTE: keep in sync with exportToHTML.ts, the initial pageview is sent from there
    case "published_site_pageview": {
      const { framerLocale } = eventData;
      document.dispatchEvent(new CustomEvent("framer:pageview", { detail: { framerLocale } }));
      break;
    }
  }
}

// ../../library/src/modules/dataHandover/dataHandover.ts
var HandoverDataType = {
  QueryCache: 0,
  CollectionUtilsCache: 1
};
var hydratedData;
function createEmptyPayload() {
  return {
    [HandoverDataType.QueryCache]: /* @__PURE__ */ new Map(),
    [HandoverDataType.CollectionUtilsCache]: /* @__PURE__ */ new Map()
  };
}
function parseHandoverData() {
  if (!isWindow || // some tests set window, but don't set document.
  false) {
    return;
  }
  if (hydratedData !== void 0) return hydratedData;
  let script = document.getElementById("__framer__handoverData");
  if (!script) return;
  try {
    hydratedData = parse(script.text) ?? createEmptyPayload();
  } catch (error) {
    hydratedData = createEmptyPayload();
    console.warn("Failed to parse handover data. Falling back to network.", error);
  }
  requestIdleCallback(() => {
    script?.remove();
    script = null;
  });
  return hydratedData;
}
function handleHydrationError(error, key7) {
  console.warn(
    getPleaseReportMessage(
      `Failed to resolve raw query result from DOM during hydration for: ${key7}. This might make the page load slightly slower.`
    )
  );
  const sampleRate = Math.random();
  if (sampleRate < 0.01) {
    const stack = error instanceof Error && typeof error.stack === "string" ? error.stack : null;
    sendTrackingEvent("published_site_load_error", {
      message: String(error),
      stack
    });
  }
}
function hasHandoverData(dataType, key7) {
  const data2 = parseHandoverData();
  if (!data2) return false;
  return data2[dataType].has(key7);
}
function getHandoverData(dataType, key7) {
  const data2 = parseHandoverData();
  if (!data2) return;
  const map2 = data2[dataType];
  if (!map2.has(key7)) return;
  const value = map2.get(key7);
  map2.delete(key7);
  return value;
}
var HandoverCollector = class {
  constructor() {
    __publicField(this, "payload", createEmptyPayload());
    __publicField(this, "isEmpty", true);
  }
  set(dataType, key7, value) {
    this.payload[dataType].set(key7, value);
    this.isEmpty = false;
  }
  has(dataType, key7) {
    return this.payload[dataType].has(key7);
  }
  get(dataType, key7) {
    return this.payload[dataType].get(key7);
  }
  /**
   * Serializes the handover data to a string safe to use inside `<script>` tags.
   */
  toString() {
    if (this.isEmpty) return void 0;
    try {
      return stringify(this.payload);
    } catch (error) {
      console.error("Failed to serialize handover data.", error);
      return void 0;
    }
  }
  clear() {
    for (const map2 of Object.values(this.payload)) {
      map2.clear();
    }
    this.isEmpty = true;
  }
};
var handoverCollector = /* @__PURE__ */ (() => isWindow ? void 0 : new HandoverCollector())();

// ../../library/src/modules/cms/CollectionUtilsCache.tsx
import { jsx as jsx4 } from "react/jsx-runtime";
var handoverDataType = /* @__PURE__ */ (() => HandoverDataType.CollectionUtilsCache)();
function getLocaleKey(locale) {
  return locale?.id ?? defaultLocaleId;
}
function makeHandoverKey(method, collectionId, localeKey, id) {
  return `${method}|${collectionId}|${localeKey}|${id}`;
}
var utilsCache = /* @__PURE__ */ new WeakMap();
function getCollectionUtilsCache(collectionUtils) {
  return (collectionId) => {
    if (!collectionUtils) return;
    const utilsFactory = collectionUtils[collectionId];
    if (!utilsFactory) return void 0;
    if (utilsCache.has(utilsFactory)) return utilsCache.get(utilsFactory);
    const cache2 = new CollectionUtilsCache(utilsFactory, collectionId);
    utilsCache.set(utilsFactory, cache2);
    return cache2;
  };
}
var CollectionUtilsCacheContext = /* @__PURE__ */ createContext(void 0);
function CollectionUtilsCacheProvider({
  children,
  collectionUtils
}) {
  const getCollectionUtilsCacheMemoized = useMemo3(() => {
    return {
      get: getCollectionUtilsCache(collectionUtils)
    };
  }, [collectionUtils]);
  return /* @__PURE__ */ jsx4(CollectionUtilsCacheContext.Provider, { value: getCollectionUtilsCacheMemoized, children });
}
function useCollectionUtils() {
  return useContext2(CollectionUtilsCacheContext);
}
var CollectionUtilsCache = class {
  constructor(utilFactory, collectionId) {
    this.collectionId = collectionId;
    __publicField(this, "module");
    /**
     * Stores returned values from CollectionUtils.
     * The values must be cached so that they can be returned synchronously when a React component unsuspends.
     */
    __publicField(this, "cacheMap", /* @__PURE__ */ new Map());
    this.module = new LazyValue(async () => {
      try {
        const utils = await utilFactory();
        assert(utils, "Couldn't find CollectionUtils");
        return utils;
      } catch (error) {
        console.error(getPleaseReportMessage("Failed to import collection module.", error));
        return void 0;
      }
    });
  }
  callUtilsMethod(method, id, locale) {
    const localeKey = getLocaleKey(locale);
    const entryKey = makeHandoverKey(method, this.collectionId, localeKey, id);
    if (this.cacheMap.has(entryKey)) {
      const cached = this.cacheMap.get(entryKey);
      const value = cached?.readMaybeAsync();
      if (handoverCollector !== void 0) {
        if (isPromise(value)) {
          return value.then((result) => {
            handoverCollector.set(handoverDataType, entryKey, result);
            return result;
          });
        }
        handoverCollector.set(handoverDataType, entryKey, value);
      }
      return value;
    }
    if (hasHandoverData(handoverDataType, entryKey)) {
      const data2 = getHandoverData(handoverDataType, entryKey);
      this.cacheMap.set(entryKey, new LazyValue(() => data2));
      return data2;
    }
    const maybeUtils = this.module.readMaybeAsync();
    const utilsIsPromise = isPromise(maybeUtils);
    let maybeResult;
    try {
      maybeResult = utilsIsPromise ? maybeUtils.then((utils) => utils?.[method](id, locale)) : maybeUtils?.[method](id, locale);
    } catch (error) {
      console.error(getPleaseReportMessage("Failed to call CollectionUtils method.", error));
      maybeResult = void 0;
    }
    if (maybeResult === void 0) {
      if (handoverCollector !== void 0) {
        handoverCollector.set(handoverDataType, entryKey, maybeResult);
      }
      this.cacheMap.set(entryKey, maybeResult);
      return;
    }
    const lazyValue = new LazyValue(
      () => maybeResult.then((result) => {
        if (handoverCollector !== void 0) {
          handoverCollector.set(handoverDataType, entryKey, result);
        }
        return result;
      }).catch((error) => {
        console.error(getPleaseReportMessage("Failed to call CollectionUtils method.", error));
        return void 0;
      })
    );
    this.cacheMap.set(entryKey, lazyValue);
    return lazyValue.readMaybeAsync();
  }
  getSlugByRecordId(recordId, locale) {
    return this.callUtilsMethod("getSlugByRecordId", recordId, locale);
  }
  getRecordIdBySlug(slug, locale) {
    return this.callUtilsMethod("getRecordIdBySlug", slug, locale);
  }
};

// ../../library/src/router/computeRelativePath.ts
function computeRelativePath(from, to) {
  if (!from.startsWith("/") || !to.startsWith("/")) {
    throw new Error("from/to paths are expected to be absolute");
  }
  const [fromDir] = getDirAndFile(from);
  const [toDir, toFile] = getDirAndFile(to);
  let relativePath = relative(fromDir, toDir);
  if (relativePath === "") relativePath = ".";
  if (!relativePath.startsWith(".") && !relativePath.startsWith("/")) {
    relativePath = "./" + relativePath;
  }
  return relativePath + "/" + toFile;
}
function getDirAndFile(path) {
  const index = path.lastIndexOf("/");
  return [path.substring(0, index + 1), path.substring(index + 1)];
}
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var StringPrototypeCharCodeAt = (str, index) => str.charCodeAt(index);
var StringPrototypeLastIndexOf = (str, searchString) => str.lastIndexOf(searchString);
var StringPrototypeSlice = (str, start, end) => str.slice(start, end);
function relative(from, to) {
  if (from === to) return "";
  from = "/" + normalizeString(from);
  to = "/" + normalizeString(to);
  if (from === to) return "";
  const fromStart = 1;
  const fromEnd = from.length;
  const fromLen = fromEnd - fromStart;
  const toStart = 1;
  const toLen = to.length - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i < length; i++) {
    const fromCode = StringPrototypeCharCodeAt(from, fromStart + i);
    if (fromCode !== StringPrototypeCharCodeAt(to, toStart + i)) break;
    else if (fromCode === CHAR_FORWARD_SLASH) lastCommonSep = i;
  }
  if (i === length) {
    if (toLen > length) {
      if (StringPrototypeCharCodeAt(to, toStart + i) === CHAR_FORWARD_SLASH) {
        return StringPrototypeSlice(to, toStart + i + 1);
      }
      if (i === 0) {
        return StringPrototypeSlice(to, toStart + i);
      }
    } else if (fromLen > length) {
      if (StringPrototypeCharCodeAt(from, fromStart + i) === CHAR_FORWARD_SLASH) {
        lastCommonSep = i;
      } else if (i === 0) {
        lastCommonSep = 0;
      }
    }
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || StringPrototypeCharCodeAt(from, i) === CHAR_FORWARD_SLASH) {
      out += out.length === 0 ? ".." : "/..";
    }
  }
  return `${out}${StringPrototypeSlice(to, toStart + lastCommonSep)}`;
}
var allowAboveRoot = false;
var separator = "/";
var isPathSeparator = (code) => code === CHAR_FORWARD_SLASH;
function normalizeString(path) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = 0;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) code = StringPrototypeCharCodeAt(path, i);
    else if (isPathSeparator(code)) break;
    else code = CHAR_FORWARD_SLASH;
    if (isPathSeparator(code)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || StringPrototypeCharCodeAt(res, res.length - 1) !== CHAR_DOT || StringPrototypeCharCodeAt(res, res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = StringPrototypeLastIndexOf(res, separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = StringPrototypeSlice(res, 0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - StringPrototypeLastIndexOf(res, separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) res += `${separator}${StringPrototypeSlice(path, lastSlash + 1, i)}`;
        else res = StringPrototypeSlice(path, lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// ../../library/src/router/customNotFoundPagePaths.ts
var customNotFoundPagePaths = /* @__PURE__ */ new Set([`/404.html`, `/404`, `/404/`]);

// ../../library/src/router/pathVariables.ts
var pathVariablesRegExpRaw = ":([a-z]\\w*)";
var pathVariablesRegExp = /* @__PURE__ */ new RegExp(pathVariablesRegExpRaw, "gi");

// ../../library/src/router/fillPathVariables.ts
function fillPathVariables(path, variables) {
  return path.replace(pathVariablesRegExp, (match, name) => {
    const value = variables[name];
    if (typeof value !== "string" || value.length === 0) return match;
    return encodeURIComponent(value);
  });
}

// ../../library/src/router/forwardQueryParams.ts
function forwardCurrentQueryParams(href) {
  const queryParamsString = typeof window !== "undefined" ? window.location.search : "";
  if (!queryParamsString) {
    return href;
  }
  return forwardQueryParams(queryParamsString, href);
}
var FRAMER_VARIANT_KEY = "framer_variant";
function forwardQueryParams(queryParamsString, href) {
  const startOfHash = href.indexOf("#");
  const hrefWithoutHash = startOfHash === -1 ? href : href.substring(0, startOfHash);
  const hash2 = startOfHash === -1 ? "" : href.substring(startOfHash);
  const startOfSearch = hrefWithoutHash.indexOf("?");
  const baseUrl = startOfSearch === -1 ? hrefWithoutHash : hrefWithoutHash.substring(0, startOfSearch);
  const searchString = startOfSearch === -1 ? "" : hrefWithoutHash.substring(startOfSearch);
  const newSearchParams = new URLSearchParams(searchString);
  const currentSearchParams = new URLSearchParams(queryParamsString);
  for (const [key7, value] of currentSearchParams) {
    if (newSearchParams.has(key7)) continue;
    if (key7 === FRAMER_VARIANT_KEY) continue;
    newSearchParams.append(key7, value);
  }
  const newSearchString = newSearchParams.toString();
  if (newSearchString === "") {
    return hrefWithoutHash + hash2;
  }
  return baseUrl + "?" + newSearchString + hash2;
}

// ../../library/src/router/getLocalizedNavigationPath.ts
async function replacePathVariables(path, currentLocale, nextLocale, defaultLocale, collectionId, pathVariables, collectionUtils) {
  let resultPath = path;
  let isMissingInLocale = false;
  const resultPathVariables = { ...pathVariables };
  const matches = Array.from(resultPath.matchAll(pathVariablesRegExp));
  const replacements = await Promise.all(
    matches.map(async (match) => {
      const pathVariableWithDelimiter = match?.[0];
      const pathVariableValue = match?.[1];
      if (!pathVariableWithDelimiter || !pathVariableValue) {
        throw new Error("Failed to replace path variables: unexpected regex match group");
      }
      const currentSlug = pathVariables[pathVariableValue];
      if (!currentSlug || !isString(currentSlug)) {
        throw new Error(`No slug found for path variable ${pathVariableValue}`);
      }
      const utils = collectionUtils?.get(collectionId);
      if (!utils || !currentLocale) {
        return currentSlug;
      }
      const maybeRecordId = utils.getRecordIdBySlug(currentSlug, currentLocale);
      const recordId = isPromise(maybeRecordId) ? await maybeRecordId : maybeRecordId;
      if (!recordId) return currentSlug;
      const maybeNextSlug = utils.getSlugByRecordId(recordId, nextLocale);
      const nextSlug = isPromise(maybeNextSlug) ? await maybeNextSlug : maybeNextSlug;
      if (!nextSlug) {
        isMissingInLocale = true;
        const maybeDefaultLocaleSlug = utils.getSlugByRecordId(recordId, defaultLocale);
        const defaultLocaleSlug = isPromise(maybeDefaultLocaleSlug) ? await maybeDefaultLocaleSlug : maybeDefaultLocaleSlug;
        if (defaultLocaleSlug) {
          resultPathVariables[pathVariableValue] = defaultLocaleSlug;
        }
        return defaultLocaleSlug ?? currentSlug;
      }
      resultPathVariables[pathVariableValue] = nextSlug;
      return nextSlug;
    })
  );
  let lastIndex = 0;
  let replacedPath = "";
  let hasMatch = false;
  for (let i = 0; i < matches.length; i++) {
    const match = matches[i];
    const replacement = replacements[i];
    if (!match || !replacement) continue;
    replacedPath += resultPath.substring(lastIndex, match.index);
    lastIndex = (match.index ?? 0) + (match[0]?.length ?? 0);
    replacedPath += replacements[i];
    hasMatch = true;
  }
  if (hasMatch) {
    replacedPath += resultPath.substring(lastIndex);
    resultPath = replacedPath;
  }
  return {
    path: resultPath,
    pathVariables: resultPathVariables,
    isMissingInLocale
  };
}
async function getLocalizedNavigationPath({
  currentLocale,
  nextLocale,
  defaultLocale,
  route,
  pathVariables,
  collectionUtils,
  preserveQueryParams
}) {
  const { path: basePath, pathLocalized } = route;
  const path = pathLocalized?.[nextLocale.id] ?? basePath;
  let result = {
    path,
    pathVariables,
    isMissingInLocale: false
  };
  if (!path) return result;
  if (pathVariables && route.collectionId) {
    try {
      const pathReplacement = await replacePathVariables(
        path,
        currentLocale,
        nextLocale,
        defaultLocale,
        route.collectionId,
        pathVariables,
        collectionUtils
      );
      result = pathReplacement;
    } catch {
    }
  }
  if (nextLocale.slug) {
    result.path = "/" + nextLocale.slug + result.path;
  }
  if (preserveQueryParams && result.path) {
    result.path = forwardCurrentQueryParams(result.path);
  }
  return result;
}

// ../../library/src/router/getSitePrefix.ts
function getSitePrefix(siteCanonicalURL) {
  if (!siteCanonicalURL) return "";
  let url;
  try {
    url = new URL(siteCanonicalURL);
  } catch {
    return "";
  }
  if (url.pathname === "/" || window.location.origin !== url.origin) return "";
  return url.pathname.endsWith("/") ? url.pathname.slice(0, -1) : url.pathname;
}

// ../../library/src/router/pageEffects/useViewTransition.ts
import { useCallback, useEffect as useEffect3, useRef } from "react";

// ../../library/src/router/pageEffects/PageEffectsContext.tsx
import React6 from "react";
import { jsx as jsx5 } from "react/jsx-runtime";
var defaultSitePageEffects = { global: void 0, routes: {} };
var PageEffectsContext = /* @__PURE__ */ React6.createContext(defaultSitePageEffects);
function PageEffectsProvider({ children, value }) {
  return /* @__PURE__ */ jsx5(PageEffectsContext.Provider, { value, children });
}
function usePageEffects() {
  return React6.useContext(PageEffectsContext);
}

// ../../library/src/router/pageEffects/getPageEffect.ts
function getPageEffectForRoute(currentRouteId, nextRouteId, { global, routes }) {
  return routes[currentRouteId]?.[nextRouteId] || global;
}

// ../../library/src/router/pageEffects/cssGeneration/linearEasing.ts
var step = 10;
var maxDuration = 1e4;
function createLinearEasing(generator) {
  let time2 = step;
  let state = generator.next(0);
  const keyframes2 = [state.value];
  while (!state.done && time2 < maxDuration) {
    state = generator.next(time2);
    keyframes2.push(state.value);
    time2 += step;
  }
  if (keyframes2.length === 1) keyframes2.push(state.value);
  return {
    easing: `linear(${keyframes2.join(",")})`,
    duration: time2 - step
  };
}

// ../../library/src/router/pageEffects/cssGeneration/masks.ts
var cssVariable = (name) => `--view-transition-${name}`;
function parseUnit(value) {
  return [parseFloat(value), value.endsWith("px") ? "px" : "%"];
}
function calcMaskPosition(mask) {
  const { innerWidth, innerHeight } = window;
  const [x, xUnit] = parseUnit(mask.x);
  const [y, yUnit] = parseUnit(mask.y);
  return {
    x: xUnit === "px" ? x : innerWidth * (x / 100),
    y: yUnit === "px" ? y : innerHeight * (y / 100)
  };
}
var conic = {
  makeKeyframe: (mask, progress2, page) => {
    let percentage = 0;
    if (page === "exit" && mask.angularDirection === "clockwise" && progress2 === "start" || page === "exit" && mask.angularDirection === "counter-clockwise" && progress2 === "end" || page === "enter" && mask.angularDirection === "counter-clockwise" && progress2 === "start" || page === "enter" && mask.angularDirection === "clockwise" && progress2 === "end") {
      percentage = mask.sweepAngle / 360 * 100;
    }
    return `${cssVariable("conic-offset")}: ${percentage}%;`;
  },
  makeStyles: (mask, page) => {
    const offsetToken = `var(${cssVariable("conic-offset")})`;
    const isTransparentToBlack = page === "exit" && mask.angularDirection === "clockwise" || page === "enter" && mask.angularDirection === "counter-clockwise";
    const firstColor = isTransparentToBlack ? "transparent" : "black";
    const secondColor = isTransparentToBlack ? "black" : "transparent";
    let gradient = `conic-gradient(from `;
    gradient += `${mask.angle}deg at ${mask.x} ${mask.y}, `;
    gradient += `${firstColor} 0%, ${firstColor} ${offsetToken}, `;
    gradient += `${secondColor} ${offsetToken}, ${secondColor} 100%)`;
    return `mask-image: ${gradient}; -webkit-mask-image: ${gradient};`;
  },
  makePropertyRules: () => `
        @property ${cssVariable("conic-offset")} {
            syntax: '<percentage>';
            initial-value: 0%;
            inherits: false;
        }
    `
};
var circle = {
  makeKeyframe: (mask, progress2) => {
    const { x, y } = calcMaskPosition(mask);
    if (progress2 === "start") {
      return `clip-path: circle(0 at ${x}px ${y}px);`;
    } else {
      const endRadius = Math.hypot(Math.max(x, window.innerWidth - x), Math.max(y, window.innerHeight - y));
      return `clip-path: circle(${endRadius}px at ${x}px ${y}px);`;
    }
  }
};
var inset = {
  makeKeyframe: (mask, progress2) => {
    const { x, y } = calcMaskPosition(mask);
    const bottom = window.innerHeight - y;
    const right = window.innerWidth - x;
    return progress2 === "start" ? `clip-path: inset(${y}px ${right}px ${bottom}px ${x}px round ${mask.round}px);` : `clip-path: inset(0 round 0);`;
  }
};
var blinds = {
  makeKeyframe: (mask, progress2, page) => {
    const [, unit] = parseUnit(mask.width);
    let width = `0${unit}`;
    if (progress2 === "start" && page === "exit" || progress2 === "end" && page === "enter") {
      width = mask.width;
    }
    return `${cssVariable("blinds-width")}: ${width};`;
  },
  makeStyles: (mask, page) => {
    const widthToken = `var(${cssVariable("blinds-width")})`;
    const firstColor = page === "exit" ? "transparent" : "black";
    const secondColor = page === "exit" ? "black" : "transparent";
    let gradient = `repeating-linear-gradient(`;
    gradient += mask.angle + 90 + "deg, ";
    gradient += `${firstColor} 0px, ${firstColor} ${widthToken}, `;
    gradient += `${secondColor} ${widthToken}, ${secondColor} ${mask.width})`;
    return `mask-image: ${gradient}; -webkit-mask-image: ${gradient};`;
  },
  makePropertyRules: () => {
    return `
            @property ${cssVariable("blinds-width")} {
                syntax: '<length-percentage>';
                initial-value: 0px;
                inherits: false;
            }
        `;
  }
};
var wipe = {
  makeKeyframe: (_mask, progress2, page) => {
    const offset = progress2 === "start" && page === "exit" || progress2 === "end" && page === "enter" ? 1 : 0;
    return `${cssVariable("wipe-offset")}: ${offset};`;
  },
  makeStyles: (mask, page) => {
    const offsetToken = `var(${cssVariable("wipe-offset")})`;
    const firstColor = page === "exit" ? "transparent" : "black";
    const secondColor = page === "exit" ? "black" : "transparent";
    let gradient = `linear-gradient(`;
    gradient += mask.angle + 90 + "deg, ";
    gradient += `${firstColor} calc(calc(0% - ${mask.width}) + calc(calc(100% + ${mask.width}) * ${offsetToken})), `;
    gradient += `${secondColor} calc(calc(100% + ${mask.width}) * ${offsetToken}))`;
    return `mask-image: ${gradient}; -webkit-mask-image: ${gradient};`;
  },
  makePropertyRules: () => {
    return `
            @property ${cssVariable("wipe-offset")} {
                syntax: '<number>';
                initial-value: 0;
                inherits: false;
            }
        `;
  }
};
var maskGenerators = { circle, conic, inset, blinds, wipe };

// ../../library/src/router/pageEffects/cssGeneration/page.ts
var restState = {
  opacity: 1,
  x: "0px",
  y: "0px",
  scale: 1,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
  mask: void 0
};
function valuesToCSSKeyframes(values, progress2, page, maskGenerator) {
  let keyframes2 = `
      opacity: ${values.opacity};
      transform: translate(${values.x}, ${values.y}) scale(${values.scale}) rotateX(${values.rotateX}deg) rotateY(${values.rotateY}deg) rotateZ(${values.rotate}deg);
    `;
  if (values.mask) {
    keyframes2 += maskGenerator?.makeKeyframe?.(values.mask, progress2, page) || "";
  }
  return keyframes2;
}
function getMaskGenerator(type) {
  return type ? maskGenerators[type] : void 0;
}
function createPageTransitionRules(page, { transition, ...values }) {
  const name = "view-transition-" + page;
  const settings = { duration: "0s", easing: "linear" };
  if (transition.type === "tween") {
    settings.duration = transition.duration + "s";
    settings.easing = `cubic-bezier(${transition.ease.join(",")})`;
  } else if (isSpringTransition(transition)) {
    const { easing, duration } = createLinearEasing(
      spring({
        keyframes: [0, 1],
        ...getSpringOptions(transition),
        restDelta: 1e-3,
        restSpeed: 1e-4
      })
    );
    settings.duration = duration + "ms";
    settings.easing = easing;
  }
  const maskGenerator = getMaskGenerator(values?.mask?.type);
  let startKeyframes = valuesToCSSKeyframes(values, "start", page, maskGenerator);
  let endKeyframes = valuesToCSSKeyframes({ ...restState, mask: values.mask }, "end", page, maskGenerator);
  if (page === "exit") {
    ;
    [startKeyframes, endKeyframes] = [endKeyframes, startKeyframes];
  }
  return `
        ${values.mask && maskGenerator?.makePropertyRules ? maskGenerator.makePropertyRules(values.mask) : ""}

        @keyframes ${name} {
            0% {
                ${startKeyframes}
            }

            100% {
                ${endKeyframes}
            }
        }

        ::view-transition-${page === "enter" ? "new" : "old"}(root) {
            animation-name: ${name};
            animation-duration: ${settings.duration};
            animation-delay: ${transition.delay}s;
            animation-timing-function: ${settings.easing};
            animation-fill-mode: both;
            ${values.mask && maskGenerator?.makeStyles ? maskGenerator.makeStyles(values.mask, page) : ""}
        }
    `;
}
function isSpringTransition(transition) {
  return transition.type === "spring";
}
function getSpringOptions(transition) {
  if (transition.durationBasedSpring) {
    return {
      duration: transition.duration * 1e3,
      bounce: transition.bounce
    };
  }
  return {
    stiffness: transition.stiffness,
    damping: transition.damping,
    mass: transition.mass
  };
}

// ../../library/src/router/pageEffects/cssGeneration/index.ts
var VIEW_TRANSITION_STYLES_ID = "view-transition-styles";
var defaultPageTransition = {
  x: "0px",
  y: "0px",
  scale: 1,
  opacity: 1,
  rotate3d: false,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
  mask: void 0,
  transition: {
    type: "tween",
    delay: 0,
    duration: 0.2,
    ease: [0.27, 0, 0.51, 1],
    stiffness: 400,
    damping: 30,
    mass: 1
  }
};
function createViewTransitionStylesheet({ exit = defaultPageTransition, enter }) {
  const styleElement = document.createElement("style");
  styleElement.id = VIEW_TRANSITION_STYLES_ID;
  let styleContent = `
        @media (prefers-reduced-motion) {
            ::view-transition-group(*),
            ::view-transition-old(*),
            ::view-transition-new(*) {
                animation: none !important;
            }
        }
    `;
  const disableMixPlusLighter = exit.mask || enter.mask || exit.opacity || enter.opacity || exit.transition.delay || enter.transition.delay;
  if (disableMixPlusLighter) {
    styleContent += `
            ::view-transition-old(*),
            ::view-transition-new(*) {
                mix-blend-mode: normal;
            }
        `;
  }
  styleContent += `
        ::view-transition-old(*),
        ::view-transition-new(*) {
            backface-visibility: hidden;
        }
    `;
  styleContent += createPageTransitionRules("exit", exit);
  styleContent += createPageTransitionRules("enter", enter);
  styleElement.textContent = styleContent;
  document.head.appendChild(styleElement);
}
function removeViewTransitionStylesheet() {
  requestIdleCallback(() => {
    frame.render(() => {
      performance.mark("framer-vt-remove");
      const element = document.getElementById(VIEW_TRANSITION_STYLES_ID);
      if (element) {
        document.head.removeChild(element);
      }
    });
  });
}

// ../../library/src/router/pageEffects/viewTransition.ts
var noop3 = () => {
};
function supportsViewTransitions() {
  return Boolean(document.startViewTransition);
}
function addVTStylesheetAfterInRender(effect) {
  return new Promise((resolve) => {
    frame.render(() => {
      performance.mark("framer-vt-style");
      createViewTransitionStylesheet(effect);
      resolve();
    });
  });
}
async function startViewTransition(updateView, effect, signal) {
  if (!supportsViewTransitions()) {
    void updateView();
    return;
  }
  await addVTStylesheetAfterInRender(effect);
  if (signal?.aborted) return;
  performance.mark("framer-vt");
  const transition = document.startViewTransition(async () => {
    performance.mark("framer-vt-freeze");
    if (signal?.aborted) return;
    else signal?.addEventListener("abort", () => transition.skipTransition());
    await updateView();
  });
  transition.updateCallbackDone.then(() => {
    performance.mark("framer-vt-unfreeze");
  }).catch(noop3);
  Promise.all([transition.ready, transition.finished]).then(() => {
    performance.mark("framer-vt-finished");
    removeViewTransitionStylesheet();
  }).catch(noop3);
  return transition;
}

// ../../library/src/router/pageEffects/useViewTransition.ts
function useViewTransition() {
  const sitePageEffects = usePageEffects();
  const resolveHasPainted = useRef(void 0);
  useEffect3(() => {
    if (resolveHasPainted.current) {
      resolveHasPainted.current();
      resolveHasPainted.current = void 0;
    }
  });
  return useCallback(
    (currentRouteId, nextRouteId, update, signal) => {
      const pageEffect = getPageEffectForRoute(currentRouteId, nextRouteId, sitePageEffects);
      if (pageEffect) {
        const hasPainted = new Promise((resolve) => {
          resolveHasPainted.current = resolve;
        });
        return startViewTransition(
          async () => {
            update();
            await hasPainted;
          },
          pageEffect,
          signal
        );
      }
      update();
    },
    [sitePageEffects]
  );
}

// ../../library/src/router/routerDomUtils.ts
function updateCanonicalURL(url, prevUrl) {
  requestIdleCallback(() => {
    const canonical = document.querySelector("link[rel='canonical']");
    if (!canonical) return;
    const newURL = new URL(url, prevUrl);
    newURL.search = "";
    canonical.setAttribute("href", newURL.toString());
  });
}
var announceDiv;
var announceNavigation = () => {
  if (!announceDiv) {
    announceDiv = document.createElement("div");
    announceDiv.setAttribute("aria-live", "assertive");
    announceDiv.setAttribute("aria-atomic", "true");
    announceDiv.style.position = "absolute";
    announceDiv.style.transform = "scale(0)";
    document.body.append(announceDiv);
  }
  setTimeout(() => {
    announceDiv.textContent = document.title;
  }, 60);
};

// ../../library/src/router/useMonitorNextPaintAfterRender.ts
import { useCallback as useCallback2, useRef as useRef2 } from "react";

// ../../library/src/utils/useAfterPaintEffect.ts
import { useLayoutEffect } from "react";
function useAfterPaintEffect(effectFn, deps, options, useEffectFn = useLayoutEffect) {
  useEffectFn(() => {
    const runAfterPaint = async (fn) => {
      await yieldToMain({ ...options, continueAfter: "paint" });
      return fn();
    };
    const runPromise = runAfterPaint(effectFn);
    return () => {
      void (async () => {
        const cleanup = await runPromise;
        if (!cleanup) return;
        void runAfterPaint(cleanup);
      })();
    };
  }, deps);
}

// ../../library/src/router/useMonitorNextPaintAfterRender.ts
function useMonitorNextPaintAfterRender(label) {
  const resolveHasPainted = useRef2(void 0);
  useAfterPaintEffect(
    () => {
      if (resolveHasPainted.current) {
        resolveHasPainted.current();
        resolveHasPainted.current = void 0;
      }
    },
    void 0,
    // user-blocking ensures we get the correct timings here. Other priorities might delay this effect a little bit.
    { priority: "user-blocking" }
  );
  return useCallback2(
    (measureDetail) => {
      const hasPainted = new Promise((resolve) => {
        resolveHasPainted.current = resolve;
      });
      if (!label) return { promise: hasPainted, measureDetail, ignore: null };
      const startLabel = `${label}-start`;
      const endLabel = `${label}-end`;
      let ignore = false;
      performance.mark(startLabel);
      hasPainted.finally(() => {
        if (ignore) return;
        performance.mark(endLabel);
        performance.measure(label, {
          start: startLabel,
          end: endLabel,
          detail: measureDetail
        });
      }).catch((e) => {
        console.error(e);
      });
      return {
        promise: hasPainted,
        measureDetail,
        ignore: () => {
          ignore = true;
          resolveHasPainted.current?.();
          resolveHasPainted.current = void 0;
        }
      };
    },
    [label]
  );
}

// ../../library/src/router/history.ts
async function pushRouteState(routeId, route, {
  currentRoutePath,
  currentRoutePathLocalized,
  currentPathVariables,
  hash: hash2,
  pathVariables,
  localeId,
  preserveQueryParams,
  siteCanonicalURL
}, isNavigationTransition = false) {
  const { path } = route;
  if (!path) return;
  const newPath = getPathForRoute(route, {
    currentRoutePath,
    currentRoutePathLocalized,
    currentPathVariables,
    hash: hash2,
    pathVariables,
    preserveQueryParams,
    siteCanonicalURL,
    localeId
  });
  try {
    return await pushHistoryState({ routeId, hash: hash2, pathVariables, localeId }, newPath, isNavigationTransition);
  } catch {
  }
}
function isHistoryState(data2) {
  const routeIdKey = "routeId";
  return isObject2(data2) && isString(data2[routeIdKey]);
}
function replaceHistoryState(data2, url, ignoreReplaceStateWrapper = false) {
  performance.mark("framer-history-replace");
  const replaceState = ignoreReplaceStateWrapper ? window.history.__proto__.replaceState : window.history.replaceState;
  replaceState.call(window.history, data2, "", url);
}
var maybeHasPopstateBug = true;
var isImpactedPopstateBugChromiumVersion = /* @__PURE__ */ (() => {
  if (typeof navigator === "undefined") return false;
  const userAgent = navigator.userAgent;
  const chromePos = userAgent.indexOf("Chrome/");
  const chromiumVersion = +userAgent.slice(chromePos + 7, userAgent.indexOf(".", chromePos));
  return chromiumVersion > 101 && chromiumVersion < 128;
})();
async function pushHistoryState(data2, url, isNavigationTransition = false) {
  performance.mark("framer-history-push");
  updateCanonicalURL(url, window.location.href);
  if (!isNavigationTransition) {
    window.history.pushState(data2, "", url);
    return;
  }
  let popstateCalled = false, popstateListener;
  if (maybeHasPopstateBug) {
    popstateListener = () => {
      popstateCalled = true;
      if (isImpactedPopstateBugChromiumVersion) return;
      const msg = "Popstate called after intercept(). Please report this to the Framer team.";
      console.error(msg);
      sendTrackingEvent("published_site_load_recoverable_error", {
        message: msg
      });
    };
    window.addEventListener("popstate", popstateListener, { once: true });
  }
  if (isImpactedPopstateBugChromiumVersion && maybeHasPopstateBug) {
    window.history.__proto__.pushState.call(window.history, data2, "", url);
  } else {
    window.history.pushState(data2, "", url);
  }
  if (maybeHasPopstateBug) {
    queueMicrotask(() => {
      if (popstateCalled) return;
      maybeHasPopstateBug = false;
      window.removeEventListener("popstate", popstateListener);
      return;
    });
  }
}
function useReplaceInitialState({
  disabled,
  routeId,
  initialPathVariables,
  initialLocaleId
}) {
  useLayoutEffect2(() => {
    if (disabled) return;
    performance.mark("framer-history-set-initial-state");
    replaceHistoryState(
      { routeId, pathVariables: initialPathVariables, localeId: initialLocaleId },
      void 0,
      true
    );
  }, []);
}
var supportsNavigationAPI = /* @__PURE__ */ (() => isWindow && typeof window.navigation?.back === "function")();
function usePopStateHandler(currentRouteId, setCurrentRouteId) {
  const startViewTransition2 = useViewTransition();
  const monitorNextPaintAfterRender = useMonitorNextPaintAfterRender("framer-route-change");
  const viewTransitionReady = useRef3(void 0);
  const popStateHandler = useCallback3(
    async ({ state }) => {
      if (window.navigation?.transition && window.navigation?.transition?.navigationType !== "traverse") return;
      if (!isObject2(state)) return;
      const { routeId, hash: hash2, pathVariables, localeId } = state;
      if (!isString(routeId)) return;
      const nextRender = monitorNextPaintAfterRender({
        popstate: true
      });
      const stopMonitoringINPRelatedInputs = monitorINPRelatedInputs();
      void nextRender.promise.finally(stopMonitoringINPRelatedInputs);
      const changeRoute = () => {
        setCurrentRouteId(
          routeId,
          isString(localeId) ? localeId : void 0,
          isString(hash2) ? hash2 : void 0,
          window.location.pathname + window.location.search + window.location.hash,
          isObject2(pathVariables) ? pathVariables : void 0,
          true,
          nextRender,
          false
        );
      };
      const viewTransition = await startViewTransition2(currentRouteId.current, routeId, changeRoute);
      const navigationTransition = window.navigation?.transition;
      await (viewTransition?.updateCallbackDone ?? Promise.resolve()).then(viewTransitionReady.current?.resolve).catch(viewTransitionReady.current?.reject);
      await nextRender.promise;
      try {
        await navigationTransition?.finished;
      } catch (error) {
        console.warn("Popstate transition failed", error);
      }
      announceNavigation();
      updateCanonicalURL(window.location.href);
    },
    [currentRouteId, monitorNextPaintAfterRender, setCurrentRouteId, startViewTransition2]
  );
  const traversalHandler = useCallback3((event) => {
    if (event.navigationType !== "traverse" || !event.canIntercept) return;
    event.intercept({
      async handler() {
        await new Promise((resolve, reject) => {
          viewTransitionReady.current = { resolve, reject };
        });
        viewTransitionReady.current = void 0;
      },
      scroll: "after-transition"
    });
  }, []);
  useEffect4(() => {
    window.addEventListener("popstate", popStateHandler);
    if (supportsNavigationAPI) window.navigation.addEventListener("navigate", traversalHandler);
    return () => {
      window.removeEventListener("popstate", popStateHandler);
      if (supportsNavigationAPI) window.navigation.removeEventListener("navigate", traversalHandler);
    };
  }, [popStateHandler, traversalHandler]);
}
function getHashForRoute(hash2, route, hashVariables) {
  const resolvedHash = getRouteElementId(route, hash2);
  if (!resolvedHash) return void 0;
  const variables = Object.assign({}, route?.elements, hashVariables);
  return resolvedHash.replace(pathVariablesRegExp, (m2, p1) => variables[p1] ?? m2);
}
function getPathForRoute(route, {
  currentRoutePath,
  currentRoutePathLocalized,
  currentPathVariables,
  hash: hash2,
  pathVariables,
  hashVariables,
  relative: relative2 = true,
  preserveQueryParams,
  onlyHash = false,
  siteCanonicalURL,
  localeId
}) {
  const resolvedHash = getHashForRoute(hash2, route, hashVariables);
  if (onlyHash) return resolvedHash ?? "";
  let currentPath = currentRoutePath ?? "/";
  if (currentRoutePathLocalized && localeId) {
    currentPath = currentRoutePathLocalized[localeId] ?? currentPath;
  }
  if (currentPathVariables) {
    currentPath = currentPath.replace(pathVariablesRegExp, (m2, p1) => String(currentPathVariables[p1] || m2));
  }
  const targetPathLocalized = localeId ? route?.pathLocalized?.[localeId] : void 0;
  const targetPath = targetPathLocalized ?? route?.path ?? "/";
  let path = targetPath;
  if (pathVariables) {
    path = path.replace(pathVariablesRegExp, (m2, p1) => String(pathVariables[p1] || m2));
  }
  const isSamePageHashNavigation = currentPath === path && resolvedHash;
  if (relative2) {
    if (customNotFoundPagePaths.has(currentPath) && typeof window !== "undefined") {
      const sitePrefix = getSitePrefix(siteCanonicalURL);
      path = computeRelativePath(window.location.pathname, sitePrefix + path);
    } else {
      path = computeRelativePath(currentPath, path);
    }
  }
  if (preserveQueryParams || isSamePageHashNavigation) {
    path = forwardCurrentQueryParams(path);
  }
  if (resolvedHash) {
    path = `${path}#${resolvedHash}`;
  }
  return path;
}
async function handleRedirectForMissingSlugs(route, pathVariables, nextLocale) {
  if (!route.path) return false;
  if (!pathVariables) return false;
  const prefix3 = nextLocale.slug ? `/${nextLocale.slug}` : "";
  const nextLocaleWithDefaultSlugPath = `${prefix3}${fillPathVariables(route.path, pathVariables)}`;
  const response = await fetch(nextLocaleWithDefaultSlugPath, {
    method: "HEAD",
    redirect: "manual"
  });
  const isRedirect = response.type === "opaqueredirect";
  if (isRedirect) {
    window.location.href = window.location.origin + nextLocaleWithDefaultSlugPath;
    return true;
  }
  return false;
}
function useSwitchLocale() {
  const collectionUtils = useCollectionUtils();
  return useCallback3(
    (options) => {
      return switchLocale({ ...options, collectionUtils });
    },
    [collectionUtils]
  );
}
async function switchLocale(options) {
  const result = await getLocalizedNavigationPath(options);
  if (!result) return;
  try {
    localStorage.preferredLocale = options.nextLocale.code;
  } catch {
  }
  try {
    if (!isString(result.path)) {
      throw new Error("Expected result.path to be a string");
    }
    if (result.isMissingInLocale) {
      const hasRedirect = await handleRedirectForMissingSlugs(
        options.route,
        result.pathVariables,
        options.nextLocale
      );
      if (hasRedirect) return;
    }
  } catch {
  }
  return result;
}
function pushLoadMoreHistory(hash2, paginationInfo) {
  try {
    const currentHistoryState = window.history.state;
    if (!isHistoryState(currentHistoryState)) return;
    const isInitialLoad = currentHistoryState?.paginationInfo === void 0 || currentHistoryState.paginationInfo[hash2] === void 0;
    const newPaginationInfo = { ...currentHistoryState.paginationInfo, [hash2]: paginationInfo };
    replaceHistoryState({ ...currentHistoryState, paginationInfo: newPaginationInfo }, void 0, isInitialLoad);
  } catch {
  }
}
function useNativeLoadingSpinner() {
  const navigationPromise = useRef3(Promise.resolve());
  const navigationController = useRef3();
  const navigateListener = useCallback3((navigateEvent) => {
    if (navigateEvent.navigationType === "traverse" || !navigateEvent.canIntercept) return;
    const controller = navigationController.current;
    controller?.signal.addEventListener("abort", () => {
      controller.abort("user aborted");
    });
    navigateEvent.intercept({
      handler: () => navigationPromise.current
    });
  }, []);
  return useCallback3(
    (promise, updateURL, controller) => {
      if (!supportsNavigationAPI) {
        void updateURL();
        return;
      }
      navigationPromise.current = promise;
      navigationController.current = controller;
      window.navigation.addEventListener("navigate", navigateListener);
      void updateURL(true);
      void promise.finally(() => {
        window.navigation.removeEventListener("navigate", navigateListener);
      });
    },
    [navigateListener]
  );
}

// ../../library/src/modules/useTracking.ts
import { useCallback as useCallback4, useContext as useContext3 } from "react";

// ../../library/src/utils/slugify.ts
var nonSlugCharactersRegExp = /[^\p{Letter}\p{Number}()]+/gu;
var trimSlugRegExp = /^-+|-+$/gu;
function slugify(value) {
  return value.toLowerCase().replace(nonSlugCharactersRegExp, "-").replace(trimSlugRegExp, "");
}

// ../../library/src/modules/NodeIdContext.tsx
import React7 from "react";
var NodeIdContext = /* @__PURE__ */ React7.createContext(null);

// ../../library/src/modules/useTracking.ts
function useTracking() {
  const router = useRouter();
  const nodeId = useContext3(NodeIdContext);
  return useCallback4(
    (trackingId) => {
      if (!router.pageviewEventData?.current) return;
      if (slugify(trackingId) !== trackingId) {
        throw new Error(`Invalid tracking ID: ${trackingId}`);
      }
      if (router.pageviewEventData.current instanceof Promise) {
        void router.pageviewEventData.current.then(
          (eventData) => sendCustomTrackingEvent(eventData, nodeId, trackingId)
        );
      } else {
        sendCustomTrackingEvent(router.pageviewEventData.current, nodeId, trackingId);
      }
    },
    [router, nodeId]
  );
}
function sendCustomTrackingEvent(eventData, nodeId, trackingId) {
  sendTrackingEvent(
    "published_site_custom_event",
    {
      ...eventData,
      nodeId,
      // Don't attach a tracking ID if it's empty
      trackingId: trackingId || null
    },
    "eager"
  );
}

// ../../library/src/router/queryParameters.tsx
import {
  createContext as createContext2,
  useCallback as useCallback5,
  useContext as useContext4,
  useDeferredValue,
  useMemo as useMemo4,
  useRef as useRef5,
  useSyncExternalStore
} from "react";

// ../../library/src/utils/useMemoOne.ts
import { useEffect as useEffect5, useRef as useRef4, useState } from "react";
function useMemoOne(factory, inputs) {
  const initial = useState(() => ({
    inputs,
    result: factory()
  }))[0];
  const isFirstRun = useRef4(true);
  const committed = useRef4(initial);
  const useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && isEqual(inputs, committed.current.inputs, false));
  const cache2 = useCache ? committed.current : {
    inputs,
    result: factory()
  };
  useEffect5(() => {
    isFirstRun.current = false;
    committed.current = cache2;
  }, [cache2]);
  return cache2.result;
}

// ../../library/src/router/useLocale.ts
import React8 from "react";

// ../../library/src/router/getLocalesForCurrentRoute.ts
async function getLocalesForCurrentRoute(activeLocale, locales, currentRoute, pathVariables, collectionUtils) {
  if (!currentRoute) return locales;
  const slugByLocaleIfCollectionPage = await getSlugByLocaleIfCollectionPage(
    activeLocale,
    locales,
    currentRoute,
    pathVariables,
    collectionUtils
  );
  const includedLocalesForCurrentRoute = currentRoute.includedLocales;
  const localesForCurrentRoute = [];
  for (const locale of locales) {
    if (includedLocalesForCurrentRoute) {
      if (!includedLocalesForCurrentRoute.includes(locale.id)) continue;
    }
    if (slugByLocaleIfCollectionPage) {
      const hasSlug = slugByLocaleIfCollectionPage.has(locale.id);
      if (!hasSlug) continue;
    }
    localesForCurrentRoute.push(locale);
  }
  return localesForCurrentRoute;
}
async function getSlugByLocaleIfCollectionPage(activeLocale, locales, currentRoute, pathVariables, collectionUtils) {
  const { collectionId } = currentRoute;
  if (!collectionId) return null;
  if (!activeLocale) return null;
  if (!pathVariables) return null;
  const { path } = currentRoute;
  if (!path) return null;
  const matches = Array.from(path.matchAll(pathVariablesRegExp));
  const lastMatch = matches.pop();
  if (!lastMatch) return null;
  const pathVariableWithDelimiter = lastMatch?.[0];
  const pathVariableValue = lastMatch?.[1];
  if (!pathVariableWithDelimiter || !pathVariableValue) {
    throw new Error("Failed to replace path variables: unexpected regex match group");
  }
  const currentSlug = pathVariables[pathVariableValue];
  if (!currentSlug || !isString(currentSlug)) {
    throw new Error(`No slug found for path variable ${pathVariableValue}`);
  }
  const utils = collectionUtils?.get(collectionId);
  if (!utils) return null;
  const maybeRecordId = utils.getRecordIdBySlug(currentSlug, activeLocale);
  const recordId = isPromise(maybeRecordId) ? await maybeRecordId : maybeRecordId;
  if (!recordId) return null;
  const slugById = /* @__PURE__ */ new Map();
  await Promise.all(
    locales.map(async (locale) => {
      const maybeSlug = utils.getSlugByRecordId(recordId, locale);
      const slug = isPromise(maybeSlug) ? await maybeSlug : maybeSlug;
      if (!slug) return;
      slugById.set(locale.id, slug);
    })
  );
  return slugById;
}

// ../../library/src/router/useLocale.ts
var noopAsync = async () => {
};
var defaultLocaleInfo = {
  activeLocale: null,
  locales: [],
  setLocale: noopAsync
};
var LocaleInfoContext = /* @__PURE__ */ (() => {
  const Context2 = React8.createContext(defaultLocaleInfo);
  Context2.displayName = "LocaleInfoContext";
  return Context2;
})();
function useLocaleInfo() {
  return React8.useContext(LocaleInfoContext);
}
function useLocalesForCurrentRoute() {
  const { currentRouteId, routes, currentPathVariables } = useRouter();
  const { activeLocale, locales } = useLocaleInfo();
  const [localesForCurrentRoute, setLocalesForCurrentRoute] = React8.useState(
    () => activeLocale ? [activeLocale] : []
  );
  const currentRoute = currentRouteId ? routes?.[currentRouteId] : void 0;
  const collectionUtils = useCollectionUtils();
  React8.useEffect(() => {
    let active = true;
    getLocalesForCurrentRoute(activeLocale, locales, currentRoute, currentPathVariables, collectionUtils).then((localesSubset) => {
      if (!active) return;
      React8.startTransition(() => {
        if (localesSubset) {
          setLocalesForCurrentRoute(localesSubset);
        } else {
          setLocalesForCurrentRoute(activeLocale ? [activeLocale] : []);
        }
      });
    }).catch(() => {
    });
    return () => {
      active = false;
    };
  }, [activeLocale, locales, collectionUtils, currentRoute, currentPathVariables]);
  return localesForCurrentRoute;
}
function useLocalizationInfo() {
  const { activeLocale, locales, setLocale } = useLocaleInfo();
  return {
    activeLocalization: activeLocale,
    localizations: locales,
    setLocalization: setLocale
  };
}
function useLocaleCode() {
  return useLocaleInfo().activeLocale?.code ?? "en-US";
}
function useLocale() {
  return useLocaleCode();
}
var LayoutDirectionContext = /* @__PURE__ */ (() => {
  const Context2 = React8.createContext("ltr");
  Context2.displayName = "LayoutDirectionContext";
  return Context2;
})();
function useLayoutDirection() {
  return React8.useContext(LayoutDirectionContext);
}

// ../../library/src/router/queryParameters.tsx
import { jsx as jsx6 } from "react/jsx-runtime";
var URLSearchParamsContext = /* @__PURE__ */ (() => {
  const Context2 = createContext2({
    urlSearchParams: new URLSearchParams(),
    triggerUpdate: () => {
    }
  });
  Context2.displayName = "URLSearchParamsContext";
  return Context2;
})();
function URLSearchParamsProvider({ children }) {
  const onStoreChangeRef = useRef5(null);
  const searchString = useSyncExternalStore(
    (onStoreChange) => {
      onStoreChangeRef.current = onStoreChange;
      const handler = () => {
        onStoreChange();
      };
      window.addEventListener("popstate", handler);
      return () => {
        onStoreChangeRef.current = null;
        window.removeEventListener("popstate", handler);
      };
    },
    () => window.location.search,
    () => ""
  );
  const deferredSearchString = useDeferredValue(searchString);
  const triggerUpdate = useCallback5(() => {
    onStoreChangeRef.current?.();
  }, []);
  const value = useMemoOne(
    () => ({
      urlSearchParams: new URLSearchParams(deferredSearchString),
      triggerUpdate
    }),
    [deferredSearchString, triggerUpdate]
  );
  return /* @__PURE__ */ jsx6(URLSearchParamsContext.Provider, { value, children });
}
function useStringArrayQueryParam({
  initialValue,
  parameterName
}) {
  const parameterNameRef = useRef5(parameterName);
  const { urlSearchParams, triggerUpdate } = useContext4(URLSearchParamsContext);
  const paramValue = urlSearchParams.getAll(parameterNameRef.current);
  const value = paramValue.length > 0 ? paramValue : initialValue;
  const setValue = useCallback5(
    async (newValues) => {
      const currentHistoryState = window.history.state;
      if (!isHistoryState(currentHistoryState)) return;
      const newUrl = new URL(window.location.href);
      newUrl.searchParams.delete(parameterNameRef.current);
      for (const newValue of newValues) {
        newUrl.searchParams.append(parameterNameRef.current, newValue);
      }
      await yieldToMain({ continueAfter: "paint" });
      replaceHistoryState(currentHistoryState, newUrl.toString());
      triggerUpdate();
    },
    [triggerUpdate]
  );
  return [value, setValue];
}
function useStringQueryParam({
  initialValue,
  parameterName
}) {
  const initialArrayValue = useMemo4(() => initialValue ? [initialValue] : EMPTY_ARRAY, [initialValue]);
  const [arrayValue, setArrayValue] = useStringArrayQueryParam({ initialValue: initialArrayValue, parameterName });
  const value = arrayValue[0] ?? "";
  const setValue = useCallback5(
    (newValue) => setArrayValue(newValue ? [newValue] : EMPTY_ARRAY),
    [setArrayValue]
  );
  return [value, setValue];
}
function useCollectionReferenceQueryParam({
  collectionId,
  initialValue,
  parameterName
}) {
  const collectionUtils = useCollectionUtils();
  const locale = useLocaleInfo().activeLocale ?? void 0;
  const [slug, setSlug] = useStringQueryParam({ initialValue: "", parameterName });
  const id = useMemo4(() => {
    if (!slug) return initialValue || void 0;
    const cache2 = getCollectionUtilsCache2(collectionUtils, collectionId);
    return use(cache2.getRecordIdBySlug(slug, locale));
  }, [collectionUtils, collectionId, initialValue, locale, slug]);
  const setId = useCallback5(
    async (newId) => {
      const cache2 = getCollectionUtilsCache2(collectionUtils, collectionId);
      const newSlug = await cache2.getSlugByRecordId(newId, locale);
      if (typeof newSlug === "string") {
        await setSlug(newSlug);
      }
    },
    [collectionUtils, collectionId, locale, setSlug]
  );
  return [id, setId];
}
function useMultiCollectionReferenceQueryParam({
  collectionId,
  initialValue,
  parameterName
}) {
  const collectionUtils = useCollectionUtils();
  const locale = useLocaleInfo().activeLocale ?? void 0;
  const [slugs, setSlugs] = useStringArrayQueryParam({ initialValue: [], parameterName });
  const ids = useMemo4(() => {
    if (slugs.length === 0) return initialValue;
    const cache2 = getCollectionUtilsCache2(collectionUtils, collectionId);
    const maybePromises = slugs.map((slug) => cache2.getRecordIdBySlug(slug, locale));
    return useAll(maybePromises).filter(isString);
  }, [collectionUtils, collectionId, initialValue, locale, slugs]);
  const setIds = useCallback5(
    async (newIds) => {
      const cache2 = getCollectionUtilsCache2(collectionUtils, collectionId);
      const newSlugs = await Promise.all(newIds.map((id) => cache2.getSlugByRecordId(id, locale)));
      await setSlugs(newSlugs.filter(isString));
    },
    [collectionUtils, collectionId, locale, setSlugs]
  );
  return [ids, setIds];
}
function getCollectionUtilsCache2(collectionUtils, collectionId) {
  const collectionUtilsCache = collectionUtils?.get(collectionId);
  assert(collectionUtilsCache, "CollectionUtilsCache not found for collectionId:", collectionId);
  return collectionUtilsCache;
}
function use(maybePromise) {
  if (isPromise(maybePromise)) throw maybePromise;
  return maybePromise;
}
function useAll(maybePromises) {
  for (const maybePromise of maybePromises) {
    if (isPromise(maybePromise)) {
      throw Promise.all(maybePromises);
    }
  }
  return maybePromises;
}

// ../../library/src/router/useRouteAnchor.ts
import React9 from "react";
function useRouteAnchor(routeId, { elementId, hash: linkHash } = {}) {
  const { navigate, currentPathVariables, preserveQueryParams, siteCanonicalURL } = useRouter();
  const { activeLocale } = useLocaleInfo();
  const route = useRoute(routeId);
  const currentRouteId = useCurrentRouteId();
  const currentRoute = useRoute(currentRouteId ?? "");
  useRoutePreloader([routeId], true);
  const hash2 = linkHash ?? elementId;
  const href = React9.useMemo(
    () => getPathForRoute(route, {
      currentRoutePath: currentRoute?.path,
      currentRoutePathLocalized: currentRoute?.pathLocalized,
      currentPathVariables,
      hash: hash2,
      preserveQueryParams,
      siteCanonicalURL,
      localeId: activeLocale?.id
    }),
    [currentRoute, currentPathVariables, hash2, preserveQueryParams, route, siteCanonicalURL, activeLocale?.id]
  );
  const navigateToRoute = React9.useCallback(() => navigate?.(routeId, hash2), [hash2, navigate, routeId]);
  const onClick = React9.useCallback(
    (event) => {
      event.preventDefault();
      navigateToRoute();
    },
    [navigateToRoute]
  );
  return { onClick, href };
}

// ../../library/src/router/hydration/reactHydrationINPOptimizer.ts
import { useEffect as useEffect6 } from "react";
var eventsToStop = [
  "mousedown",
  "mouseup",
  "touchcancel",
  "touchend",
  "touchstart",
  "auxclick",
  "dblclick",
  "pointercancel",
  "pointerdown",
  "pointerup",
  "dragend",
  "dragstart",
  "drop",
  "compositionend",
  "compositionstart",
  "keydown",
  "keypress",
  "keyup",
  "input",
  "textInput",
  // Intentionally camelCase
  "copy",
  "cut",
  "paste",
  "click",
  "change",
  "contextmenu",
  "reset"
];
var stopFn = (event) => {
  if (!event.target?.closest?.("#main")) return;
  event.stopPropagation();
  performance.mark("framer-react-event-handling-prevented");
};
var shouldTurnOnEventHandling = false;
function turnOffReactEventHandling() {
  if (!eventsToStop) return;
  shouldTurnOnEventHandling = true;
  performance.mark("framer-react-event-handling-start");
  const options = { capture: true };
  const body = document.body;
  eventsToStop.forEach((event) => body.addEventListener(event, stopFn, options));
}
function TurnOnReactEventHandling() {
  useEffect6(() => {
    if (!shouldTurnOnEventHandling || !eventsToStop) return;
    const options = { capture: true };
    const body = document.body;
    eventsToStop.forEach((event) => body.removeEventListener(event, stopFn, options));
    eventsToStop = void 0;
    performance.mark("framer-react-event-handling-end");
  }, []);
  return null;
}

// ../../library/src/router/hydration/hydrationTimings.ts
import { useEffect as useEffect7, useInsertionEffect, useLayoutEffect as useLayoutEffect3 } from "react";

// ../../library/src/router/hydration/onlyRunOnce.ts
function onlyRunOnce(originalMethod) {
  let hasRun = false;
  return function(...args) {
    if (hasRun) return;
    hasRun = true;
    return originalMethod.apply(this, args);
  };
}

// ../../library/src/router/hydration/hydrationTimings.ts
function measureSafe(name, start, end) {
  try {
    performance.measure(name, start, end);
  } catch (e) {
    console.warn(`Could not measure ${name}`, e);
  }
}
var _measureUnattributedHydrationOverhead_dec, _measureMutationEffects_dec, _markLayoutStylePaintEnd_dec, _markRafEnd_dec, _markRafStart_dec, _markUseEffectsEnd_dec, _markUseEffectsAreSynchronous_dec, _markUseEffectsRouterStart_dec, _markUseEffectsStart_dec, _markUseLayoutEffectsEnd_dec, _markRouterUseLayoutEffectStart_dec, _markUseLayoutEffectsStart_dec, _markUseInsertionEffectsEnd_dec, _markUseInsertionEffectRouterStart_dec, _markUseInsertionEffectsStart_dec, _markRenderEnd_dec, _markRenderStart_dec, _init;
_markRenderStart_dec = [onlyRunOnce], _markRenderEnd_dec = [onlyRunOnce], _markUseInsertionEffectsStart_dec = [onlyRunOnce], _markUseInsertionEffectRouterStart_dec = [onlyRunOnce], _markUseInsertionEffectsEnd_dec = [onlyRunOnce], _markUseLayoutEffectsStart_dec = [onlyRunOnce], _markRouterUseLayoutEffectStart_dec = [onlyRunOnce], _markUseLayoutEffectsEnd_dec = [onlyRunOnce], _markUseEffectsStart_dec = [onlyRunOnce], _markUseEffectsRouterStart_dec = [onlyRunOnce], _markUseEffectsAreSynchronous_dec = [onlyRunOnce], _markUseEffectsEnd_dec = [onlyRunOnce], _markRafStart_dec = [onlyRunOnce], _markRafEnd_dec = [onlyRunOnce], _markLayoutStylePaintEnd_dec = [onlyRunOnce], _measureMutationEffects_dec = [onlyRunOnce], _measureUnattributedHydrationOverhead_dec = [onlyRunOnce];
var HydrationMarker = class {
  constructor() {
    __runInitializers(_init, 5, this);
    __publicField(this, "render", {
      markStart: () => this.markRenderStart(),
      markEnd: () => this.markRenderEnd()
    });
    __publicField(this, "mutationEffects", {
      measure: () => this.measureMutationEffects()
    });
    __publicField(this, "useInsertionEffects", {
      markStart: () => this.markUseInsertionEffectsStart(),
      markRouterStart: () => this.markUseInsertionEffectRouterStart(),
      markEnd: () => this.markUseInsertionEffectsEnd()
    });
    __publicField(this, "useLayoutEffects", {
      markStart: () => this.markUseLayoutEffectsStart(),
      markRouterStart: () => this.markRouterUseLayoutEffectStart(),
      markEnd: () => this.markUseLayoutEffectsEnd()
    });
    __publicField(this, "useEffects", {
      markStart: () => this.markUseEffectsStart(),
      markRouterStart: () => this.markUseEffectsRouterStart(),
      markEnd: () => this.markUseEffectsEnd(),
      markAreSynchronous: () => this.markUseEffectsAreSynchronous()
    });
    __publicField(this, "browserRendering", {
      hasStarted: false,
      requestAnimationFrame: {
        markStart: () => this.markRafStart(),
        markEnd: () => this.markRafEnd()
      },
      layoutStylePaint: {
        markEnd: () => this.markLayoutStylePaintEnd()
      }
    });
    __publicField(this, "unattributedHydrationOverhead", {
      measure: () => this.measureUnattributedHydrationOverhead()
    });
  }
  markRenderStart() {
    performance.mark("framer-hydration-start" /* Hydration_Start */);
  }
  markRenderEnd() {
    performance.mark("framer-hydration-render-end" /* ReactRender_End */);
    measureSafe("framer-hydration-render" /* ReactRender */, "framer-hydration-start" /* Hydration_Start */, "framer-hydration-render-end" /* ReactRender_End */);
  }
  markUseInsertionEffectsStart() {
    performance.mark("framer-hydration-insertion-effects-start" /* UseInsertionEffects_Start */);
  }
  markUseInsertionEffectRouterStart() {
    performance.mark("framer-hydration-router-insertion-effect" /* UseInsertionEffect_RouterStart */);
  }
  markUseInsertionEffectsEnd() {
    performance.mark("framer-hydration-insertion-effects-end" /* UseInsertionEffects_End */);
    measureSafe(
      "framer-hydration-insertion-effects" /* UseInsertionEffects */,
      "framer-hydration-insertion-effects-start" /* UseInsertionEffects_Start */,
      "framer-hydration-insertion-effects-end" /* UseInsertionEffects_End */
    );
  }
  markUseLayoutEffectsStart() {
    performance.mark("framer-hydration-layout-effects-start" /* UseLayoutEffects_Start */);
  }
  markRouterUseLayoutEffectStart() {
    performance.mark("framer-hydration-router-layout-effect" /* UseLayoutEffect_RouterStart */);
  }
  markUseLayoutEffectsEnd() {
    performance.mark("framer-hydration-layout-effects-end" /* UseLayoutEffects_End */);
    measureSafe("framer-hydration-layout-effects" /* UseLayoutEffects */, "framer-hydration-layout-effects-start" /* UseLayoutEffects_Start */, "framer-hydration-layout-effects-end" /* UseLayoutEffects_End */);
  }
  markUseEffectsStart() {
    performance.mark("framer-hydration-effects-start" /* UseEffects_Start */);
  }
  markUseEffectsRouterStart() {
    performance.mark("framer-hydration-router-effect" /* UseEffects_RouterStart */);
  }
  markUseEffectsAreSynchronous() {
    performance.mark("framer-hydration-effects-sync" /* UseEffectsAreSynchronous */);
  }
  markUseEffectsEnd() {
    performance.mark("framer-hydration-effects-end" /* UseEffects_End */);
    measureSafe(
      "framer-hydration-effects" /* UseEffects */,
      performance.getEntriesByName("framer-hydration-first-paint" /* BrowserRender_LayoutStylePaintEnd */)[0]?.name ?? performance.getEntriesByName("framer-hydration-effects-start" /* UseEffects_Start */)[0]?.name,
      "framer-hydration-effects-end" /* UseEffects_End */
    );
  }
  markRafStart() {
    this.browserRendering.hasStarted = true;
    performance.mark("framer-hydration-browser-render-start" /* BrowserRender_RafStart */);
  }
  markRafEnd() {
    performance.mark("framer-hydration-browser-raf-end" /* BrowserRender_RafEnd */);
    measureSafe(
      "framer-hydration-raf" /* BrowserRender_RafDuration */,
      "framer-hydration-browser-render-start" /* BrowserRender_RafStart */,
      "framer-hydration-browser-raf-end" /* BrowserRender_RafEnd */
    );
  }
  markLayoutStylePaintEnd() {
    performance.mark("framer-hydration-first-paint" /* BrowserRender_LayoutStylePaintEnd */);
    measureSafe("framer-hydration-time-to-first-paint" /* TimeToFirstPaint */, "framer-hydration-start" /* Hydration_Start */, "framer-hydration-first-paint" /* BrowserRender_LayoutStylePaintEnd */);
    measureSafe(
      "framer-hydration-browser-render" /* BrowserRender_LayoutStylePaintDuration */,
      "framer-hydration-browser-raf-end" /* BrowserRender_RafEnd */,
      "framer-hydration-first-paint" /* BrowserRender_LayoutStylePaintEnd */
    );
  }
  measureMutationEffects() {
    measureSafe("framer-hydration-commit" /* MutationEffects */, "framer-hydration-layout-effects-end" /* UseLayoutEffects_End */, "framer-hydration-effects-start" /* UseEffects_Start */);
  }
  measureUnattributedHydrationOverhead() {
    measureSafe(
      "framer-hydration-uho" /* UnattributedHydrationOverhead */,
      // If effects have run before the start of the render pipeline, we measure from the effects end.
      // If not, the paint will happen before effects run, so we measure from the layout effects end.
      performance.getEntriesByName("framer-hydration-effects-end" /* UseEffects_End */)[0]?.name ?? performance.getEntriesByName("framer-hydration-layout-effects-end" /* UseLayoutEffects_End */)[0]?.name,
      "framer-hydration-browser-render-start" /* BrowserRender_RafStart */
    );
  }
};
_init = __decoratorStart(null);
__decorateElement(_init, 1, "markRenderStart", _markRenderStart_dec, HydrationMarker);
__decorateElement(_init, 1, "markRenderEnd", _markRenderEnd_dec, HydrationMarker);
__decorateElement(_init, 1, "markUseInsertionEffectsStart", _markUseInsertionEffectsStart_dec, HydrationMarker);
__decorateElement(_init, 1, "markUseInsertionEffectRouterStart", _markUseInsertionEffectRouterStart_dec, HydrationMarker);
__decorateElement(_init, 1, "markUseInsertionEffectsEnd", _markUseInsertionEffectsEnd_dec, HydrationMarker);
__decorateElement(_init, 1, "markUseLayoutEffectsStart", _markUseLayoutEffectsStart_dec, HydrationMarker);
__decorateElement(_init, 1, "markRouterUseLayoutEffectStart", _markRouterUseLayoutEffectStart_dec, HydrationMarker);
__decorateElement(_init, 1, "markUseLayoutEffectsEnd", _markUseLayoutEffectsEnd_dec, HydrationMarker);
__decorateElement(_init, 1, "markUseEffectsStart", _markUseEffectsStart_dec, HydrationMarker);
__decorateElement(_init, 1, "markUseEffectsRouterStart", _markUseEffectsRouterStart_dec, HydrationMarker);
__decorateElement(_init, 1, "markUseEffectsAreSynchronous", _markUseEffectsAreSynchronous_dec, HydrationMarker);
__decorateElement(_init, 1, "markUseEffectsEnd", _markUseEffectsEnd_dec, HydrationMarker);
__decorateElement(_init, 1, "markRafStart", _markRafStart_dec, HydrationMarker);
__decorateElement(_init, 1, "markRafEnd", _markRafEnd_dec, HydrationMarker);
__decorateElement(_init, 1, "markLayoutStylePaintEnd", _markLayoutStylePaintEnd_dec, HydrationMarker);
__decorateElement(_init, 1, "measureMutationEffects", _measureMutationEffects_dec, HydrationMarker);
__decorateElement(_init, 1, "measureUnattributedHydrationOverhead", _measureUnattributedHydrationOverhead_dec, HydrationMarker);
__decoratorMetadata(_init, HydrationMarker);
var hydrationMarker;
function markHydrationStart() {
  hydrationMarker = new HydrationMarker();
  hydrationMarker.render.markStart();
}
function useMarkRouterEffects() {
  useInsertionEffect(() => {
    hydrationMarker?.useInsertionEffects.markRouterStart();
  }, []);
  useLayoutEffect3(() => {
    hydrationMarker?.useLayoutEffects.markRouterStart();
  }, []);
  useEffect7(() => {
    hydrationMarker?.useEffects.markRouterStart();
  }, []);
}
var wasInBackground = false;
function useMarkSuspenseEffectsStart() {
  useInsertionEffect(() => {
    hydrationMarker?.render.markEnd();
    hydrationMarker?.useInsertionEffects.markStart();
  }, []);
  useLayoutEffect3(() => {
    hydrationMarker?.useLayoutEffects.markStart();
    if (document.visibilityState !== "visible") {
      wasInBackground = true;
      return;
    }
    frame.read(() => {
      hydrationMarker?.browserRendering.requestAnimationFrame.markStart();
      hydrationMarker?.unattributedHydrationOverhead.measure();
    });
  }, []);
  useEffect7(() => {
    hydrationMarker?.useEffects.markStart();
    if (!hydrationMarker?.browserRendering.hasStarted) {
      hydrationMarker?.mutationEffects.measure();
      hydrationMarker?.useEffects.markAreSynchronous();
    }
  }, []);
}
function useMarkSuspenseEffectEnd() {
  useInsertionEffect(() => {
    hydrationMarker?.useInsertionEffects.markEnd();
  }, []);
  useLayoutEffect3(() => {
    hydrationMarker?.useLayoutEffects.markEnd();
    if (wasInBackground || document.visibilityState !== "visible") return;
    frame.read(() => {
      hydrationMarker?.browserRendering.requestAnimationFrame.markEnd();
      void yieldToMain().then(() => {
        hydrationMarker?.browserRendering.layoutStylePaint.markEnd();
      });
    });
  }, []);
  useEffect7(() => {
    hydrationMarker?.useEffects.markEnd();
  }, []);
}
function MarkSuspenseEffectsStart() {
  useMarkSuspenseEffectsStart();
  return null;
}
function MarkSuspenseEffectsEnd() {
  useMarkSuspenseEffectEnd();
  return null;
}
var MarkSuspenseEffects = { Start: MarkSuspenseEffectsStart, End: MarkSuspenseEffectsEnd };

// ../../library/src/router/error-boundary/NotFoundErrorBoundary.tsx
import { Component } from "react";

// ../../library/src/router/renderPage.tsx
import React10 from "react";
import { jsx as jsx7 } from "react/jsx-runtime";
function renderPage(Page4, defaultPageStyle) {
  const props = { style: defaultPageStyle, "data-framer-root": "" };
  return React10.isValidElement(Page4) ? React10.cloneElement(Page4, props) : /* @__PURE__ */ jsx7(Page4, { ...props });
}

// ../../library/src/router/error-boundary/NotFoundErrorBoundary.tsx
var NotFoundError = class extends Error {
};
var NotFoundErrorBoundary = class extends Component {
  constructor(props) {
    super(props);
    this.state = { error: void 0, forceUpdateKey: props.forceUpdateKey };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  /** Resets the error when forceUpdateKey gets bumped. */
  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.forceUpdateKey !== prevState.forceUpdateKey) {
      const newState = {
        forceUpdateKey: nextProps.forceUpdateKey
      };
      if (prevState.error) {
        newState.error = void 0;
      }
      return newState;
    }
    return null;
  }
  render() {
    if (this.state.error === void 0) {
      return this.props.children;
    }
    if (!(this.state.error instanceof NotFoundError)) {
      throw this.state.error;
    }
    const { notFoundPage, defaultPageStyle } = this.props;
    if (!notFoundPage) {
      throw this.state.error;
    }
    return renderPage(notFoundPage, defaultPageStyle);
  }
};

// ../../shared/src/emptyArray.ts
var frozenEmptyArray = Object.freeze([]);
function emptyArray() {
  return frozenEmptyArray;
}

// ../../library/src/router/inferInitialRouteFromPath.ts
var routeInfoCache;
function getRouteInfoMemo(routes) {
  if (routeInfoCache?.lastRoutes !== routes) {
    const pathRoutes = {};
    const pathRoutesLocalized = {};
    let paths = [];
    const pathsLocalized = {};
    const lastRoutes = routes;
    for (const routeId in routes) {
      const route = routes[routeId];
      assert(route, "route must be defined");
      const { path, pathLocalized } = route;
      if (!path) continue;
      const depth = pathDepth(path);
      pathRoutes[path] = { path, depth, routeId };
      if (!pathLocalized) continue;
      for (const localeId in pathLocalized) {
        const localizedPath = pathLocalized[localeId];
        assert(localizedPath, "localizedPath must be defined");
        const localizedDepth = pathDepth(localizedPath);
        const byLocale = pathRoutesLocalized[localeId] ||= {};
        byLocale[localizedPath] = {
          path: localizedPath,
          depth: localizedDepth,
          routeId
        };
      }
    }
    paths = Object.values(pathRoutes);
    paths.sort(({ depth: depth1 }, { depth: depth2 }) => depth2 - depth1);
    for (const localeId in pathRoutesLocalized) {
      const routesByPathLocalized = pathRoutesLocalized[localeId];
      if (!routesByPathLocalized) continue;
      const pathsForLocale = Object.values(routesByPathLocalized);
      pathsForLocale.sort(({ depth: depth1 }, { depth: depth2 }) => depth2 - depth1);
      pathsLocalized[localeId] = pathsForLocale;
    }
    routeInfoCache = {
      pathRoutes,
      pathRoutesLocalized,
      paths,
      pathsLocalized,
      lastRoutes
    };
  }
  return {
    pathRoutes: routeInfoCache.pathRoutes,
    paths: routeInfoCache.paths,
    pathRoutesLocalized: routeInfoCache.pathRoutesLocalized,
    pathsLocalized: routeInfoCache.pathsLocalized
  };
}
function inferInitialRouteFromPath(routes, locationPath, fallback = true, locales = emptyArray()) {
  return inferInitialRouteFromPathAndLocales(routes, locationPath, locales, fallback);
}
function inferInitialRouteFromPathAndLocales(routes, locationPath, locales, fallback = true) {
  const { pathRoutes, paths, pathRoutesLocalized, pathsLocalized } = getRouteInfoMemo(routes);
  let activeLocale;
  let localeId;
  let hasNonDefaultLocale = false;
  if (locales.length > 0) {
    const firstPathSegment = locationPath.split("/").find(Boolean);
    if (firstPathSegment) {
      activeLocale = locales.find(({ slug }) => slug === firstPathSegment);
      if (activeLocale) {
        localeId = activeLocale.id;
        locationPath = locationPath.substring(activeLocale.slug.length + 1);
        hasNonDefaultLocale = true;
      }
    }
    if (!localeId) {
      const defaultLocale = locales.find(({ slug }) => slug === "");
      if (defaultLocale) {
        localeId = defaultLocale.id;
      }
    }
  }
  if (localeId && hasNonDefaultLocale) {
    const localizedMap = pathRoutesLocalized[localeId];
    const exactMatchForLocale = localizedMap ? localizedMap[locationPath] : void 0;
    if (exactMatchForLocale) {
      const match = matchPath(locationPath, exactMatchForLocale.path);
      if (match.isMatch) {
        return { routeId: exactMatchForLocale.routeId, localeId, pathVariables: match.pathVariables };
      }
    }
  }
  const exactMatch = pathRoutes[locationPath];
  if (exactMatch) {
    const match = matchPath(locationPath, exactMatch.path);
    if (match.isMatch) return { routeId: exactMatch.routeId, localeId, pathVariables: match.pathVariables };
  }
  if (localeId && hasNonDefaultLocale) {
    const localizedList = pathsLocalized[localeId];
    if (localizedList) {
      for (const { path, routeId } of localizedList) {
        const match = matchPath(locationPath, path);
        if (match.isMatch) {
          return { routeId, localeId, pathVariables: match.pathVariables };
        }
      }
    }
  }
  for (const { path, routeId } of paths) {
    const match = matchPath(locationPath, path);
    if (match.isMatch) {
      return { routeId, localeId, pathVariables: match.pathVariables };
    }
  }
  if (!fallback) throw new Error("No exact match found for path");
  const rootPath = pathRoutes["/"];
  if (rootPath) return { routeId: rootPath.routeId, localeId };
  const firstRoute = Object.keys(routes)[0];
  if (!firstRoute) throw new Error("Router should not have undefined routes");
  return { routeId: firstRoute, localeId };
}
function pathDepth(path) {
  const pathWithTrimmedSlashes = path.replace(/^\/|\/$/gu, "");
  if (pathWithTrimmedSlashes === "") return 0;
  return pathWithTrimmedSlashes.split("/").length;
}
function matchPath(path, routePath) {
  const pathVariablesKeys = [];
  const safeRoutePath = escapeStringRegExp(routePath);
  const routePathRegExpString = safeRoutePath.replace(pathVariablesRegExp, (_, name) => {
    pathVariablesKeys.push(name);
    return "([^/]+)";
  });
  const routePathRegExp = new RegExp(routePathRegExpString + "$");
  const matches = path.match(routePathRegExp);
  if (!matches) return { isMatch: false };
  if (matches.length === 1) return { isMatch: true };
  const pathVariables = {};
  const pathVariablesValues = matches.slice(1);
  for (let i = 0; i < pathVariablesKeys.length; ++i) {
    const key7 = pathVariablesKeys[i];
    if (key7 === void 0) continue;
    const value = pathVariablesValues[i];
    const existingValue = pathVariables[key7];
    if (existingValue) {
      if (existingValue !== value) {
        return { isMatch: false };
      } else {
        continue;
      }
    }
    if (value === void 0) {
      throw new Error("Path variable values cannot be undefined");
    }
    pathVariables[key7] = value;
  }
  return { isMatch: true, pathVariables };
}
function escapeStringRegExp(string) {
  return string.replace(/[|\\{}()[\]^$+*?.]/gu, "\\$&").replace(/-/gu, "\\x2d");
}

// ../../library/src/router/routeVariants.ts
function getVariantsFromServerTiming() {
  if ("PerformanceServerTiming" in window) {
    const serverTiming = performance.getEntriesByType("navigation")[0]?.serverTiming;
    if (!serverTiming || serverTiming.length === 0) return new URLSearchParams();
    const entry = serverTiming.find((it) => it.name === "abtests");
    if (!entry) return new URLSearchParams();
    return new URLSearchParams(entry.description);
  }
  return new URLSearchParams();
}
function patchRoute(routes, abTestId, abTestingVariantId) {
  const route = routes[abTestingVariantId];
  if (!route) return;
  const routeId = route.abTestingParentId ?? abTestingVariantId;
  if (!routes[routeId]) return;
  const { abTestingParentId, ...patchingRoute } = route;
  const elements = routes[routeId].elements || route.elements ? { ...routes[routeId].elements, ...route.elements } : void 0;
  routes[routeId] = {
    ...patchingRoute,
    elements,
    abTestingVariantId,
    abTestId
  };
}
function patchRoutesFromSearchParams(routes, variants) {
  for (const [abTestId, abTestingVariantId] of variants) {
    patchRoute(routes, abTestId, abTestingVariantId);
  }
}
function removeRoutesVariants(routes) {
  for (const routeId in routes) {
    if (routes[routeId]?.abTestingParentId) {
      delete routes[routeId];
    }
  }
}
function patchInitialRoute(routes, routeId) {
  if (!routes[routeId]) return;
  if (!routes[routeId].abTestingParentId) return;
  const parentId = routes[routeId].abTestingParentId;
  const { abTestingParentId, ...route } = routes[routeId];
  const elements = routes[parentId]?.elements || route.elements ? { ...routes[parentId]?.elements, ...route.elements } : void 0;
  routes[parentId] = {
    ...route,
    elements,
    abTestingVariantId: routeId
  };
}
function patchRoutesForABTesting(routes, initialRouteId) {
  if (typeof window === "undefined") return initialRouteId;
  let resolvedInitialRouteId = initialRouteId;
  if (initialRouteId) {
    patchInitialRoute(routes, initialRouteId);
    const parentRouteId = routes[initialRouteId]?.abTestingParentId;
    if (parentRouteId) {
      resolvedInitialRouteId = parentRouteId;
    }
  }
  patchRoutesFromSearchParams(routes, getVariantsFromServerTiming());
  removeRoutesVariants(routes);
  return resolvedInitialRouteId;
}

// ../../shared/src/ssg/constants.ts
var mainTagId = "main";
var generatedPageDatasetKey = "framerGeneratedPage";
var searchIndexMetaName = "framer-search-index";
var searchIndexMetaSelector = `meta[name="${searchIndexMetaName}"]`;
var startOfHeadStartMarker = "<!-- Start of headStart -->";
var endOfHeadStartMarker = "<!-- End of headStart -->";
var startOfHeadEndMarker = "<!-- Start of headEnd -->";
var endOfHeadEndMarker = "<!-- End of headEnd -->";
var startOfBodyStartMarker = "<!-- Start of bodyStart -->";
var endOfBodyStartMarker = "<!-- End of bodyStart -->";
var startOfBodyEndMarker = "<!-- Start of bodyEnd -->";
var endOfBodyEndMarker = "<!-- End of bodyEnd -->";

// ../../library/src/router/useMetadata.ts
import * as React12 from "react";

// ../../library/src/modules/LibraryFeaturesContext.ts
import React11 from "react";
var LibraryFeaturesContext = /* @__PURE__ */ React11.createContext(void 0);
LibraryFeaturesContext.displayName = "LibraryFeaturesContext";
var LibraryFeaturesProvider = /* @__PURE__ */ (() => LibraryFeaturesContext.Provider)();
var useLibraryFeatures = () => {
  const context = React11.useContext(LibraryFeaturesContext);
  return context ?? {};
};

// ../../library/src/utils/insertHTML.ts
async function insertHTML(html, referenceNode, position = "beforeend") {
  let insertionParent, insertionPoint;
  switch (position) {
    case "beforebegin":
      assert(referenceNode.parentNode, "Can't use 'beforebegin' with a referenceNode at the top level");
      insertionParent = referenceNode.parentNode;
      insertionPoint = referenceNode;
      break;
    case "afterend":
      assert(referenceNode.parentNode, "Can't use 'afterend' with a referenceNode at the top level");
      insertionParent = referenceNode.parentNode;
      insertionPoint = referenceNode.nextSibling;
      break;
    case "afterbegin":
      insertionParent = referenceNode;
      insertionPoint = referenceNode.firstChild;
      break;
    case "beforeend":
      insertionParent = referenceNode;
      insertionPoint = null;
      break;
    default:
      assertNever(position);
  }
  const range = document.createRange();
  range.selectNodeContents(insertionParent);
  const fragment = range.createContextualFragment(html);
  await pump(fragment, insertionParent, insertionPoint);
}
async function pump(sourceNode, targetParent, beforeNode) {
  for (let node = sourceNode.firstChild; node; node = node.nextSibling) {
    if (node instanceof HTMLScriptElement) {
      const needsWait = handleScript(node, targetParent, beforeNode);
      if (needsWait !== void 0) {
        await needsWait;
      }
      continue;
    }
    const clone = node.cloneNode(false);
    targetParent.insertBefore(clone, beforeNode);
    if (node.firstChild) {
      await pump(node, clone, null);
    }
  }
}
function handleScript(node, parent, beforeNode) {
  const script = node.cloneNode(true);
  if (!node.hasAttribute("src") || // external
  node.hasAttribute("async") || // async
  node.hasAttribute("defer") || // defer
  node.getAttribute("type")?.toLowerCase() === "module") {
    parent.insertBefore(script, beforeNode);
  } else {
    return execExternalBlockingScript(script, parent, beforeNode);
  }
}
function execExternalBlockingScript(script, parent, beforeNode) {
  return new Promise((resolve) => {
    script.onload = script.onerror = resolve;
    parent.insertBefore(script, beforeNode);
  });
}

// ../../library/src/router/useMetadata.ts
function useMetadata(metadata) {
  const { isInitialNavigation } = useRouter();
  const { customCodeSiteSettings } = useLibraryFeatures();
  React12.useEffect(() => {
    if (metadata.robots) {
      let robotsTag = document.querySelector('meta[name="robots"]');
      if (robotsTag) {
        robotsTag.setAttribute("content", metadata.robots);
      } else {
        robotsTag = document.createElement("meta");
        robotsTag.setAttribute("name", "robots");
        robotsTag.setAttribute("content", metadata.robots);
        document.head.appendChild(robotsTag);
      }
    }
  }, [metadata.robots]);
  React12.useInsertionEffect(() => {
    document.title = metadata.title || "";
    if (metadata.viewport) {
      document.querySelector('meta[name="viewport"]')?.setAttribute("content", metadata.viewport);
    }
  }, [metadata.title, metadata.viewport]);
  React12.useEffect(() => {
    if (!isInitialNavigation) return;
    if (customCodeSiteSettings) return;
    const mainTag = document.getElementById(mainTagId);
    const isGeneratedPage = mainTag && mainTag.dataset[generatedPageDatasetKey] !== void 0;
    if (isGeneratedPage) return;
    void insertCustomHTML(
      metadata.customHTMLHeadStart,
      metadata.customHTMLHeadEnd,
      metadata.customHTMLBodyStart,
      metadata.customHTMLBodyEnd
    );
  }, []);
}
async function insertCustomHTML(customHTMLHeadStart, customHTMLHeadEnd, customHTMLBodyStart, customHTMLBodyEnd) {
  let endOfHeadStart;
  let endOfHeadEnd;
  let endOfBodyStart;
  let endOfBodyEnd;
  if (customHTMLHeadStart || customHTMLHeadEnd) {
    const { start, end } = findCommentMarkers(
      document.head.childNodes,
      customHTMLHeadStart ? endOfHeadStartMarker : void 0,
      customHTMLHeadEnd ? endOfHeadEndMarker : void 0
    );
    endOfHeadStart = start;
    endOfHeadEnd = end;
  }
  if (customHTMLBodyStart || customHTMLBodyEnd) {
    const { start, end } = findCommentMarkers(
      document.body.childNodes,
      customHTMLBodyStart ? endOfBodyStartMarker : void 0,
      customHTMLBodyEnd ? endOfBodyEndMarker : void 0
    );
    endOfBodyStart = start;
    endOfBodyEnd = end;
  }
  if (customHTMLHeadStart && endOfHeadStart) {
    await insertHTML(customHTMLHeadStart, endOfHeadStart, "beforebegin");
  }
  if (customHTMLHeadEnd && endOfHeadEnd) {
    await insertHTML(customHTMLHeadEnd, endOfHeadEnd, "beforebegin");
  }
  if (customHTMLBodyStart && endOfBodyStart) {
    await insertHTML(customHTMLBodyStart, endOfBodyStart, "beforebegin");
  }
  if (customHTMLBodyEnd && endOfBodyEnd) {
    await insertHTML(customHTMLBodyEnd, endOfBodyEnd, "beforebegin");
  }
}
function findCommentMarkers(nodes, startMarker, endMarker) {
  if (!startMarker && !endMarker) return { start: void 0, end: void 0 };
  let start;
  let end;
  let i = 0;
  let j = nodes.length - 1;
  while (i <= j) {
    const startNode = nodes[i];
    const endNode = nodes[j];
    if (!start && startNode?.nodeType === Node.COMMENT_NODE && startMarker && `<!--${startNode.nodeValue}-->` === startMarker) {
      start = startNode;
      if (!endMarker) break;
    }
    if (!end && endNode?.nodeType === Node.COMMENT_NODE && endMarker && `<!--${endNode.nodeValue}-->` === endMarker) {
      end = endNode;
      if (!startMarker) break;
    }
    if (start && end) break;
    i++;
    j--;
  }
  return { start, end };
}

// ../../library/src/utils/warnOnce.ts
var warningMessages = /* @__PURE__ */ new Set();
function warnOnce2(keyMessage, ...rest) {
  if (warningMessages.has(keyMessage)) return;
  warningMessages.add(keyMessage);
  console.warn(keyMessage, ...rest);
}

// ../../library/src/utils/deprecation.ts
function deprecationWarning(removedItem, removalVersion, replacement) {
  const replacementText = replacement ? `, use ${replacement} instead` : "";
  const warningText = `Deprecation warning: ${removedItem} will be removed in version ${removalVersion}${replacementText}.`;
  warnOnce2(warningText);
}

// ../../library/src/animation/Animatable/Observers.ts
var Observers = class {
  constructor() {
    __publicField(this, "observers", /* @__PURE__ */ new Set());
    __publicField(this, "transactions", {});
  }
  add(observer) {
    this.observers.add(observer);
    let isCalled = false;
    return () => {
      if (isCalled) {
        return;
      }
      isCalled = true;
      this.remove(observer);
    };
  }
  remove(observer) {
    this.observers.delete(observer);
  }
  notify(change, transaction) {
    if (transaction) {
      const accumulatedChange = this.transactions[transaction] || change;
      accumulatedChange.value = change.value;
      this.transactions[transaction] = accumulatedChange;
    } else {
      this.callObservers(change);
    }
  }
  finishTransaction(transaction) {
    const accumulatedChange = this.transactions[transaction];
    delete this.transactions[transaction];
    return this.callObservers(accumulatedChange, transaction);
  }
  callObservers(change, transaction) {
    const finishObservers = [];
    new Set(this.observers).forEach((observer) => {
      if (typeof observer === "function") {
        observer(change, transaction);
      } else {
        observer.update(change, transaction);
        finishObservers.push(observer.finish);
      }
    });
    return finishObservers;
  }
};

// ../../library/src/animation/Animatable/Animatable.ts
var Animatable = /* @__PURE__ */ (() => {
  function Animatable2(value) {
    deprecationWarning("Animatable()", "2.0.0", "the new animation API (https://www.framer.com/api/animation/)");
    return isAnimatable(value) ? value : new AnimatableValue(value);
  }
  Animatable2.transaction = (update) => {
    const transactionId = Math.random();
    const updatedValues = /* @__PURE__ */ new Set();
    const updater = (animatable, value) => {
      animatable.set(value, transactionId);
      updatedValues.add(animatable);
    };
    update(updater, transactionId);
    const finishObservers = [];
    updatedValues.forEach((value) => {
      finishObservers.push(...value.finishTransaction(transactionId));
    });
    finishObservers.forEach((finish) => {
      finish(transactionId);
    });
  };
  Animatable2.getNumber = (value, defaultValue = 0) => {
    return Animatable2.get(value, defaultValue);
  };
  Animatable2.get = (value, defaultValue) => {
    if (value === void 0 || value === null) {
      return defaultValue;
    }
    if (isAnimatable(value)) {
      return value.get();
    }
    return value;
  };
  Animatable2.objectToValues = (object) => {
    if (!object) {
      return object;
    }
    const result = {};
    for (const key7 in object) {
      const value = object[key7];
      if (isAnimatable(value)) {
        result[key7] = value.get();
      } else {
        result[key7] = value;
      }
    }
    return result;
  };
  return Animatable2;
})();
var onUpdateKey = "onUpdate";
var finishTransactionKey = "finishTransaction";
function isAnimatable(value) {
  return value !== null && typeof value === "object" && onUpdateKey in value && value[onUpdateKey] instanceof Function && finishTransactionKey in value && value[finishTransactionKey] instanceof Function;
}
function animatableInterpolation(value, currentInterpolation) {
  return {
    interpolate(from, to) {
      const fromValue = from.get();
      const toValue = to.get();
      const result = Animatable(fromValue);
      return (progress2) => {
        const v = currentInterpolation.interpolate(fromValue, toValue)(progress2);
        result.set(v);
        return result;
      };
    },
    difference(from, to) {
      const v = from.get();
      return currentInterpolation.difference(v, to.get());
    }
  };
}
var AnimatableValue = class {
  constructor(value) {
    this.value = value;
    __publicField(this, "observers", new Observers());
  }
  static interpolationFor(value, currentInterpolation) {
    if (isAnimatable(value)) {
      return animatableInterpolation(value, currentInterpolation);
    }
  }
  get() {
    return this.value;
  }
  set(value, transaction) {
    const oldValue = this.value;
    if (isAnimatable(value)) {
      value = value.get();
    }
    this.value = value;
    const change = {
      value,
      oldValue
    };
    this.observers.notify(change, transaction);
  }
  finishTransaction(transaction) {
    return this.observers.finishTransaction(transaction);
  }
  onUpdate(handler) {
    return this.observers.add(handler);
  }
};

// ../../library/src/render/utils/roundedNumber.ts
function roundedNumber(value, decimals) {
  const d = Math.round(Math.abs(decimals));
  const multiplier = 10 ** d;
  return Math.round(value * multiplier) / multiplier;
}
function roundedNumberString(value, decimals) {
  const result = value.toFixed(decimals);
  return decimals === 0 ? result : `${+result}`;
}
function roundWithOffset(value, offset) {
  if (offset === 0) {
    return Math.round(value);
  }
  offset -= offset | 0;
  if (offset < 0) {
    offset = 1 - offset;
  }
  return Math.round(value - offset) + offset;
}
function roundToHalfPixel(value) {
  return Math.round(value * 2) / 2;
}

// ../../library/src/render/types/Point.ts
function Point(x, y) {
  return { x, y };
}
((Point2) => {
  Point2.isQuadrilateralPoints = (points) => {
    return points?.length === 4;
  };
  Point2.add = (...args) => {
    return args.reduce(
      (previousValue, currentValue) => {
        return { x: previousValue.x + currentValue.x, y: previousValue.y + currentValue.y };
      },
      { x: 0, y: 0 }
    );
  };
  Point2.subtract = (a, b) => {
    return { x: a.x - b.x, y: a.y - b.y };
  };
  Point2.multiply = (a, b) => {
    return { x: a.x * b, y: a.y * b };
  };
  Point2.divide = (a, b) => {
    return { x: a.x / b, y: a.y / b };
  };
  Point2.absolute = (point) => {
    return {
      x: Math.abs(point.x),
      y: Math.abs(point.y)
    };
  };
  Point2.reverse = (point) => {
    return {
      x: point.x * -1,
      y: point.y * -1
    };
  };
  Point2.pixelAligned = (point, offset = { x: 0, y: 0 }) => {
    return {
      x: roundWithOffset(point.x, offset.x),
      y: roundWithOffset(point.y, offset.y)
    };
  };
  Point2.distance = (a, b) => {
    const deltaX = Math.abs(a.x - b.x);
    const deltaY = Math.abs(a.y - b.y);
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  };
  Point2.angle = (a, b) => {
    return Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI - 90;
  };
  Point2.angleFromX = (a, b) => {
    return Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI;
  };
  Point2.isEqual = (a, b) => {
    return a.x === b.x && a.y === b.y;
  };
  Point2.rotationNormalizer = () => {
    let lastValue;
    return (value) => {
      if (typeof lastValue !== "number") {
        lastValue = value;
      }
      const diff = lastValue - value;
      const maxDiff = Math.abs(diff) + 180;
      const nTimes = Math.floor(maxDiff / 360);
      if (diff < 180) {
        value -= nTimes * 360;
      }
      if (diff > 180) {
        value += nTimes * 360;
      }
      lastValue = value;
      return value;
    };
  };
  function center(a, b) {
    return {
      x: (a.x + b.x) / 2,
      y: (a.y + b.y) / 2
    };
  }
  Point2.center = center;
  function centroid(points) {
    let sumX = 0;
    let sumY = 0;
    points.forEach((point) => {
      sumX += point.x;
      sumY += point.y;
    });
    const centroidX = sumX / points.length;
    const centroidY = sumY / points.length;
    return { x: centroidX, y: centroidY };
  }
  Point2.centroid = centroid;
  function sortClockwise(points) {
    const centerPoint = Point2.centroid(points);
    const angles = /* @__PURE__ */ new Map();
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      if (!point) continue;
      angles.set(point, Math.atan2(point.y - centerPoint.y, point.x - centerPoint.x));
    }
    return points.sort((a, b) => (angles.get(a) ?? 0) - (angles.get(b) ?? 0));
  }
  Point2.sortClockwise = sortClockwise;
})(Point || (Point = {}));

// ../../library/src/animation/Animators/BezierAnimator.ts
var BezierDefaults = {
  curve: "ease" /* Ease */,
  duration: 1
};
function controlPointsForCurve(curve) {
  switch (curve) {
    case "linear" /* Linear */:
      return [0, 0, 1, 1];
    case "ease" /* Ease */:
      return [0.25, 0.1, 0.25, 1];
    case "ease-in" /* EaseIn */:
      return [0.42, 0, 1, 1];
    case "ease-out" /* EaseOut */:
      return [0, 0, 0.58, 1];
    case "ease-in-out" /* EaseInOut */:
      return [0.42, 0, 0.58, 1];
  }
}
var BezierAnimator = class {
  constructor(options, interpolation) {
    this.interpolation = interpolation;
    __publicField(this, "unitBezier");
    __publicField(this, "options");
    __publicField(this, "current");
    __publicField(this, "destination");
    __publicField(this, "interpolator");
    __publicField(this, "progress", 0);
    __publicField(this, "next", (delta) => {
      const { duration } = this.options;
      this.progress += delta / duration;
      const value = this.unitBezier.solve(this.progress, this.solveEpsilon(duration));
      assert(this.interpolator !== void 0, "setFrom() or setTo() must be called before next()");
      this.current = this.interpolator(value);
      return this.current;
    });
    this.options = { ...BezierDefaults, ...options };
    let controlPoints;
    if (typeof this.options.curve === "string") {
      controlPoints = controlPointsForCurve(this.options.curve);
    } else {
      controlPoints = this.options.curve;
    }
    const [p1x, p1y, p2x, p2y] = controlPoints;
    this.unitBezier = new UnitBezier(Point(p1x, p1y), Point(p2x, p2y));
  }
  setFrom(value) {
    this.current = value;
    this.updateInterpolator();
  }
  setTo(value) {
    this.destination = value;
    this.updateInterpolator();
  }
  isReady() {
    return this.interpolator !== void 0;
  }
  updateInterpolator() {
    if (this.current === void 0 || this.destination === void 0) {
      return;
    }
    this.interpolator = this.interpolation.interpolate(this.current, this.destination);
  }
  isFinished() {
    return this.progress >= 1;
  }
  solveEpsilon(duration) {
    return 1 / (200 * duration);
  }
};
var UnitBezier = class {
  constructor(point1, point2) {
    __publicField(this, "a");
    __publicField(this, "b");
    __publicField(this, "c");
    this.c = Point.multiply(point1, 3);
    this.b = Point.subtract(Point.multiply(Point.subtract(point2, point1), 3), this.c);
    this.a = Point.subtract(Point.subtract(Point(1, 1), this.c), this.b);
  }
  solve(x, epsilon2) {
    return this.sampleY(this.solveForT(x, epsilon2));
  }
  sampleX(t) {
    return ((this.a.x * t + this.b.x) * t + this.c.x) * t;
  }
  sampleY(t) {
    return ((this.a.y * t + this.b.y) * t + this.c.y) * t;
  }
  sampleDerivativeX(t) {
    return (3 * this.a.x * t + 2 * this.b.x) * t + this.c.x;
  }
  solveForT(x, epsilon2) {
    let t0, t1, t2, x2, d2, i;
    t2 = x;
    for (i = 0; i < 8; ++i) {
      x2 = this.sampleX(t2) - x;
      if (Math.abs(x2) < epsilon2) return t2;
      d2 = this.sampleDerivativeX(t2);
      if (Math.abs(d2) < epsilon2) break;
      t2 = t2 - x2 / d2;
    }
    t0 = 0;
    t1 = 1;
    t2 = x;
    if (t2 < t0) return t0;
    if (t2 > t1) return t1;
    while (t0 < t1) {
      x2 = this.sampleX(t2);
      if (Math.abs(x2 - x) < epsilon2) return t2;
      if (x > x2) t0 = t2;
      else t1 = t2;
      t2 = (t1 - t0) * 0.5 + t0;
    }
    return t2;
  }
};

// ../../library/src/animation/Animators/Integrator.ts
var Integrator = class {
  constructor(accelerationFunction) {
    __publicField(this, "accelerationForState");
    this.accelerationForState = accelerationFunction;
  }
  integrateState(state, dt) {
    const a = this.evaluateState(state);
    const b = this.evaluateStateWithDerivative(state, dt * 0.5, a);
    const c = this.evaluateStateWithDerivative(state, dt * 0.5, b);
    const d = this.evaluateStateWithDerivative(state, dt, c);
    const dxdt = 1 / 6 * (a.dx + 2 * (b.dx + c.dx) + d.dx);
    const dvdt = 1 / 6 * (a.dv + 2 * (b.dv + c.dv) + d.dv);
    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;
    return state;
  }
  evaluateState(initialState2) {
    const dv = this.accelerationForState(initialState2);
    return { dx: initialState2.v, dv };
  }
  evaluateStateWithDerivative(initialState2, dt, derivative) {
    const state = {
      x: initialState2.x + derivative.dx * dt,
      v: initialState2.v + derivative.dv * dt
    };
    const output = {
      dx: state.v,
      dv: this.accelerationForState(state)
    };
    return output;
  }
};

// ../../library/src/animation/Animators/FrictionAnimator.ts
var FrictionAnimator = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "integrator");
    this.options = {
      velocity: 0,
      friction: 2,
      tolerance: 1 / 10
    };
    Object.assign(this.options, options);
    this.state = {
      x: 0,
      v: this.options.velocity
    };
    this.integrator = new Integrator((state) => -(this.options.friction * state.v));
  }
  setFrom(value) {
    this.state.x = value;
  }
  setTo(value) {
  }
  setVelocity(velocity) {
    this.state.v = velocity;
  }
  getState() {
    return this.state;
  }
  isReady() {
    return true;
  }
  next(delta) {
    this.state = this.integrator.integrateState(this.state, delta);
    return this.state.x;
  }
  isFinished() {
    return Math.abs(this.state.v) < this.options.tolerance;
  }
};

// ../../library/src/interpolation/Interpolation.ts
function isInterpolatable(value) {
  return typeof value === "function" && value.interpolationFor && typeof value.interpolationFor === "function";
}
var Interpolation = {
  /**
   * @param from -
   * @param to -
   * @internal
   */
  handleUndefined: (from, to) => {
    if (from === void 0) {
      from = to;
    }
    if (to === void 0) {
      to = from;
    }
    return [from, to];
  }
};

// ../../library/src/interpolation/NumberInterpolation.ts
var NumberInterpolation = {
  interpolate(from, to) {
    ;
    [from, to] = Interpolation.handleUndefined(from, to);
    const a1 = from;
    const b1 = to - a1;
    return (progress2) => {
      const value = a1 + b1 * progress2;
      return value;
    };
  },
  difference(from, to) {
    return to - from;
  }
};

// ../../library/src/animation/Animators/SpringCurveValueConverter.ts
var epsilon = 1e-3;
var minDuration = 0.01;
var maxDuration2 = 10;
var minDamping = /* @__PURE__ */ (() => Number.MIN_VALUE)();
var maxDamping = 1;
function approximateRoot(func, derivative, initialGuess, times = 12) {
  let result = initialGuess;
  for (let i = 1, end = times, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
    result = result - func(result) / derivative(result);
  }
  return result;
}
function angularFrequency(undampedFrequency, dampingRatio) {
  return undampedFrequency * Math.sqrt(1 - Math.pow(dampingRatio, 2));
}
var SpringCurveValueConverter = {
  computeDampingRatio: (tension, friction, mass = 1) => {
    return friction / (2 * Math.sqrt(mass * tension));
  },
  // Tries to compute the duration of a spring,
  // but can't for certain velocities and if dampingRatio >= 1
  // In those cases it will return null
  computeDuration: (tension, friction, velocity = 0, mass = 1) => {
    let duration;
    const dampingRatio = SpringCurveValueConverter.computeDampingRatio(tension, friction);
    const undampedFrequency = Math.sqrt(tension / mass);
    if (dampingRatio < 1) {
      const a = Math.sqrt(1 - Math.pow(dampingRatio, 2));
      const b = velocity / (a * undampedFrequency);
      const c = dampingRatio / a;
      const d = -((b - c) / epsilon);
      if (d <= 0) {
        return null;
      }
      duration = Math.log(d) / (dampingRatio * undampedFrequency);
    } else {
      return null;
    }
    return duration;
  },
  computeDerivedCurveOptions: (dampingRatio, duration, velocity = 0, mass = 1) => {
    let derivative, envelope;
    dampingRatio = Math.max(Math.min(dampingRatio, maxDamping), minDamping);
    duration = Math.max(Math.min(duration, maxDuration2), minDuration);
    if (dampingRatio < 1) {
      envelope = function(envelopeUndampedFrequency) {
        const exponentialDecay = envelopeUndampedFrequency * dampingRatio;
        const currentDisplacement = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b = angularFrequency(envelopeUndampedFrequency, dampingRatio);
        const c = Math.exp(-currentDisplacement);
        return epsilon - a / b * c;
      };
      derivative = function(derivativeUndampedFrequency) {
        const exponentialDecay = derivativeUndampedFrequency * dampingRatio;
        const currentDisplacement = exponentialDecay * duration;
        const d = currentDisplacement * velocity + velocity;
        const e = Math.pow(dampingRatio, 2) * Math.pow(derivativeUndampedFrequency, 2) * duration;
        const f = Math.exp(-currentDisplacement);
        const g = angularFrequency(Math.pow(derivativeUndampedFrequency, 2), dampingRatio);
        const factor = -envelope(derivativeUndampedFrequency) + epsilon > 0 ? -1 : 1;
        return factor * ((d - e) * f) / g;
      };
    } else {
      envelope = function(envelopeUndampedFrequency) {
        const a = Math.exp(-envelopeUndampedFrequency * duration);
        const b = (envelopeUndampedFrequency - velocity) * duration + 1;
        return -epsilon + a * b;
      };
      derivative = function(derivativeUndampedFrequency) {
        const a = Math.exp(-derivativeUndampedFrequency * duration);
        const b = (velocity - derivativeUndampedFrequency) * Math.pow(duration, 2);
        return a * b;
      };
    }
    const result = {
      tension: 100,
      friction: 10,
      velocity
    };
    const initialGuess = 5 / duration;
    const undampedFrequency = approximateRoot(envelope, derivative, initialGuess);
    if (!Number.isNaN(undampedFrequency)) {
      result.tension = Math.pow(undampedFrequency, 2) * mass;
      result.friction = dampingRatio * 2 * Math.sqrt(mass * result.tension);
    }
    return result;
  }
};

// ../../library/src/animation/Animators/SpringAnimator.ts
var SpringTensionFrictionDefaults = /* @__PURE__ */ (() => ({
  tension: 500,
  friction: 10,
  tolerance: 1 / 1e4,
  velocity: 0
}))();
var SpringDampingDurationDefaults = {
  dampingRatio: 1,
  duration: 1,
  velocity: 0,
  mass: 1
};
function isDampingDurationSpringOptions(options) {
  if (!options) {
    return false;
  }
  return typeof options.dampingRatio === "number" || typeof options.duration === "number" || typeof options.mass === "number";
}
var SpringAnimator = class {
  constructor(options, interpolation) {
    this.interpolation = interpolation;
    __publicField(this, "options");
    __publicField(this, "current");
    __publicField(this, "destination");
    __publicField(this, "difference");
    __publicField(this, "state");
    __publicField(this, "integrator");
    __publicField(this, "interpolator");
    let _opt;
    if (isDampingDurationSpringOptions(options)) {
      const toPass = { ...SpringDampingDurationDefaults, ...options };
      _opt = SpringCurveValueConverter.computeDerivedCurveOptions(
        toPass.dampingRatio,
        toPass.duration,
        toPass.velocity,
        toPass.mass
      );
    } else {
      _opt = options;
    }
    this.options = { ...SpringTensionFrictionDefaults, ..._opt };
    this.state = {
      x: 0,
      v: this.options.velocity
    };
    this.integrator = new Integrator((state) => -this.options.tension * state.x - this.options.friction * state.v);
  }
  isReady() {
    return this.interpolator !== void 0 && this.difference !== void 0;
  }
  next(delta) {
    this.state = this.integrator.integrateState(this.state, delta);
    assert(this.interpolator !== void 0, "setFrom() or setTo() must be called before next()");
    const value = this.interpolator(this.progress());
    return value;
  }
  isFinished() {
    const positionNearZero = Math.abs(this.state.x) < this.options.tolerance;
    const velocityNearZero = Math.abs(this.state.v) < this.options.tolerance;
    return positionNearZero && velocityNearZero;
  }
  setFrom(value) {
    this.current = value;
    this.updateInterpolator();
  }
  setVelocity(velocity) {
    this.state.v = velocity;
  }
  progress() {
    assert(this.difference !== void 0, "setTo() must be called before progress()");
    return 1 - this.state.x / this.difference;
  }
  // The spring always settles to 0, so we create an interpolation to the destination
  // And calculate the progress based on the current state and the span of the interpolation
  // This lets us integrate over state.x, even though Value is generic
  setTo(value) {
    assert(this.current !== void 0, "setFrom() must be called before setTo()");
    this.destination = value;
    this.difference = this.interpolation.difference(this.destination, this.current);
    this.state.x = this.difference;
    this.updateInterpolator();
  }
  /** @internal */
  getState() {
    return this.state;
  }
  updateInterpolator() {
    if (this.current === void 0 || this.destination === void 0) {
      return;
    }
    this.interpolator = this.interpolation.interpolate(this.current, this.destination);
  }
};

// ../../library/src/animation/Animators/InertialScrollAnimator.ts
var Defaults = {
  velocity: 0,
  min: 0,
  max: 0,
  momentum: {
    friction: 2,
    tolerance: 10
  },
  bounce: {
    tension: 500,
    friction: 10,
    tolerance: 1
  }
};
var InertialScrollAnimator = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "current");
    __publicField(this, "frictionAnimator");
    __publicField(this, "springAnimator");
    __publicField(this, "useSpring");
    this.options = Object.assign({ ...Defaults }, options);
    this.frictionAnimator = new FrictionAnimator({
      friction: this.options.momentum.friction,
      tolerance: this.options.momentum.tolerance,
      velocity: this.options.velocity
    });
    this.springAnimator = new SpringAnimator(
      {
        tension: this.options.bounce.tension,
        friction: this.options.bounce.friction,
        tolerance: this.options.bounce.tolerance,
        velocity: this.options.velocity
      },
      NumberInterpolation
    );
    this.useSpring = false;
  }
  isReady() {
    return true;
  }
  next(delta) {
    this.current = this.currentAnimator.next(delta);
    if (!this.useSpring) {
      this.tryTransitionToSpring();
    }
    return this.current;
  }
  get currentAnimator() {
    if (this.useSpring) {
      return this.springAnimator;
    }
    return this.frictionAnimator;
  }
  isFinished() {
    return this.currentAnimator.isFinished();
  }
  get state() {
    return this.currentAnimator.getState();
  }
  setFrom(value) {
    this.setState({ x: value, v: this.state.v });
  }
  setState(state) {
    this.frictionAnimator.setFrom(state.x);
    this.frictionAnimator.setVelocity(state.v);
    if (this.isValidState()) {
      return this.tryTransitionToSpring();
    } else {
      let bound = 0;
      if (this.state.x <= this.options.min) {
        bound = this.options.min;
      }
      if (this.state.x >= this.options.max) {
        bound = this.options.max;
      }
      return this.transitionToSpring(bound);
    }
  }
  setTo(destination) {
    this.frictionAnimator.setTo(destination);
    this.springAnimator.setTo(destination);
  }
  setLimits(min, max) {
    this.options.min = min;
    this.options.max = max;
  }
  // If the position is outside the min and max bounds, and traveling
  // further away, then transition from friction to spring animation
  tryTransitionToSpring() {
    const belowMinWithVelocity = this.state.x < this.options.min && this.state.v <= 0;
    const aboveMaxWithVelocity = this.state.x > this.options.max && this.state.v >= 0;
    if (belowMinWithVelocity || aboveMaxWithVelocity) {
      let bound;
      if (belowMinWithVelocity) {
        bound = this.options.min;
      } else {
        bound = this.options.max;
      }
      this.transitionToSpring(bound);
    } else {
      this.useSpring = false;
    }
  }
  transitionToSpring(bound) {
    this.springAnimator.setFrom(this.state.x);
    this.springAnimator.setVelocity(this.state.v);
    this.springAnimator.setTo(bound);
    this.useSpring = true;
  }
  // If the position is outside the min and max bounds, but traveling
  // back towards the bounds, check if the velocity is sufficient to
  // carry the position back within bounds. If it is, let friction do the
  // work. If not, the state is invalid, so use the spring.
  isValidState() {
    const belowMinTravelingBack = this.state.x < this.options.min && this.state.v > 0;
    const aboveMaxTravelingBack = this.state.x > this.options.max && this.state.v < 0;
    if (belowMinTravelingBack || aboveMaxTravelingBack) {
      let bound;
      if (belowMinTravelingBack) {
        bound = this.options.min;
      } else {
        bound = this.options.max;
      }
      const friction = this.frictionAnimator.options.friction;
      const solution = 1 - friction * (bound - this.state.x) / this.state.v;
      return solution > 0;
    }
    return true;
  }
  // The math behind _isValidState:
  //
  // 1. Integrate the friction animator's acceleration to find velocity
  //
  //         a = - k * v
  //     dv/dt = - k * v
  // Int(dv/v) = - k * Int(dt)
  //      ln v = - k * t + C
  //
  // => Solve for C at t = 0
  //
  // ln v(0) = - k * 0 + C
  // ln v(0) = C
  //
  // => Plug C back into v(t)
  //
  //     ln v = - k * t + ln v(0)
  // e^(ln v) = e^(- k * t) + e^(ln v(0))
  //        v = v(0) * e^(- k * t)
  //
  // 2. Integrate velocity to find position
  //
  // Int(v) = v(0) * Int(e^(- k * t))
  //      x = - v(0) * e^(-k * t) / k + C
  //
  // => Solve for C at t = 0
  //
  //            x(0) = - v(0) * e^(-k * 0) / k + C
  //            x(0) = - v(0) / k + C
  // x(0) + v(0) / k = C
  //
  // => Plug C back into x(t)
  //
  // x = - v(0) * e^(-k * t) / k + x(0) + v(0) / k
  //
  // 3. Check if a (real) solution exists for t for position x
  //
  //                                x = - v(0) * e^(-k * t) / k + x(0) + v(0) / k
  //                         x - x(0) = - v(0) * e^(-k * t) / k + v(0) / k
  //                   k * (x - x(0)) = - v(0) * e^(-k * t) + v(0)
  //            k * (x - x(0)) - v(0) = - v(0) * e^(-k * t)
  // (k * (x - x(0)) - v(0)) / - v(0) = e^(-k * t)
  //       1 - (k * (x - x(0)) / v(0) = e^(-k * t)
  //   ln(1 - (k * (x - x(0)) / v(0)) = -k * t
  //
  // Therefore, a real solution exists if 1 - (k * (x - x(0)) / v(0) > 0
};

// ../../library/src/render/types/Color/CSSNames.ts
var cssNames = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};

// ../../library/src/render/types/Color/Utils.ts
function modulate(value, rangeA, rangeB, limit = false) {
  const [fromLow, fromHigh] = rangeA;
  const [toLow, toHigh] = rangeB;
  const fromDelta = fromHigh - fromLow;
  if (fromDelta === 0) return (toHigh + toLow) / 2;
  const toDelta = toHigh - toLow;
  if (toDelta === 0) return toLow;
  const result = toLow + (value - fromLow) / fromDelta * toDelta;
  if (limit === true) {
    if (toLow < toHigh) {
      if (result < toLow) {
        return toLow;
      }
      if (result > toHigh) {
        return toHigh;
      }
    } else {
      if (result > toLow) {
        return toLow;
      }
      if (result < toHigh) {
        return toHigh;
      }
    }
  }
  return result;
}
function isNumeric(value) {
  return !Number.isNaN(value) && Number.isFinite(value);
}
function percentToFraction(val) {
  const digits = numberFromString(val);
  if (digits !== void 0) {
    if (val.includes("%")) {
      return digits / 100;
    }
    return digits;
  }
  return 0;
}
function numberFromString(input) {
  const match = /\d?\.?\d+/u.exec(input);
  return match ? Number(match[0]) : void 0;
}

// ../../library/src/render/types/Color/types.ts
var ColorFormat = /* @__PURE__ */ ((ColorFormat2) => {
  ColorFormat2["RGB"] = "rgb";
  ColorFormat2["HSL"] = "hsl";
  ColorFormat2["HSV"] = "hsv";
  ColorFormat2["HEX"] = "hex";
  ColorFormat2["NAME"] = "name";
  return ColorFormat2;
})(ColorFormat || {});
var ColorMixModelType = /* @__PURE__ */ ((ColorMixModelType2) => {
  ColorMixModelType2["RGB"] = "rgb";
  ColorMixModelType2["RGBA"] = "rgba";
  ColorMixModelType2["HSL"] = "hsl";
  ColorMixModelType2["HSLA"] = "hsla";
  ColorMixModelType2["HUSL"] = "husl";
  return ColorMixModelType2;
})(ColorMixModelType || {});

// ../../library/src/render/types/Color/converters.ts
var Hsluv = /* @__PURE__ */ (() => require_hsluv().Hsluv)();
var hsluvConverter = /* @__PURE__ */ new Hsluv();
function rgbToHsluv(r, g, b) {
  hsluvConverter.rgb_r = r / 255;
  hsluvConverter.rgb_g = g / 255;
  hsluvConverter.rgb_b = b / 255;
  hsluvConverter.rgbToHsluv();
  return {
    h: hsluvConverter.hsluv_h,
    s: hsluvConverter.hsluv_s,
    l: hsluvConverter.hsluv_l
  };
}
function rgbaFromHusl(h, s, l, a = 1) {
  hsluvConverter.hsluv_h = h;
  hsluvConverter.hsluv_s = s;
  hsluvConverter.hsluv_l = l;
  hsluvConverter.hsluvToRgb();
  return {
    r: hsluvConverter.rgb_r * 255,
    g: hsluvConverter.rgb_g * 255,
    b: hsluvConverter.rgb_b * 255,
    a
  };
}
function hsvToStr(h, s, v, a) {
  const _h = Math.round(h);
  const _s = Math.round(s * 100);
  const _v = Math.round(v * 100);
  return a === void 0 || a === 1 ? "hsv(" + _h + ", " + _s + "%, " + _v + "%)" : "hsva(" + _h + ", " + _s + "%, " + _v + "%, " + a + ")";
}
function rgbToRgb(r, g, b) {
  return {
    r: isNumeric(r) ? bound01(r, 255) * 255 : 0,
    g: isNumeric(g) ? bound01(g, 255) * 255 : 0,
    b: isNumeric(b) ? bound01(b, 255) * 255 : 0
  };
}
function rgbToHex(r, g, b, allow3Char) {
  const hex2 = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16))
  ];
  if (allow3Char && hex2[0].charAt(0) === hex2[0].charAt(1) && hex2[1].charAt(0) === hex2[1].charAt(1) && hex2[2].charAt(0) === hex2[2].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbToHsl(r, g, b) {
  let l;
  let s;
  const _r = bound01(r, 255);
  const _g = bound01(g, 255);
  const _b = bound01(b, 255);
  const max = Math.max(_r, _g, _b);
  const min = Math.min(_r, _g, _b);
  let h = s = l = (max + min) / 2;
  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case _r:
        h = (_g - _b) / d + (_g < _b ? 6 : 0);
        break;
      case _g:
        h = (_b - _r) / d + 2;
        break;
      case _b:
        h = (_r - _g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h: h * 360, s, l };
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  let r;
  let g;
  let b;
  h = bound01(h, 360);
  s = bound01(s * 100, 100);
  l = bound01(l * 100, 100);
  if (s === 0) {
    r = g = b = l;
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;
  let h = 0;
  const s = max === 0 ? 0 : d / max;
  const v = max;
  if (max === min) {
    h = 0;
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h, s, v };
}
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s * 100, 100);
  v = bound01(v * 100, 100);
  const i = Math.floor(h);
  const f = h - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  const mod = i % 6;
  const r = [v, q, p, p, t, v][mod];
  const g = [t, v, v, q, p, p][mod];
  const b = [p, p, t, v, v, q][mod];
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function bound01(n, max) {
  let _max;
  let _n;
  if (typeof max === "string") _max = parseFloat(max);
  else _max = max;
  if (typeof n === "string") {
    if (isOnePointZero(n)) {
      n = "100%";
    }
    const processPercent = isPercentage(n);
    _n = Math.min(_max, Math.max(0, parseFloat(n)));
    if (processPercent) {
      _n = Math.floor(_n * _max) / 100;
    }
  } else {
    _n = n;
  }
  if (Math.abs(_n - _max) < 1e-6) {
    return 1;
  }
  return _n % _max / _max;
}
function isOnePointZero(n) {
  return typeof n === "string" && n.includes(".") && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.includes("%");
}
function pad2(char) {
  if (char.length === 1) {
    return "0" + char;
  } else {
    return "" + char;
  }
}
var matchers = /* @__PURE__ */ (() => {
  const cssInteger = "[-\\+]?\\d+%?";
  const cssNumber = "[-\\+]?\\d*\\.\\d+%?";
  const cssUnit = "(?:" + cssNumber + ")|(?:" + cssInteger + ")";
  const permissiveMatch3 = "[\\s|\\(]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")\\s*\\)?";
  const permissiveMatch4 = "[\\s|\\(]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")[,|\\s]+(" + cssUnit + ")\\s*\\)?";
  return {
    rgb: new RegExp("rgb" + permissiveMatch3),
    rgba: new RegExp("rgba" + permissiveMatch4),
    hsl: new RegExp("hsl" + permissiveMatch3),
    hsla: new RegExp("hsla" + permissiveMatch4),
    hsv: new RegExp("hsv" + permissiveMatch3),
    hsva: new RegExp("hsva" + permissiveMatch4),
    hex3: /^([\da-f])([\da-f])([\da-f])$/iu,
    hex6: /^([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu,
    hex4: /^#?([\da-f])([\da-f])([\da-f])([\da-f])$/iu,
    hex8: /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu
  };
})();
function stringToObject(inputColor) {
  if (inputColor.includes("gradient(")) return false;
  if (inputColor.includes("var(")) return false;
  const trimLeft = /^[\s,#]+/u;
  let color2 = inputColor.replace(trimLeft, "").trimEnd().toLowerCase();
  const namedColor = cssNames[color2];
  if (namedColor) {
    color2 = namedColor;
  }
  if (color2 === "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name" /* NAME */
    };
  }
  let match;
  if (match = matchers.rgb.exec(color2)) {
    return {
      r: parseInt(match[1] ?? ""),
      g: parseInt(match[2] ?? ""),
      b: parseInt(match[3] ?? ""),
      a: 1,
      format: "rgb" /* RGB */
    };
  }
  if (match = matchers.rgba.exec(color2)) {
    return {
      r: parseInt(match[1] ?? ""),
      g: parseInt(match[2] ?? ""),
      b: parseInt(match[3] ?? ""),
      a: parseFloat(match[4] ?? ""),
      format: "rgb" /* RGB */
    };
  }
  if (match = matchers.hsl.exec(color2)) {
    return {
      h: parseInt(match[1] ?? ""),
      s: percentToFraction(match[2] ?? ""),
      l: percentToFraction(match[3] ?? ""),
      a: 1,
      format: "hsl" /* HSL */
    };
  }
  if (match = matchers.hsla.exec(color2)) {
    return {
      h: parseInt(match[1] ?? ""),
      s: percentToFraction(match[2] ?? ""),
      l: percentToFraction(match[3] ?? ""),
      a: parseFloat(match[4] ?? ""),
      format: "hsl" /* HSL */
    };
  }
  if (match = matchers.hsv.exec(color2)) {
    return {
      h: parseInt(match[1] ?? ""),
      s: percentToFraction(match[2] ?? ""),
      v: percentToFraction(match[3] ?? ""),
      a: 1,
      format: "hsv" /* HSV */
    };
  }
  if (match = matchers.hsva.exec(color2)) {
    return {
      h: parseInt(match[1] ?? ""),
      s: percentToFraction(match[2] ?? ""),
      v: percentToFraction(match[3] ?? ""),
      a: parseFloat(match[4] ?? ""),
      format: "hsv" /* HSV */
    };
  }
  if (match = matchers.hex8.exec(color2)) {
    return {
      r: parseIntFromHex(match[1] ?? ""),
      g: parseIntFromHex(match[2] ?? ""),
      b: parseIntFromHex(match[3] ?? ""),
      a: convertHexToDecimal(match[4] ?? ""),
      format: namedColor ? "name" /* NAME */ : "hex" /* HEX */
    };
  }
  if (match = matchers.hex6.exec(color2)) {
    return {
      r: parseIntFromHex(match[1] ?? ""),
      g: parseIntFromHex(match[2] ?? ""),
      b: parseIntFromHex(match[3] ?? ""),
      a: 1,
      format: namedColor ? "name" /* NAME */ : "hex" /* HEX */
    };
  }
  if (match = matchers.hex4.exec(color2)) {
    return {
      r: parseIntFromHex(`${match[1]}${match[1]}`),
      g: parseIntFromHex(`${match[2]}${match[2]}`),
      b: parseIntFromHex(`${match[3]}${match[3]}`),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: namedColor ? "name" /* NAME */ : "hex" /* HEX */
    };
  }
  if (match = matchers.hex3.exec(color2)) {
    return {
      r: parseIntFromHex(`${match[1]}${match[1]}`),
      g: parseIntFromHex(`${match[2]}${match[2]}`),
      b: parseIntFromHex(`${match[3]}${match[3]}`),
      a: 1,
      format: namedColor ? "name" /* NAME */ : "hex" /* HEX */
    };
  } else {
    return false;
  }
}
function parseIntFromHex(hex2) {
  return parseInt(hex2, 16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}

// ../../library/src/render/types/Color/p3.ts
var p3Matcher = /^color\(display-p3\s+(?<r>\d+\.\d+|\d+|\.\d+)\s+(?<g>\d+\.\d+|\d+|\.\d+)\s+(?<b>\d+\.\d+|\d+|\.\d+)(?:\s*\/\s*(?<a>\d+\.\d+|\d+|\.\d+))?\)$/u;
function parseP3(color2) {
  const match = p3Matcher.exec(color2);
  if (!match) return null;
  const { r = "0", g = "0", b = "0", a } = match.groups ?? {};
  return {
    r: parseFloat(r),
    g: parseFloat(g),
    b: parseFloat(b),
    a: a ? parseFloat(a) : 1
  };
}
function convertRGBChannelToLrgb(c = 0) {
  const abs = Math.abs(c);
  if (abs <= 0.04045) return c / 12.92;
  return (Math.sign(c) || 1) * ((abs + 0.055) / 1.055) ** 2.4;
}
function convertRgbToLrgb({ r, g, b, a }) {
  return {
    r: convertRGBChannelToLrgb(r),
    g: convertRGBChannelToLrgb(g),
    b: convertRGBChannelToLrgb(b),
    a
  };
}
function convertLrgbChannelToRgb(c = 0) {
  const abs = Math.abs(c);
  if (abs > 31308e-7) return (Math.sign(c) || 1) * (1.055 * abs ** (1 / 2.4) - 0.055);
  return c * 12.92;
}
function convertLrgbToRgb({ r, g, b, a }) {
  return {
    r: convertLrgbChannelToRgb(r),
    g: convertLrgbChannelToRgb(g),
    b: convertLrgbChannelToRgb(b),
    a
  };
}
var convertP3ToXyz65 = (color2) => {
  const { r, g, b, a } = convertRgbToLrgb(color2);
  return {
    x: 0.486570948648216 * r + 0.265667693169093 * g + 0.1982172852343625 * b,
    y: 0.2289745640697487 * r + 0.6917385218365062 * g + 0.079286914093745 * b,
    z: 0 * r + 0.0451133818589026 * g + 1.043944368900976 * b,
    a
  };
};
var convertXyz65ToRgb = ({ x = 0, y = 0, z = 0, a = 1 }) => {
  return convertLrgbToRgb({
    r: x * 3.2409699419045226 - y * 1.537383177570094 - 0.4986107602930034 * z,
    g: x * -0.9692436362808796 + y * 1.8759675015077204 + 0.0415550574071756 * z,
    b: x * 0.0556300796969936 - y * 0.2039769588889765 + 1.0569715142428784 * z,
    a
  });
};
var convertRgbToXyz65 = (color2) => {
  const { r, g, b, a } = convertRgbToLrgb(color2);
  return {
    x: 0.4123907992659593 * r + 0.357584339383878 * g + 0.1804807884018343 * b,
    y: 0.2126390058715102 * r + 0.715168678767756 * g + 0.0721923153607337 * b,
    z: 0.0193308187155918 * r + 0.119194779794626 * g + 0.9505321522496607 * b,
    a
  };
};
var convertXyz65ToP3 = ({ x = 0, y = 0, z = 0, a = 1 }) => {
  return convertLrgbToRgb({
    r: x * 2.4934969119414263 - y * 0.9313836179191242 - 0.402710784450717 * z,
    g: x * -0.8294889695615749 + y * 1.7626640603183465 + 0.0236246858419436 * z,
    b: x * 0.0358458302437845 - y * 0.0761723892680418 + 0.9568845240076871 * z,
    a
  });
};
function convertRGBToHSV({ r, g, b, a }) {
  const M = Math.max(r, g, b), m2 = Math.min(r, g, b);
  const res = {
    h: 0,
    s: M === 0 ? 0 : 1 - m2 / M,
    v: M,
    a
  };
  if (M - m2 !== 0) {
    res.h = (M === r ? (g - b) / (M - m2) + (g < b ? 6 : 0) : M === g ? (b - r) / (M - m2) + 2 : (r - g) / (M - m2) + 4) * 60;
  }
  return res;
}
function normalizeHue(hue) {
  return (hue = hue % 360) < 0 ? hue + 360 : hue;
}
function convertHsvToRgb({ h = 0, s = 0, v = 0, a = 1 }) {
  const hue = normalizeHue(h);
  const f = Math.abs(hue / 60 % 2 - 1);
  switch (Math.floor(hue / 60)) {
    case 0:
      return { r: v, g: v * (1 - s * f), b: v * (1 - s), a };
    case 1:
      return { r: v * (1 - s * f), g: v, b: v * (1 - s), a };
    case 2:
      return { r: v * (1 - s), g: v, b: v * (1 - s * f), a };
    case 3:
      return { r: v * (1 - s), g: v * (1 - s * f), b: v, a };
    case 4:
      return { r: v * (1 - s * f), g: v * (1 - s), b: v, a };
    case 5:
      return { r: v, g: v * (1 - s), b: v * (1 - s * f), a };
    default:
      return { r: v * (1 - s), g: v * (1 - s), b: v * (1 - s), a };
  }
}
function convertRgbToP3(color2) {
  return convertXyz65ToP3(convertRgbToXyz65(color2));
}
function convertP3ToRgb(color2) {
  return convertXyz65ToRgb(convertP3ToXyz65(color2));
}

// ../../library/src/render/types/Color/Color.ts
var P3Color = class _P3Color {
  constructor(color2) {
    __publicField(this, "format", "p3");
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = color2.r ?? 0;
    this.g = color2.g ?? 0;
    this.b = color2.b ?? 0;
    this.a = color2.a ?? 1;
  }
  hsv() {
    return convertRGBToHSV(this);
  }
  rgb() {
    return convertP3ToRgb(this);
  }
  hsl() {
    return rgbToHsl(this.r, this.g, this.b);
  }
  toString(space = "p3", overrides) {
    switch (space) {
      case "p3": {
        const r = overrides?.r ?? this.r;
        const g = overrides?.g ?? this.g;
        const b = overrides?.b ?? this.b;
        const a = overrides?.a ?? this.a;
        return a === 1 ? `color(display-p3 ${r} ${g} ${b})` : `color(display-p3 ${r} ${g} ${b} / ${a})`;
      }
      case "srgb": {
        const color2 = this.rgb();
        const clampedR = Math.round(Math.max(0, Math.min(color2.r, 1)) * 100) / 100;
        const clampedG = Math.round(Math.max(0, Math.min(color2.g, 1)) * 100) / 100;
        const clampedB = Math.round(Math.max(0, Math.min(color2.b, 1)) * 100) / 100;
        const r = overrides?.r ?? clampedR * 255;
        const g = overrides?.g ?? clampedG * 255;
        const b = overrides?.b ?? clampedB * 255;
        const a = overrides?.a ?? color2.a ?? 1;
        return a === 1 ? `rgb(${r}, ${g}, ${b})` : `rgba(${r}, ${g}, ${b}, ${a})`;
      }
    }
  }
  static isP3String(color2) {
    return color2.startsWith("color(display-p3");
  }
  static fromHSV(color2, space = "p3") {
    switch (space) {
      case "p3":
        return new _P3Color(convertHsvToRgb(color2));
      case "srgb":
        return new _P3Color(convertRgbToP3(convertHsvToRgb(color2)));
    }
  }
  static fromRGB(color2) {
    return new _P3Color(
      convertRgbToP3({
        // Converted an rgb value between 0-255 to a 0-1 decimal with 5 decimal places -> 0.78607.
        r: Math.round(color2.r / 255 * 1e4) / 1e4,
        g: Math.round(color2.g / 255 * 1e4) / 1e4,
        b: Math.round(color2.b / 255 * 1e4) / 1e4,
        a: color2.a ?? 1
      })
    );
  }
  static fromRGBString(color2) {
    const value = Color(color2);
    if (!value) return void 0;
    return _P3Color.fromRGB(value);
  }
  static fromString(color2) {
    if (!_P3Color.isP3String(color2)) return void 0;
    const parsed = parseP3(color2);
    if (!parsed) return void 0;
    return new _P3Color({ r: parsed.r, g: parsed.g, b: parsed.b, a: parsed.a });
  }
  static srgbFromValue(color2) {
    if (!isString(color2) || !Color.isP3String(color2)) return color2;
    const value = _P3Color.fromString(color2);
    if (!value) return color2;
    return value.toString("srgb");
  }
  static multiplyAlpha(color2, alpha2) {
    return new _P3Color({
      r: color2.r,
      g: color2.g,
      b: color2.b,
      a: color2.a * alpha2
    });
  }
};
function clampRGB(color2) {
  return P3Color.srgbFromValue(color2);
}
var cache = /* @__PURE__ */ new Map();
var Color = /* @__PURE__ */ (() => {
  function Color2(color2, r, g, b) {
    if (typeof color2 === "string") {
      let c = cache.get(color2);
      if (c) return c;
      c = createColor(color2);
      if (c === void 0) return { ...Color2("black"), isValid: false };
      cache.set(color2, c);
      return c;
    }
    const created = createColor(color2, r, g, b);
    return created !== void 0 ? created : { ...Color2("black"), isValid: false };
  }
  function createColor(color2, r, g, b) {
    if (color2 === "") return void 0;
    const colorData = getCompleteColorStrategy(color2, r, g, b);
    if (colorData) {
      const newColor = {
        r: colorData.r,
        g: colorData.g,
        b: colorData.b,
        a: colorData.a,
        h: colorData.h,
        s: colorData.s,
        l: colorData.l,
        initialValue: typeof color2 === "string" && colorData.format !== "hsv" /* HSV */ ? color2 : void 0,
        roundA: Math.round(100 * colorData.a) / 100,
        format: colorData.format,
        mix: Color2.mix,
        toValue: () => Color2.toRgbString(newColor)
      };
      return newColor;
    } else {
      return void 0;
    }
  }
  const ColorMixModel = {
    isRGB(colorModel) {
      return colorModel === "rgb" /* RGB */ || colorModel === "rgba" /* RGBA */;
    },
    isHSL(colorModel) {
      return colorModel === "hsl" /* HSL */ || colorModel === "hsla" /* HSLA */;
    }
  };
  Color2.inspect = (color2, initialValue) => {
    if (color2.format === "hsl" /* HSL */) {
      return `<${color2.constructor.name} h:${color2.h} s:${color2.s} l:${color2.l} a:${color2.a}>`;
    } else if (color2.format === "hex" /* HEX */ || color2.format === "name" /* NAME */) {
      return `<${color2.constructor.name} "${initialValue}">`;
    } else {
      return `<${color2.constructor.name} r:${color2.r} g:${color2.g} b:${color2.b} a:${color2.a}>`;
    }
  };
  Color2.isColor = (color2) => {
    if (typeof color2 === "string") {
      return Color2.isColorString(color2);
    } else {
      return Color2.isColorObject(color2);
    }
  };
  Color2.isColorString = (colorString) => {
    if (typeof colorString === "string") {
      return stringToObject(colorString) !== false;
    }
    return false;
  };
  Color2.isColorObject = (color2) => {
    return isObject2(color2) && typeof color2.r === "number" && typeof color2.g === "number" && typeof color2.b === "number" && typeof color2.h === "number" && typeof color2.s === "number" && typeof color2.l === "number" && typeof color2.a === "number" && typeof color2.roundA === "number" && typeof color2.format === "string";
  };
  Color2.toString = (color2) => {
    return Color2.toRgbString(color2);
  };
  Color2.toHex = (color2, allow3Char = false) => {
    return rgbToHex(color2.r, color2.g, color2.b, allow3Char);
  };
  Color2.toHexString = (color2, allow3Char = false) => {
    return `#${Color2.toHex(color2, allow3Char)}`;
  };
  Color2.isP3String = (color2) => {
    if (typeof color2 !== "string") return false;
    return P3Color.isP3String(color2);
  };
  Color2.toRgbString = (color2) => {
    return color2.a === 1 ? "rgb(" + Math.round(color2.r) + ", " + Math.round(color2.g) + ", " + Math.round(color2.b) + ")" : "rgba(" + Math.round(color2.r) + ", " + Math.round(color2.g) + ", " + Math.round(color2.b) + ", " + color2.roundA + ")";
  };
  Color2.toHusl = (color2) => {
    return {
      ...rgbToHsluv(color2.r, color2.g, color2.b),
      a: color2.roundA
    };
  };
  Color2.toHslString = (color2) => {
    const hsl = Color2.toHsl(color2);
    const h = Math.round(hsl.h);
    const s = Math.round(hsl.s * 100);
    const l = Math.round(hsl.l * 100);
    return color2.a === 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + color2.roundA + ")";
  };
  Color2.toHsv = (color2) => {
    const hsv = rgbToHsv(color2.r, color2.g, color2.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: color2.a };
  };
  Color2.toHsvString = (color2) => {
    const hsv = rgbToHsv(color2.r, color2.g, color2.b);
    const h = Math.round(hsv.h * 360);
    const s = Math.round(hsv.s * 100);
    const v = Math.round(hsv.v * 100);
    return color2.a === 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + color2.roundA + ")";
  };
  Color2.toName = (color2) => {
    if (color2.a === 0) {
      return "transparent";
    }
    if (color2.a < 1) {
      return false;
    }
    const hex2 = rgbToHex(color2.r, color2.g, color2.b, true);
    for (const key7 of Object.keys(cssNames)) {
      const value = cssNames[key7];
      if (value === hex2) {
        return key7;
      }
    }
    return false;
  };
  Color2.toHsl = (color2) => {
    return {
      h: Math.round(color2.h),
      s: color2.s,
      l: color2.l,
      a: color2.a
    };
  };
  Color2.toRgb = (color2) => {
    return {
      r: Math.round(color2.r),
      g: Math.round(color2.g),
      b: Math.round(color2.b),
      a: color2.a
    };
  };
  Color2.brighten = (color2, amount = 10) => {
    const rgb = Color2.toRgb(color2);
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return Color2(rgb);
  };
  Color2.lighten = (color2, amount = 10) => {
    const hsl = Color2.toHsl(color2);
    hsl.l += amount / 100;
    hsl.l = Math.min(1, Math.max(0, hsl.l));
    return Color2(hsl);
  };
  Color2.darken = (color2, amount = 10) => {
    const hsl = Color2.toHsl(color2);
    hsl.l -= amount / 100;
    hsl.l = Math.min(1, Math.max(0, hsl.l));
    return Color2(hsl);
  };
  Color2.saturate = (color2, amount = 10) => {
    const hsl = Color2.toHsl(color2);
    hsl.s += amount / 100;
    hsl.s = Math.min(1, Math.max(0, hsl.s));
    return Color2(hsl);
  };
  Color2.desaturate = (color2, amount = 10) => {
    const hsl = Color2.toHsl(color2);
    hsl.s -= amount / 100;
    hsl.s = Math.min(1, Math.max(0, hsl.s));
    return Color2(hsl);
  };
  Color2.grayscale = (color2) => {
    return Color2.desaturate(color2, 100);
  };
  Color2.hueRotate = (color2, angle) => {
    const hsl = Color2.toHsl(color2);
    hsl.h += angle;
    hsl.h = hsl.h > 360 ? hsl.h - 360 : hsl.h;
    return Color2(hsl);
  };
  Color2.alpha = (color2, a = 1) => {
    return Color2({
      r: color2.r,
      g: color2.g,
      b: color2.b,
      a
    });
  };
  Color2.transparent = (color2) => {
    return Color2.alpha(color2, 0);
  };
  Color2.multiplyAlpha = (color2, alphaValue = 1) => {
    return Color2({
      r: color2.r,
      g: color2.g,
      b: color2.b,
      a: color2.a * alphaValue
    });
  };
  Color2.interpolate = (colorA, colorB, model = "rgb" /* RGB */) => {
    if (!Color2.isColorObject(colorA) || !Color2.isColorObject(colorB)) {
      throw new TypeError("Both arguments for Color.interpolate must be Color objects");
    }
    return (progress2) => {
      const color2 = Color2.mixAsColor(colorA, colorB, progress2, false, model);
      return color2;
    };
  };
  Color2.mix = (from, toColor, { model = "rgb" /* RGB */ } = {}) => {
    const fromColor = typeof from === "string" ? Color2(from) : from;
    const mixer = Color2.interpolate(fromColor, toColor, model);
    return (p) => Color2.toRgbString(mixer(p));
  };
  Color2.mixAsColor = (colorA, colorB, fraction2 = 0.5, limit = false, model = "rgb" /* RGB */) => {
    let result = null;
    if (ColorMixModel.isRGB(model)) {
      result = Color2({
        r: modulate(fraction2, [0, 1], [colorA.r, colorB.r], limit),
        g: modulate(fraction2, [0, 1], [colorA.g, colorB.g], limit),
        b: modulate(fraction2, [0, 1], [colorA.b, colorB.b], limit),
        a: modulate(fraction2, [0, 1], [colorA.a, colorB.a], limit)
      });
    } else {
      let hslA, hslB;
      if (ColorMixModel.isHSL(model)) {
        hslA = Color2.toHsl(colorA);
        hslB = Color2.toHsl(colorB);
      } else {
        hslA = Color2.toHusl(colorA);
        hslB = Color2.toHusl(colorB);
      }
      if (hslA.s === 0) {
        hslA.h = hslB.h;
      } else if (hslB.s === 0) {
        hslB.h = hslA.h;
      }
      const fromH = hslA.h;
      const toH = hslB.h;
      let deltaH = toH - fromH;
      if (deltaH > 180) {
        deltaH = toH - 360 - fromH;
      } else if (deltaH < -180) {
        deltaH = toH + 360 - fromH;
      }
      const tween = {
        h: modulate(fraction2, [0, 1], [fromH, fromH + deltaH], limit),
        s: modulate(fraction2, [0, 1], [hslA.s, hslB.s], limit),
        l: modulate(fraction2, [0, 1], [hslA.l, hslB.l], limit),
        a: modulate(fraction2, [0, 1], [colorA.a, colorB.a], limit)
      };
      if (ColorMixModel.isHSL(model)) {
        result = Color2(tween);
      } else {
        result = Color2(rgbaFromHusl(tween.h, tween.s, tween.l, tween.a));
      }
    }
    return result;
  };
  Color2.random = (alphaValue = 1) => {
    function gen() {
      return Math.floor(Math.random() * 255);
    }
    return Color2("rgba(" + gen() + ", " + gen() + ", " + gen() + ", " + alphaValue + ")");
  };
  Color2.grey = (amount = 0.5, alphaValue = 1) => {
    amount = Math.floor(amount * 255);
    return Color2("rgba(" + amount + ", " + amount + ", " + amount + ", " + alphaValue + ")");
  };
  Color2.gray = Color2.grey;
  Color2.rgbToHsl = (r, g, b) => {
    return rgbToHsl(r, g, b);
  };
  Color2.isValidColorProperty = (name, value) => {
    const isColorKey = name.toLowerCase().slice(-5) === "color" || name === "fill" || name === "stroke";
    if (isColorKey && typeof value === "string" && Color2.isColorString(value)) {
      return true;
    }
    return false;
  };
  Color2.difference = (colorA, colorB) => {
    const _r = (colorA.r + colorB.r) / 2;
    const deltaR = colorA.r - colorB.r;
    const deltaG = colorA.g - colorB.g;
    const deltaB = colorA.b - colorB.b;
    const deltaR2 = Math.pow(deltaR, 2);
    const deltaG2 = Math.pow(deltaG, 2);
    const deltaB2 = Math.pow(deltaB, 2);
    return Math.sqrt(2 * deltaR2 + 4 * deltaG2 + 3 * deltaB2 + _r * (deltaR2 - deltaB2) / 256);
  };
  Color2.equal = (colorA, colorB, tolerance = 0.1) => {
    if (Math.abs(colorA.r - colorB.r) >= tolerance) {
      return false;
    }
    if (Math.abs(colorA.g - colorB.g) >= tolerance) {
      return false;
    }
    if (Math.abs(colorA.b - colorB.b) >= tolerance) {
      return false;
    }
    if (Math.abs(colorA.a - colorB.a) * 256 >= tolerance) {
      return false;
    }
    return true;
  };
  const channelToDecimal = interpolate([0, 255], [0, 1]);
  function convertChannelToLinearRgb(channel) {
    channel = channelToDecimal(channel);
    const abs = Math.abs(channel);
    if (abs < 0.04045) return channel / 12.92;
    return (Math.sign(channel) || 1) * Math.pow((abs + 0.055) / 1.055, 2.4);
  }
  Color2.luminance = (color2) => {
    const { r, g, b } = Color2.toRgb(color2);
    return 0.2126 * convertChannelToLinearRgb(r) + 0.7152 * convertChannelToLinearRgb(g) + 0.0722 * convertChannelToLinearRgb(b);
  };
  Color2.contrast = (a, b) => {
    const l1 = Color2.luminance(a);
    const l2 = Color2.luminance(b);
    return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
  };
  return Color2;
})();
function getCompleteColorStrategy(colorOrR, g, b, a = 1) {
  let completeColor;
  if (typeof colorOrR === "number" && !Number.isNaN(colorOrR) && typeof g === "number" && !Number.isNaN(g) && typeof b === "number" && !Number.isNaN(b)) {
    const _r = colorOrR;
    const _g = g;
    const _b = b;
    const _a = a;
    completeColor = getCompleteColorFromRGB({ r: _r, g: _g, b: _b, a: _a });
  } else if (typeof colorOrR === "string") {
    completeColor = getCompleteColorFromString(colorOrR);
  } else if (typeof colorOrR === "object") {
    if (colorOrR.hasOwnProperty("r") && colorOrR.hasOwnProperty("g") && colorOrR.hasOwnProperty("b")) {
      completeColor = getCompleteColorFromRGB(colorOrR);
    } else {
      completeColor = getCompleteColorFromHSL(colorOrR);
    }
  }
  return completeColor;
}
function getCompleteColorFromString(color2) {
  const result = stringToObject(color2);
  if (result) {
    if (result.format === "hsl" /* HSL */) {
      return getCompleteColorFromHSL(result);
    } else if (result.format === "hsv" /* HSV */) {
      return getCompleteColorFromHSV(result);
    } else {
      return getCompleteColorFromRGB(result);
    }
  }
}
function getCompleteColorFromHSV(color2) {
  const rgb = hsvToRgb(color2.h, color2.s, color2.v);
  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
  return {
    ...hsl,
    ...rgb,
    format: "rgb" /* RGB */,
    a: color2.a !== void 0 ? correctAlpha(color2.a) : 1
  };
}
function getCompleteColorFromRGB(color2) {
  const rgb = rgbToRgb(color2.r, color2.g, color2.b);
  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
  return {
    ...hsl,
    ...rgb,
    format: "rgb" /* RGB */,
    a: color2.a !== void 0 ? correctAlpha(color2.a) : 1
  };
}
function getCompleteColorFromHSL(color2) {
  let h;
  let s;
  let l;
  let rgb = { r: 0, g: 0, b: 0 };
  let hsl = { h: 0, s: 0, l: 0 };
  h = isNumeric(color2.h) ? color2.h : 0;
  h = (h + 360) % 360;
  s = isNumeric(color2.s) ? color2.s : 1;
  if (typeof color2.s === "string") {
    s = numberFromString(color2.s);
  }
  l = isNumeric(color2.l) ? color2.l : 0.5;
  if (typeof color2.l === "string") {
    l = numberFromString(color2.l);
  }
  rgb = hslToRgb(h, s, l);
  hsl = {
    h,
    s,
    l
  };
  return {
    ...rgb,
    ...hsl,
    a: color2.a === void 0 ? 1 : color2.a,
    format: "hsl" /* HSL */
  };
}
function correctAlpha(alphaValue) {
  alphaValue = parseFloat(alphaValue);
  if (alphaValue < 0) {
    alphaValue = 0;
  }
  if (Number.isNaN(alphaValue) || alphaValue > 1) {
    alphaValue = 1;
  }
  return alphaValue;
}

// ../../library/src/interpolation/ColorInterpolation.ts
var ColorInterpolation = (type = "husl" /* HUSL */) => {
  return {
    interpolate(from, to) {
      ;
      [from, to] = Interpolation.handleUndefined(from, to);
      return Color.interpolate(Color(from), Color(to), type);
    },
    difference(from, to) {
      return Color.difference(Color(from), Color(to));
    }
  };
};

// ../../library/src/interpolation/NoInterpolation.ts
var NoInterpolation = {
  interpolate(from, to) {
    ;
    [from, to] = Interpolation.handleUndefined(from, to);
    return (progress2) => {
      return progress2 < 0.5 ? from : to;
    };
  },
  difference(from, to) {
    return from === to ? 0 : 1;
  }
};

// ../../library/src/interpolation/ObjectInterpolation.ts
var ObjectInterpolation = (valueInterpolation) => {
  return {
    interpolate(from, to) {
      ;
      [from, to] = Interpolation.handleUndefined(from, to);
      const result = Object.assign({}, from);
      const interpolations = {};
      const keys3 = /* @__PURE__ */ new Set();
      for (const key7 in from) {
        interpolations[key7] = valueInterpolation.interpolate(from[key7], to[key7]);
        keys3.add(key7);
      }
      for (const key7 in to) {
        if (!keys3.has(key7)) {
          interpolations[key7] = valueInterpolation.interpolate(from[key7], to[key7]);
          keys3.add(key7);
        }
      }
      return (progress2) => {
        for (const key7 in interpolations) {
          result[key7] = interpolations[key7](progress2);
        }
        return result;
      };
    },
    difference(from, to) {
      let sum = 0;
      for (const key7 in from) {
        const difference = valueInterpolation.difference(from[key7], to[key7]);
        sum += Math.pow(difference, 2);
      }
      return Math.sqrt(sum);
    }
  };
};

// ../../library/src/interpolation/ValueInterpolation.ts
var DefaultInterpolationOptions = {
  colorModel: "husl" /* HUSL */
};
var ValueInterpolation = class _ValueInterpolation {
  /**
   * @internal
   */
  constructor(options = DefaultInterpolationOptions) {
    __publicField(this, "options");
    /**
     * @internal
     */
    __publicField(this, "interpolate", (from, to) => {
      ;
      [from, to] = Interpolation.handleUndefined(from, to);
      return this.interPolationForValue(from).interpolate(from, to);
    });
    /**
     * @internal
     */
    __publicField(this, "difference", (from, to) => {
      const interpolation = this.interPolationForValue(from);
      return interpolation.difference(from, to);
    });
    this.options = { ...DefaultInterpolationOptions, ...options };
  }
  /**
   * @internal
   */
  interPolationForValue(value) {
    const type = typeof value;
    if (type === "number") {
      return NumberInterpolation;
    } else if (type === "boolean" || type === "function") {
      return NoInterpolation;
    } else if (Color.isColor(value)) {
      return ColorInterpolation(this.options.colorModel);
    } else if (type === "object") {
      if (value === null) {
        return NoInterpolation;
      }
      const constructor = value.constructor;
      if (constructor && isInterpolatable(constructor)) {
        const interpolation = constructor.interpolationFor(value, this);
        if (interpolation && interpolation !== this && interpolation.constructor !== _ValueInterpolation) {
          return interpolation;
        }
      }
      return ObjectInterpolation(this);
    }
    console.warn(`No interpolation defined for ${value}`);
    return NoInterpolation;
  }
};
var AnyInterpolation = /* @__PURE__ */ new ValueInterpolation();

// ../../library/src/render/utils/isMotionValue.ts
var isMotionValue2 = (v) => v instanceof MotionValue;

// ../../library/src/animation/Animators/PrecalculatedAnimator.ts
var Defaults2 = /* @__PURE__ */ (() => ({
  delta: 1 / 60,
  maxValues: 1e4
}))();
var PrecalculatedAnimator = class {
  constructor(options) {
    __publicField(this, "animator");
    __publicField(this, "values");
    __publicField(this, "currentTime", 0);
    __publicField(this, "totalTime");
    __publicField(this, "options");
    this.options = { ...Defaults2, ...options };
    this.animator = options.animator;
  }
  preCalculate() {
    if (!this.animator.isReady()) {
      return;
    }
    const { delta } = this.options;
    this.values = [];
    while (!this.animator.isFinished() && this.values.length < this.options.maxValues) {
      let value = this.animator.next(this.options.delta);
      if (typeof value === "object" && value) {
        const object = value;
        const copy = { ...object };
        value = copy;
      }
      this.values.push(value);
    }
    this.totalTime = this.values.length * delta;
  }
  indexForTime(time2) {
    assert(this.values !== void 0, "values must be set before calling indexForTime()");
    assert(this.totalTime !== void 0, "totalTime must be set before calling indexForTime()");
    return Math.max(
      0,
      Math.min(this.values.length - 1, Math.round(this.values.length * (time2 / this.totalTime)) - 1)
    );
  }
  valueForTime(time2) {
    assert(this.values !== void 0, "values must be set before calling valueForTime()");
    const index = this.indexForTime(time2);
    const value = this.values[index];
    return value;
  }
  setFrom(value) {
    this.animator.setFrom(value);
    this.preCalculate();
  }
  setTo(end) {
    this.animator.setTo(end);
    this.preCalculate();
  }
  isReady() {
    assert(this.totalTime !== void 0, "totalTime must be set before calling isReady()");
    return this.values !== void 0 && this.values.length > 0 && this.totalTime > 0;
  }
  next(delta) {
    this.currentTime += delta;
    return this.valueForTime(this.currentTime);
  }
  isFinished() {
    assert(this.totalTime !== void 0, "totalTime must be set before calling isFinished()");
    return this.totalTime === 0 || this.currentTime >= this.totalTime;
  }
  get endValue() {
    this.preCalculate();
    assert(this.totalTime !== void 0, "expecting totalTime to be set after calling preCalculate()");
    const value = this.valueForTime(this.totalTime);
    assert(this.values !== void 0, "expecting values to be set after calling preCalculate()");
    return this.values.length > 0 ? value : this.animator.next(0);
  }
};

// ../../library/src/core/EventEmitter.ts
var EventEmitter3 = /* @__PURE__ */ (() => require_eventemitter3().EventEmitter)();
var EventEmitter = class {
  constructor() {
    __publicField(this, "_emitter", new EventEmitter3());
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  eventListeners() {
    const listeners = {};
    for (const eventName of this._emitter.eventNames()) {
      listeners[eventName] = this._emitter.listeners(eventName);
    }
    return listeners;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn, false, false, this);
  }
  off(eventName, fn) {
    this.removeEventListeners(eventName, fn);
  }
  once(eventName, fn) {
    this.addEventListener(eventName, fn, true, false, this);
  }
  unique(eventName, fn) {
    this.addEventListener(eventName, fn, false, true, this);
  }
  addEventListener(eventName, fn, once2, unique, context) {
    if (unique) {
      for (const name of this._emitter.eventNames()) {
        if (fn === this._emitter.listeners(name)) {
          return;
        }
      }
    }
    if (once2 === true) {
      this._emitter.once(eventName, fn, context);
    } else {
      this._emitter.addListener(eventName, fn, context);
    }
  }
  removeEventListeners(eventName, fn) {
    if (eventName) {
      this._emitter.removeListener(eventName, fn);
    } else {
      this.removeAllEventListeners();
    }
  }
  removeAllEventListeners() {
    this._emitter.removeAllListeners();
  }
  countEventListeners(eventName) {
    if (eventName) {
      return this._emitter.listeners(eventName).length;
    } else {
      let count = 0;
      for (const name of this._emitter.eventNames()) {
        count += this._emitter.listeners(name).length;
      }
      return count;
    }
  }
  emit(eventName, ...args) {
    this._emitter.emit(eventName, ...args);
  }
};

// ../../library/src/core/Time.ts
var _raf = (f) => {
  setTimeout(f, 1 / 60);
};
var __raf = /* @__PURE__ */ (() => safeWindow["requestAnimationFrame"] || _raf)();
var raf = (f) => __raf(f);

// ../../library/src/core/Loop.ts
var LoopTimeStep = /* @__PURE__ */ (() => 1 / 60)();
var Loop = class extends EventEmitter {
  /**
   * @internal
   */
  constructor(start = false) {
    super();
    __publicField(this, "_started", false);
    __publicField(this, "_frame", 0);
    __publicField(this, "_frameTasks", []);
    /**
     * @internal
     */
    __publicField(this, "tick", () => {
      if (!this._started) return;
      raf(this.tick);
      this.emit("update", this._frame, LoopTimeStep);
      this.emit("render", this._frame, LoopTimeStep);
      this._processFrameTasks();
      this._frame++;
    });
    if (start) {
      this.start();
    }
  }
  /**
   * To add a task to be done at the end of a frame.
   * Tasks added from a task will be ignored. These will run after loop events have been processed.
   * @internal
   */
  addFrameTask(task) {
    this._frameTasks.push(task);
  }
  _processFrameTasks() {
    const postEventTasks = this._frameTasks;
    const length = postEventTasks.length;
    if (length === 0) return;
    for (let i = 0; i < length; i++) {
      postEventTasks[i]?.();
    }
    postEventTasks.length = 0;
  }
  /**
   * @internal
   */
  static set TimeStep(value) {
    LoopTimeStep = value;
  }
  /**
   * @internal
   */
  static get TimeStep() {
    return LoopTimeStep;
  }
  /**
   * @internal
   */
  start() {
    if (this._started) return this;
    this._frame = 0;
    this._started = true;
    raf(this.tick);
    return this;
  }
  /**
   * @internal
   * @deprecated Dont use `stop` as you could be stopping the MainLoop for others.
   */
  stop() {
    this._started = false;
    return this;
  }
  /**
   * @internal
   */
  get frame() {
    return this._frame;
  }
  /**
   * @internal
   */
  get time() {
    return this._frame * LoopTimeStep;
  }
};
var MainLoop = /* @__PURE__ */ new Loop();

// ../../library/src/render/types/RenderEnvironment.ts
var RenderEnvironment = {
  target: (
    // Enable static renderer when taking screenshots
    // in screenshot-site lambda
    safeWindow.location.origin === "https://screenshot.framer.invalid" ? "EXPORT" /* export */ : "PREVIEW" /* preview */
  ),
  zoom: 1
};
function executeInRenderEnvironment(customEnvironment, task) {
  const previousEnvironment = Object.assign({}, RenderEnvironment);
  Object.assign(RenderEnvironment, customEnvironment);
  const result = task();
  Object.assign(RenderEnvironment, previousEnvironment);
  return result;
}
function setGlobalRenderEnvironment(environment2) {
  Object.assign(RenderEnvironment, environment2);
}
function useRenderEnvironment(target, zoom) {
  let willChangeElements = false;
  if (RenderEnvironment.target !== target) {
    RenderEnvironment.target = target;
    willChangeElements = true;
  }
  if (RenderEnvironment.zoom !== zoom) {
    RenderEnvironment.zoom = zoom;
  }
  return { willChangeElements };
}
var RenderTarget = {
  /**
   * The component is to be rendered for the Framer canvas.
   *
   * @remarks
   * ```jsx
   * function App() {
   *   if (RenderTarget.current() === RenderTarget.canvas) {
   *     return <CanvasComponent />
   *   }
   *   return <DefaultComponent />
   * }
   * ```
   */
  canvas: "CANVAS" /* canvas */,
  /**
   * The component is to be rendered for export.
   *
   * @remarks
   * ```jsx
   * function App() {
   *   if (RenderTarget.current() === RenderTarget.export) {
   *     return <ExportComponent />
   *   }
   *   return <DefaultComponent />
   * }
   * ```
   */
  export: "EXPORT" /* export */,
  /**
   * The component is to be rendered as a preview thumbnail, for example in the
   * component panel.
   *
   * @remarks
   * ```jsx
   * function App() {
   *   if (RenderTarget.current() === RenderTarget.thumbnail) {
   *     return <Thumbnail />
   *   }
   *   return <DefaultComponent />
   * }
   * ```
   */
  thumbnail: "THUMBNAIL" /* thumbnail */,
  /**
   * The component is being rendered in the preview window.
   *
   * @remarks
   * ```jsx
   * function App() {
   *   React.useEffect(() => {
   *     if (RenderTarget.current() === RenderTarget.preview) {
   *       // Do something in preview.
   *     }
   *   })
   *   return <DefaultComponent />
   * }
   * ```
   */
  preview: "PREVIEW" /* preview */,
  /**
   * Returns the current `RenderTarget` allowing components to apply
   * different behaviors depending on the environment.
   *
   * @remarks
   * ```jsx
   * function App() {
   *   if (RenderTarget.current() === RenderTarget.thumbnail) {
   *     return <PreviewIcon />
   *   }
   *   return <Frame>...</Frame>
   * }
   * ```
   */
  current: () => RenderEnvironment.target,
  /**
   * Returns true if the current `RenderTarget` has performance restrictions.
   * Use this to avoid doing heavy work in these contexts because they may
   * bail on the rendering if the component takes too long.
   *
   * @remarks
   * ```jsx
   * function App() {
   *   if (RenderTarget.hasRestrictions()) {
   *     return <SomePlaceholder />
   *   }
   *   return <RichPreviewContent />
   * }
   * ```
   */
  hasRestrictions: () => {
    const target = RenderEnvironment.target;
    if (target === "CANVAS" /* canvas */) return true;
    if (target === "EXPORT" /* export */) return true;
    return false;
  }
};

// ../../library/src/animation/Drivers/AnimationDriver.ts
var AnimationDriver = class {
  constructor(animator, updateCallback, finishedCallback) {
    this.animator = animator;
    this.updateCallback = updateCallback;
    this.finishedCallback = finishedCallback;
    __publicField(this, "update", (frame2, elapsed) => {
      if (this.animator.isFinished()) {
        this.finish();
      } else {
        const value = this.animator.next(elapsed);
        this.updateCallback(value);
      }
    });
    if (!this.animator.isReady()) {
      console.warn("AnimationDriver initialized with animator that isn't ready");
    }
  }
  finish() {
    if (this.finishedCallback) {
      this.finishedCallback(this.animator.isFinished());
    }
  }
  isFinished() {
    return this.animator.isFinished();
  }
};

// ../../library/src/animation/Drivers/MainLoopDriver.ts
var MainLoopAnimationDriver = class extends AnimationDriver {
  play() {
    if (RenderEnvironment.target !== RenderTarget.preview) {
      this.finishedCallback && this.finishedCallback(false);
      return;
    }
    MainLoop.on("update", this.update);
  }
  cancel() {
    MainLoop.off("update", this.update);
  }
  finish() {
    MainLoop.off("update", this.update);
    super.finish();
  }
};

// ../../library/src/animation/FramerAnimation.ts
var DefaultDeprecatedAnimationOptions = {
  precalculate: false,
  colorModel: "husl" /* HUSL */
};
var FramerAnimation = class _FramerAnimation {
  /**
   * @internal
   */
  constructor(target, from, to, animatorClass, options, driverClass = MainLoopAnimationDriver) {
    /**
     * @internal
     */
    __publicField(this, "driver");
    /**
     * @internal
     */
    __publicField(this, "playStateSource", "idle");
    /**
     * @internal
     */
    __publicField(this, "onfinish");
    /**
     * @internal
     */
    __publicField(this, "oncancel");
    /**
     * @internal
     */
    __publicField(this, "readyPromise", Promise.resolve());
    /**
     * @internal
     */
    __publicField(this, "readyResolve", null);
    /**
     * @internal
     */
    __publicField(this, "finishedPromise", Promise.resolve());
    /**
     * @internal
     */
    __publicField(this, "finishedResolve", null);
    /**
     * @internal
     */
    // biome-ignore lint/suspicious/noExplicitAny: deprecated
    __publicField(this, "finishedReject", null);
    this.resetFinishedPromise();
    const deprecatedAnimationOptions = { ...DefaultDeprecatedAnimationOptions };
    const animatorOptions = {};
    if (options) {
      Object.assign(deprecatedAnimationOptions, options);
      Object.assign(animatorOptions, options);
    }
    let interpolation;
    if (deprecatedAnimationOptions.customInterpolation) {
      interpolation = deprecatedAnimationOptions.customInterpolation;
    } else {
      interpolation = new ValueInterpolation(options);
    }
    let animator;
    if (!animatorClass) {
      animator = new BezierAnimator({}, interpolation);
    } else {
      animator = new animatorClass(animatorOptions, interpolation);
    }
    if (deprecatedAnimationOptions.precalculate) {
      animator = new PrecalculatedAnimator({ animator });
    }
    animator.setFrom(from);
    animator.setTo(to);
    const updateCallback = (value) => {
      _FramerAnimation.driverCallbackHandler(target, value);
    };
    const finishedCallback = (isFinished) => {
      if (isFinished) {
        _FramerAnimation.driverCallbackHandler(target, to);
        if (this.playStateSource === "running") {
          this.playStateValue = "finished";
        }
      }
    };
    this.driver = new driverClass(animator, updateCallback, finishedCallback);
  }
  /**
   * @internal
   */
  static driverCallbackHandler(target, value) {
    if (isAnimatable(target) || isMotionValue2(target)) {
      target.set(value);
    } else {
      const targetObject = target;
      Animatable.transaction((update) => {
        for (const key7 in targetObject) {
          const targetValue = targetObject[key7];
          if (isAnimatable(targetValue)) {
            update(targetValue, value[key7]);
          } else {
            targetObject[key7] = value[key7];
          }
        }
      });
    }
  }
  /**
   * @internal
   */
  get playStateValue() {
    return this.playStateSource;
  }
  /**
   * @internal
   */
  set playStateValue(value) {
    if (value !== this.playStateSource) {
      const oldValue = value;
      this.playStateSource = value;
      switch (value) {
        case "idle":
          if (oldValue === "running") {
            this.oncancel && this.oncancel();
          }
          this.readyResolve && this.readyResolve();
          this.resetReadyPromise();
          break;
        case "finished":
          if (oldValue === "idle") {
            console.warn("Bad state transition");
            break;
          }
          this.onfinish && this.onfinish();
          this.finishedResolve && this.finishedResolve();
          break;
        case "running":
          this.resetReadyPromise();
          break;
      }
      if (oldValue === "finished") {
        this.resetFinishedPromise();
      }
      if (value === "finished") {
        this.playStateValue = "idle";
      }
    }
  }
  /**
   * @internal
   */
  get playState() {
    return this.playStateValue;
  }
  /**
   * @internal
   */
  resetReadyPromise() {
    this.readyResolve = null;
    this.readyPromise = new Promise((resolve, reject) => {
      this.readyResolve = resolve;
    });
  }
  /**
       * Wait for the animation to be ready to play.
       * @remarks
       * ```jsx
       * const animation = animate.ease(value, 100)
       * animation.ready().then(() => {
       *    // Animation is ready
       * })
  
       * // async/await syntax
       * const animation = animate.ease(value, 100)
       * await animation.ready()
       * // Animation is ready
       * ```
       * @returns Promise that is resolved when the animation is ready to play
       * @public
       */
  get ready() {
    return this.readyPromise;
  }
  /**
   * @internal
   */
  resetFinishedPromise() {
    this.finishedResolve = null;
    this.finishedReject = null;
    this.finishedPromise = new Promise((resolve, reject) => {
      this.finishedResolve = resolve;
      this.finishedReject = reject;
    });
    this.finishedPromise.catch((reason) => {
    });
  }
  /**
   * Wait for the animation to be finished.
   * @remarks
   * ```jsx
   * // async/await syntax
   * const animation = animate.ease(value, 100)
   * await animation.finished()
   * // Animation is finished
   *
   *
   * const animation = animate.ease(value, 100)
   * animation.ready().then(() => {
   *    // Animation is finished
   * })
   * ```
   * @returns Promise that is resolved when the animation is ready to play
   * @public
   */
  get finished() {
    return this.finishedPromise;
  }
  /**
   * @internal
   */
  play() {
    this.playStateValue = "running";
    this.driver.play();
  }
  /**
   * Cancels the animation if it is still running.
   * @remarks
   * ```jsx
   * const animation = animate.ease(value, 100, {duration: 3})
   * setTimeout(() => animation.cancel(), 500)
   * ```
   * @public
   */
  cancel() {
    if (this.playStateValue !== "running") {
      return;
    }
    this.driver.cancel();
    if (this.playState !== "idle") {
      const reason = "AbortError";
      this.finishedReject && this.finishedReject(reason);
    }
    this.playStateValue = "idle";
  }
  /**
   * @internal
   */
  finish() {
    if (this.playStateSource === "running") {
      this.playStateValue = "finished";
      this.driver.finish();
    }
  }
  /**
   * @internal
   */
  isFinished() {
    return this.playStateValue === "finished";
  }
};

// ../../library/src/animation/Motion/autoValueHandlers.ts
var correctBorderScale = (axis) => ({
  correct: (latest, { delta, treeScale }) => {
    if (typeof latest === "string") latest = parseFloat(latest);
    if (latest === 0) return "0px";
    let corrected = latest;
    if (delta && treeScale) {
      corrected = Math.round(latest / delta[axis].scale / treeScale[axis]);
      corrected = Math.max(corrected, 1);
    }
    return corrected + "px";
  }
});

// ../../library/src/animation/Motion/MotionSetup.tsx
import { Fragment, jsx as jsx8 } from "react/jsx-runtime";
addScaleCorrector({
  borderTopWidth: correctBorderScale("y"),
  borderLeftWidth: correctBorderScale("x"),
  borderRightWidth: correctBorderScale("x"),
  borderBottomWidth: correctBorderScale("y")
});
function MotionSetup({ children }) {
  return /* @__PURE__ */ jsx8(Fragment, { children });
}

// ../../library/src/animation/Motion/startAnimation.ts
function startAnimation(_key, value, target, transition = {}) {
  warnOnce2(
    `"startAnimation" is unsupported. Use "animate" instead: https://www.framer.com/api/motion/utilities/#animate`
  );
  return new Promise((resolve) => {
    animate(value, target, {
      ...transition,
      onComplete: () => resolve()
    });
  });
}

// ../../library/src/animation/animate.ts
function deprecatedAnimate(from, to, animator, options) {
  deprecationWarning("animate()", "2.0.0", "the new animation API (https://www.framer.com/api/animation/)");
  const target = from;
  let fromValue;
  if (isAnimatable(from) || isMotionValue2(from)) {
    fromValue = from.get();
  } else {
    fromValue = Animatable.objectToValues(from);
  }
  const animation = new FramerAnimation(target, fromValue, to, animator, options);
  animation.play();
  return animation;
}
var animate2 = /* @__PURE__ */ (() => {
  function animate3(from, to, animatorOrTransition, options) {
    return isAnimatable(from) ? deprecatedAnimate(from, to, animatorOrTransition, options) : animate(from, to, animatorOrTransition);
  }
  animate3.spring = (from, to, options) => {
    return animate3(from, to, SpringAnimator, options);
  };
  animate3.bezier = (from, to, options) => {
    return animate3(from, to, BezierAnimator, options);
  };
  animate3.linear = (from, to, options) => {
    return animate3.bezier(from, to, { ...options, curve: "linear" /* Linear */ });
  };
  animate3.ease = (from, to, options) => {
    return animate3.bezier(from, to, { ...options, curve: "ease" /* Ease */ });
  };
  animate3.easeIn = (from, to, options) => {
    return animate3.bezier(from, to, { ...options, curve: "ease-in" /* EaseIn */ });
  };
  animate3.easeOut = (from, to, options) => {
    return animate3.bezier(from, to, { ...options, curve: "ease-out" /* EaseOut */ });
  };
  animate3.easeInOut = (from, to, options) => {
    return animate3.bezier(from, to, { ...options, curve: "ease-in-out" /* EaseInOut */ });
  };
  return animate3;
})();

// ../../library/src/components/AnimateLayout/LayoutIdContext.tsx
import React13, { useCallback as useCallback6, useContext as useContext5, useMemo as useMemo5, useRef as useRef6 } from "react";
import { Fragment as Fragment2, jsx as jsx9 } from "react/jsx-runtime";
var LayoutIdContext = /* @__PURE__ */ React13.createContext({
  getLayoutId: (args) => null,
  persistLayoutIdCache: () => {
  },
  top: false,
  enabled: true
});
function LayoutIdProvider({ children }) {
  const context = useContext5(LayoutIdContext);
  if (context.top) return /* @__PURE__ */ jsx9(Fragment2, { children });
  const cache2 = useRef6({
    // When we provide a layoutId for a node based on it's first
    // duplicatedFrom id, we save it's layoutId mapped to it's actual id.
    // Future screen's nodes will check this cache first, to see if they've
    // previously been assigned a layoutId, or if any of there other
    // duplicatedFrom ids matched a node that was previously assigned a
    // layoutId.
    byId: {},
    byName: {},
    // When we navigate from screens that were duplicated from a future
    // screen, to that future screen, we want to do a reverse lookup on the
    // last duplicatedFrom id, rather than the id. We need to keep them
    // separate so they don't overlap.
    byLastId: {},
    byPossibleId: {},
    byLastName: {},
    byLayoutId: {},
    // When we don't have a cached layoutId for all duplicatedFrom ids, we
    // need to increment and save it so that we don't create clashing
    // layoutIds. We also need to reset name counts between screens, so we
    // record those separately.
    count: {
      byId: {},
      byName: {}
    }
  });
  const screen = useRef6({
    byId: {},
    byName: {},
    byLastId: {},
    byPossibleId: {},
    byLastName: {},
    byLayoutId: {}
  });
  const usedIds = useRef6(/* @__PURE__ */ new Set()).current;
  const getLayoutId = useCallback6(({ id, name, duplicatedFrom }) => {
    if (!id) return null;
    const cacheKey = name ? "byName" : "byId";
    const previousId = cache2.current[cacheKey][id];
    if (previousId) return previousId;
    const nodeIdentifier = name || id;
    if (!duplicatedFrom && !usedIds.has(nodeIdentifier) && (!cache2.current.byLayoutId[nodeIdentifier] || cache2.current.byLayoutId[nodeIdentifier] === nodeIdentifier)) {
      if (cache2.current.count[cacheKey][nodeIdentifier] === void 0) {
        cache2.current.count[cacheKey][nodeIdentifier] = 0;
        cache2.current.byLayoutId[nodeIdentifier] = nodeIdentifier;
        screen.current[cacheKey][id] = nodeIdentifier;
      }
      usedIds.add(nodeIdentifier);
      return nodeIdentifier;
    }
    let possibleMatch = void 0;
    if (duplicatedFrom?.length) {
      for (let index = duplicatedFrom.length - 1; index >= 0; index--) {
        const duplicatedId = duplicatedFrom[index];
        assert(!!duplicatedId, `duplicatedId must be defined`);
        const match = cache2.current[cacheKey][duplicatedId];
        const byLastIdMatch = cache2.current.byLastId[duplicatedId];
        if (byLastIdMatch && !possibleMatch) {
          const matchedLayoutId = cache2.current.byLayoutId[byLastIdMatch];
          const shouldUseNamedLastIdMatch = !matchedLayoutId || matchedLayoutId === name;
          if (byLastIdMatch && !usedIds.has(byLastIdMatch) && (name ? shouldUseNamedLastIdMatch : true)) {
            possibleMatch = [byLastIdMatch, duplicatedId];
          }
        }
        const previousLayoutId = match ? cache2.current.byLayoutId[match] : void 0;
        const shouldUseNamedMatch = !previousLayoutId || previousLayoutId === name;
        if (match && !usedIds.has(match) && (name ? shouldUseNamedMatch : true)) {
          screen.current[cacheKey][id] = match;
          screen.current.byLastId[duplicatedId] = match;
          usedIds.add(match);
          return match;
        }
      }
    }
    const last = cache2.current.byLastId[id];
    if (last && !usedIds.has(last)) {
      usedIds.add(last);
      screen.current.byId[id] = last;
      return last;
    }
    if (possibleMatch) {
      const [match, duplicatedId] = possibleMatch;
      screen.current[cacheKey][id] = match;
      screen.current.byLastId[duplicatedId] = match;
      usedIds.add(match);
      return match;
    }
    const possible = cache2.current.byPossibleId[id];
    if (possible && !usedIds.has(possible)) {
      usedIds.add(possible);
      screen.current.byId[id] = possible;
      return possible;
    }
    const rootDuplicatedId = duplicatedFrom?.[0];
    const identifier = name || rootDuplicatedId || id;
    const value = (cache2.current.count[cacheKey][identifier] ?? -1) + 1;
    const { layoutId, value: nextValue } = nextLayoutId(identifier, value, usedIds);
    cache2.current.count[cacheKey][identifier] = nextValue;
    screen.current[cacheKey][id] = layoutId;
    if (duplicatedFrom?.length) {
      if (!name) {
        const lastId = duplicatedFrom[duplicatedFrom.length - 1];
        if (lastId) {
          screen.current.byLastId[lastId] = layoutId;
        }
        if (duplicatedFrom.length > 1) {
          for (let index = 0; index < duplicatedFrom.length - 1; index++) {
            const possibleId = duplicatedFrom[index];
            if (possibleId === void 0) continue;
            if (!screen.current.byPossibleId[possibleId]) {
              screen.current.byPossibleId[possibleId] = layoutId;
            }
          }
        }
      }
    }
    screen.current.byLayoutId[layoutId] = nodeIdentifier;
    usedIds.add(layoutId);
    return layoutId;
  }, []);
  const persistLayoutIdCache = useCallback6(() => {
    cache2.current = {
      byId: {
        ...cache2.current.byId,
        ...screen.current.byId
      },
      byLastId: {
        ...cache2.current.byLastId,
        ...screen.current.byLastId
      },
      byPossibleId: {
        ...cache2.current.byPossibleId,
        ...screen.current.byPossibleId
      },
      byName: {
        ...cache2.current.byName,
        ...screen.current.byName
      },
      byLastName: { ...cache2.current.byLastName, ...screen.current.byLastName },
      byLayoutId: { ...cache2.current.byLayoutId, ...screen.current.byLayoutId },
      // Unlike the count.byId, we need to reset the count.byName because
      // named layers might not have duplicatedFrom ids (e.g. imported
      // from Figma). When we can use duplicatedFrom ids to check if an id
      // was assigned on a previous screen, we don't increment the count,
      // which means that the count only increments for new items, and
      // only increments on a new screen if the node is new. Since named
      // layers need to always match in some way between screens, we reset
      // the count so that the second named layer on a second screen is
      // always name-1 if it doesn't have any duplicatedFrom ids.
      count: {
        ...cache2.current.count,
        byName: {}
      }
    };
    screen.current = {
      byId: {},
      byName: {},
      byLastId: {},
      byPossibleId: {},
      byLastName: {},
      byLayoutId: {}
    };
    usedIds.clear();
  }, []);
  const contextValue = useRef6({
    getLayoutId,
    persistLayoutIdCache,
    top: true,
    enabled: true
  }).current;
  return /* @__PURE__ */ jsx9(LayoutIdContext.Provider, { value: contextValue, children });
}
function nextLayoutId(identifier, initialValue, usedIds) {
  let value = initialValue;
  let layoutId = value ? `${identifier}-${value}` : identifier;
  while (usedIds.has(layoutId)) {
    value++;
    layoutId = `${identifier}-${value}`;
  }
  return { layoutId, value };
}
function AutomaticLayoutIds({ enabled = true, ...props }) {
  const context = useContext5(LayoutIdContext);
  const contextValue = useMemo5(() => {
    return {
      ...context,
      enabled
    };
  }, [enabled]);
  return /* @__PURE__ */ jsx9(LayoutIdContext.Provider, { ...props, value: contextValue });
}

// ../../library/src/components/Device/Device.tsx
import React14, { Component as Component2 } from "react";

// ../../library/src/components/utils/useConstant.ts
import { useRef as useRef7 } from "react";
function useConstant(init) {
  const ref = useRef7(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// ../../library/src/components/Device/ErrorPlaceholder.tsx
import { jsx as jsx10, jsxs } from "react/jsx-runtime";
var baseStyle = {
  background: void 0,
  display: "flex",
  flexDirection: "column",
  justifyContent: "center",
  alignItems: "center",
  lineHeight: "1.4em",
  textOverflow: "ellipsis",
  overflow: "hidden",
  minHeight: 0,
  width: "100%",
  height: "100%"
};
var errorStyle = /* @__PURE__ */ (() => ({
  ...baseStyle,
  border: "1px solid rgba(149, 149, 149, 0.15)",
  borderRadius: 6,
  fontSize: "12px",
  backgroundColor: "rgba(149, 149, 149, 0.1)",
  color: "#a5a5a5"
}))();
var textStyle = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  flexShrink: 0,
  padding: `0 10px`
};
var titleStyle = /* @__PURE__ */ (() => ({
  ...textStyle,
  // TODO: Use Fresco tokens for this.
  fontWeight: 500
}))();
var messageStyle = /* @__PURE__ */ (() => ({
  ...textStyle,
  whiteSpace: "pre",
  maxHeight: "calc(50% - calc(20px * var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)))",
  WebkitMaskImage: "linear-gradient(to bottom, black 80%, transparent 100%)"
}))();
function ErrorPlaceholder(props) {
  const { error, file } = props;
  const title = file ? `Error in ${stripSlash(file)}` : "Error";
  const message = error instanceof Error ? error.message : "" + error;
  return /* @__PURE__ */ jsxs("div", { style: errorStyle, children: [
    /* @__PURE__ */ jsx10("div", { className: "text", style: titleStyle, children: title }),
    message && /* @__PURE__ */ jsx10("div", { className: "text", style: messageStyle, children: message })
  ] });
}
function stripSlash(title) {
  if (title.startsWith("./")) {
    return title.replace("./", "");
  }
  return title;
}

// ../../library/src/components/Device/Device.tsx
import { jsx as jsx11, jsxs as jsxs2 } from "react/jsx-runtime";
function getScaleData(deviceOptions, containerSize) {
  const { componentWidth, componentHeight } = getComponentSize(deviceOptions);
  const scaleX = containerSize.width / componentWidth;
  const scaleY = containerSize.height / componentHeight;
  const scale2 = Math.min(scaleX, scaleY, 1);
  let screenScalePixelFix = 1;
  if (scale2 < 1) {
    const actualScreenWidth = deviceOptions.screenWidth * scale2;
    const desiredScreenWidth = actualScreenWidth + 1;
    const screenScaleX = desiredScreenWidth / actualScreenWidth;
    const actualScreenHeight = deviceOptions.screenHeight * scale2;
    const desiredScreenHeight = actualScreenHeight + 1;
    const screenScaleY = desiredScreenHeight / actualScreenHeight;
    const screenScale = Math.max(screenScaleX, screenScaleY);
    screenScalePixelFix = screenScale;
  }
  return {
    scale: scale2,
    screenScalePixelFix,
    scaledComponentWidth: componentWidth * scale2,
    scaledComponentHeight: componentHeight * scale2,
    scaledDeviceWidth: deviceOptions.deviceWidth * scale2,
    scaledDeviceHeight: deviceOptions.deviceHeight * scale2
  };
}
function getColorsFromTheme(theme, type) {
  if (type === "none") return {};
  if (!theme) return {};
  const isDarkTheme = theme === "dark";
  return {
    shadowColor: isDarkTheme ? "rgba(0, 0, 0, 0.55)" : "rgba(0, 0, 0, 0.15)",
    bezelColor: isDarkTheme ? "#222" : "#fff",
    bezelShadeColor: isDarkTheme ? "#000" : "rgba(0, 0, 0, 0.2)",
    screenColor: isDarkTheme ? "#333" : "#eee"
  };
}
var ErrorBoundary = class extends Component2 {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {});
  }
  componentDidCatch(error, info) {
    let stack = info.componentStack?.split("\n").filter((line) => line.length !== 0);
    let currentIndex = 0;
    if (stack) {
      for (const line of stack) {
        if (line.startsWith(`    in ${this.constructor.name}`)) {
          break;
        }
        currentIndex++;
      }
      stack = stack.slice(0, currentIndex);
    }
    this.setState({
      lastError: {
        error,
        componentStack: stack
      }
    });
  }
  componentDidUpdate(_, prevState) {
    if (this.state.lastError === void 0) return;
    if (prevState.lastError === this.state.lastError) this.setState({ lastError: void 0 });
  }
  render() {
    if (this.state.lastError) {
      return /* @__PURE__ */ jsx11(ErrorPlaceholder, { error: this.state.lastError.error.message, file: "Prototype" });
    }
    return this.props.children;
  }
};
function Device({
  canResize = false,
  children,
  ResizeObserver: ResizeObserver2 = safeWindow.ResizeObserver,
  ...options
}) {
  const optionsRef = React14.useRef(void 0);
  if (optionsRef.current === void 0) optionsRef.current = options;
  const deviceAppearance = options.deviceOptions?.appearance.type;
  const scaleDataRef = React14.useRef();
  const containerRef = React14.useRef(null);
  const deviceRef = React14.useRef(null);
  const screenRef = React14.useRef(null);
  const updateImperativeScale = React14.useCallback(({ scale: scale2, screenScalePixelFix }) => {
    if (!scaleDataRef.current || !deviceRef.current || !screenRef.current) return;
    deviceRef.current.style.transform = `scale(${scale2})`;
    screenRef.current.style.transform = `scale(${screenScalePixelFix})`;
  }, []);
  if (scaleDataRef.current === void 0 && options.deviceOptions && options.scaleTo && options.scaleTo !== "dynamic") {
    const scale2 = scaleDataRef.current = getScaleData(options.deviceOptions, options.scaleTo);
    updateImperativeScale(scale2);
  }
  const invertScale = React14.useCallback((point) => {
    if (!scaleDataRef.current) return point;
    const { scale: scale2 = 1 } = scaleDataRef.current;
    return { x: point.x / scale2, y: point.y / scale2 };
  }, []);
  const updateScale = React14.useCallback(() => {
    const { deviceOptions, scaleTo } = optionsRef.current ?? {};
    if (!deviceOptions || !scaleTo || scaleTo !== "dynamic" || !containerRef.current) return;
    if (containerRef.current.offsetWidth === 0 || containerRef.current.offsetHeight === 0) return;
    const scaleData = scaleDataRef.current = getScaleData(deviceOptions, {
      width: containerRef.current.offsetWidth,
      height: containerRef.current.offsetHeight
    });
    updateImperativeScale(scaleData);
  }, [updateImperativeScale]);
  const observer = useConstant(() => {
    if (!ResizeObserver2) {
      return;
    }
    return new ResizeObserver2(() => updateScale());
  });
  React14.useLayoutEffect(() => {
    optionsRef.current = {
      deviceOptions: options.deviceOptions,
      overrideTheme: options.overrideTheme,
      scaleTo: options.scaleTo
    };
  }, [options.deviceOptions, options.overrideTheme, options.scaleTo]);
  React14.useLayoutEffect(() => {
    updateScale();
  }, [updateScale]);
  React14.useEffect(() => {
    if (!observer || !containerRef.current) return;
    observer.observe(containerRef.current);
    return () => observer.disconnect();
  }, []);
  const { containerStyle: containerStyle2, handStyle, deviceStyle, deviceImageStyle, screenStyle } = getDeviceStyle(options);
  const resizeStyles = canResize ? {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%"
  } : {};
  const screenBackground = options.deviceOptions?.transparentBackground ? "transparent" : "white";
  return /* @__PURE__ */ jsx11("div", { style: { ...containerStyle2, ...resizeStyles }, ref: containerRef, children: /* @__PURE__ */ jsxs2("div", { style: { ...deviceStyle }, ref: deviceRef, children: [
    handStyle && /* @__PURE__ */ jsx11("div", { style: handStyle }),
    deviceAppearance === "external-clay" && deviceImageStyle && /* @__PURE__ */ jsx11("div", { style: deviceImageStyle }),
    /* @__PURE__ */ jsx11(
      "div",
      {
        style: {
          ...screenStyle,
          pointerEvents: void 0,
          backgroundColor: children ? screenBackground : screenStyle.backgroundColor
        },
        ref: screenRef,
        children: /* @__PURE__ */ jsx11(MotionConfig, { transformPagePoint: invertScale, children: /* @__PURE__ */ jsx11(ErrorBoundary, { children }) })
      }
    ),
    deviceAppearance === "realistic" && deviceImageStyle && /* @__PURE__ */ jsx11("div", { style: deviceImageStyle })
  ] }) });
}
var DEVICE_PADDING = 45;
var HAND_IMG_WIDTH = 2400;
var HAND_IMG_HEIGHT = 3740;
var HAND_IMG_GAP_WIDTH = 859;
var HAND_IMG_GAP_LEFT = 772;
var HAND_IMG_GAP_BOTTOM = /* @__PURE__ */ (() => 992 - 5)();
var noDeviceSize = { componentWidth: 500, componentHeight: 500 };
function getComponentSize(options) {
  if (!options) return noDeviceSize;
  const { deviceWidth, deviceHeight, noPadding } = options;
  const padding = noPadding ? 0 : DEVICE_PADDING * 2;
  return {
    componentWidth: deviceWidth + padding,
    componentHeight: deviceHeight + padding
  };
}
function getDeviceStyle({ scaleTo, deviceOptions, overrideTheme } = {}) {
  const noDeviceStyle = { containerStyle: {}, deviceStyle: {}, screenStyle: {} };
  if (!deviceOptions) return noDeviceStyle;
  const { componentWidth, componentHeight } = getComponentSize(deviceOptions);
  const overriddenColors = getColorsFromTheme(overrideTheme, deviceOptions.appearance.type);
  const {
    deviceWidth,
    deviceHeight,
    appearance,
    screenWidth,
    screenHeight,
    screenMaxHeight,
    screenOffsetTop,
    screenOffsetLeft,
    screenRadius,
    screenMaskImage,
    screenColor,
    shadow,
    background,
    hand
  } = deviceOptions;
  const boxShadows = [];
  if (appearance.type === "clay" && shadow) {
    boxShadows.push(shadow);
  }
  let bezelStyle = void 0;
  if (appearance.type === "clay") {
    bezelStyle = {
      borderRadius: appearance.bezelRadius,
      backgroundColor: overriddenColors.bezelColor || appearance.bezelColor
    };
    if (overriddenColors.bezelShadeColor || appearance.bezelShadeColor) {
      boxShadows.push(`inset 0 0 15px ${overriddenColors.bezelShadeColor || appearance.bezelShadeColor}`);
    }
  }
  const handOffsetLeft = hand?.offsetLeft ?? 0;
  const handOffsetRight = hand?.offsetRight ?? 0;
  const handOffsetBottom = hand?.offsetBottom ?? 0;
  const handScale = (deviceWidth - handOffsetLeft - handOffsetRight) / HAND_IMG_GAP_WIDTH;
  return {
    containerStyle: {
      width: scaleTo ? "100%" : componentWidth,
      height: scaleTo ? "100%" : componentHeight,
      flex: "1 1 0",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      overflow: "hidden",
      background
    },
    handStyle: hand && {
      width: HAND_IMG_WIDTH * handScale,
      height: HAND_IMG_HEIGHT * handScale,
      position: "absolute",
      pointerEvents: "none",
      backgroundImage: `url("${hand.imageUrl}")`,
      backgroundSize: "contain",
      backgroundRepeat: "no-repeat",
      left: -HAND_IMG_GAP_LEFT * handScale + handOffsetLeft,
      bottom: -HAND_IMG_GAP_BOTTOM * handScale + handOffsetBottom
    },
    deviceStyle: {
      width: deviceWidth,
      height: deviceHeight,
      flexShrink: 0,
      position: "absolute",
      boxShadow: boxShadows.join(","),
      ...bezelStyle
    },
    deviceImageStyle: appearance.type === "realistic" || appearance.type === "external-clay" ? {
      width: appearance.imageWidth,
      height: appearance.imageHeight,
      position: "absolute",
      pointerEvents: "none",
      overflow: "hidden",
      backgroundImage: `url("${appearance.imageUrl}")`,
      backgroundPosition: "top left",
      backgroundRepeat: "no-repeat",
      backgroundSize: `${appearance.imageWidth}px ${appearance.imageHeight}px`,
      // Rotate 90 degrees counter-clockwise around (0,0), then move the
      // result down into the viewport (rightmost transform is applied first).
      transformOrigin: "top left",
      transform: appearance.rotateImage ? `translateY(${appearance.imageWidth}px) rotate(-90deg)` : void 0
    } : void 0,
    screenStyle: {
      width: screenWidth,
      height: screenHeight,
      maxHeight: screenMaxHeight,
      position: "absolute",
      top: screenOffsetTop,
      left: screenOffsetLeft,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      overflow: "hidden",
      borderRadius: screenRadius,
      backgroundColor: overriddenColors.screenColor || screenColor,
      ...screenMaskImage && {
        maskImage: screenMaskImage,
        WebkitMaskImage: screenMaskImage,
        maskSize: "contain",
        WebkitMaskSize: "contain"
      }
    }
  };
}

// ../../library/src/components/Device/DeviceCodeComponent.tsx
import React18 from "react";

// ../../library/src/render/types/NewConstraints.tsx
import React15 from "react";

// ../../library/src/render/utils/isFiniteNumber.ts
function isFiniteNumber(value) {
  return Number.isFinite(value);
}
function finiteNumber(value) {
  return isFiniteNumber(value) ? value : void 0;
}

// ../../library/src/utils/type-guards.ts
function isEmpty(obj) {
  return !obj || !Object.keys(obj).length && obj.constructor === Object;
}
function isReactElement(test) {
  return typeof test !== "string" && typeof test !== "number";
}
function isReactChild(test) {
  return test !== null && typeof test !== "undefined" && typeof test !== "boolean" && !isEmpty(test);
}

// ../../library/src/render/utils/degreesToRadians.ts
function degreesToRadians(degrees2) {
  return degrees2 * (Math.PI / 180);
}

// ../../library/src/render/types/Line.ts
var Line = /* @__PURE__ */ (() => {
  function Line2(a, b) {
    return { a, b };
  }
  Line2.offset = (line, offset) => {
    const angle = Point.angleFromX(line.a, line.b);
    const rad = degreesToRadians(angle);
    const x = offset * Math.sin(rad);
    const y = offset * Math.cos(rad);
    return Line2(
      { x: line.a.x + x, y: line.a.y - y },
      {
        x: line.b.x + x,
        y: line.b.y - y
      }
    );
  };
  Line2.intersection = (lineA, lineB, segments) => {
    const x1 = lineA.a.x;
    const y1 = lineA.a.y;
    const x2 = lineA.b.x;
    const y2 = lineA.b.y;
    const x3 = lineB.a.x;
    const y3 = lineB.a.y;
    const x4 = lineB.b.x;
    const y4 = lineB.b.y;
    const a1 = (x4 - x3) * (y3 - y1) - (y4 - y3) * (x3 - x1);
    const b1 = (x4 - x3) * (y2 - y1) - (y4 - y3) * (x2 - x1);
    const c1 = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
    if (a1 === 0 && b1 === 0) return null;
    if (b1 === 0) return null;
    const alpha2 = a1 / b1;
    const beta = c1 / b1;
    if (segments && (alpha2 < 0 || alpha2 > 1 || beta < 0 || beta > 1)) return null;
    return {
      x: x1 + alpha2 * (x2 - x1),
      y: y1 + alpha2 * (y2 - y1)
    };
  };
  Line2.intersectionAngle = (lineA, lineB) => {
    const deltaAX = lineA.b.x - lineA.a.x;
    const deltaAY = lineA.b.y - lineA.a.y;
    const deltaBX = lineB.b.x - lineB.a.x;
    const deltaBY = lineB.b.y - lineB.a.y;
    const angle = Math.atan2(deltaAX * deltaBY - deltaAY * deltaBX, deltaAX * deltaBX + deltaAY * deltaBY);
    return angle * (180 / Math.PI);
  };
  Line2.isOrthogonal = (line) => {
    return line.a.x === line.b.x || line.a.y === line.b.y;
  };
  Line2.perpendicular = (line, pointOnLine) => {
    const deltaX = line.a.x - line.b.x;
    const deltaY = line.a.y - line.b.y;
    const pointB = Point(pointOnLine.x - deltaY, pointOnLine.y + deltaX);
    return Line2(pointB, pointOnLine);
  };
  Line2.projectPoint = (line, point) => {
    const perp = Line2.perpendicular(line, point);
    return Line2.intersection(line, perp);
  };
  Line2.pointAtPercentDistance = (line, distance2) => {
    const hypotenuse = Line2.distance(line);
    const r = distance2 * hypotenuse / hypotenuse;
    return {
      x: r * line.b.x + (1 - r) * line.a.x,
      y: r * line.b.y + (1 - r) * line.a.y
    };
  };
  Line2.distance = (line) => {
    return Point.distance(line.a, line.b);
  };
  return Line2;
})();

// ../../library/src/render/types/Rect.ts
var Rect = {
  /**
   *
   * @param rect -
   * @param other -
   * @returns if the input rectangles are equal in size and position
   * @public
   */
  equals: function(rect, other) {
    if (rect === other) return true;
    if (!rect || !other) return false;
    return rect.x === other.x && rect.y === other.y && rect.width === other.width && rect.height === other.height;
  },
  /** @internal */
  from: (rect) => {
    return {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    };
  },
  /** @internal */
  atOrigin: (size) => {
    return {
      x: 0,
      y: 0,
      width: size.width,
      height: size.height
    };
  },
  /** @internal */
  fromTwoPoints: (a, b) => {
    return {
      x: Math.min(a.x, b.x),
      y: Math.min(a.y, b.y),
      width: Math.abs(a.x - b.x),
      height: Math.abs(a.y - b.y)
    };
  },
  /** @internal */
  fromRect: (rect) => {
    return {
      x: rect.left,
      y: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  },
  /** @internal */
  multiply: (rect, n) => {
    return {
      x: rect.x * n,
      y: rect.y * n,
      width: rect.width * n,
      height: rect.height * n
    };
  },
  /** @internal */
  divide: (rect, n) => {
    return Rect.multiply(rect, 1 / n);
  },
  /** @internal */
  offset: (rect, delta) => {
    const xOffset = typeof delta.x === "number" ? delta.x : 0;
    const yOffset = typeof delta.y === "number" ? delta.y : 0;
    return {
      ...rect,
      x: rect.x + xOffset,
      y: rect.y + yOffset
    };
  },
  /** @internal */
  inflate: (rect, value) => {
    if (value === 0) return rect;
    const doubleValue = 2 * value;
    return {
      x: rect.x - value,
      y: rect.y - value,
      width: rect.width + doubleValue,
      height: rect.height + doubleValue
    };
  },
  /** @internal */
  pixelAligned: (rect) => {
    const x = Math.round(rect.x);
    const y = Math.round(rect.y);
    const rectMaxX = Math.round(rect.x + rect.width);
    const rectMaxY = Math.round(rect.y + rect.height);
    const width = Math.max(rectMaxX - x, 0);
    const height = Math.max(rectMaxY - y, 0);
    return { x, y, width, height };
  },
  /** @internal */
  halfPixelAligned: (rect) => {
    const x = Math.round(rect.x * 2) / 2;
    const y = Math.round(rect.y * 2) / 2;
    const rectMaxX = Math.round((rect.x + rect.width) * 2) / 2;
    const rectMaxY = Math.round((rect.y + rect.height) * 2) / 2;
    const width = Math.max(rectMaxX - x, 1);
    const height = Math.max(rectMaxY - y, 1);
    return { x, y, width, height };
  },
  /** @internal */
  round: (rect, decimals = 0) => {
    const x = roundedNumber(rect.x, decimals);
    const y = roundedNumber(rect.y, decimals);
    const width = roundedNumber(rect.width, decimals);
    const height = roundedNumber(rect.height, decimals);
    return { x, y, width, height };
  },
  /** @internal */
  roundToOutside: (rect) => {
    const x = Math.floor(rect.x);
    const y = Math.floor(rect.y);
    const rectMaxX = Math.ceil(rect.x + rect.width);
    const rectMaxY = Math.ceil(rect.y + rect.height);
    const width = Math.max(rectMaxX - x, 0);
    const height = Math.max(rectMaxY - y, 0);
    return { x, y, width, height };
  },
  /**
   * @param rect -
   * @internal
   */
  minX: (rect) => {
    return rect.x;
  },
  /**
   * @param rect -
   * @internal
   */
  maxX: (rect) => {
    return rect.x + rect.width;
  },
  /**
   * @param rect -
   * @internal
   */
  minY: (rect) => {
    return rect.y;
  },
  /**
   * @param rect -
   * @internal
   */
  maxY: (rect) => {
    return rect.y + rect.height;
  },
  /** @internal */
  positions: (rect) => {
    return {
      minX: rect.x,
      midX: rect.x + rect.width / 2,
      maxX: Rect.maxX(rect),
      minY: rect.y,
      midY: rect.y + rect.height / 2,
      maxY: Rect.maxY(rect)
    };
  },
  /**
   *
   * @param rect -
   * @internal
   */
  center: (rect) => {
    return {
      x: rect.x + rect.width / 2,
      y: rect.y + rect.height / 2
    };
  },
  /** @internal */
  boundingRectFromPoints: (points) => {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      minX = Math.min(minX, point.x);
      maxX = Math.max(maxX, point.x);
      minY = Math.min(minY, point.y);
      maxY = Math.max(maxY, point.y);
    }
    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
  },
  /**
   * Returns the precise box defined by the given points, starting from the top-left point. This produces the same
   * Rect as Rect.boundingRectFromPoints *only* when the rect described by the points is not rotated.
   *
   * @internal
   */
  fromPoints: (ps) => {
    const [tl, tr, _, bl] = ps;
    const { x, y } = tl;
    const width = Point.distance(tl, tr);
    const height = Point.distance(tl, bl);
    return { x, y, width, height };
  },
  /**
   * Returns a rect containing all input rects
   * @param rect - a list of rectangles
   * @returns A rectangle that fits exactly around the input rects
   * @internal
   */
  merge: (...rect) => {
    const min = {
      x: Math.min(...rect.map(Rect.minX)),
      y: Math.min(...rect.map(Rect.minY))
    };
    const max = {
      x: Math.max(...rect.map(Rect.maxX)),
      y: Math.max(...rect.map(Rect.maxY))
    };
    return Rect.fromTwoPoints(min, max);
  },
  /** @internal */
  intersection: (rect1, rect2) => {
    const x = Math.max(rect1.x, rect2.x);
    const x2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width);
    const y = Math.max(rect1.y, rect2.y);
    const y2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);
    return { x, y, width: x2 - x, height: y2 - y };
  },
  /**
   * Returns all the corner points for a rect
   * @param rect -
   * @internal
   */
  points: (rect) => {
    return [
      { x: Rect.minX(rect), y: Rect.minY(rect) },
      { x: Rect.minX(rect), y: Rect.maxY(rect) },
      { x: Rect.maxX(rect), y: Rect.minY(rect) },
      { x: Rect.maxX(rect), y: Rect.maxY(rect) }
    ];
  },
  /**
   * Returns all the corner points for a rect at the origin.
   * @internal
   */
  pointsAtOrigin: (rect) => {
    return [
      { x: 0, y: 0 },
      { x: rect.width, y: 0 },
      { x: rect.width, y: rect.height },
      { x: 0, y: rect.height }
    ];
  },
  /** Takes a rect and transforms it by a matrix, resulting in the bounding rectangle of the
   * rotated and/or translated original.
   * @param rect - rectangle to transform
   * @param matrix - matrix to transform by
   * @returns The bounding rectangle of the rotated and/or translated rect.
   */
  transform: (rect, matrix) => {
    const { x: x1, y: y1 } = matrix.transformPoint({ x: rect.x, y: rect.y });
    const { x: x2, y: y2 } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y });
    const { x: x3, y: y3 } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y + rect.height });
    const { x: x4, y: y4 } = matrix.transformPoint({ x: rect.x, y: rect.y + rect.height });
    const x = Math.min(x1, x2, x3, x4);
    const width = Math.max(x1, x2, x3, x4) - x;
    const y = Math.min(y1, y2, y3, y4);
    const height = Math.max(y1, y2, y3, y4) - y;
    return { x, y, width, height };
  },
  /**
   * Checks if a rectangle contains a point
   * @param rect - The rectangle to check
   * @param point - The point to check
   * @returns true if the provided rectangle contains the provided point
   * @internal
   */
  containsPoint: (rect, point) => {
    if (point.x < Rect.minX(rect)) {
      return false;
    }
    if (point.x > Rect.maxX(rect)) {
      return false;
    }
    if (point.y < Rect.minY(rect)) {
      return false;
    }
    if (point.y > Rect.maxY(rect)) {
      return false;
    }
    if (Number.isNaN(rect.x)) {
      return false;
    }
    if (Number.isNaN(rect.y)) {
      return false;
    }
    return true;
  },
  /**
   * Returns wether a rect contains another rect entirely
   * @param rectA -
   * @param rectB -
   * @returns true if rectA contains rectB
   */
  containsRect: (rectA, rectB) => {
    for (const point of Rect.points(rectB)) {
      if (!Rect.containsPoint(rectA, point)) {
        return false;
      }
    }
    return true;
  },
  /** @internal */
  toCSS: (rect) => {
    return {
      display: "block",
      transform: `translate(${rect.x}px, ${rect.y}px)`,
      width: `${rect.width}px`,
      height: `${rect.height}px`
    };
  },
  /** @internal */
  inset: (rect, n) => {
    return {
      x: rect.x + n,
      y: rect.y + n,
      width: Math.max(0, rect.width - 2 * n),
      height: Math.max(0, rect.height - 2 * n)
    };
  },
  /** @internal */
  intersects: (rectA, rectB) => {
    return !(rectB.x >= Rect.maxX(rectA) || Rect.maxX(rectB) <= rectA.x || rectB.y >= Rect.maxY(rectA) || Rect.maxY(rectB) <= rectA.y);
  },
  /** @internal */
  overlapHorizontally: (rectA, rectB) => {
    const aMax = Rect.maxX(rectA);
    const bMax = Rect.maxX(rectB);
    return aMax > rectB.x && bMax > rectA.x;
  },
  /** @internal */
  overlapVertically: (rectA, rectB) => {
    const aMax = Rect.maxY(rectA);
    const bMax = Rect.maxY(rectB);
    return aMax > rectB.y && bMax > rectA.y;
  },
  /** @internal */
  doesNotIntersect: (rect, rects) => {
    return rects.find((comparingRect) => {
      return Rect.intersects(comparingRect, rect);
    }) === void 0;
  },
  /**
   *
   * @param rectA -
   * @param rectB -
   * @returns if the input rectangles are equal in size and position
   * @public
   * @deprecated: please use Rect.equals instead
   */
  isEqual: (rectA, rectB) => {
    return Rect.equals(rectA, rectB);
  },
  // @TODO: duplicate of points()
  /**
   * @returns [tl, tr, br, bl]
   * @internal
   */
  cornerPoints: (rect) => {
    const rectMinX = rect.x;
    const rectMaxX = rect.x + rect.width;
    const rectMinY = rect.y;
    const rectMaxY = rect.y + rect.height;
    const corner1 = { x: rectMinX, y: rectMinY };
    const corner2 = { x: rectMaxX, y: rectMinY };
    const corner3 = { x: rectMaxX, y: rectMaxY };
    const corner4 = { x: rectMinX, y: rectMaxY };
    return [corner1, corner2, corner3, corner4];
  },
  /** @internal */
  midPoints: (rect) => {
    const rectMinX = rect.x;
    const rectMidX = rect.x + rect.width / 2;
    const rectMaxX = rect.x + rect.width;
    const rectMinY = rect.y;
    const rectMidY = rect.y + rect.height / 2;
    const rectMaxY = rect.y + rect.height;
    const top = { x: rectMidX, y: rectMinY };
    const right = { x: rectMaxX, y: rectMidY };
    const bottom = { x: rectMidX, y: rectMaxY };
    const left = { x: rectMinX, y: rectMidY };
    return [top, right, bottom, left];
  },
  /** @internal */
  pointDistance: (rect, point) => {
    let x = 0;
    let y = 0;
    if (point.x < rect.x) {
      x = rect.x - point.x;
    } else if (point.x > Rect.maxX(rect)) {
      x = point.x - Rect.maxX(rect);
    }
    if (point.y < rect.y) {
      y = rect.y - point.y;
    } else if (point.y > Rect.maxY(rect)) {
      y = point.y - Rect.maxY(rect);
    }
    return Point.distance({ x, y }, { x: 0, y: 0 });
  },
  delta: (a, b) => {
    const pointA = { x: Rect.minX(a), y: Rect.minY(a) };
    const pointB = { x: Rect.minX(b), y: Rect.minY(b) };
    return {
      x: pointA.x - pointB.x,
      y: pointA.y - pointB.y
    };
  },
  /** @internal */
  withMinSize: (rect, minSize) => {
    const { width: minWidth, height: minHeight } = minSize;
    const diffX = rect.width - minWidth;
    const diffY = rect.height - minHeight;
    return {
      width: Math.max(rect.width, minWidth),
      height: Math.max(rect.height, minHeight),
      x: rect.width < minWidth ? rect.x + diffX / 2 : rect.x,
      y: rect.height < minHeight ? rect.y + diffY / 2 : rect.y
    };
  },
  /**
   * Return false if any point is not inside or on the provided rect.
   * @internal
   */
  anyPointsOutsideRect: (rect, ps) => {
    const rectMinX = Rect.minX(rect);
    const rectMinY = Rect.minY(rect);
    const rectMaxX = Rect.maxX(rect);
    const rectMaxY = Rect.maxY(rect);
    for (const point of ps) {
      if (point.x < rectMinX || point.x > rectMaxX) {
        return true;
      }
      if (point.y < rectMinY || point.y > rectMaxY) {
        return true;
      }
    }
    return false;
  },
  /** @internal */
  edges: (rect) => {
    const [tl, tr, br, bl] = Rect.cornerPoints(rect);
    return [Line(tl, tr), Line(tr, br), Line(br, bl), Line(bl, tl)];
  },
  /**
   * Return a new rect projected into a new position based on the anchor rect and the given direction/alignment.
   * @internal
   */
  rebaseRectOnto: (rect, anchorRect, direction, alignment) => {
    const rebasedRect = { ...rect };
    switch (direction) {
      case "bottom":
      case "top":
        switch (alignment) {
          case "start":
            rebasedRect.x = anchorRect.x;
            break;
          case "center":
            rebasedRect.x = anchorRect.x + anchorRect.width / 2 - rect.width / 2;
            break;
          case "end":
            rebasedRect.x = anchorRect.x + anchorRect.width - rect.width;
            break;
          default:
            assertNever(alignment);
        }
        break;
      case "left":
        rebasedRect.x = anchorRect.x - rect.width;
        break;
      case "right":
        rebasedRect.x = anchorRect.x + anchorRect.width;
        break;
      default:
        assertNever(direction);
    }
    switch (direction) {
      case "left":
      case "right":
        switch (alignment) {
          case "start":
            rebasedRect.y = anchorRect.y;
            break;
          case "center":
            rebasedRect.y = anchorRect.y + anchorRect.height / 2 - rect.height / 2;
            break;
          case "end":
            rebasedRect.y = anchorRect.y + anchorRect.height - rect.height;
            break;
          default:
            assertNever(alignment);
        }
        break;
      case "top":
        rebasedRect.y = anchorRect.y - rect.height;
        break;
      case "bottom":
        rebasedRect.y = anchorRect.y + anchorRect.height;
        break;
      default:
        assertNever(direction);
    }
    return rebasedRect;
  }
};

// ../../library/src/render/types/Constraints.ts
var constraintDefaults = {
  left: null,
  right: null,
  top: null,
  bottom: null,
  centerX: "50%",
  centerY: "50%",
  aspectRatio: null,
  parentSize: null,
  width: 100,
  height: 100
};
var DimensionType = /* @__PURE__ */ ((DimensionType2) => {
  DimensionType2[DimensionType2["FixedNumber"] = 0] = "FixedNumber";
  DimensionType2[DimensionType2["Percentage"] = 1] = "Percentage";
  DimensionType2[DimensionType2["Auto"] = 2] = "Auto";
  DimensionType2[DimensionType2["FractionOfFreeSpace"] = 3] = "FractionOfFreeSpace";
  DimensionType2[DimensionType2["Viewport"] = 4] = "Viewport";
  DimensionType2[DimensionType2["FitImage"] = 5] = "FitImage";
  return DimensionType2;
})(DimensionType || {});
function isAutoDimensionType(dimensionType) {
  if (isUndefined(dimensionType)) return false;
  return dimensionType === 2 /* Auto */ || dimensionType === 5 /* FitImage */;
}
function isConstraintSupportingChild(child) {
  if (!isReactChild(child) || !isReactElement(child)) {
    return false;
  }
  return true;
}
var ConstraintMask = {
  // Modifies the constraint mask to remove invalid (mutually exclusive) options and returns the original.
  // TODO: this removes major inconsistencies but probably needs to be merged with ConstraintSolver.
  quickfix: (constraints) => {
    if (isAutoDimensionType(constraints.widthType) || isAutoDimensionType(constraints.heightType)) {
      constraints.aspectRatio = null;
    }
    if (isFiniteNumber(constraints.aspectRatio)) {
      if (constraints.left && constraints.right) {
        constraints.widthType = 0 /* FixedNumber */;
      }
      if (constraints.top && constraints.bottom) {
        constraints.heightType = 0 /* FixedNumber */;
      }
      if (constraints.left && constraints.right && constraints.top && constraints.bottom) {
        constraints.bottom = false;
      }
      if (constraints.widthType !== 0 /* FixedNumber */ && constraints.heightType !== 0 /* FixedNumber */) {
        constraints.heightType = 0 /* FixedNumber */;
      }
    }
    if (constraints.left && constraints.right) {
      if (constraints.fixedSize || isAutoDimensionType(constraints.widthType) || isFiniteNumber(constraints.maxWidth)) {
        constraints.right = false;
      }
      constraints.widthType = 0 /* FixedNumber */;
    }
    if (constraints.top && constraints.bottom) {
      if (constraints.fixedSize || isAutoDimensionType(constraints.heightType) || isFiniteNumber(constraints.maxHeight)) {
        constraints.bottom = false;
      }
      constraints.heightType = 0 /* FixedNumber */;
    }
    return constraints;
  }
};
function valueToDimensionType(value) {
  if (typeof value === "string") {
    const trimmedValue = value.trim();
    if (trimmedValue === "auto") return 2 /* Auto */;
    if (trimmedValue.endsWith("fr")) return 3 /* FractionOfFreeSpace */;
    if (trimmedValue.endsWith("%")) return 1 /* Percentage */;
    if (trimmedValue.endsWith("vw") || trimmedValue.endsWith("vh")) return 4 /* Viewport */;
  }
  return 0 /* FixedNumber */;
}
var ConstraintValues = {
  // Returns concrete current values given some ConstraintProperties.
  fromProperties: (props) => {
    const { left, right, top, bottom, width, height, centerX, centerY, aspectRatio, autoSize } = props;
    const constraints = ConstraintMask.quickfix({
      left: isFiniteNumber(left) || isAnimatable(left),
      right: isFiniteNumber(right) || isAnimatable(right),
      top: isFiniteNumber(top) || isAnimatable(top),
      bottom: isFiniteNumber(bottom) || isAnimatable(bottom),
      widthType: valueToDimensionType(width),
      heightType: valueToDimensionType(height),
      aspectRatio: aspectRatio || null,
      fixedSize: autoSize === true
    });
    let widthValue = null;
    let heightValue = null;
    let widthType = 0 /* FixedNumber */;
    let heightType = 0 /* FixedNumber */;
    if (constraints.widthType !== 0 /* FixedNumber */ && typeof width === "string") {
      const parsedWidth = parseFloat(width);
      if (width.endsWith("fr")) {
        widthType = 3 /* FractionOfFreeSpace */;
        widthValue = parsedWidth;
      } else if (width === "auto") {
        widthType = 2 /* Auto */;
      } else {
        widthType = 1 /* Percentage */;
        widthValue = parsedWidth / 100;
      }
    } else if (width !== void 0 && typeof width !== "string") {
      widthValue = Animatable.getNumber(width);
    }
    if (constraints.heightType !== 0 /* FixedNumber */ && typeof height === "string") {
      const parsedHeight = parseFloat(height);
      if (height.endsWith("fr")) {
        heightType = 3 /* FractionOfFreeSpace */;
        heightValue = parsedHeight;
      } else if (height === "auto") {
        heightType = 2 /* Auto */;
      } else {
        heightType = 1 /* Percentage */;
        heightValue = parseFloat(height) / 100;
      }
    } else if (height !== void 0 && typeof height !== "string") {
      heightValue = Animatable.getNumber(height);
    }
    let centerAnchorX = 0.5;
    let centerAnchorY = 0.5;
    if (centerX) {
      centerAnchorX = parseFloat(centerX) / 100;
    }
    if (centerY) {
      centerAnchorY = parseFloat(centerY) / 100;
    }
    return {
      left: constraints.left ? Animatable.getNumber(left) : null,
      right: constraints.right ? Animatable.getNumber(right) : null,
      top: constraints.top ? Animatable.getNumber(top) : null,
      bottom: constraints.bottom ? Animatable.getNumber(bottom) : null,
      widthType,
      heightType,
      width: widthValue,
      height: heightValue,
      aspectRatio: constraints.aspectRatio || null,
      centerAnchorX,
      centerAnchorY
    };
  },
  toSize: (values, parentSizeInfo, autoSize, freeSpace) => {
    let width = null;
    let height = null;
    const parentWidth = parentSizeInfo?.sizing ? Animatable.getNumber(parentSizeInfo?.sizing.width) : null;
    const parentHeight = parentSizeInfo?.sizing ? Animatable.getNumber(parentSizeInfo?.sizing.height) : null;
    const hOpposingPinsOffset = pinnedOffset(values.left, values.right);
    if (parentWidth && isFiniteNumber(hOpposingPinsOffset)) {
      width = parentWidth - hOpposingPinsOffset;
    } else if (autoSize && isAutoDimensionType(values.widthType)) {
      width = autoSize.width;
    } else if (isFiniteNumber(values.width)) {
      switch (values.widthType) {
        case 0 /* FixedNumber */:
          width = values.width;
          break;
        case 3 /* FractionOfFreeSpace */:
          width = freeSpace ? freeSpace.freeSpaceInParent.width / freeSpace.freeSpaceUnitDivisor.width * values.width : null;
          break;
        case 1 /* Percentage */:
        case 4 /* Viewport */:
          if (parentWidth) {
            width = parentWidth * values.width;
          }
          break;
        case 2 /* Auto */:
        case 5 /* FitImage */:
          break;
        default:
          assertNever(values.widthType);
      }
    }
    const vOpposingPinsOffset = pinnedOffset(values.top, values.bottom);
    if (parentHeight && isFiniteNumber(vOpposingPinsOffset)) {
      height = parentHeight - vOpposingPinsOffset;
    } else if (autoSize && isAutoDimensionType(values.heightType)) {
      height = autoSize.height;
    } else if (isFiniteNumber(values.height)) {
      switch (values.heightType) {
        case 0 /* FixedNumber */:
          height = values.height;
          break;
        case 3 /* FractionOfFreeSpace */:
          height = freeSpace ? freeSpace.freeSpaceInParent.height / freeSpace.freeSpaceUnitDivisor.height * values.height : null;
          break;
        case 1 /* Percentage */:
        case 4 /* Viewport */:
          if (parentHeight) {
            height = parentHeight * values.height;
          }
          break;
        case 2 /* Auto */:
        case 5 /* FitImage */:
          break;
        default:
          assertNever(values.heightType);
      }
    }
    return sizeAfterApplyingConstraintsAndAspectRatio(
      width,
      height,
      values,
      {
        height: parentHeight ?? 0,
        width: parentWidth ?? 0
      },
      parentSizeInfo?.viewport
    );
  },
  // Returns a parent-relative rect given concrete ConstraintValues.
  toRect: (values, parentSizeInfo = null, autoSize = null, pixelAlign = false, freeSpace = null) => {
    let x = values.left || 0;
    let y = values.top || 0;
    const { width, height } = ConstraintValues.toSize(values, parentSizeInfo, autoSize, freeSpace);
    const parentSizeForPositioning = parentSizeInfo?.positioning ?? null;
    const positioningParentWidth = parentSizeForPositioning ? Animatable.getNumber(parentSizeForPositioning.width) : null;
    const positioningParentHeight = parentSizeForPositioning ? Animatable.getNumber(parentSizeForPositioning.height) : null;
    if (values.left !== null) {
      x = values.left;
    } else if (positioningParentWidth && values.right !== null) {
      x = positioningParentWidth - values.right - width;
    } else if (positioningParentWidth) {
      x = values.centerAnchorX * positioningParentWidth - width / 2;
    }
    if (values.top !== null) {
      y = values.top;
    } else if (positioningParentHeight && values.bottom !== null) {
      y = positioningParentHeight - values.bottom - height;
    } else if (positioningParentHeight) {
      y = values.centerAnchorY * positioningParentHeight - height / 2;
    }
    const f = { x, y, width, height };
    if (pixelAlign) {
      return Rect.pixelAligned(f);
    }
    return f;
  }
};
var defaultWidth = 200;
var defaultHeight = 200;
function getConstraintValue(constraint, value, parentSize, viewport) {
  if (typeof value === "string") {
    if (value.endsWith("%") && parentSize) {
      switch (constraint) {
        case "maxWidth":
        case "minWidth":
          return parseFloat(value) / 100 * parentSize.width;
        case "maxHeight":
        case "minHeight":
          return parseFloat(value) / 100 * parentSize.height;
        default:
          break;
      }
    }
    if (value.endsWith("vh")) {
      if (!viewport) return constraintValueForUncalculatedViewport(constraint);
      switch (constraint) {
        case "maxWidth":
        case "minWidth":
          return parseFloat(value) / 100 * viewport.width;
        case "maxHeight":
        case "minHeight":
          return parseFloat(value) / 100 * viewport.height;
        default:
          break;
      }
    }
    return parseFloat(value);
  }
  return value;
}
function constraintValueForUncalculatedViewport(constraint) {
  switch (constraint) {
    case "minWidth":
    case "minHeight":
      return Number.NEGATIVE_INFINITY;
    case "maxWidth":
    case "maxHeight":
      return Number.POSITIVE_INFINITY;
    default:
      assertNever(constraint, "unknown constraint key");
  }
}
function constrainHeight(height, values, parentSize, viewport) {
  if (values.minHeight) {
    height = Math.max(getConstraintValue("minHeight", values.minHeight, parentSize, viewport), height);
  }
  if (values.maxHeight) {
    height = Math.min(getConstraintValue("maxHeight", values.maxHeight, parentSize, viewport), height);
  }
  return height;
}
function constrainWidth(width, values, parentSize, viewport) {
  if (values.minWidth) {
    width = Math.max(getConstraintValue("minWidth", values.minWidth, parentSize, viewport), width);
  }
  if (values.maxWidth) {
    width = Math.min(getConstraintValue("maxWidth", values.maxWidth, parentSize, viewport), width);
  }
  return width;
}
function sizeAfterApplyingConstraintsAndAspectRatio(width, height, values, parentSize, viewport) {
  let w = constrainWidth(isFiniteNumber(width) ? width : defaultWidth, values, parentSize, viewport);
  let h = constrainHeight(isFiniteNumber(height) ? height : defaultHeight, values, parentSize, viewport);
  if (isFiniteNumber(values.aspectRatio) && values.aspectRatio > 0) {
    if (isFiniteNumber(values.left) && isFiniteNumber(values.right)) {
      h = w / values.aspectRatio;
    } else if (isFiniteNumber(values.top) && isFiniteNumber(values.bottom)) {
      w = h * values.aspectRatio;
    } else if (values.widthType !== 0 /* FixedNumber */) {
      h = w / values.aspectRatio;
    } else {
      w = h * values.aspectRatio;
    }
  }
  return {
    width: w,
    height: h
  };
}
function pinnedOffset(start, end) {
  if (!isFiniteNumber(start) || !isFiniteNumber(end)) return null;
  return start + end;
}

// ../../library/src/render/types/NewConstraints.tsx
import { Fragment as Fragment3, jsx as jsx12 } from "react/jsx-runtime";
function containsInvalidStringValues(props) {
  if (typeof props.right === "string") return true;
  if (typeof props.bottom === "string") return true;
  if (typeof props.left === "string" && (!props.center || props.center === "y")) {
    return true;
  }
  if (typeof props.top === "string" && (!props.center || props.center === "x")) {
    return true;
  }
  return false;
}
function constraintsEnabled(props) {
  if (!props._constraints) return false;
  if (containsInvalidStringValues(props)) return false;
  return props._constraints.enabled;
}
function sizeFromFiniteNumberProps(props) {
  const { size } = props;
  let { width, height } = props;
  if (isFiniteNumber(size)) {
    if (width === void 0) {
      width = size;
    }
    if (height === void 0) {
      height = size;
    }
  }
  if (isFiniteNumber(width) && isFiniteNumber(height)) {
    return {
      width,
      height
    };
  }
  return null;
}
function rectFromFiniteNumberProps(props) {
  const size = sizeFromFiniteNumberProps(props);
  if (size === null) {
    return null;
  }
  const { left, top } = props;
  if (isFiniteNumber(left) && isFiniteNumber(top)) {
    return {
      x: left,
      y: top,
      ...size
    };
  }
  return null;
}
function calculateRect(props, parentSize, pixelAlign = true) {
  if (props.positionFixed || props.positionAbsolute) return null;
  const parentSizeDisabled = parentSize === 1 /* Disabled */ || parentSize === 2 /* DisabledForCurrentLevel */;
  if (!constraintsEnabled(props) || parentSizeDisabled) {
    return rectFromFiniteNumberProps(props);
  }
  const constraintValues = getConstraintValues(props);
  const enabledParentSize = deprecatedParentSize(parentSize);
  const parentSizeInfo = enabledParentSize ? { sizing: enabledParentSize, positioning: enabledParentSize, viewport: null } : null;
  return ConstraintValues.toRect(constraintValues, parentSizeInfo, null, pixelAlign, null);
}
function getConstraintValues(props) {
  const { left, right, top, bottom, center, _constraints, size } = props;
  let { width, height } = props;
  if (width === void 0) {
    width = size;
  }
  if (height === void 0) {
    height = size;
  }
  const { aspectRatio, autoSize } = _constraints;
  const constraintMask = ConstraintMask.quickfix({
    left: isFiniteNumber(left),
    right: isFiniteNumber(right),
    top: isFiniteNumber(top),
    bottom: isFiniteNumber(bottom),
    widthType: valueToDimensionType(width),
    heightType: valueToDimensionType(height),
    aspectRatio: aspectRatio || null,
    fixedSize: autoSize === true
  });
  let widthValue = null;
  let heightValue = null;
  let widthType = 0 /* FixedNumber */;
  let heightType = 0 /* FixedNumber */;
  if (constraintMask.widthType !== 0 /* FixedNumber */ && typeof width === "string") {
    const parsedWidth = parseFloat(width);
    if (width.endsWith("fr")) {
      widthType = 3 /* FractionOfFreeSpace */;
      widthValue = parsedWidth;
    } else if (width === "auto") {
      widthType = 2 /* Auto */;
    } else {
      widthType = 1 /* Percentage */;
      widthValue = parsedWidth / 100;
    }
  } else if (width !== void 0 && typeof width !== "string") {
    widthValue = width;
  }
  if (constraintMask.heightType !== 0 /* FixedNumber */ && typeof height === "string") {
    const parsedHeight = parseFloat(height);
    if (height.endsWith("fr")) {
      heightType = 3 /* FractionOfFreeSpace */;
      heightValue = parsedHeight;
    } else if (height === "auto") {
      heightType = 2 /* Auto */;
    } else {
      heightType = 1 /* Percentage */;
      heightValue = parseFloat(height) / 100;
    }
  } else if (height !== void 0 && typeof height !== "string") {
    heightValue = height;
  }
  let centerAnchorX = 0.5;
  let centerAnchorY = 0.5;
  if (center === true || center === "x") {
    constraintMask.left = false;
    if (typeof left === "string") {
      centerAnchorX = parseFloat(left) / 100;
    }
  }
  if (center === true || center === "y") {
    constraintMask.top = false;
    if (typeof top === "string") {
      centerAnchorY = parseFloat(top) / 100;
    }
  }
  return {
    // Because we check isFiniteNumber when creating the masks,
    // We know that left, right, top and bottom are numbers if the mask is true for the corresponding value
    // We need to cast this because typescript does not understand that
    left: constraintMask.left ? left : null,
    right: constraintMask.right ? right : null,
    top: constraintMask.top ? top : null,
    bottom: constraintMask.bottom ? bottom : null,
    widthType,
    heightType,
    width: widthValue,
    height: heightValue,
    aspectRatio: constraintMask.aspectRatio || null,
    centerAnchorX,
    centerAnchorY,
    minHeight: props.minHeight,
    maxHeight: props.maxHeight,
    minWidth: props.minWidth,
    maxWidth: props.maxWidth
  };
}
var ParentSizeState = /* @__PURE__ */ ((ParentSizeState2) => {
  ParentSizeState2[ParentSizeState2["Unknown"] = 0] = "Unknown";
  ParentSizeState2[ParentSizeState2["Disabled"] = 1] = "Disabled";
  ParentSizeState2[ParentSizeState2["DisabledForCurrentLevel"] = 2] = "DisabledForCurrentLevel";
  return ParentSizeState2;
})(ParentSizeState || {});
var ConstraintsContext = /* @__PURE__ */ React15.createContext({
  parentSize: 0 /* Unknown */
});
function deprecatedParentSize(parentSize) {
  if (parentSize === 0 /* Unknown */ || parentSize === 1 /* Disabled */ || parentSize === 2 /* DisabledForCurrentLevel */) {
    return null;
  }
  return parentSize;
}
function useParentSize() {
  return React15.useContext(ConstraintsContext).parentSize;
}
function isSize(o) {
  return typeof o === "object";
}
var ProvideParentSize = (props) => {
  const currentParentSize = useParentSize();
  const { parentSize, children } = props;
  const value = React15.useMemo(
    () => ({ parentSize }),
    [getParentWidth(parentSize), getParentHeight(parentSize)]
  );
  if (currentParentSize === 1 /* Disabled */) {
    return children ? /* @__PURE__ */ jsx12(Fragment3, { children }) : null;
  }
  return /* @__PURE__ */ jsx12(ConstraintsContext.Provider, { value, children });
};
function getParentWidth(parentSize) {
  return isSize(parentSize) ? parentSize.width : parentSize;
}
function getParentHeight(parentSize) {
  return isSize(parentSize) ? parentSize.height : parentSize;
}
function useProvideParentSize(node, parentSize) {
  return /* @__PURE__ */ jsx12(ProvideParentSize, { parentSize, children: node });
}
function useConstraints(props) {
  const parentSize = useParentSize();
  const calculatedRect = calculateRect(props, parentSize, true);
  return calculatedRect;
}
function isAutoSized({
  width,
  height
}) {
  return width === "auto" || width === "min-content" || height === "auto" || height === "min-content";
}

// ../../library/src/render/types/PropertyControls.ts
var ControlType = /* @__PURE__ */ ((ControlType2) => {
  ControlType2["Boolean"] = "boolean";
  ControlType2["Number"] = "number";
  ControlType2["String"] = "string";
  ControlType2["RichText"] = "richtext";
  ControlType2["FusedNumber"] = "fusednumber";
  ControlType2["Enum"] = "enum";
  ControlType2["SegmentedEnum"] = "segmentedenum";
  ControlType2["Color"] = "color";
  ControlType2["Image"] = "image";
  ControlType2["ResponsiveImage"] = "responsiveimage";
  ControlType2["File"] = "file";
  ControlType2["ComponentInstance"] = "componentinstance";
  ControlType2["Slot"] = "slot";
  ControlType2["Array"] = "array";
  ControlType2["EventHandler"] = "eventhandler";
  ControlType2["Transition"] = "transition";
  ControlType2["BoxShadow"] = "boxshadow";
  ControlType2["Link"] = "link";
  ControlType2["Date"] = "date";
  ControlType2["Object"] = "object";
  ControlType2["Font"] = "font";
  ControlType2["PageScope"] = "pagescope";
  ControlType2["ScrollSectionRef"] = "scrollsectionref";
  ControlType2["CustomCursor"] = "customcursor";
  ControlType2["Border"] = "border";
  ControlType2["Cursor"] = "cursor";
  ControlType2["Padding"] = "padding";
  ControlType2["BorderRadius"] = "borderradius";
  ControlType2["Gap"] = "gap";
  ControlType2["CollectionReference"] = "collectionreference";
  ControlType2["MultiCollectionReference"] = "multicollectionreference";
  ControlType2["TrackingId"] = "trackingid";
  ControlType2["VectorSetItem"] = "vectorsetitem";
  ControlType2["LinkRelValues"] = "linkrelvalues";
  return ControlType2;
})(ControlType || {});

// ../../library/src/modules/isFlexboxGapSupported.ts
var isFlexboxGapSupportedCached;
function isFlexboxGapSupported() {
  if (isFlexboxGapSupportedCached !== void 0) {
    return isFlexboxGapSupportedCached;
  }
  const flex = document.createElement("div");
  Object.assign(flex.style, {
    position: "absolute",
    // avoid layout shift
    display: "flex",
    flexDirection: "column",
    rowGap: "1px"
  });
  flex.appendChild(document.createElement("div"));
  flex.appendChild(document.createElement("div"));
  document.body.appendChild(flex);
  const isSupported = flex.scrollHeight === 1;
  if (flex.parentNode) {
    flex.parentNode.removeChild(flex);
  }
  isFlexboxGapSupportedCached = isSupported;
  return isSupported;
}

// ../../library/src/modules/workaroundFlexboxGapNotSupported.ts
var flexboxGapNotSupportedClass = "flexbox-gap-not-supported";
var initialized = false;
function installFlexboxGapWorkaroundIfNeeded() {
  if (initialized) return;
  initialized = true;
  if (isFlexboxGapSupported()) return;
  document.body.classList.add(flexboxGapNotSupportedClass);
}

// ../../library/src/render/utils/injectDeprecatedRichTextRules.ts
var richTextStylesRule = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6,
[data-framer-component-type="DeprecatedRichText"] li,
[data-framer-component-type="DeprecatedRichText"] ol,
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] span:not([data-text-fill]) {
    font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
    font-style: var(--framer-font-style, normal);
    font-weight: var(--framer-font-weight, 400);
    color: var(--framer-text-color, #000);
    font-size: var(--framer-font-size, 16px);
    letter-spacing: var(--framer-letter-spacing, 0);
    text-transform: var(--framer-text-transform, none);
    text-decoration: var(--framer-text-decoration, none);
    line-height: var(--framer-line-height, 1.2em);
    text-align: var(--framer-text-alignment, start);
}
`;
var richTextParagraphSpacingStylesRule = `
[data-framer-component-type="DeprecatedRichText"] p:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] div:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h1:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h2:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h3:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h4:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h5:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h6:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ol:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ul:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] .framer-image:not(:first-child) {
    margin-top: var(--framer-paragraph-spacing, 0);
}
`;
var richTextBackgroundMaskStylesRule = `
[data-framer-component-type="DeprecatedRichText"] span[data-text-fill] {
    display: inline-block;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
`;
var richTextLinkStylesRule = `
[data-framer-component-type="DeprecatedRichText"] a,
[data-framer-component-type="DeprecatedRichText"] a span:not([data-text-fill]) {
    font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
    font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
    font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
    color: var(--framer-link-text-color, var(--framer-text-color, #000));
    font-size: var(--framer-link-font-size, var(--framer-font-size, 16px));
    text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
    text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
}
`;
var richTextLinkHoverStylesRule = `
[data-framer-component-type="DeprecatedRichText"] a:hover,
[data-framer-component-type="DeprecatedRichText"] a:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`;
var richTextLinkCurrentStylesRule = `
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current],
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current] span:not([data-text-fill]):not([data-nested-link]) {
    font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`;
var richTextLinkCurrentHoverStylesRule = `
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current]:hover,
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current]:hover span:not([data-text-fill]):not([data-nested-link]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
    color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
}
`;
var richTextBoldStylesRule = `
[data-framer-component-type="DeprecatedRichText"] strong {
    font-weight: bolder;
}
`;
var richTextItalicStylesRule = `
[data-framer-component-type="DeprecatedRichText"] em {
    font-style: italic;
}
`;
var richTextImageRule = `
[data-framer-component-type="DeprecatedRichText"] .framer-image {
    display: block;
    max-width: 100%;
    height: auto;
}
`;
var richTextBlockElementResetRule = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6 {
    margin: 0;
    padding: 0;
}
`;
var richTextStylesPresetResetRule = `
[data-framer-component-type="DeprecatedRichText"] .text-styles-preset-reset {
    --framer-font-family: Inter, Inter Placeholder, sans-serif;
    --framer-font-style: normal;
    --framer-font-weight: 500;
    --framer-text-color: #000;
    --framer-font-size: 16px;
    --framer-letter-spacing: 0;
    --framer-text-transform: none;
    --framer-text-decoration: none;
    --framer-line-height: 1.2em;
    --framer-text-alignment: start;
    --framer-font-open-type-features: normal;
    --font-variation-settings: normal;
}
`;
var richTextStylesList = `
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] ol {
    display: table;
    width: 100%;
    padding-left: 0;
    margin: 0;
}
`;
var richTextStylesListItem = `
[data-framer-component-type="DeprecatedRichText"] li {
    display: table-row;
    counter-increment: list-item;
    list-style: none;
}
`;
var richTextStylesNumberedListMarker = `
[data-framer-component-type="DeprecatedRichText"] ol > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: counter(list-item) ".";
    white-space: nowrap;
}
`;
var richTextStylesBulletedListMarker = `
[data-framer-component-type="DeprecatedRichText"] ul > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: "\u2022";
}
`;
var deprecatedRichTextCSSRules = [
  `[data-framer-component-type="DeprecatedRichText"] { cursor: inherit; }`,
  richTextStylesPresetResetRule,
  richTextBlockElementResetRule,
  richTextStylesRule,
  richTextParagraphSpacingStylesRule,
  richTextBackgroundMaskStylesRule,
  richTextLinkStylesRule,
  richTextLinkHoverStylesRule,
  richTextLinkCurrentStylesRule,
  richTextLinkCurrentHoverStylesRule,
  richTextBoldStylesRule,
  richTextItalicStylesRule,
  richTextImageRule,
  richTextStylesList,
  richTextStylesListItem,
  richTextStylesNumberedListMarker,
  richTextStylesBulletedListMarker
];

// ../../library/src/render/presentation/Forms/shared.ts
import React16 from "react";
var FormInputStyleVariableNames = /* @__PURE__ */ ((FormInputStyleVariableNames2) => {
  FormInputStyleVariableNames2["Padding"] = "--framer-input-padding";
  FormInputStyleVariableNames2["BorderRadiusTopLeft"] = "--framer-input-border-radius-top-left";
  FormInputStyleVariableNames2["BorderRadiusTopRight"] = "--framer-input-border-radius-top-right";
  FormInputStyleVariableNames2["BorderRadiusBottomRight"] = "--framer-input-border-radius-bottom-right";
  FormInputStyleVariableNames2["BorderRadiusBottomLeft"] = "--framer-input-border-radius-bottom-left";
  FormInputStyleVariableNames2["CornerShape"] = "--framer-input-corner-shape";
  FormInputStyleVariableNames2["BorderColor"] = "--framer-input-border-color";
  FormInputStyleVariableNames2["BorderTopWidth"] = "--framer-input-border-top-width";
  FormInputStyleVariableNames2["BorderRightWidth"] = "--framer-input-border-right-width";
  FormInputStyleVariableNames2["BorderBottomWidth"] = "--framer-input-border-bottom-width";
  FormInputStyleVariableNames2["BorderLeftWidth"] = "--framer-input-border-left-width";
  FormInputStyleVariableNames2["BorderStyle"] = "--framer-input-border-style";
  FormInputStyleVariableNames2["Background"] = "--framer-input-background";
  FormInputStyleVariableNames2["FontFamily"] = "--framer-input-font-family";
  FormInputStyleVariableNames2["FontWeight"] = "--framer-input-font-weight";
  FormInputStyleVariableNames2["FontSize"] = "--framer-input-font-size";
  FormInputStyleVariableNames2["FontColor"] = "--framer-input-font-color";
  FormInputStyleVariableNames2["FontStyle"] = "--framer-input-font-style";
  FormInputStyleVariableNames2["FontLetterSpacing"] = "--framer-input-font-letter-spacing";
  FormInputStyleVariableNames2["FontTextAlignment"] = "--framer-input-font-text-alignment";
  FormInputStyleVariableNames2["FontLineHeight"] = "--framer-input-font-line-height";
  FormInputStyleVariableNames2["FontOpenType"] = "--framer-input-font-open-type-features";
  FormInputStyleVariableNames2["PlaceholderColor"] = "--framer-input-placeholder-color";
  FormInputStyleVariableNames2["BoxShadow"] = "--framer-input-box-shadow";
  FormInputStyleVariableNames2["FocusedBorderColor"] = "--framer-input-focused-border-color";
  FormInputStyleVariableNames2["FocusedBorderWidth"] = "--framer-input-focused-border-width";
  FormInputStyleVariableNames2["FocusedBorderStyle"] = "--framer-input-focused-border-style";
  FormInputStyleVariableNames2["FocusedBackground"] = "--framer-input-focused-background";
  FormInputStyleVariableNames2["FocusedBoxShadow"] = "--framer-input-focused-box-shadow";
  FormInputStyleVariableNames2["FocusedTransition"] = "--framer-input-focused-transition";
  FormInputStyleVariableNames2["BooleanCheckedBackground"] = "--framer-input-boolean-checked-background";
  FormInputStyleVariableNames2["BooleanCheckedBorderColor"] = "--framer-input-boolean-checked-border-color";
  FormInputStyleVariableNames2["BooleanCheckedBorderWidth"] = "--framer-input-boolean-checked-border-width";
  FormInputStyleVariableNames2["BooleanCheckedBorderStyle"] = "--framer-input-boolean-checked-border-style";
  FormInputStyleVariableNames2["BooleanCheckedBoxShadow"] = "--framer-input-boolean-checked-box-shadow";
  FormInputStyleVariableNames2["BooleanCheckedTransition"] = "--framer-input-boolean-checked-transition";
  FormInputStyleVariableNames2["InvalidTextColor"] = "--framer-input-invalid-text-color";
  FormInputStyleVariableNames2["IconBackgroundImage"] = "--framer-input-icon-image";
  FormInputStyleVariableNames2["IconMaskImage"] = "--framer-input-icon-mask-image";
  FormInputStyleVariableNames2["IconColor"] = "--framer-input-icon-color";
  FormInputStyleVariableNames2["WrapperHeight"] = "--framer-input-wrapper-height";
  return FormInputStyleVariableNames2;
})(FormInputStyleVariableNames || {});
var Var = FormInputStyleVariableNames;
var inputClassName = "framer-form-input";
var inputWrapperClassName = "framer-form-input-wrapper";
var emptyValueClassName = "framer-form-input-empty";
var forcedFocusClassName = "framer-form-input-forced-focus";
var forcedCheckedClassName = "framer-form-input-forced-checked";
function cssValue(value) {
  if (typeof value === "number") return value;
  if (value.startsWith("--")) return css.variable(value);
  if (value === "") return '""';
  return value;
}
var css = /* @__PURE__ */ (() => {
  function css2(selector, declaration) {
    let output = " ";
    for (const key7 in declaration) {
      const value = declaration[key7];
      assert(value !== void 0, "Encountered `undefined` in CSSDeclaration");
      output += `${key7.replace(/([A-Z])/gu, "-$1").toLowerCase()}: ${cssValue(value)}; `;
    }
    return selector + " {" + output + "}";
  }
  css2.variable = (...variables) => {
    const lastItem = variables[variables.length - 1];
    assert(lastItem !== void 0, "Zero variables passed to `css.variable`");
    let value = lastItem.startsWith("--") ? `var(${lastItem})` : lastItem;
    for (let index = variables.length - 2; index >= 0; index--) {
      const element = variables[index];
      value = `var(${element}, ${value})`;
    }
    return value;
  };
  return css2;
})();
var sharedInputCSS = /* @__PURE__ */ (() => [
  css(`.${inputClassName}`, {
    padding: css.variable(Var.Padding),
    background: "transparent",
    fontFamily: css.variable(Var.FontFamily),
    fontWeight: css.variable(Var.FontWeight),
    fontSize: css.variable(Var.FontSize),
    fontStyle: css.variable(Var.FontStyle),
    color: css.variable(Var.FontColor),
    fontFeatureSettings: css.variable(Var.FontOpenType),
    border: "none",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden",
    width: "100%",
    height: css.variable(Var.WrapperHeight, "100%"),
    letterSpacing: css.variable(Var.FontLetterSpacing),
    textAlign: css.variable(Var.FontTextAlignment),
    lineHeight: css.variable(Var.FontLineHeight)
  }),
  css(`.${inputClassName}:focus-visible`, { outline: "none" })
])();
var inputWrapperCSS = /* @__PURE__ */ (() => [css(`.${inputWrapperClassName}`, { overflow: "hidden" })])();
var inputBorderAllSides = `var(${Var.BorderTopWidth}) var(${Var.BorderRightWidth}) var(${Var.BorderBottomWidth}) var(${Var.BorderLeftWidth})`;
var inputBorderCSS = /* @__PURE__ */ (() => [
  `.${inputWrapperClassName}:after {
        content: "";
        pointer-events: none;
        box-sizing: border-box;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-top-left-radius: var(${Var.BorderRadiusTopLeft});
        border-top-right-radius: var(${Var.BorderRadiusTopRight});
        border-bottom-right-radius: var(${Var.BorderRadiusBottomRight});
        border-bottom-left-radius: var(${Var.BorderRadiusBottomLeft});
        corner-shape: var(${Var.CornerShape});
        border-color: var(${Var.BorderColor});
        border-top-width: var(${Var.BorderTopWidth});
        border-right-width: var(${Var.BorderRightWidth});
        border-bottom-width: var(${Var.BorderBottomWidth});
        border-left-width: var(${Var.BorderLeftWidth});
        border-style: var(${Var.BorderStyle});
        transition: var(${Var.FocusedTransition});
        transition-property: border-color, border-width, border-style, border-top-left-radius, border-top-right-radius, border-bottom-right-radius, border-bottom-left-radius, corner-shape;
    }`
])();
var customValidityKey = "customError";
var validKey = "valid";
function isRelevantValidityStateKey(key7) {
  return key7 !== customValidityKey && key7 !== validKey;
}
function isInvalid(validity) {
  for (const key7 in validity) {
    if (!isRelevantValidityStateKey(key7)) continue;
    if (validity?.[key7] === true) return true;
  }
  return false;
}
function useCustomValidity(onValid, onInvalid, onChange, onBlur, onFocus) {
  const isValidRef = React16.useRef(null);
  const handleInvalid = React16.useCallback(
    (e) => {
      if (!onInvalid) return;
      if (isValidRef.current === false) return;
      isValidRef.current = false;
      e.currentTarget.setCustomValidity(" ");
      e.currentTarget.reportValidity();
      onInvalid(e);
    },
    [onInvalid]
  );
  const handleChange = React16.useCallback(
    (e) => {
      onChange?.(e);
      if (!onInvalid && !onValid) return;
      const validity = e.target.validity;
      if (isValidRef.current === false && !isInvalid(validity)) {
        e.currentTarget.setCustomValidity("");
        e.target.reportValidity();
        isValidRef.current = true;
        onValid?.();
      }
    },
    [onInvalid, onValid, onChange]
  );
  const handleBlur = React16.useCallback(
    (e) => {
      if (!onInvalid) {
        onBlur?.(e);
        return;
      }
      if (isValidRef.current === false) return;
      const validity = e.currentTarget.validity;
      if (isInvalid(validity)) {
        handleInvalid(e);
        return;
      }
      onBlur?.(e);
    },
    [handleInvalid, onBlur, onInvalid]
  );
  return React16.useMemo(() => {
    return {
      onInvalid: handleInvalid,
      onChange: handleChange,
      onBlur: handleBlur,
      onFocus
    };
  }, [handleInvalid, handleChange, handleBlur, onFocus]);
}
var iconSpacing = 10;
var iconSize = 16;
var inputIconCSSDeclaration = /* @__PURE__ */ (() => ({
  content: "",
  display: "block",
  position: "absolute",
  right: 0,
  top: 0,
  bottom: 0,
  width: `${iconSize}px`,
  boxSizing: "content-box",
  padding: css.variable(Var.Padding),
  border: "none",
  pointerEvents: "none",
  backgroundRepeat: "no-repeat",
  backgroundSize: `${iconSize}px`,
  maskRepeat: "no-repeat",
  maskSize: `${iconSize}px`,
  backgroundColor: css.variable(Var.IconColor)
}))();

// ../../library/src/render/utils/injectRichTextRules.ts
function createRGBVariableFallbacks(variables, fallback) {
  return css.variable(...variables.flatMap((variable) => [`${variable}-rgb`, variable]), fallback);
}
var defaultRichTextContainerStyle = {
  display: "flex",
  flexDirection: "column",
  justifyContent: "flex-start"
};
var defaultTextFillStyle = {
  display: "inline-block"
};
var defaultImageStyle = {
  display: "block"
};
var richTextCSSRules = /* @__PURE__ */ (() => [
  /**
   * RichTextContainer styles can get overridden by other static or inline styles collected in
   * style collectors, as well as styles defined directly in the @link{RichText.tsx} component.
   *
   * NOTE: `display: flex` can get overridden with `display: -webkit-box` in
   * @link{collectTextTruncation.ts} if the text is truncated. In this case, the flex-specific
   * properties are not supported, e.g. `justify-content`. This is ok because truncated text has
   * auto height and doesn't support vertical alignment. In any case, keep this in mind when
   * using other flex-specific properties.
   * */
  /* css */
  `
        [data-framer-component-type="RichTextContainer"] {
            display: ${defaultRichTextContainerStyle.display};
            flex-direction: ${defaultRichTextContainerStyle.flexDirection};
            justify-content: ${defaultRichTextContainerStyle.justifyContent};
            outline: none;
            flex-shrink: 0;
        }
    `,
  /* css */
  `
        p.framer-text,
        div.framer-text,
        figure.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        ol.framer-text,
        ul.framer-text {
            margin: 0;
            padding: 0;
        }
    `,
  /* css */
  `
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text,
        mark.framer-text,
        span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-blockquote-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-text-transform, none));
            text-decoration-line: var(--framer-blockquote-text-decoration, var(--framer-text-decoration, initial));
            text-decoration-style: var(--framer-blockquote-text-decoration-style, var(--framer-text-decoration-style, initial));
            text-decoration-color: var(--framer-blockquote-text-decoration-color, var(--framer-text-decoration-color, initial));
            text-decoration-thickness: var(--framer-blockquote-text-decoration-thickness, var(--framer-text-decoration-thickness, initial));
            text-decoration-skip-ink: var(--framer-blockquote-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial));
            text-underline-offset: var(--framer-blockquote-text-decoration-offset, var(--framer-text-decoration-offset, initial));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
            text-align: var(--framer-blockquote-text-alignment, var(--framer-text-alignment, start));
            -webkit-text-stroke-width: var(--framer-text-stroke-width, initial);
            -webkit-text-stroke-color: var(--framer-text-stroke-color, initial);
            -moz-font-feature-settings: var(--framer-font-open-type-features, initial);
            -webkit-font-feature-settings: var(--framer-font-open-type-features, initial);
            font-feature-settings: var(--framer-font-open-type-features, initial);
            font-variation-settings: var(--framer-font-variation-axes, normal);
            text-wrap: var(--framer-text-wrap-override, var(--framer-text-wrap));
        }
    `,
  /* css */
  `
        mark.framer-text,
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text {
            background-color: var(--framer-blockquote-text-background-color, var(--framer-text-background-color, initial));
            border-radius: var(--framer-blockquote-text-background-radius, var(--framer-text-background-radius, initial));
            corner-shape: var(--framer-blockquote-text-background-corner-shape, var(--framer-text-background-corner-shape, initial));
            padding: var(--framer-blockquote-text-background-padding, var(--framer-text-background-padding, initial));
        }
    `,
  /* css */
  `
        @supports not (color: color(display-p3 1 1 1)) {
            p.framer-text,
            div.framer-text,
            h1.framer-text,
            h2.framer-text,
            h3.framer-text,
            h4.framer-text,
            h5.framer-text,
            h6.framer-text,
            li.framer-text,
            ol.framer-text,
            ul.framer-text,
            span.framer-text:not([data-text-fill]) {
                color: ${createRGBVariableFallbacks(["--framer-blockquote-text-color", "--framer-text-color"], "#000")};
                -webkit-text-stroke-color: ${createRGBVariableFallbacks(["--framer-text-stroke-color"], "initial")};
            }

            mark.framer-text {
                background-color: ${createRGBVariableFallbacks(["--framer-blockquote-text-background-color", "--framer-text-background-color"], "initial")};
            }
        }
    `,
  /* css */
  `
        .framer-fit-text .framer-text {
            white-space: nowrap;
            white-space-collapse: preserve;
        }
    `,
  /* css */
  `
        strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold, var(--framer-font-family-bold));
            font-style: var(--framer-blockquote-font-style-bold, var(--framer-font-style-bold));
            font-weight: var(--framer-blockquote-font-weight-bold, var(--framer-font-weight-bold, bolder));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-bold, var(--framer-font-variation-axes-bold));
        }
    `,
  /* css */
  `
        em.framer-text {
            font-family: var(--framer-blockquote-font-family-italic, var(--framer-font-family-italic));
            font-style: var(--framer-blockquote-font-style-italic, var(--framer-font-style-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-italic, var(--framer-font-weight-italic));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-italic, var(--framer-font-variation-axes-italic));
        }
    `,
  /* css */
  `
        em.framer-text > strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold-italic, var(--framer-font-family-bold-italic));
            font-style: var(--framer-blockquote-font-style-bold-italic, var(--framer-font-style-bold-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-bold-italic, var(--framer-font-weight-bold-italic, bolder));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-bold-italic, var(--framer-font-variation-axes-bold-italic));
        }
    `,
  /* css */
  `
        p.framer-text:not(:first-child),
        div.framer-text:not(:first-child),
        h1.framer-text:not(:first-child),
        h2.framer-text:not(:first-child),
        h3.framer-text:not(:first-child),
        h4.framer-text:not(:first-child),
        h5.framer-text:not(:first-child),
        h6.framer-text:not(:first-child),
        ol.framer-text:not(:first-child),
        ul.framer-text:not(:first-child),
        blockquote.framer-text:not(:first-child),
        table.framer-text:not(:first-child),
        figure.framer-text:not(:first-child),
        .framer-image.framer-text:not(:first-child) {
            margin-top: var(--framer-blockquote-paragraph-spacing, var(--framer-paragraph-spacing, 0));
        }
    `,
  // The first child of a list item is a paragraph. If the second child is a
  // nested list we don't want it to have paragraph spacing.
  /* css */
  `
        li.framer-text > ul.framer-text:nth-child(2),
        li.framer-text > ol.framer-text:nth-child(2) {
            margin-top: 0;
        }
    `,
  // background-clip: text clips to the physical dimensions of text as appose
  // to the rendered dimensions. normal text will bleed out side these
  // constraints but since this is just a clipping mask over the area the text
  // takes up we have cases where the text will get clipped. That is why we
  // need to expand the area that the gradient applies to to allow users to
  // use low line-heights. This will result in gradients not aligning
  // perfectly to the edges of the text. but this is a acceptable trade off at
  // this point. For now we increase the area of the clipping mask on the
  // bottom (for descenders) and the right for italic or wide fonts.
  /* css */
  `
        .framer-text[data-text-fill] {
            display: ${defaultTextFillStyle.display};
            background-clip: text;
            -webkit-background-clip: text;
            /* make this a transparent color if you want to visualise the clipping  */
            -webkit-text-fill-color: transparent;
            padding: max(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / 2));
            margin: min(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / -2));
        }
    `,
  /* css */
  `
        code.framer-text,
        code.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
        }
    `,
  /* css */
  `
        @supports not (color: color(display-p3 1 1 1)) {
            code.framer-text,
            code.framer-text span.framer-text:not([data-text-fill]) {
                color: ${createRGBVariableFallbacks(["--framer-blockquote-text-color", "--framer-code-text-color", "--framer-text-color"], "#000")};
            }
        }
    `,
  /* css */
  `
        blockquote.framer-text {
            margin-block-start: initial;
            margin-block-end: initial;
            margin-inline-start: initial;
            margin-inline-end: initial;
            unicode-bidi: initial;
        }
    `,
  /* css */
  `
        a.framer-text,
        a.framer-text span.framer-text:not([data-text-fill]),
        span.framer-text[data-nested-link],
        span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
            /* Ensure the color is inherited from the link style rather than the parent text for nested spans */
            color: inherit;
            font-family: var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            /* Cursor inherit to overwrite the user agent stylesheet on rich text links. */
            cursor: var(--framer-custom-cursors, pointer);
            /* Don't inherit background styles from any parent text style. */
            background-color: initial;
            border-radius: var(--framer-link-text-background-radius, initial);
            corner-shape: var(--framer-link-text-background-corner-shape, initial);
            padding: var(--framer-link-text-background-padding, initial);
        }
    `,
  // Animateable link styles can't be applied to the nested spans of links because it breaks animations
  /* css */
  `
        a.framer-text,
        span.framer-text[data-nested-link] {
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            text-decoration-line: var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, initial)));
            text-decoration-style: var(--framer-blockquote-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, initial)));
            text-decoration-color: var(--framer-blockquote-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, initial)));
            text-decoration-thickness: var(--framer-blockquote-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, initial)));
            text-decoration-skip-ink: var(--framer-blockquote-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial)));
            text-underline-offset: var(--framer-blockquote-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset, initial)));
            /* Don't inherit background styles from any parent text style. */
            background-color: var(--framer-link-text-background-color, initial);
        }
    `,
  /* css */
  `
        @supports not (color: color(display-p3 1 1 1)) {
            a.framer-text,
            span.framer-text[data-nested-link] {
                color: ${createRGBVariableFallbacks(["--framer-blockquote-text-color", "--framer-link-text-color", "--framer-text-color"], "#000")};
                background-color: ${createRGBVariableFallbacks(["--framer-link-text-background-color"], "initial")};
                text-decoration-color: ${createRGBVariableFallbacks(["--framer-link-text-decoration-color", "--framer-text-decoration-color"], "currentcolor")};
            }
        }
    `,
  /* css */
  `
    code.framer-text a.framer-text,
    code.framer-text a.framer-text span.framer-text:not([data-text-fill]),
    code.framer-text span.framer-text[data-nested-link],
    code.framer-text span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
        font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
        font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
        font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
        color: inherit;
        font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
    }
`,
  /* css */
  `
    code.framer-text a.framer-text,
    code.framer-text span.framer-text[data-nested-link] {
        color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
    }
`,
  /* css */
  `
    @supports not (color: color(display-p3 1 1 1)) {
        code.framer-text a.framer-text,
        code.framer-text a.framer-text span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-nested-link],
        code.framer-text span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
            color: ${createRGBVariableFallbacks(["--framer-blockquote-text-color", "--framer-link-text-color", "--framer-code-text-color", "--framer-text-color"], "#000")};
        }
    }
`,
  /* css */
  `
        a.framer-text:hover,
        a.framer-text:hover span.framer-text:not([data-text-fill]),
        span.framer-text[data-nested-link]:hover,
        span.framer-text[data-nested-link]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            border-radius: var(--framer-link-hover-text-background-radius, var(--framer-link-text-background-radius, var(--framer-text-background-radius, initial)));
            corner-shape: var(--framer-link-hover-text-background-corner-shape, var(--framer-link-text-background-corner-shape, var(--framer-text-background-corner-shape, initial)));
            padding: var(--framer-link-hover-text-background-padding, var(--framer-link-text-background-padding, var(--framer-text-background-padding, initial)));
        }
    `,
  /* css */
  `
        a.framer-text:hover,
        span.framer-text[data-nested-link]:hover {
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            text-decoration-line: var(--framer-link-hover-text-decoration, var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, initial))));
            text-decoration-style: var(--framer-link-hover-text-decoration-style, var(--framer-blockquote-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, initial))));
            text-decoration-color: var(--framer-link-hover-text-decoration-color, var(--framer-blockquote-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, initial))));
            text-decoration-thickness: var(--framer-link-hover-text-decoration-thickness, var(--framer-blockquote-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, initial))));
            text-decoration-skip-ink: var(--framer-link-hover-text-decoration-skip-ink, var(--framer-blockquote-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial))));
            text-underline-offset: var(--framer-link-hover-text-decoration-offset, var(--framer-blockquote-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset, initial))));
            background-color: var(--framer-link-hover-text-background-color, var(--framer-link-text-background-color, var(--framer-text-background-color, initial)));
        }
    `,
  /* css */
  `
    @supports not (color: color(display-p3 1 1 1)) {
        a.framer-text:hover,
        span.framer-text[data-nested-link]:hover {
            color: ${createRGBVariableFallbacks(["--framer-link-hover-text-color", "--framer-blockquote-text-color", "--framer-link-text-color", "--framer-text-color"], "#000")};
            background-color: ${createRGBVariableFallbacks(["--framer-link-hover-text-background-color", "--framer-link-text-background-color", "--framer-text-background-color"], "initial")};
            text-decoration-color: ${createRGBVariableFallbacks(["--framer-link-hover-text-decoration-color", "--framer-link-text-decoration-color", "--framer-text-decoration-color"], "currentcolor")};
        }
    }
    `,
  /* css */
  `
        code.framer-text a.framer-text:hover,
        code.framer-text span.framer-text[data-nested-link]:hover {
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
        }
    `,
  /* css */
  `
    @supports not (color: color(display-p3 1 1 1)) {
        code.framer-text a.framer-text:hover,
        code.framer-text span.framer-text[data-nested-link]:hover {
            color: ${createRGBVariableFallbacks(["--framer-link-hover-text-color", "--framer-blockquote-text-color", "--framer-link-text-color", "--framer-code-text-color", "--framer-text-color"], "#000")};
        }
    }
   `,
  /* css */
  `
        a.framer-text[data-framer-page-link-current],
        a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
        span.framer-text[data-framer-page-link-current],
        span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            border-radius: var(--framer-link-current-text-background-radius, var(--framer-link-text-background-radius, initial));
            corner-shape: var(--framer-link-current-text-background-corner-shape, var(--framer-link-text-background-corner-shape, initial));
            padding: var(--framer-link-current-text-background-padding, var(--framer-link-text-background-padding, initial));
        }
    `,
  /* css */
  `
        a.framer-text[data-framer-page-link-current],
        span.framer-text[data-framer-page-link-current] {
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            text-decoration-line: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, initial)));
            text-decoration-style: var(--framer-link-current-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, initial)));
            text-decoration-color: var(--framer-link-current-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, initial)));
            text-decoration-thickness: var(--framer-link-current-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, initial)));
            text-decoration-skip-ink: var(--framer-link-current-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial)));
            text-underline-offset: var(--framer-link-current-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset, initial)));
            background-color: var(--framer-link-current-text-background-color, var(--framer-link-text-background-color, var(--framer-text-background-color, initial)));
        }
    `,
  /* css */
  `
        @supports not (color: color(display-p3 1 1 1)) {
            a.framer-text[data-framer-page-link-current],
            span.framer-text[data-framer-page-link-current]{
                color: ${createRGBVariableFallbacks(["--framer-link-current-text-color", "--framer-link-text-color", "--framer-text-color"], "#000")};
                background-color: ${createRGBVariableFallbacks(["--framer-link-current-text-background-color", "--framer-link-text-background-color", "--framer-text-background-color"], "initial")};
                text-decoration-color: ${createRGBVariableFallbacks(["--framer-link-current-text-decoration-color", "--framer-link-text-decoration-color", "--framer-text-decoration-color"], "currentcolor")};
            }
        }
    `,
  /* css */
  `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-framer-page-link-current],
        code.framer-text span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: inherit;
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `,
  /* css */
  `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text span.framer-text[data-framer-page-link-current] {
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
        }
    `,
  /* css */
  `
        @supports not (color: color(display-p3 1 1 1)) {
            code.framer-text a.framer-text[data-framer-page-link-current],
            code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
            code.framer-text span.framer-text[data-framer-page-link-current],
            code.framer-text span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
                color: ${createRGBVariableFallbacks(["--framer-link-current-text-color", "--framer-link-text-color", "--framer-code-text-color", "--framer-text-color"], "#000")};
                background-color: ${createRGBVariableFallbacks(["--framer-link-current-text-background-color", "--framer-link-text-background-color", "--framer-text-background-color"], "initial")};
            }
        }
    `,
  /* css */
  `
        a.framer-text[data-framer-page-link-current]:hover,
        a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]),
        span.framer-text[data-framer-page-link-current]:hover,
        span.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            color: inherit;
            font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            border-radius: var(--framer-link-hover-text-background-radius, var(--framer-link-current-text-background-radius, var(--framer-link-text-background-radius, initial)));
            corner-shape: var(--framer-link-hover-text-background-corner-shape, var(--framer-link-current-text-background-corner-shape, var(--framer-link-text-background-corner-shape, initial)));
            padding: var(--framer-link-hover-text-background-padding, var(--framer-link-current-text-background-padding, var(--framer-link-text-background-padding, initial)));
        }
    `,
  /* css */
  `
        a.framer-text[data-framer-page-link-current]:hover,
        span.framer-text[data-framer-page-link-current]:hover {
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            text-decoration-line: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, initial))));
            text-decoration-style: var(--framer-link-hover-text-decoration-style, var(--framer-link-current-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, initial))));
            text-decoration-color: var(--framer-link-hover-text-decoration-color, var(--framer-link-current-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, initial))));
            text-decoration-thickness: var(--framer-link-hover-text-decoration-thickness, var(--framer-link-current-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, initial))));
            text-decoration-skip-ink: var(--framer-link-hover-text-decoration-skip-ink, var(--framer-link-current-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial))));
            text-underline-offset: var(--framer-link-hover-text-decoration-offset, var(--framer-link-current-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset, initial))));
            background-color: var(--framer-link-hover-text-background-color, var(--framer-link-current-text-background-color, var(--framer-link-text-background-color, initial)));
        }
    `,
  /* css */
  `
        @supports not (color: color(display-p3 1 1 1)) {
            a.framer-text[data-framer-page-link-current]:hover,
            span.framer-text[data-framer-page-link-current]:hover {
                color: ${createRGBVariableFallbacks(["--framer-link-hover-text-color", "--framer-link-current-text-color", "--framer-link-text-color", "--framer-code-text-color", "--framer-text-color"], "#000")};
                background-color: ${createRGBVariableFallbacks(["--framer-link-hover-text-background-color", "--framer-link-current-text-background-color", "--framer-link-text-background-color"], "initial")};
                text-decoration-color: ${createRGBVariableFallbacks(["--framer-link-hover-text-decoration-color", "--framer-link-current-text-decoration-color", "--framer-link-text-decoration-color", "--framer-text-decoration-color"], "currentcolor")};
            }
        }
    `,
  /* css */
  `
        code.framer-text a.framer-text[data-framer-page-link-current]:hover,
        code.framer-text span.framer-text[data-framer-page-link-current]:hover {
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
        }
    `,
  /* css */
  `
        @supports not (color: color(display-p3 1 1 1)) {
            code.framer-text a.framer-text[data-framer-page-link-current]:hover,
            code.framer-text a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]),
            code.framer-text span.framer-text[data-framer-page-link-current]:hover,
            code.framer-text span.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
                color: ${createRGBVariableFallbacks(["--framer-link-hover-text-color", "--framer-link-current-text-color", "--framer-link-text-color", "--framer-code-text-color", "--framer-text-color"], "#000")};
                background-color: ${createRGBVariableFallbacks(["--framer-link-hover-text-background-color", "--framer-link-current-text-background-color", "--framer-link-text-background-color"], "initial")};
            }
        }
    `,
  /* css */
  `
        .framer-image.framer-text {
            display: ${defaultImageStyle.display};
            max-width: 100%;
            height: auto;
        }
    `,
  /* css */
  `
        .text-styles-preset-reset.framer-text {
            --framer-font-family: Inter, Inter Placeholder, sans-serif;
            --framer-font-style: normal;
            --framer-font-weight: 500;
            --framer-text-color: #000;
            --framer-font-size: 16px;
            --framer-letter-spacing: 0;
            --framer-text-transform: none;
            --framer-text-decoration: none;
            --framer-text-decoration-style: none;
            --framer-text-decoration-color: none;
            --framer-text-decoration-thickness: none;
            --framer-text-decoration-skip-ink: none;
            --framer-text-decoration-offset: none;
            --framer-line-height: 1.2em;
            --framer-text-alignment: start;
            --framer-font-open-type-features: normal;
            --framer-text-background-color: initial;
            --framer-text-background-radius: initial;
            --framer-text-background-corner-shape: initial;
            --framer-text-background-padding: initial;
        }
    `,
  /* css */
  `
        ol.framer-text {
            --list-style-type: decimal;
        }
    `,
  // Why all the `position: relative` and `position: absolute` and `::before` tricks?
  // We want uls disks and ols numbers to be left-aligned at the start of the line.
  // Theres no way to do that with ::marker styles alone, so we have to resort to this trick.
  /* css */
  `
        ul.framer-text,
        ol.framer-text {
            padding-inline-start: 0;
            position: relative;
        }
    `,
  /* css */
  `
        li.framer-text {
            counter-increment: list-item;
            list-style: none;
            padding-inline-start: 2ch;
        }
    `,
  // font-variant-numeric: tabular-nums enables monospaced numbers (which is neat in a vertical list of numbers)
  // and makes `li`s match the default browser styles better.
  /* css */
  `
        ol.framer-text > li.framer-text::before {
            position: absolute;
            inset-inline-start: 0;
            content: counter(list-item, var(--list-style-type)) ".";
            font-variant-numeric: tabular-nums;
        }
    `,
  // Why this? Due to `position: absolute` (see above), if a list has a lot of items, the numbers
  // might start overlapping the text content. This compensates for that. The trick is based on
  // https://alistapart.com/article/quantity-queries-for-css/#section6. The trick doesnt account
  // for lists longer than 1,000,000 items, but if you have a list of 1,000,000 items, youll have
  // other problems \_()_/
  /* css */
  `
        ol.framer-text > li.framer-text:nth-last-child(n + 10),
        ol.framer-text > li.framer-text:nth-last-child(n + 10) ~ li {
            padding-inline-start: 3ch;
        }
    `,
  /* css */
  `
        ol.framer-text > li.framer-text:nth-last-child(n + 100),
        ol.framer-text > li.framer-text:nth-last-child(n + 100) ~ li {
            padding-inline-start: 4ch;
        }
    `,
  /* css */
  `
        ol.framer-text > li.framer-text:nth-last-child(n + 1000),
        ol.framer-text > li.framer-text:nth-last-child(n + 1000) ~ li {
            padding-inline-start: 5ch;
        }
    `,
  /* css */
  `
        ol.framer-text > li.framer-text:nth-last-child(n + 10000),
        ol.framer-text > li.framer-text:nth-last-child(n + 10000) ~ li {
            padding-inline-start: 6ch;
        }
    `,
  /* css */
  `
        ol.framer-text > li.framer-text:nth-last-child(n + 100000),
        ol.framer-text > li.framer-text:nth-last-child(n + 100000) ~ li {
            padding-inline-start: 7ch;
        }
    `,
  /* css */
  `
        ol.framer-text > li.framer-text:nth-last-child(n + 1000000),
        ol.framer-text > li.framer-text:nth-last-child(n + 1000000) ~ li {
            padding-inline-start: 8ch;
        }
    `,
  /* css */
  `
        ul.framer-text > li.framer-text::before {
            position: absolute;
            inset-inline-start: 0;
            content: "\u2022";
        }
    `,
  /* css */
  `
        .framer-table-wrapper {
            overflow-x: auto;
        }
    `,
  /* css */
  `
        table.framer-text,
        .framer-table-wrapper table.framer-text {
            border-collapse: separate;
            border-spacing: 0;
            table-layout: auto;
            word-break: normal;
            width: 100%;
        }
    `,
  /* css */
  `
        td.framer-text,
        th.framer-text {
            min-width: 16ch;
            vertical-align: top;
        }
    `,
  /* css */
  `
        .framer-text-module[data-width="fill"] > :first-child,
        .framer-text-module:not([data-width="fit"])[style*="aspect-ratio"] > :first-child {
            width: 100%;
        }
    `,
  /* css */
  `
        @supports not (aspect-ratio: 1) {
            .framer-text-module:not([data-width="fit"])[style*="aspect-ratio"] {
                position: relative;
            }
        }
    `,
  /* css */
  `
        @supports not (aspect-ratio: 1) {
            .framer-text-module:not([data-width="fit"])[style*="aspect-ratio"]::before {
                content: "";
                display: block;
                padding-bottom: calc(100% / calc(var(--aspect-ratio)));
            }
        }
    `,
  /* css */
  `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[data-width="fill"] > :first-child,
            .framer-text-module:not([data-width="fit"])[style*="aspect-ratio"] > :first-child {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
            }
        }
    `
])();
var textTruncationDisplayInlineVariableForSafari16 = "--text-truncation-display-inline-for-safari-16";
var textTruncationDisplayNoneVariableForSafari16 = "--text-truncation-display-none-for-safari-16";
var textTruncationLineBreakVariableForSafari16 = "--text-truncation-line-break-for-safari-16";
var blockLikeElementSelectors = [
  "div.framer-text",
  "p.framer-text",
  "h1.framer-text",
  "h2.framer-text",
  "h3.framer-text",
  "h4.framer-text",
  "h5.framer-text",
  "h6.framer-text",
  "ol.framer-text",
  "ul.framer-text",
  "li.framer-text",
  "blockquote.framer-text",
  ".framer-text.framer-image"
];
var anySafariVersion = "(background: -webkit-named-image(i))";
var safari17OrGreater = "(contain-intrinsic-size: inherit)";
var safari16TextTruncationFix = /* @__PURE__ */ (() => [
  `@supports ${anySafariVersion} and (not ${safari17OrGreater}) {
        /* Render block-like elements inline when text is truncated, otherwise default to user agent (revert)  */
        ${blockLikeElementSelectors.join(", ")} { display: var(${textTruncationDisplayInlineVariableForSafari16}, revert) }

        /* Add a line break after each block-like element that we render inline, to resemble the block-like behavior */
        ${blockLikeElementSelectors.map((selector) => `${selector}::after`).join(", ")} { content: var(${textTruncationLineBreakVariableForSafari16}); white-space: pre; }

        /* Don't render modules (e.g. videos, code-blocks), or tables when text is truncated, because often these can't be truncated and their children might be block elements */
        .framer-text.framer-text-module,
        .framer-text.framer-table-wrapper { display: var(${textTruncationDisplayNoneVariableForSafari16}, revert) }

        /* Render text-fill elements inline when text is truncated, otherwise default to their default value (e.g. inline-block) */
        p.framer-text[data-text-fill] { display: var(${textTruncationDisplayInlineVariableForSafari16}, ${defaultTextFillStyle.display}) }
    }`
])();

// ../../library/src/render/utils/setDocumentStyles.ts
var defaultCache = /* @__PURE__ */ new Set();
var defaultSheet;
function injectCSSRule(cssRule, sheet, cache2 = defaultCache) {
  if (!cssRule || cache2.has(cssRule) || typeof document === "undefined") return;
  cache2.add(cssRule);
  if (!sheet) {
    if (!defaultSheet) {
      const styleElement = document.createElement("style");
      styleElement.setAttribute("type", "text/css");
      styleElement.setAttribute("data-framer-css", "true");
      if (!document.head) {
        console.warn("not injecting CSS: the document is missing a <head> element");
        return;
      }
      document.head.appendChild(styleElement);
      if (styleElement.sheet) {
        defaultSheet = styleElement.sheet;
      } else {
        console.warn("not injecting CSS: injected <style> element does not have a sheet", styleElement);
        return;
      }
    }
    sheet = defaultSheet;
  }
  try {
    sheet.insertRule(cssRule, sheet.cssRules.length);
  } catch {
  }
}

// ../../library/src/render/utils/injectComponentCSSRules.ts
var componentCSSRules = [`[data-framer-component-type] { position: absolute; }`];
var textAlignmentRule = `
[data-framer-component-type="Text"] > * {
    text-align: var(--framer-text-alignment, start);
}`;
var textBlockSpanRule = `
[data-framer-component-type="Text"] span span,
[data-framer-component-type="Text"] p span,
[data-framer-component-type="Text"] h1 span,
[data-framer-component-type="Text"] h2 span,
[data-framer-component-type="Text"] h3 span,
[data-framer-component-type="Text"] h4 span,
[data-framer-component-type="Text"] h5 span,
[data-framer-component-type="Text"] h6 span {
    display: block;
}`;
var textInlineSpanRule = `
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span {
    display: unset;
}`;
var renderTextStylesRule = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    font-family: var(--font-family);
    font-style: var(--font-style);
    font-weight: min(calc(var(--framer-font-weight-increase, 0) + var(--font-weight, 400)), 900);
    color: var(--text-color);
    letter-spacing: var(--letter-spacing);
    font-size: var(--font-size);
    text-transform: var(--text-transform);
    --text-decoration: var(--framer-text-decoration-style, solid) var(--framer-text-decoration, none) var(--framer-text-decoration-color, currentcolor) var(--framer-text-decoration-thickness, auto);
    --text-decoration-skip-ink: var(--framer-text-decoration-skip-ink);
    --text-underline-offset: var(--framer-text-decoration-offset);
    line-height: var(--line-height);
}`;
var textStylesRule = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    --font-family: var(--framer-font-family);
    --font-style: var(--framer-font-style);
    --font-weight: var(--framer-font-weight);
    --text-color: var(--framer-text-color);
    --letter-spacing: var(--framer-letter-spacing);
    --font-size: var(--framer-font-size);
    --text-transform: var(--framer-text-transform);
    --text-decoration: var(--framer-text-decoration-style, solid) var(--framer-text-decoration, none) var(--framer-text-decoration-color, currentcolor) var(--framer-text-decoration-thickness, auto);
    --text-decoration-skip-ink: var(--framer-text-decoration-skip-ink);
    --text-underline-offset: var(--framer-text-decoration-offset);
    --line-height: var(--framer-line-height);
}`;
var linkStylesRule = `
[data-framer-component-type="Text"] a,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] a span span span,
[data-framer-component-type="Text"] a p span span,
[data-framer-component-type="Text"] a h1 span span,
[data-framer-component-type="Text"] a h2 span span,
[data-framer-component-type="Text"] a h3 span span,
[data-framer-component-type="Text"] a h4 span span,
[data-framer-component-type="Text"] a h5 span span,
[data-framer-component-type="Text"] a h6 span span {
    --font-family: var(--framer-link-font-family, var(--framer-font-family));
    --font-style: var(--framer-link-font-style, var(--framer-font-style));
    --font-weight: var(--framer-link-font-weight, var(--framer-font-weight));
    --text-color: var(--framer-link-text-color, var(--framer-text-color));
    --font-size: var(--framer-link-font-size, var(--framer-font-size));
    --text-transform: var(--framer-link-text-transform, var(--framer-text-transform));
    --text-decoration: var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, solid)) var(--framer-link-text-decoration, var(--framer-text-decoration, none)) var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, currentcolor)) var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, auto));
    --text-decoration-skip-ink: var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink));
    --text-underline-offset: var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset));
}`;
var linkHoverStylesRule = `
[data-framer-component-type="Text"] a:hover,
[data-framer-component-type="Text"] a div span:hover,
[data-framer-component-type="Text"] a span span span:hover,
[data-framer-component-type="Text"] a p span span:hover,
[data-framer-component-type="Text"] a h1 span span:hover,
[data-framer-component-type="Text"] a h2 span span:hover,
[data-framer-component-type="Text"] a h3 span span:hover,
[data-framer-component-type="Text"] a h4 span span:hover,
[data-framer-component-type="Text"] a h5 span span:hover,
[data-framer-component-type="Text"] a h6 span span:hover {
    --font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-hover-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, solid))) var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))) var(--framer-link-hover-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, currentcolor))) var(--framer-link-hover-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, auto)));
    --text-decoration-skip-ink: var(--framer-link-hover-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink)));
    --text-underline-offset: var(--framer-link-hover-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset)));
}`;
var linkCurrentStylesRule = `
[data-framer-component-type="Text"].isCurrent a,
[data-framer-component-type="Text"].isCurrent a div span,
[data-framer-component-type="Text"].isCurrent a span span span,
[data-framer-component-type="Text"].isCurrent a p span span,
[data-framer-component-type="Text"].isCurrent a h1 span span,
[data-framer-component-type="Text"].isCurrent a h2 span span,
[data-framer-component-type="Text"].isCurrent a h3 span span,
[data-framer-component-type="Text"].isCurrent a h4 span span,
[data-framer-component-type="Text"].isCurrent a h5 span span,
[data-framer-component-type="Text"].isCurrent a h6 span span {
    --font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-current-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, solid))) var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))) var(--framer-link-current-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, currentcolor))) var(--framer-link-current-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, auto)));
    --text-decoration-skip-ink: var(--framer-link-current-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink)));
    --text-underline-offset: var(--framer-link-current-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset)));
}`;
var textCSSRules = [
  `[data-framer-component-type="Text"] { cursor: inherit; }`,
  `[data-framer-component-text-autosized] * { white-space: pre; }`,
  textAlignmentRule,
  textBlockSpanRule,
  textInlineSpanRule,
  renderTextStylesRule,
  textStylesRule,
  linkStylesRule,
  linkHoverStylesRule,
  linkCurrentStylesRule
];
var stackPositionRule = `
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > [data-framer-component-type] {
    position: relative;
}`;
var nativeStackGapRules = /* @__PURE__ */ (() => [
  `[data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: var(--stack-native-row-gap);
        column-gap: var(--stack-native-column-gap);
    }`,
  `.${flexboxGapNotSupportedClass} [data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: unset;
        column-gap: unset;
    }`
])();
var stackGapRule = /* @__PURE__ */ (() => `
.${flexboxGapNotSupportedClass} [data-framer-legacy-stack-gap-enabled="true"] > *, [data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"] {
    margin-top: calc(var(--stack-gap-y) / 2);
    margin-bottom: calc(var(--stack-gap-y) / 2);
    margin-right: calc(var(--stack-gap-x) / 2);
    margin-left: calc(var(--stack-gap-x) / 2);
}
`)();
var stackDirectionRuleVertical = /* @__PURE__ */ (() => `
.${flexboxGapNotSupportedClass}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child,
.${flexboxGapNotSupportedClass}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child {
    margin-top: 0;
    margin-left: 0;
}`)();
var stackDirectionRuleHorizontal = /* @__PURE__ */ (() => `
.${flexboxGapNotSupportedClass}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child,
.${flexboxGapNotSupportedClass}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child {
    margin-right: 0;
    margin-bottom: 0;
}`)();
var stackCSSRules = /* @__PURE__ */ (() => [
  stackPositionRule,
  stackGapRule,
  ...nativeStackGapRules,
  stackDirectionRuleVertical,
  stackDirectionRuleHorizontal
])();
var navigationCSSRules = [
  `
NavigationContainer
[data-framer-component-type="NavigationContainer"] > *,
[data-framer-component-type="NavigationContainer"] > [data-framer-component-type] {
    position: relative;
}`
];
var scrollCSSRules = [
  `[data-framer-component-type="Scroll"]::-webkit-scrollbar { display: none; }`,
  `[data-framer-component-type="ScrollContentWrapper"] > * { position: relative; }`
];
var nativeScrollCSSRules = [
  `[data-framer-component-type="NativeScroll"] { -webkit-overflow-scrolling: touch; }`,
  `[data-framer-component-type="NativeScroll"] > * { position: relative; }`,
  `[data-framer-component-type="NativeScroll"].direction-both { overflow-x: auto; overflow-y: auto; }`,
  `[data-framer-component-type="NativeScroll"].direction-vertical { overflow-x: hidden; overflow-y: auto; }`,
  `[data-framer-component-type="NativeScroll"].direction-horizontal { overflow-x: auto; overflow-y: hidden; }`,
  `[data-framer-component-type="NativeScroll"].direction-vertical > * { width: 100% !important; }`,
  `[data-framer-component-type="NativeScroll"].direction-horizontal > * { height: 100% !important; }`,
  `[data-framer-component-type="NativeScroll"].scrollbar-hidden::-webkit-scrollbar { display: none; }`
];
var deviceComponentCSSRules = [
  `[data-framer-component-type="DeviceComponent"].no-device > * { width: 100% !important; height: 100% !important; }`
];
var pageContentWrapperWrapperCSSRules = [
  `[data-framer-component-type="PageContentWrapper"] > *, [data-framer-component-type="PageContentWrapper"] > [data-framer-component-type] { position: relative; }`
];
var presenceCSS = [
  `[data-is-present="false"], [data-is-present="false"] * { pointer-events: none !important; }`
];
var lightboxCSS = [`.framer-lightbox-container { opacity: 1 !important; pointer-events: auto !important; }`];
var cursorCSS = [
  `[data-framer-cursor="pointer"] { cursor: pointer; }`,
  `[data-framer-cursor="grab"] { cursor: grab; }`,
  `[data-framer-cursor="grab"]:active { cursor: grabbing; }`
];
var frameCSS = [
  // Non-sites prototyping projects render with FrameWithMotion and Stacks. In
  // that context this rule ensures pointer events work in a specific way
  // designed for prototypes that we don't care about anymore in sites. We
  // can't remove it for legacy reasons, but sites will never render any
  // elements that are impacted by this rule. However, users can still use the
  // <Frame> api in code, at which point this rule will kick in. We don't
  // encourage the use of this API anymore, and bugs that come from this will
  // be the user's concern.
  `[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }`,
  // This is fully deprecated, and will never exist in code that is generated
  // after 24/01/2023. There will be existing code-generated that depends on
  // this rule existing, so we can't remove it.
  `[data-framer-generated] * { pointer-events: unset }`
];
var resetCSS = [
  `[data-reset="button"] {
        border-width: 0;
        padding: 0;
        background: none;
}`
];
var hideScrollbars = [
  `[data-hide-scrollbars="true"]::-webkit-scrollbar { width: 0px; height: 0px; }`,
  `[data-hide-scrollbars="true"]::-webkit-scrollbar-thumb { background: transparent; }`,
  `[data-hide-scrollbars="true"] { scrollbar-width: none; }`
];
var willChangeOverrideCSSVariable = "--framer-will-change-override";
var willChangeEffectOverrideCSSVariable = "--framer-will-change-effect-override";
var willChangeFilterOverrideCSSVariable = "--framer-will-change-filter-override";
var anySafariVersion2 = "(background: -webkit-named-image(i))";
var safari16OrGreater = "(grid-template-rows: subgrid)";
var safari26OrGreater = "(position-area: top right)";
var willChangeTransformRules = (isPreview) => isPreview ? [
  `body { ${willChangeOverrideCSSVariable}: none; }`,
  `@supports ${anySafariVersion2} and (not ${safari16OrGreater}) { body { ${willChangeOverrideCSSVariable}: transform; } }`
] : [`body { ${willChangeOverrideCSSVariable}: none; ${willChangeEffectOverrideCSSVariable}: none; }`];
var willChangeFilterRules = (isPreview) => isPreview ? [
  `body { ${willChangeFilterOverrideCSSVariable}: none; }`,
  `@supports ${anySafariVersion2} and (not ${safari26OrGreater}) { body { ${willChangeFilterOverrideCSSVariable}: filter; } }`
] : [`body { ${willChangeFilterOverrideCSSVariable}: none; }`];
var frameCSSRules = (isPreview) => {
  return isPreview ? frameCSS : [];
};
var svgCSSRules = [`.svgContainer svg { display: block; }`];
var overflowClipFallbackCSSVariable = "--overflow-clip-fallback";
var overflowClipFallbackCSSRules = /* @__PURE__ */ (() => [
  `@supports (not (overflow: clip)) {
        :root { ${overflowClipFallbackCSSVariable}: hidden; }
    }`
])();
var combineCSSRules = (isPreview) => [
  ...willChangeTransformRules(isPreview),
  ...willChangeFilterRules(isPreview),
  ...componentCSSRules,
  ...textCSSRules,
  ...richTextCSSRules,
  ...deprecatedRichTextCSSRules,
  ...stackCSSRules,
  ...navigationCSSRules,
  ...scrollCSSRules,
  ...nativeScrollCSSRules,
  ...pageContentWrapperWrapperCSSRules,
  ...deviceComponentCSSRules,
  ...presenceCSS,
  ...cursorCSS,
  ...frameCSSRules(isPreview),
  ...svgCSSRules,
  ...resetCSS,
  ...hideScrollbars,
  ...overflowClipFallbackCSSRules,
  ...lightboxCSS,
  ...safari16TextTruncationFix
];
var combinedCSSRules = /* @__PURE__ */ combineCSSRules(false);
var combinedCSSRulesForPreview = /* @__PURE__ */ combineCSSRules(true);
var didInject = false;
function injectComponentCSSRules() {
  if (didInject) return;
  didInject = true;
  const styles4 = RenderTarget.current() === RenderTarget.preview ? combinedCSSRulesForPreview : combinedCSSRules;
  for (const rule of styles4) {
    injectCSSRule(rule, void 0, void 0);
  }
}

// ../../library/src/utils/applyControlDefaultsToReactDefaultProps.ts
function isReactComponent(component) {
  return isObject2(component) || isFunction(component);
}
var optionalKey = "optional";
function controlIsOptional(control) {
  return !!control && optionalKey in control && control[optionalKey] === true;
}
function shouldBeNever(_) {
}
function getControlDefaultValue(control) {
  try {
    switch (control.type) {
      case "string" /* String */:
      case "collectionreference" /* CollectionReference */:
      case "multicollectionreference" /* MultiCollectionReference */:
      case "color" /* Color */:
      case "date" /* Date */:
      case "link" /* Link */:
      case "boxshadow" /* BoxShadow */:
      case "padding" /* Padding */:
      case "borderradius" /* BorderRadius */:
      case "gap" /* Gap */:
        return isString(control.defaultValue) ? control.defaultValue : void 0;
      case "boolean" /* Boolean */:
        return isBoolean(control.defaultValue) ? control.defaultValue : void 0;
      case "enum" /* Enum */:
        if (isUndefined(control.defaultValue)) return void 0;
        return control.options.includes(control.defaultValue) ? control.defaultValue : void 0;
      case "fusednumber" /* FusedNumber */:
      case "number" /* Number */:
        return isNumber(control.defaultValue) ? control.defaultValue : void 0;
      case "transition" /* Transition */:
        return isObject2(control.defaultValue) ? control.defaultValue : void 0;
      case "border" /* Border */:
        return isObject2(control.defaultValue) ? control.defaultValue : void 0;
      case "font" /* Font */:
        return isObject2(control.defaultValue) ? control.defaultValue : void 0;
      case "linkrelvalues" /* LinkRelValues */:
        return isArray(control.defaultValue) ? control.defaultValue : void 0;
      case "object" /* Object */: {
        const value = isObject2(control.defaultValue) ? control.defaultValue : {};
        if (isObject2(control.controls)) {
          applyControlDefaultsToDefaultProps(value, control.controls);
        }
        return value;
      }
      case "array" /* Array */:
        return isArray(control.defaultValue) ? control.defaultValue : void 0;
      case "file" /* File */:
      case "image" /* Image */:
      case "richtext" /* RichText */:
      case "pagescope" /* PageScope */:
      case "eventhandler" /* EventHandler */:
      case "segmentedenum" /* SegmentedEnum */:
      case "responsiveimage" /* ResponsiveImage */:
      case "componentinstance" /* ComponentInstance */:
      case "slot" /* Slot */:
      case "scrollsectionref" /* ScrollSectionRef */:
      case "customcursor" /* CustomCursor */:
      case "cursor" /* Cursor */:
      case "trackingid" /* TrackingId */:
      case "vectorsetitem" /* VectorSetItem */:
        return void 0;
      // No default
      default:
        shouldBeNever(control);
        return void 0;
    }
  } catch {
    return void 0;
  }
}
function applyControlDefaultsToDefaultProps(defaultProps, controls) {
  for (const controlKey in controls) {
    const control = controls[controlKey];
    if (!control) continue;
    const currentDefault = defaultProps[controlKey];
    if (!isUndefined(currentDefault)) continue;
    if (controlIsOptional(control)) continue;
    const defaultValue = getControlDefaultValue(control);
    if (isUndefined(defaultValue)) continue;
    defaultProps[controlKey] = defaultValue;
  }
}
function getDefaultProps(component) {
  if (isObject2(component.defaultProps)) {
    return component.defaultProps;
  }
  const defaultProps = {};
  component.defaultProps = defaultProps;
  return defaultProps;
}
function applyControlDefaultsToReactDefaultProps(component, controls) {
  if (!isReactComponent(component)) return;
  const defaultProps = getDefaultProps(component);
  applyControlDefaultsToDefaultProps(defaultProps, controls);
}

// ../../library/src/utils/addPropertyControls.ts
function addPropertyControls(component, propertyControls) {
  Object.assign(component, { propertyControls });
  applyControlDefaultsToReactDefaultProps(component, propertyControls);
}
function getPropertyControls(component) {
  return component.propertyControls;
}

// ../../library/src/components/Device/presets.ts
var defaultPresetId = "iphone-12-pro";
var presetsBase = /* @__PURE__ */ (() => ({
  iPhonePro: {
    // Screen mask takes care of the rounded screen corners for iPhones Pro,
    // and actually using a radius here produces visual artifacts in Chrome.
    screenRadius: (
      /* 38 */
      0
    ),
    clayBezelLeft: 21,
    clayBezelRight: 21,
    clayBezelTop: 21,
    clayBezelBottom: 21,
    clayBezelRadius: 38 + 21
  },
  iPhone8: {
    screenRadius: 0,
    clayBezelLeft: 24,
    clayBezelRight: 24,
    clayBezelTop: 96,
    clayBezelBottom: 96,
    clayBezelRadius: 38 * 1.5
  },
  iPadPro: {
    screenRadius: 25,
    clayBezelLeft: 38,
    clayBezelRight: 38,
    clayBezelTop: 38,
    clayBezelBottom: 38,
    clayBezelRadius: 25 + 38
  },
  desktop: {
    clayBezelLeft: 20,
    clayBezelRight: 20,
    clayBezelTop: 20,
    clayBezelBottom: 20,
    clayBezelRadius: 20
  }
}))();
var devicePresets = /* @__PURE__ */ (() => [
  {
    id: "iphone-12",
    title: "iPhone 12",
    screenRadius: 0,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 390,
    screenHeight: 844,
    externalClay: {
      width: 500,
      height: 974,
      screenOffsetTop: 65,
      screenOffsetLeft: 55
    },
    screenMask: '<g style="transform: scale(0.5);"><path d="M171.2 0c2.3 0 4 .5 5.4 1.3 1.6 1 2.8 2.2 3.7 3.8.8 1.6 1.2 2.3 1.2 4.9 0 12 2.2 19 6.2 26.5s9.8 13.3 17.3 17.4c7.5 4 15.8 6.1 30.6 6.1h311.5c14.3 0 22.5-2.2 29.9-6.1 7.5-4 13.3-10 17.3-17.4 4-7.5 6.2-14.5 6.2-26.5 0-2.6.4-3.2 1.1-4.9.8-1.6 2-2.9 3.4-3.8 1.4-.8 3.2-1.3 5.4-1.3h54.2c40.1 0 54.7 4.2 69.4 12a81.8 81.8 0 0134 34c7.8 14.7 12 29.3 12 69.4v1457.2c0 40.1-4.2 54.7-12 69.4a81.8 81.8 0 01-34 34c-14.7 7.8-29.3 12-69.4 12H115.4c-40.1 0-54.7-4.2-69.4-12a81.8 81.8 0 01-34-34c-7.8-14.7-12-29.3-12-69.4V115.4C0 75.3 4.2 60.7 12 46a81.8 81.8 0 0134-34C60.7 4.2 75.3 0 115.4 0h55.4z" fill="#000" fill-rule="evenodd"/></g>',
    realisticImage: {
      width: 490,
      height: 944,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: "black", title: "Black", colorValue: "#2E2C36" },
        { id: "white", title: "White", colorValue: "#F7F3F0" },
        { id: "blue", title: "Blue", colorValue: "#14496D" },
        { id: "green", title: "Green", colorValue: "#DAF0D9" },
        { id: "red", title: "Red", colorValue: "#DB4141" }
      ],
      handOffset: { left: 29, right: 29, bottom: 29 }
    }
  },
  {
    id: "iphone-12-mini",
    title: "iPhone 12 Mini",
    screenRadius: 0,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 360,
    screenHeight: 780,
    externalClay: {
      width: 450,
      height: 890,
      screenOffsetTop: 55,
      screenOffsetLeft: 45
    },
    screenMask: '<g style="transform: scale(0.5);"><path d="M142 18c0 19 14 47 43 48h349c31 0 44-29 44-48 0-12 4-18 14-18h18c38 0 52 4 66 11 14 8 25 19 33 33v1c7 14 11 28 11 65v1340c0 38-4 52-11 66-8 14-19 25-33 33h-1c-14 7-28 11-65 11H110c-38 0-52-4-66-11-14-8-25-19-33-33v-1c-7-13-11-27-11-64V110c0-38 4-52 11-66 8-14 19-25 33-33h1C58 4 72 0 109 0h16c11 0 17 6 17 18z" fill="#000" fill-rule="evenodd"/></g>',
    realisticImage: {
      width: 460,
      height: 880,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: "black", title: "Black", colorValue: "#2E2C36" },
        { id: "white", title: "White", colorValue: "#F7F3F0" },
        { id: "blue", title: "Blue", colorValue: "#14496D" },
        { id: "green", title: "Green", colorValue: "#DAF0D9" },
        { id: "red", title: "Red", colorValue: "#DB4141" }
      ],
      handOffset: { left: 31.5, right: 30.5, bottom: 30 }
    }
  },
  {
    id: "iphone-12-pro",
    title: "iPhone 12 Pro",
    screenRadius: 0,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 390,
    screenHeight: 844,
    externalClay: {
      width: 494,
      height: 968,
      screenOffsetTop: 62,
      screenOffsetLeft: 52
    },
    screenMask: '<g style="transform: scale(0.5);"><path d="M171.2 0c2.3 0 4 .5 5.4 1.3 1.6 1 2.8 2.2 3.7 3.8.8 1.6 1.2 2.3 1.2 4.9 0 12 2.2 19 6.2 26.5s9.8 13.3 17.3 17.4c7.5 4 15.8 6.1 30.6 6.1h311.5c14.3 0 22.5-2.2 29.9-6.1 7.5-4 13.3-10 17.3-17.4 4-7.5 6.2-14.5 6.2-26.5 0-2.6.4-3.2 1.1-4.9.8-1.6 2-2.9 3.4-3.8 1.4-.8 3.2-1.3 5.4-1.3h54.2c40.1 0 54.7 4.2 69.4 12a81.8 81.8 0 0134 34c7.8 14.7 12 29.3 12 69.4v1457.2c0 40.1-4.2 54.7-12 69.4a81.8 81.8 0 01-34 34c-14.7 7.8-29.3 12-69.4 12H115.4c-40.1 0-54.7-4.2-69.4-12a81.8 81.8 0 01-34-34c-7.8-14.7-12-29.3-12-69.4V115.4C0 75.3 4.2 60.7 12 46a81.8 81.8 0 0134-34C60.7 4.2 75.3 0 115.4 0h55.4z" fill="#000" fill-rule="evenodd"/></g>',
    realisticImage: {
      width: 490,
      height: 944,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: "graphite", title: "Graphite", colorValue: "#585753" },
        { id: "silver", title: "Silver", colorValue: "#E5E6E1" },
        { id: "pacific-blue", title: "Pacific Blue", colorValue: "#415D6C" },
        { id: "gold", title: "Gold", colorValue: "#FCECD5" }
      ],
      handOffset: { left: 29, right: 29, bottom: 29 }
    }
  },
  {
    id: "iphone-12-pro-max",
    title: "iPhone 12 Pro Max",
    screenRadius: 50,
    // to prevent leaking pixel in the corners, see https://github.com/framer/company/issues/20429
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 428,
    screenHeight: 926,
    externalClay: {
      width: 532,
      height: 1050,
      screenOffsetTop: 62,
      screenOffsetLeft: 52
    },
    screenMask: '<path d="M102 0c6 0 7 3 7 9 0 10 7 23 24 23h164c13 0 22-12 22-23 0-6 1-9 7-9h34c24 0 32 2 41 7s15 11 20 20 7 17 7 41v790c0 24-2 32-7 41s-11 15-20 20-17 7-41 7H68c-24 0-32-2-41-7s-15-11-20-20-7-17-7-41V68c0-24 2-32 7-41S18 12 27 7s17-7 41-7h34z" fill="#000" fill-rule="evenodd"/>',
    realisticImage: {
      width: 528,
      height: 1026,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: "graphite", title: "Graphite", colorValue: "#585753" },
        { id: "silver", title: "Silver", colorValue: "#E5E6E1" },
        { id: "pacific-blue", title: "Pacific Blue", colorValue: "#415D6C" },
        { id: "gold", title: "Gold", colorValue: "#FCECD5" }
      ],
      handOffset: { left: 28.5, right: 28, bottom: 29 }
    }
  },
  {
    id: "iphone-11",
    title: "iPhone 11",
    // Screen mask takes care of the rounded screen corners for iPhones Pro,
    // and actually using a radius here produces visual artifacts in Chrome.
    screenRadius: (
      /* 38 */
      0
    ),
    clayBezelLeft: 35.5,
    clayBezelRight: 35.5,
    clayBezelTop: 35.5,
    clayBezelBottom: 35.5,
    clayBezelRadius: 77,
    screenWidth: 414,
    screenHeight: 896,
    externalClay: {
      width: 524,
      height: 1026,
      screenOffsetTop: 65,
      screenOffsetLeft: 55
    },
    screenMask: '<path d="M85.5 0C89.1 0 92 3 92 6.5c.3 6 1.5 10 3.4 13.5 2.2 4.1 5.5 7.4 9.6 9.6 4.2 2.2 8.9 3.4 17 3.4h170c8.1 0 12.8-1.2 17-3.4 4.1-2.2 7.4-5.5 9.6-9.6A31 31 0 00322 6.5c0-3.6 3-6.5 6.5-6.5h32.3c18.5 0 25.2 2 32 5.5 6.7 3.7 12 9 15.7 15.7 3.6 6.8 5.5 13.5 5.5 32v789.6c0 18.5-2 25.2-5.5 32-3.7 6.7-9 12-15.7 15.7-6.8 3.6-13.5 5.5-32 5.5H53.2c-18.5 0-25.2-2-32-5.5-6.7-3.7-12-9-15.7-15.7C2 868 0 861.3 0 842.8V53.2c0-18.5 2-25.2 5.5-32 3.7-6.7 9-12 15.7-15.7C28 2 34.7 0 53.2 0h32.3z" fill="#000" fill-rule="nonzero"/>',
    realisticImage: {
      width: 514,
      height: 996,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: "black", title: "Black", colorValue: "#202120" },
        { id: "white", title: "White", colorValue: "#F9F6EF" },
        { id: "purple", title: "Purple", colorValue: "#D1CDDB" },
        { id: "green", title: "Green", colorValue: "#ADE0CD" },
        { id: "red", title: "Red", colorValue: "#B90D2E" },
        { id: "yellow", title: "Yellow", colorValue: "#FFE680" }
      ],
      handOffset: { left: 14.5, right: 14.5, bottom: 14.5 }
    }
  },
  {
    id: "iphone-11-pro",
    title: "iPhone 11 Pro",
    ...presetsBase.iPhonePro,
    screenWidth: 375,
    screenHeight: 812,
    externalClay: {
      width: 485,
      height: 942,
      screenOffsetTop: 65,
      screenOffsetLeft: 55
    },
    screenMask: '<path d="M292 8.668V9c0 9.266-7.07 21-23.332 21h-162C90.402 30 83.332 18.266 83.332 9v-.332c0-4.285 0-8.668-7.664-8.668H43.332C16.312 0 0 16.313 0 43.332v725.336C0 795.688 16.313 812 43.332 812h288.336c27.02 0 43.332-16.313 43.332-43.332V43.332C375 16.312 358.687 0 331.668 0h-32C292 0 292 4.383 292 8.668zm0 0"/>',
    realisticImage: {
      width: 475,
      height: 912,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#52514F" },
        { id: "silver", title: "Silver", colorValue: "#EBEBE3" },
        { id: "gold", title: "Gold", colorValue: "#FBD7BD" },
        { id: "midnight-green", title: "Midnight Green", colorValue: "#4F5850" }
      ],
      handOffset: { left: 24.5, right: 24.5, bottom: 23.5 }
    }
  },
  {
    id: "iphone-11-pro-max",
    title: "iPhone 11 Pro Max",
    ...presetsBase.iPhonePro,
    screenWidth: 414,
    screenHeight: 896,
    externalClay: {
      width: 524,
      height: 1026,
      screenOffsetTop: 65,
      screenOffsetLeft: 55
    },
    screenMask: '<path d="M96 0c3.313 0 5.91 2.688 6 6 .18 6.645 1.191 10.148 2.938 13.41 1.917 3.586 4.73 6.402 8.316 8.317 3.586 1.918 7.441 2.941 15.445 2.941h156.602c8.004 0 11.86-1.023 15.445-2.941 3.586-1.915 6.399-4.73 8.317-8.317 1.746-3.265 2.746-6.758 2.937-13.41.094-3.313 2.688-6 6-6h46.004c17.387 0 23.687 1.809 30.043 5.21 6.355 3.4 11.344 8.388 14.742 14.743C412.191 26.31 414 32.61 414 49.996v796.008c0 17.387-1.809 23.687-5.21 30.043-3.4 6.355-8.388 11.344-14.743 14.742-6.356 3.402-12.656 5.211-30.043 5.211H49.996c-17.387 0-23.687-1.809-30.043-5.21-6.355-3.4-11.344-8.388-14.742-14.743C1.809 869.69 0 863.39 0 846.004V49.996C0 32.61 1.809 26.31 5.21 19.953c3.4-6.355 8.388-11.344 14.743-14.742C26.31 1.809 32.61 0 49.996 0zm0 0"/>',
    realisticImage: {
      width: 514,
      height: 996,
      screenOffsetLeft: 50,
      screenOffsetTop: 50,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#52514F" },
        { id: "silver", title: "Silver", colorValue: "#EBEBE3" },
        { id: "gold", title: "Gold", colorValue: "#FBD7BD" },
        { id: "midnight-green", title: "Midnight Green", colorValue: "#4F5850" }
      ],
      handOffset: { left: 23.5, right: 24.5, bottom: 24 }
    }
  },
  {
    id: "iphone-8",
    title: "iPhone 8",
    ...presetsBase.iPhone8,
    screenWidth: 375,
    screenHeight: 667,
    externalClay: {
      width: 491,
      height: 971,
      screenOffsetLeft: 58,
      screenOffsetTop: 152
    },
    realisticImage: {
      width: 475,
      height: 927,
      screenOffsetLeft: 50,
      screenOffsetTop: 130,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#28282A" },
        { id: "silver", title: "Silver", colorValue: "#DFE1E2" },
        { id: "gold", title: "Gold", colorValue: "#F6E6DB" }
      ],
      handOffset: { left: 22, right: 22, bottom: 18.5 }
    }
  },
  {
    id: "iphone-8-plus",
    title: "iPhone 8 Plus",
    ...presetsBase.iPhone8,
    screenWidth: 414,
    screenHeight: 736,
    externalClay: {
      width: 530,
      height: 1064,
      screenOffsetLeft: 58,
      screenOffsetTop: 164
    },
    realisticImage: {
      width: 514,
      height: 996,
      screenOffsetLeft: 50,
      screenOffsetTop: 130,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#28282A" },
        { id: "silver", title: "Silver", colorValue: "#DFE1E2" },
        { id: "gold", title: "Gold", colorValue: "#F6E6DB" }
      ],
      handOffset: { left: 21, right: 20.5, bottom: 19 }
    }
  },
  {
    id: "iphone-se",
    title: "iPhone SE",
    screenWidth: 320,
    screenHeight: 568,
    screenRadius: 0,
    clayBezelLeft: 20,
    clayBezelRight: 20,
    clayBezelTop: 112,
    clayBezelBottom: 112,
    clayBezelRadius: 38 * 1.5,
    externalClay: {
      width: 436,
      height: 872,
      screenOffsetLeft: 58,
      screenOffsetTop: 152
    },
    realisticImage: {
      width: 420,
      height: 828,
      screenOffsetLeft: 50,
      screenOffsetTop: 130,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#C3C4C8" },
        { id: "silver", title: "Silver", colorValue: "#E1E2E4" },
        { id: "gold", title: "Gold", colorValue: "#EFD8BD" },
        { id: "rose-gold", title: "Rose Gold", colorValue: "#F7CFCA" }
      ],
      handOffset: { left: 22, right: 22, bottom: 26.5 }
    }
  },
  {
    id: "samsung-galaxy-s7",
    title: "Samsung Galaxy S7",
    screenRadius: 0,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 360,
    screenHeight: 640,
    externalClay: {
      width: 454,
      height: 880,
      screenOffsetTop: 120,
      screenOffsetLeft: 47
    },
    realisticImage: {
      width: 440,
      height: 860,
      screenOffsetLeft: 40,
      screenOffsetTop: 110,
      availableColors: [
        { id: "black", title: "Black", colorValue: "#2E2C36" },
        { id: "white", title: "White", colorValue: "#F7F3F0" },
        { id: "silver", title: "Silver", colorValue: "#E5E6E1" },
        { id: "gold", title: "Gold", colorValue: "#FCECD5" }
      ],
      handOffset: { left: 26, right: 25.5, bottom: 32 }
    }
  },
  // deprecated
  {
    id: "samsung-note-10",
    title: "Samsung Note 10",
    screenWidth: 360,
    screenHeight: 760,
    screenRadius: 10,
    clayBezelLeft: 7,
    clayBezelRight: 7,
    clayBezelTop: 15,
    clayBezelBottom: 15,
    clayBezelRadius: 15
  },
  {
    id: "pixel-5",
    title: "Google Pixel 5",
    screenRadius: 31,
    clayBezelLeft: 22,
    clayBezelRight: 22,
    clayBezelTop: 22,
    clayBezelBottom: 22,
    clayBezelRadius: 66,
    screenWidth: 360,
    screenHeight: 780,
    externalClay: {
      width: 460,
      height: 900,
      screenOffsetTop: 60,
      screenOffsetLeft: 50
    },
    realisticImage: {
      width: 920 / 2,
      height: 1760 / 2,
      screenOffsetLeft: 100 / 2,
      screenOffsetTop: 100 / 2,
      availableColors: [
        { id: "just-black", title: "Just Black", colorValue: "#2E2C36" },
        { id: "sorta-sage", title: "Sorta Sage", colorValue: "#B7C9C0" }
      ],
      handOffset: {
        left: 31.5,
        right: 31,
        bottom: 31
        /* 1t */
      }
    }
  },
  {
    id: "pixel-4",
    title: "Google Pixel 4",
    screenWidth: 360,
    screenHeight: 760,
    screenRadius: 34,
    clayBezelLeft: 10,
    clayBezelRight: 10,
    clayBezelTop: 50,
    clayBezelBottom: 25,
    clayBezelRadius: 50,
    externalClay: {
      width: 460,
      height: 938,
      screenOffsetLeft: 50,
      screenOffsetTop: 89
    },
    realisticImage: {
      width: 460,
      height: 920,
      screenOffsetLeft: 50,
      screenOffsetTop: 80,
      availableColors: [
        { id: "clearly-white", title: "Clearly White", colorValue: "#EAEDF2" },
        { id: "just-black", title: "Just Black", colorValue: "#1A1A1A" },
        { id: "oh-so-orange", title: "Oh So Orange", colorValue: "#FF7A68" }
      ],
      handOffset: {
        left: 35.5,
        right: 35.5,
        bottom: 57
        /* 1t */
      }
    }
  },
  // Desktop ------------------------------------------------------------------------------------------------------------------------
  {
    id: "macbook-air",
    title: "MacBook Air",
    screenWidth: 1440,
    screenHeight: 900,
    disableRotation: true,
    externalClay: {
      width: 1890,
      height: 1125,
      screenOffsetLeft: 225,
      screenOffsetTop: 98
    },
    realisticImage: {
      width: 3848 / 2,
      height: 2240 / 2,
      screenOffsetLeft: 484 / 2,
      screenOffsetTop: 196 / 2,
      availableColors: [
        { id: "silver", title: "Silver", colorValue: "#E5E6E1" },
        { id: "space-grey", title: "Space Grey", colorValue: "#B1B5B7" },
        { id: "gold", title: "Gold", colorValue: "#FCECD5" }
      ]
    }
  },
  {
    id: "macbook-pro-13",
    title: `MacBook Pro 13"`,
    screenWidth: 1440,
    screenHeight: 900,
    disableRotation: true,
    externalClay: {
      width: 1914,
      height: 1169,
      screenOffsetLeft: 236,
      screenOffsetTop: 109
    },
    realisticImage: {
      width: 3916 / 2,
      height: 2330 / 2,
      screenOffsetLeft: 518 / 2,
      screenOffsetTop: 218 / 2,
      availableColors: [
        { id: "silver", title: "Silver", colorValue: "#E5E6E1" },
        { id: "space-grey", title: "Space Grey", colorValue: "#B1B5B7" }
      ]
    }
  },
  {
    id: "macbook-pro-16",
    title: `MacBook Pro 16"`,
    screenWidth: 1536,
    screenHeight: 960,
    disableRotation: true,
    externalClay: {
      width: 1984,
      height: 1179,
      screenOffsetLeft: 225,
      screenOffsetTop: 78
    },
    realisticImage: {
      width: 4032 / 2,
      height: 2348 / 2,
      screenOffsetLeft: 480 / 2,
      screenOffsetTop: 148 / 2,
      availableColors: [
        { id: "silver", title: "Silver", colorValue: "#E5E6E1" },
        { id: "space-grey", title: "Space Grey", colorValue: "#B1B5B7" }
      ]
    }
  },
  {
    id: "imac-21-5",
    title: `iMac 21.5"`,
    screenWidth: 2048,
    screenHeight: 1152,
    disableRotation: true,
    externalClay: {
      width: 2288,
      height: 1892,
      screenOffsetLeft: 120,
      screenOffsetTop: 120
    },
    realisticImage: {
      width: 4562 / 2,
      height: 3796 / 2,
      screenOffsetLeft: 232 / 2,
      screenOffsetTop: 244 / 2
    }
  },
  {
    id: "imac-27",
    title: `iMac 27"`,
    screenWidth: 2560,
    screenHeight: 1440,
    disableRotation: true,
    externalClay: {
      width: 2848,
      height: 2351,
      screenOffsetLeft: 144,
      screenOffsetTop: 151
    },
    realisticImage: {
      width: 5676 / 2,
      height: 4720 / 2,
      screenOffsetLeft: 278 / 2,
      screenOffsetTop: 292 / 2,
      availableColors: [
        { id: "silver", title: "Silver", colorValue: "#E5E6E1" },
        { id: "pro", title: "Pro", colorValue: "#5F5E63" }
      ]
    }
  },
  {
    id: "pro-display-xdr",
    title: `Pro Display XDR`,
    screenWidth: 3008,
    screenHeight: 1692,
    disableRotation: true,
    externalClay: {
      width: 3148,
      height: 2325,
      screenOffsetLeft: 70,
      screenOffsetTop: 60
    },
    realisticImage: {
      width: 6276 / 2,
      height: 4695 / 2,
      screenOffsetLeft: 130 / 2,
      screenOffsetTop: 130 / 2
    }
  },
  {
    id: "dell-xps",
    title: `Dell XPS`,
    screenWidth: 1920,
    screenHeight: 1080,
    disableRotation: true,
    externalClay: {
      width: 2624,
      height: 1381,
      screenOffsetLeft: 352,
      screenOffsetTop: 57
    },
    realisticImage: {
      width: 5412 / 2,
      height: 2746 / 2,
      screenOffsetLeft: 786 / 2,
      screenOffsetTop: 108 / 2
    }
  },
  {
    id: "surface-book",
    title: `Microsoft Surface Book`,
    screenWidth: 1500,
    screenHeight: 1e3,
    disableRotation: true,
    externalClay: {
      width: 2089,
      height: 1234,
      screenOffsetLeft: 296,
      screenOffsetTop: 93
    },
    realisticImage: {
      width: 4200 / 2,
      height: 2508 / 2,
      screenOffsetLeft: 600 / 2,
      screenOffsetTop: 210 / 2
    }
  },
  // Tablets ------------------------------------------------------------------------------------------------------------------------
  {
    id: "ipad",
    title: "iPad",
    screenRadius: 0,
    screenWidth: 810,
    screenHeight: 1080,
    clayBezelLeft: 30,
    clayBezelRight: 30,
    clayBezelTop: 95,
    clayBezelBottom: 95,
    clayBezelRadius: 0,
    externalClay: {
      width: 966,
      height: 1378,
      screenOffsetLeft: 78,
      screenOffsetTop: 149
    },
    realisticImage: {
      width: 1920 / 2,
      height: 2720 / 2,
      screenOffsetLeft: 75,
      screenOffsetTop: 140,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#C3C4C8" },
        { id: "silver", title: "Silver", colorValue: "#E1E2E4" },
        { id: "gold", title: "Gold", colorValue: "#EFD8BD" }
      ]
    }
  },
  {
    id: "ipad-mini",
    title: "iPad Mini",
    screenRadius: 0,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 768,
    screenHeight: 1024,
    externalClay: {
      width: 924,
      height: 1384,
      screenOffsetLeft: 78,
      screenOffsetTop: 180
    },
    realisticImage: {
      width: 1856 / 2,
      height: 2728 / 2,
      screenOffsetLeft: 160 / 2,
      screenOffsetTop: 340 / 2,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#C3C4C8" },
        { id: "silver", title: "Silver", colorValue: "#E1E2E4" },
        { id: "gold", title: "Gold", colorValue: "#EFD8BD" }
      ]
    }
  },
  {
    id: "ipad-air",
    title: "iPad Air",
    screenRadius: 18,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 820,
    screenHeight: 1180,
    externalClay: {
      width: 994,
      height: 1374,
      screenOffsetLeft: 87,
      screenOffsetTop: 97
    },
    realisticImage: {
      width: 1960 / 2,
      height: 2680 / 2,
      screenOffsetLeft: 160 / 2,
      screenOffsetTop: 160 / 2,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#C3C4C8" },
        { id: "silver", title: "Silver", colorValue: "#E1E2E4" },
        { id: "rose-gold", title: "Rose Gold", colorValue: "#ECCBC4" },
        { id: "blue", title: "Blue", colorValue: "#CBDAE6" },
        { id: "green", title: "Green", colorValue: "#DAF0D9" }
      ]
    }
  },
  {
    id: "ipad-pro-11",
    title: "iPad Pro 11\u2033",
    screenRadius: 17,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 834,
    screenHeight: 1194,
    externalClay: {
      width: 990,
      height: 1370,
      screenOffsetLeft: 78,
      screenOffsetTop: 88
    },
    realisticImage: {
      width: 1968 / 2,
      height: 2688 / 2,
      screenOffsetLeft: 75,
      screenOffsetTop: 75,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#C3C4C8" },
        { id: "silver", title: "Silver", colorValue: "#E1E2E4" }
      ]
    }
  },
  {
    id: "ipad-pro-12-9",
    title: "iPad Pro 12.9\u2033",
    ...presetsBase.iPadPro,
    screenRadius: 17,
    screenWidth: 1024,
    screenHeight: 1366,
    externalClay: {
      width: 1180,
      height: 1542,
      screenOffsetLeft: 78,
      screenOffsetTop: 88
    },
    realisticImage: {
      width: 2348 / 2,
      height: 3032 / 2,
      screenOffsetLeft: 75,
      screenOffsetTop: 75,
      availableColors: [
        { id: "space-grey", title: "Space Grey", colorValue: "#C3C4C8" },
        { id: "silver", title: "Silver", colorValue: "#E1E2E4" }
      ]
    }
  },
  {
    id: "surface-3",
    title: "Microsoft Surface 3",
    screenRadius: 0,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 960,
    screenHeight: 640,
    externalClay: {
      width: 1184,
      height: 864,
      screenOffsetLeft: 112,
      screenOffsetTop: 112
    },
    realisticImage: {
      width: 2280 / 2,
      height: 1580 / 2,
      screenOffsetLeft: 180 / 2,
      screenOffsetTop: 150 / 2
    }
  },
  {
    id: "surface-pro-4",
    title: "Microsoft Surface Pro 4",
    screenRadius: 0,
    clayBezelLeft: 49,
    clayBezelRight: 49,
    clayBezelTop: 49,
    clayBezelBottom: 49,
    clayBezelRadius: 49,
    screenWidth: 1368,
    screenHeight: 912,
    externalClay: {
      width: 1592,
      height: 1136,
      screenOffsetLeft: 112,
      screenOffsetTop: 112
    },
    realisticImage: {
      width: 3176 / 2,
      height: 2224 / 2,
      screenOffsetLeft: 220 / 2,
      screenOffsetTop: 200 / 2
    }
  },
  // Watches ------------------------------------------------------------------------------------------------------------------------
  {
    id: "apple-watch-44",
    title: `Apple Watch 44mm`,
    screenRadius: 33,
    screenWidth: 184,
    screenHeight: 224,
    disableRotation: true,
    externalClay: {
      width: 298,
      height: 502,
      screenOffsetLeft: 57,
      screenOffsetTop: 129
    },
    realisticImage: {
      width: 548 / 2,
      height: 908 / 2,
      screenOffsetLeft: 90 / 2,
      screenOffsetTop: 230 / 2,
      availableColors: [
        { id: "black", title: "Black", colorValue: "#2E2C36" },
        { id: "white", title: "White", colorValue: "#F7F3F0" },
        { id: "yellow", title: "Yellow", colorValue: "#FDDC6C" },
        { id: "orange", title: "Orange", colorValue: "#F35C56" }
      ]
    }
  },
  {
    id: "apple-watch-40",
    title: `Apple Watch 40mm`,
    screenRadius: 27,
    screenWidth: 162,
    screenHeight: 197,
    disableRotation: true,
    externalClay: {
      width: 280,
      height: 463,
      screenOffsetLeft: 59,
      screenOffsetTop: 124
    },
    realisticImage: {
      width: 504 / 2,
      height: 854 / 2,
      screenOffsetLeft: 90 / 2,
      screenOffsetTop: 230 / 2,
      availableColors: [
        { id: "black", title: "Black", colorValue: "#2E2C36" },
        { id: "white", title: "White", colorValue: "#F7F3F0" },
        { id: "yellow", title: "Yellow", colorValue: "#FDDC6C" },
        { id: "orange", title: "Orange", colorValue: "#F35C56" }
      ]
    }
  },
  // TVs ------------------------------------------------------------------------------------------------------------------------
  {
    id: "tv-full-hd",
    title: `Full HD`,
    screenRadius: 0,
    screenWidth: 1920,
    screenHeight: 1080,
    externalClay: {
      width: 1968,
      height: 1168,
      screenOffsetLeft: 24,
      screenOffsetTop: 12
    },
    realisticImage: {
      width: 4040 / 2,
      height: 2360 / 2,
      screenOffsetLeft: 100 / 2,
      screenOffsetTop: 100 / 2
    }
  },
  {
    id: "tv-4k",
    title: `4K`,
    screenRadius: 0,
    screenWidth: 3840,
    screenHeight: 2160,
    externalClay: {
      width: 3908,
      height: 2308,
      screenOffsetLeft: 34,
      screenOffsetTop: 24
    },
    realisticImage: {
      width: 7960 / 2,
      height: 4600 / 2,
      screenOffsetLeft: 140 / 2,
      screenOffsetTop: 140 / 2
    }
  },
  // Old devices ------------------------------------------------------------------------------------------------------------------------
  // deprecated
  {
    id: "720p",
    title: "720p",
    ...presetsBase.desktop,
    screenWidth: 720,
    screenHeight: 1280
  },
  // deprecated
  {
    id: "900p",
    title: "900p",
    ...presetsBase.desktop,
    screenWidth: 900,
    screenHeight: 1440
  },
  // deprecated
  {
    id: "1080p",
    title: "1080p",
    ...presetsBase.desktop,
    screenWidth: 1080,
    screenHeight: 1920
  },
  // deprecated
  {
    id: "1440p",
    title: "1440p",
    ...presetsBase.desktop,
    screenWidth: 1440,
    screenHeight: 2560
  },
  // deprecated
  {
    id: "4k",
    title: "4K",
    ...presetsBase.desktop,
    screenWidth: 2160,
    screenHeight: 3840
  }
])();
var deviceCodeComponentPresetIds = [
  "iphone-12",
  "iphone-12-mini",
  "iphone-12-pro",
  "iphone-11",
  "iphone-11-pro",
  "iphone-11-pro-max",
  "iphone-8",
  "iphone-8-plus",
  "iphone-se",
  "samsung-note-10",
  "pixel-4",
  "ipad",
  "ipad-pro-11",
  "ipad-pro-12-9",
  "720p",
  "900p",
  "1080p",
  "1440p",
  "4k"
];
var devicePresetsMap = /* @__PURE__ */ devicePresets.reduce(
  (map2, preset) => {
    map2[preset.id] = preset;
    return map2;
  },
  {}
);
function getDevicePreset(presetId) {
  return devicePresetsMap[presetId] ?? devicePresetsMap[defaultPresetId];
}

// ../../library/src/components/Device/DeviceCodeComponentProps.ts
var defaultDeviceProps = {
  preset: defaultPresetId,
  customWidth: 375,
  customHeight: 800,
  customBezel: 20,
  isMixedBezel: false,
  bezelTop: 20,
  bezelRight: 20,
  bezelBottom: 20,
  bezelLeft: 20,
  customBezelRadius: 20,
  customScreenRadius: 0,
  orientation: "portrait",
  skin: "clay",
  theme: "dark",
  shadow: true,
  backgroundColor: void 0
};
function convertPropsToDeviceOptions(props, { forceOldClay = false } = {}) {
  if (props.preset === "no-device") {
    return;
  }
  let preset;
  if (props.preset === "custom") {
    preset = {
      screenWidth: props.customWidth,
      screenHeight: props.customHeight,
      screenRadius: props.customScreenRadius,
      clayBezelTop: props.isMixedBezel ? props.bezelTop : props.customBezel,
      clayBezelRight: props.isMixedBezel ? props.bezelRight : props.customBezel,
      clayBezelBottom: props.isMixedBezel ? props.bezelBottom : props.customBezel,
      clayBezelLeft: props.isMixedBezel ? props.bezelLeft : props.customBezel,
      clayBezelRadius: props.customBezelRadius
    };
  } else {
    preset = getDevicePreset(props.preset);
  }
  const colors = getColorsFromTheme(props.theme);
  const shadowColor = colors.shadowColor;
  const shadow = props.shadow ? `0 10px 30px ${shadowColor}` : void 0;
  const rotate = !preset.disableRotation && (props.orientation === "landscape" || props.rotated);
  let deviceWidth;
  let deviceHeight;
  let screenOffsetTop;
  let screenOffsetLeft;
  let colorId = props.colorId;
  let appearance;
  if ((props.skin === void 0 || props.skin === "realistic") && preset.realisticImage && props.preset) {
    deviceWidth = preset.realisticImage.width;
    deviceHeight = preset.realisticImage.height;
    screenOffsetTop = preset.realisticImage.screenOffsetTop;
    screenOffsetLeft = preset.realisticImage.screenOffsetLeft;
    colorId = colorId ?? colorIdForTheme(props.theme, preset.realisticImage.availableColors);
    appearance = {
      type: "realistic",
      imageUrl: colorId ? `https://preview.framercdn.com/images/devices/${props.preset}-${colorId}.png` : `https://preview.framercdn.com/images/devices/${props.preset}.png`,
      imageWidth: preset.realisticImage.width,
      imageHeight: preset.realisticImage.height,
      rotateImage: rotate
    };
  } else {
    deviceWidth = preset.screenWidth + (preset.clayBezelLeft ?? 0) + (preset.clayBezelRight ?? 0);
    deviceHeight = preset.screenHeight + (preset.clayBezelTop ?? 0) + (preset.clayBezelBottom ?? 0);
    screenOffsetTop = preset.clayBezelTop ?? 0;
    screenOffsetLeft = preset.clayBezelLeft ?? 0;
    if (preset.externalClay && !forceOldClay) {
      deviceWidth = preset.externalClay.width;
      deviceHeight = preset.externalClay.height;
      screenOffsetTop = preset.externalClay.screenOffsetTop;
      screenOffsetLeft = preset.externalClay.screenOffsetLeft;
      appearance = {
        type: "external-clay",
        imageUrl: `https://preview.framercdn.com/images/devices/${props.preset}-${props.theme}.svg`,
        imageWidth: preset.externalClay.width,
        imageHeight: preset.externalClay.height,
        rotateImage: rotate
      };
    } else {
      appearance = {
        type: "clay",
        bezelRadius: preset.clayBezelRadius !== void 0 ? `${preset.clayBezelRadius}px` : void 0,
        bezelColor: colors.bezelColor,
        bezelShadeColor: colors.bezelShadeColor
      };
    }
  }
  let screenWidth = preset.screenWidth;
  let screenHeight = preset.screenHeight;
  if (rotate) {
    const screenOffsetRight = deviceWidth - screenWidth - screenOffsetLeft;
    [deviceWidth, deviceHeight] = [deviceHeight, deviceWidth];
    [screenWidth, screenHeight] = [screenHeight, screenWidth];
    [screenOffsetTop, screenOffsetLeft] = [screenOffsetRight, screenOffsetTop];
  }
  const handOffset = preset.realisticImage?.handOffset;
  return {
    deviceWidth,
    deviceHeight,
    appearance,
    screenWidth,
    screenHeight,
    screenOffsetTop,
    screenOffsetLeft,
    screenRadius: preset.screenRadius !== void 0 ? `${preset.screenRadius}px` : void 0,
    screenMaskImage: appearance.type !== "realistic" && preset.screenMask ? makeScreenMaskImage({
      mask: preset.screenMask,
      // width/height of the mask = screen width/height pre-rotation
      width: preset.screenWidth,
      height: preset.screenHeight,
      rotate
    }) : void 0,
    screenColor: colors.screenColor,
    shadow,
    hand: props.hand !== void 0 && supportsHand(props) ? {
      imageUrl: `https://preview.framercdn.com/images/hands/${props.hand}.png`,
      offsetLeft: handOffset?.left,
      offsetRight: handOffset?.right,
      offsetBottom: handOffset?.bottom
    } : void 0,
    background: props.backgroundColor,
    theme: props.theme,
    colorId
  };
}
function makeScreenMaskImage({
  mask,
  width,
  height,
  rotate = false
}) {
  const transform2 = rotate ? (
    // Rotate 90 degrees counter-clockwise around (0,0), then move the
    // result down into the viewport (rightmost transform is applied first).
    `transform="translate(0 ${width}) rotate(-90)"`
  ) : "";
  return encodeSVGForCSS(
    `<svg xmlns="http://www.w3.org/2000/svg" viewport="0 0 ${width} ${height}" preserveAspectRatio="none"><g x="0" y="0" ${transform2}>${mask}</g></svg>`
  );
}
var lightColors = /* @__PURE__ */ new Set(["white", "silver", "clearly-white", "sorta-sage"]);
var darkColors = /* @__PURE__ */ new Set(["black", "space-grey", "graphite", "just-black", "pro"]);
function colorIdForTheme(theme, availableColors) {
  if (!availableColors) return;
  const colors = theme === "light" ? lightColors : darkColors;
  for (const color2 of availableColors) {
    if (colors.has(color2.id)) {
      return color2.id;
    }
  }
  return availableColors[0]?.id;
}
function supportsHand({ preset: presetId, skin, orientation = "portrait" }) {
  if (!presetId || presetId === "custom" || presetId === "no-device" || orientation === "landscape") return false;
  const preset = getDevicePreset(presetId);
  return skin !== "clay" && preset.realisticImage?.handOffset !== void 0;
}

// ../../library/src/components/Device/usePrototypingMetaTags.ts
import React17 from "react";
function applyMetaTag(name, props) {
  let tag = document.querySelector(`meta[name="${name}"]`);
  if (!tag) {
    tag = document.createElement("meta");
    document.getElementsByTagName("head")[0]?.appendChild(tag);
    tag.setAttribute("name", name);
  }
  for (const [k, v] of Object.entries(props)) {
    tag.setAttribute(k, v);
  }
}
function usePrototypingMetaTags() {
  React17.useEffect(() => {
    applyMetaTag("mobile-web-app-capable", { content: "yes" });
    applyMetaTag("apple-mobile-web-app-capable", { content: "yes" });
    applyMetaTag("apple-mobile-web-app-status-bar-style", {
      content: "black-translucent"
    });
    applyMetaTag("viewport", {
      content: "viewport-fit=cover, user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1"
    });
  }, []);
}

// ../../library/src/components/Device/DeviceCodeComponent.tsx
import { jsx as jsx13 } from "react/jsx-runtime";
var DeviceCodeComponentInner = ({
  children,
  ...props
}) => {
  usePrototypingMetaTags();
  const deviceOptions = convertPropsToDeviceOptions(props, { forceOldClay: true });
  React18.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, []);
  if (!deviceOptions) {
    return /* @__PURE__ */ jsx13(
      "div",
      {
        "data-framer-component-type": "DeviceComponent",
        className: "no-device",
        style: { width: "100%", height: "100%" },
        children: /* @__PURE__ */ jsx13(ProvideParentSize, { parentSize: 1 /* Disabled */, children })
      }
    );
  }
  const child = Array.isArray(children) ? children[0] : children;
  const resizedChild = child && React18.isValidElement(child) ? React18.cloneElement(child, {
    width: deviceOptions.screenWidth,
    height: deviceOptions.screenHeight
  }) : null;
  return /* @__PURE__ */ jsx13(Device, { scaleTo: "dynamic", deviceOptions, children: resizedChild });
};
var DeviceCodeComponent = /* @__PURE__ */ (() => {
  const { componentWidth: defaultWidth2, componentHeight: defaultHeight2 } = getComponentSize(
    convertPropsToDeviceOptions(defaultDeviceProps, { forceOldClay: true })
  );
  DeviceCodeComponentInner.defaultProps = {
    width: defaultWidth2,
    height: defaultHeight2,
    ...defaultDeviceProps
  };
  const deviceCodeComponentPresets = devicePresets.filter((preset) => deviceCodeComponentPresetIds.includes(preset.id));
  addPropertyControls(DeviceCodeComponentInner, {
    children: {
      title: "Content",
      type: "slot" /* Slot */,
      maxCount: 1
    },
    preset: {
      type: "enum" /* Enum */,
      options: ["no-device", "custom"].concat(deviceCodeComponentPresets.map((preset) => preset.id)),
      optionTitles: ["No Device", "Custom"].concat(deviceCodeComponentPresets.map((preset) => preset.title))
    },
    customWidth: {
      title: "Width",
      type: "number" /* Number */,
      min: 0,
      displayStepper: true,
      hidden: (props) => props.preset !== "custom"
    },
    customHeight: {
      title: "Height",
      type: "number" /* Number */,
      min: 0,
      displayStepper: true,
      hidden: (props) => props.preset !== "custom"
    },
    customBezel: {
      title: "Bezel",
      type: "fusednumber" /* FusedNumber */,
      min: 0,
      toggleKey: "isMixedBezel",
      toggleTitles: ["a", "b"],
      valueKeys: ["bezelTop", "bezelRight", "bezelBottom", "bezelLeft"],
      valueLabels: ["T", "R", "B", "L"],
      hidden: (props) => props.preset !== "custom"
    },
    customBezelRadius: {
      title: "Bezel Radius",
      type: "number" /* Number */,
      min: 0,
      displayStepper: true,
      hidden: (props) => props.preset !== "custom"
    },
    customScreenRadius: {
      title: "Screen Radius",
      type: "number" /* Number */,
      min: 0,
      displayStepper: true,
      hidden: (props) => props.preset !== "custom"
    },
    orientation: {
      type: "enum" /* Enum */,
      displaySegmentedControl: true,
      options: ["portrait", "landscape"],
      optionTitles: ["Portrait", "Landscape"],
      optionIcons: ["orientation-portrait", "orientation-landscape"],
      hidden: (props) => !!props.preset && !supportsOrientation(props.preset)
    },
    skin: {
      title: "Device",
      type: "enum" /* Enum */,
      displaySegmentedControl: true,
      options: ["realistic", "clay"],
      optionTitles: ["Realistic", "Clay"],
      defaultValue: "clay",
      hidden: (props) => !!props.preset && !supportsRealisticSkin(props.preset)
    },
    theme: {
      type: "enum" /* Enum */,
      displaySegmentedControl: true,
      options: ["light", "dark"],
      optionTitles: ["Light", "Dark"],
      hidden: (props) => !!props.preset && !supportsThemes(props.preset, props.skin)
    },
    shadow: {
      type: "boolean" /* Boolean */,
      enabledTitle: "On",
      disabledTitle: "Off",
      hidden: ({ skin, preset }) => preset !== "custom" && skin === "realistic" || preset === "no-device"
    },
    hand: {
      type: "enum" /* Enum */,
      options: [null, "hand-1", "hand-2"],
      optionTitles: ["None", "Model 1", "Model 2"],
      hidden: (props) => !supportsHand(props)
    },
    backgroundColor: {
      type: "color" /* Color */,
      title: "Background",
      optional: true,
      hidden: ({ preset }) => preset === "no-device"
    }
  });
  return DeviceCodeComponentInner;
})();
function supportsOrientation(presetId) {
  if (presetId === "no-device") return false;
  if (presetId === "custom") return true;
  const preset = getDevicePreset(presetId);
  return !preset.disableRotation;
}
function supportsRealisticSkin(presetId) {
  if (presetId === "custom" || presetId === "no-device") return false;
  const preset = getDevicePreset(presetId);
  return !!preset.realisticImage;
}
function supportsThemes(presetId, skin) {
  if (presetId === "no-device") return false;
  if (presetId === "custom" || skin !== "realistic") return true;
  const preset = getDevicePreset(presetId);
  const realisticImage = preset.realisticImage;
  if (realisticImage === void 0) {
    return true;
  }
  if (colorIdForTheme("dark", realisticImage.availableColors) !== void 0) {
    return true;
  }
  return false;
}

// ../../library/src/components/EmptyState.tsx
import React25 from "react";

// ../../library/src/render/presentation/Frame/FrameWithMotion.tsx
import React24, { forwardRef as forwardRef2, useContext as useContext8, useRef as useRef8 } from "react";

// ../../library/src/modules/useIsStaticRenderer.ts
import { useState as useState2 } from "react";
function isStaticRenderer() {
  const currentTarget = RenderTarget.current();
  return currentTarget === RenderTarget.canvas || currentTarget === RenderTarget.export;
}
function useIsStaticRenderer() {
  const [isStatic] = useState2(() => isStaticRenderer());
  return isStatic;
}

// ../../library/src/utils/asRecord.ts
var asRecord = (object) => object;

// ../../library/src/utils/isPropValid.ts
function memoize(fn) {
  const cache2 = Object.create(Object.prototype);
  return (arg) => {
    if (cache2[arg] === void 0) cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var reactPropsRegex = /^(?:children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|[dkrxyz]|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y1|y2|yChannelSelector|zoomAndPan|for|class|autofocus|(?:[Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*)$/u;
var isPropValid = /* @__PURE__ */ memoize(
  (prop) => reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91
  /* Z+1 */
);

// ../../library/src/utils/runtimeInjection.ts
import { useMemo as useMemo6 } from "react";
var mockWithWarning = (message) => {
  return () => {
    warnOnce2(message);
  };
};
var mockWithoutWarning = () => {
  return () => {
  };
};
var implementation = {
  // We need a default implementation for useImageSource and useImageElement as it is used for
  // rendering image backgrounds which would break otherwise. The default value is used for HTML
  // export and when using the library without Framer.
  imagePlaceholderSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="126" height="126"><path id="a" d="M126 0v21.584L21.584 126H0v-17.585L108.415 0H126Zm0 108.414V126h-17.586L126 108.414Zm0-84v39.171L63.585 126H24.414L126 24.414Zm0 42v39.17L105.584 126h-39.17L126 66.414ZM105.586 0 0 105.586V66.415L66.415 0h39.171Zm-42 0L0 63.586V24.415L24.415 0h39.171Zm-42 0L0 21.586V0h21.586Z" fill="rgb(136, 136, 136, 0.2)" fill-rule="evenodd"/></svg>`,
  useImageSource(image) {
    return image.src ?? "";
  },
  useImageElement(image, rect, nodeId) {
    const src = runtime.useImageSource(image, rect, nodeId);
    return useMemo6(() => {
      const element = new Image();
      element.src = src;
      if (image.srcSet) element.srcset = image.srcSet;
      return element;
    }, [src, image.srcSet]);
  },
  canRenderOptimizedCanvasImage() {
    return false;
  },
  isOnPageCanvas: false
};
var isRuntimeInjected = false;
var runtimeProxy = {
  get(target, key7, reciever) {
    if (Reflect.has(target, key7)) {
      return Reflect.get(target, key7, reciever);
    }
    if (["getLogger"].includes(String(key7))) {
      return mockWithoutWarning();
    }
    if (isRuntimeInjected) {
      return mockWithWarning(`${String(key7)} is not available in this version of Framer.`);
    }
    return mockWithWarning(`${String(key7)} is only available inside of Framer. https://www.framer.com/`);
  }
};
var runtime = /* @__PURE__ */ new Proxy(implementation, runtimeProxy);
function _injectRuntime(injectedRuntime) {
  Object.assign(implementation, injectedRuntime);
  isRuntimeInjected = true;
}

// ../../library/src/render/style/BackgroundImageComponent.tsx
import React19, { useCallback as useCallback7 } from "react";

// ../../library/src/render/utils/corners.ts
var cornerPropertiesToInherit = {
  borderRadius: "inherit",
  cornerShape: "inherit"
};

// ../../shared/src/assert.ts
function assert2(condition, ...msg) {
  if (condition) return;
  const e = Error("Assertion Error" + (msg.length > 0 ? ": " + msg.join(" ") : ""));
  if (e.stack) {
    try {
      const lines = e.stack.split("\n");
      if (lines[1]?.includes("assert")) {
        lines.splice(1, 1);
        e.stack = lines.join("\n");
      } else if (lines[0]?.includes("assert")) {
        lines.splice(0, 1);
        e.stack = lines.join("\n");
      }
    } catch {
    }
  }
  throw e;
}

// ../../shared/src/diffValues.ts
var missing = Symbol("missing");

// ../../shared/src/errors.ts
var errorReporter;
function reportError({
  error: maybeError,
  tags,
  extras,
  critical,
  caller
}) {
  assert2(
    errorReporter,
    "Set up an error callback with setErrorReporter, or configure Sentry with initializeEnvironment"
  );
  const error = reportableError(maybeError, caller);
  errorReporter({
    error,
    tags: { ...error.tags, ...tags },
    extras: { ...error.extras, ...extras },
    critical: !!critical
  });
  return error;
}
function reportableError(error, caller = reportableError) {
  if (error instanceof Error) {
    return error;
  }
  return new UnhandledError(error, caller);
}
var UnhandledError = class extends Error {
  constructor(error, caller) {
    const message = error ? JSON.stringify(error) : "No error message provided";
    super(message);
    this.message = message;
    if (caller && Error.captureStackTrace) {
      Error.captureStackTrace(this, caller);
    } else {
      try {
        throw new Error();
      } catch (e) {
        this.stack = e.stack;
      }
    }
  }
};

// ../../shared/src/hostInfo.ts
var hostname = typeof window !== "undefined" ? window.location.hostname : void 0;
var isLocal = Boolean(hostname && ["web.framerlocal.com", "localhost", "127.0.0.1", "[::1]"].includes(hostname));
var hosts = (() => {
  if (!hostname) return;
  if (isLocal) {
    return { main: hostname, previewLink: void 0 };
  }
  const previewHostRegex = /^(([^.]+\.)?beta\.)?((?:development\.)?framer\.com)$/u;
  const match = hostname.match(previewHostRegex);
  if (!match || !match[3]) return;
  return {
    previewLink: match[2] && match[0],
    main: match[3]
  };
})();
var hostInfo = {
  hosts,
  isDevelopment: hosts?.main === "development.framer.com",
  isProduction: hosts?.main === "framer.com",
  isLocal
};

// ../../shared/src/ServiceMap.ts
var cachedServiceMap;
function getServiceMap() {
  if (typeof window === "undefined") return {};
  if (cachedServiceMap) return cachedServiceMap;
  cachedServiceMap = extractServiceMap();
  return cachedServiceMap;
}
function extractServiceMap() {
  const location = window.location;
  let services = window?.bootstrap?.services;
  if (services) {
    return services;
  }
  let topOrigin;
  try {
    const topWindow = window.top;
    topOrigin = topWindow.location.origin;
    services = window.top?.bootstrap?.services;
    if (services) {
      return services;
    }
  } catch (e) {
  }
  if (topOrigin && topOrigin !== location.origin) {
    throw Error(`Unexpectedly embedded by ${topOrigin} (expected ${location.origin})`);
  }
  if (location.origin.endsWith("framer.com") || location.origin.endsWith("framer.dev")) {
    throw Error("ServiceMap data was not provided in document");
  }
  try {
    const servicesJSON = new URLSearchParams(location.search).get("services") || new URLSearchParams(location.hash.substring(1)).get("services");
    if (servicesJSON) {
      services = JSON.parse(servicesJSON);
    }
  } catch (e) {
  }
  if (services && typeof services === "object" && services.api) {
    return services;
  }
  throw Error("ServiceMap requested but not available");
}

// ../../shared/src/logger.ts
function jsonSafeCopy(obj, depth = 0, seen = /* @__PURE__ */ new Set()) {
  if (obj === null) return obj;
  if (typeof obj === "function") return `[Function: ${obj.name ?? "unknown"}]`;
  if (typeof obj !== "object") return obj;
  if (obj instanceof Error) return `[${obj.toString()}]`;
  if (seen.has(obj)) return "[Circular]";
  if (depth > 2) return "...";
  seen.add(obj);
  try {
    if ("toJSON" in obj && typeof obj.toJSON === "function") {
      return jsonSafeCopy(obj.toJSON(), depth + 1, seen);
    } else if (Array.isArray(obj)) {
      return obj.map((v) => jsonSafeCopy(v, depth + 1, seen));
    } else if (Object.getPrototypeOf(obj) !== Object.prototype) {
      return `[Object: ${"__class" in obj && obj.__class || obj.constructor?.name}]`;
    } else {
      const result = {};
      for (const [key7, v] of Object.entries(obj)) {
        result[key7] = jsonSafeCopy(v, depth + 1, seen);
      }
      return result;
    }
  } catch (e) {
    return `[Throws: ${e instanceof Error ? e.message : e}]`;
  } finally {
    seen.delete(obj);
  }
}
var levelNames = ["trace", "debug", "info", "warn", "error"];
var postfixNames = [":trace", ":debug", ":info", ":warn", ":error"];
function applyLogLevelSpec(spec, all) {
  const missingSpecs = [];
  for (const s of spec.split(/[ ,]/u)) {
    let match = s.trim();
    if (match.length === 0) continue;
    let level = 1 /* Debug */;
    let inverted = false;
    if (match.startsWith("-")) {
      match = match.slice(1);
      level = 3 /* Warn */;
      inverted = true;
    }
    for (let i = 0; i <= 4 /* Error */; i++) {
      const postfix = postfixNames[i];
      if (!postfix) continue;
      if (match.endsWith(postfix)) {
        level = i;
        if (inverted) {
          level += 1;
        }
        match = match.slice(0, match.length - postfix.length);
        if (match.length === 0) {
          match = "*";
        }
        break;
      }
    }
    const regex2 = new RegExp("^" + escapeRegExp(match).replace(/\\\*/gu, ".*") + "$");
    let loggersUpdated = 0;
    for (const logger of all) {
      if (logger.id.match(regex2)) {
        logger.level = level;
        ++loggersUpdated;
      }
    }
    if (loggersUpdated === 0) {
      missingSpecs.push(s);
    }
  }
  return missingSpecs;
}
var _LogEntry = class _LogEntry {
  constructor(logger, level, parts) {
    this.logger = logger;
    this.level = level;
    this.parts = parts;
    __publicField(this, "id");
    __publicField(this, "time");
    __publicField(this, "stringPrefix");
    this.id = _LogEntry.nextId++;
    this.time = Date.now();
  }
  toMessage() {
    if (this.stringPrefix) return this.parts;
    const r = [
      new Date(this.time).toISOString().substr(-14, 14),
      levelNames[this.level] + ": [" + this.logger.id + "]"
    ];
    let i = 0;
    for (; i < this.parts.length; i++) {
      const part = this.parts[i];
      if (typeof part === "string") {
        r.push(part);
        continue;
      }
      break;
    }
    this.stringPrefix = r.join(" ");
    this.parts.splice(0, i, this.stringPrefix);
    return this.parts;
  }
  toString() {
    return this.toMessage().map((part) => {
      const type = typeof part;
      if (type === "string") return part;
      if (type === "function") return `[Function: ${part.name ?? "unknown"}]`;
      if (part instanceof Error) return part.stack ?? part.toString();
      const json = JSON.stringify(jsonSafeCopy(part));
      if (json?.length > 253) {
        return json.slice(0, 250) + "...";
      }
      return json;
    }).join(" ");
  }
};
__publicField(_LogEntry, "nextId", 0);
var LogEntry = _LogEntry;
var logLevelSpec = "*:app:info,app:info";
var isNode = typeof process !== "undefined" && !!process.kill;
var isCI = isNode && false;
if (isCI) {
  logLevelSpec = "-:warn";
} else if (isNode) {
  logLevelSpec = "";
}
try {
  if (typeof window !== "undefined" && window.localStorage) {
    logLevelSpec = window.localStorage.logLevel || logLevelSpec;
  }
} catch {
}
try {
  if (typeof process !== "undefined") {
    logLevelSpec = process.env.DEBUG || logLevelSpec;
  }
} catch {
}
try {
  if (typeof window !== "undefined") {
    Object.assign(window, { setLogLevel });
  }
} catch {
}
try {
  if (typeof window !== "undefined" && !!window.postMessage && window.top === window) {
    window.addEventListener("message", (msg) => {
      if (!msg.data || typeof msg.data !== "object") return;
      const { loggerId, level, parts, printed } = msg.data;
      if (typeof loggerId !== "string") return;
      if (!Array.isArray(parts) || parts.length < 1 || typeof level !== "number") return;
      const logger = getLogger(loggerId);
      if (level < 0 /* Trace */ || level > 5 /* NotLogging */) return;
      parts[0] = parts[0].replace("[", "*[");
      const entry = new LogEntry(logger, level, parts);
      entry.stringPrefix = parts[0];
      replayBuffer.push(entry);
      if (printed) return;
      if (logger.level > level) return;
      console?.log(...entry.toMessage());
    });
  }
} catch {
}
var postLogEntry;
try {
  if (typeof window !== "undefined" && !!window.postMessage && window.parent !== window && // Don't post messages to the top-level site from the Editor Bar
  !window.location.pathname.startsWith("/edit")) {
    postLogEntry = (entry) => {
      try {
        const parts = entry.toMessage().map((p) => jsonSafeCopy(p));
        const logger = entry.logger;
        const level = entry.level;
        const printed = logger.level <= entry.level;
        const data2 = { loggerId: logger.id, level, parts, printed };
        window.parent?.postMessage(data2, getServiceMap().app);
      } catch {
      }
    };
  }
} catch {
}
var loggers = {};
var replayBuffer = [];
var maxReplayBufferEntries = 1e3;
function createLogEntry(logger, level, parts) {
  const entry = new LogEntry(logger, level, parts);
  replayBuffer.push(entry);
  postLogEntry?.(entry);
  while (replayBuffer.length > maxReplayBufferEntries) {
    replayBuffer.shift();
  }
  return entry;
}
function getLogReplayBuffer(maxEntries) {
  if (typeof maxEntries === "number") {
    maxReplayBufferEntries = maxEntries;
  }
  return replayBuffer;
}
var pathRegex = /\/(?<filename>[^/.]+)(?=\.(?:debug\.)?html$)/u;
var cachedFilename;
function getFilenameFromWindowPathname() {
  if (typeof window === "undefined" || !window.location) return;
  cachedFilename ??= pathRegex.exec(window.location.pathname)?.groups?.filename;
  return cachedFilename;
}
function getLogger(id) {
  const path = getFilenameFromWindowPathname();
  id = (path ? path + ":" : "") + id;
  const existing = loggers[id];
  if (existing) return existing;
  const logger = new Logger(id);
  loggers[id] = logger;
  applyLogLevelSpec(logLevelSpec, [logger]);
  postLogEntry?.(new LogEntry(logger, -1, []));
  return logger;
}
function setLogLevel(spec, replay = true) {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      window.localStorage.logLevel = spec;
    }
  } catch {
  }
  const previousSpec = logLevelSpec;
  logLevelSpec = spec;
  const all = Object.values(loggers);
  for (const logger of all) {
    logger.level = 3 /* Warn */;
  }
  const missingSpecs = applyLogLevelSpec(spec, all);
  if (missingSpecs.length > 0) {
    console?.warn("Some log level specs matched no loggers:", missingSpecs);
  }
  if (replay && replayBuffer.length > 0) {
    console?.log("--- LOG REPLAY ---");
    for (const entry of replayBuffer) {
      if (entry.logger.level > entry.level) continue;
      if (entry.level >= 3 /* Warn */) {
        console?.warn(...entry.toMessage());
      } else {
        console?.log(...entry.toMessage());
      }
    }
    console?.log("--- END OF LOG REPLAY ---");
  }
  return previousSpec;
}
var enrichWithLogs = (extras) => {
  const result = {
    ...extras,
    logs: getLogReplayBuffer().slice(-50).map((entry) => entry.toString().slice(0, 600)).join("\n")
  };
  if (extras.logs) {
    console?.warn("extras.logs is reserved for log replay buffer, use another key");
  }
  return result;
};
var Logger = class {
  constructor(id, errorIsCritical) {
    this.id = id;
    __publicField(this, "level", 3 /* Warn */);
    __publicField(this, "didLog", {});
    __publicField(this, "errorIsCritical");
    /**
     * Trace level messages are not recorded, send to parent frames, or outputted, unless the logger
     * is current set at the trace level.
     */
    __publicField(this, "trace", (...parts) => {
      if (this.level > 0 /* Trace */) return;
      const entry = createLogEntry(this, 0 /* Trace */, parts);
      console?.log(...entry.toMessage());
    });
    /** Debug level is supposed to be used for things that log often and are disabled by default. */
    __publicField(this, "debug", (...parts) => {
      const entry = createLogEntry(this, 1 /* Debug */, parts);
      if (this.level > 1 /* Debug */) return;
      console?.log(...entry.toMessage());
    });
    /**
     * Info level is supposed to be used for once per big user action, or maybe once per minute
     * things. Some loggers log at this level by default. Don't overuse.
     */
    __publicField(this, "info", (...parts) => {
      const entry = createLogEntry(this, 2 /* Info */, parts);
      if (this.level > 2 /* Info */) return;
      console?.info(...entry.toMessage());
    });
    __publicField(this, "warn", (...parts) => {
      const entry = createLogEntry(this, 3 /* Warn */, parts);
      if (this.level > 3 /* Warn */) return;
      console?.warn(...entry.toMessage());
    });
    __publicField(this, "warnOncePerMinute", (firstPart, ...parts) => {
      const lastLoggedTime = this.didLog[firstPart];
      if (lastLoggedTime && lastLoggedTime > Date.now()) return;
      this.didLog[firstPart] = Date.now() + 1e3 * 60;
      parts.unshift(firstPart);
      const entry = createLogEntry(this, 3 /* Warn */, parts);
      if (this.level > 3 /* Warn */) return;
      console?.warn(...entry.toMessage());
    });
    __publicField(this, "error", (...parts) => {
      const entry = createLogEntry(this, 4 /* Error */, parts);
      if (this.level > 4 /* Error */) return;
      console?.error(...entry.toMessage());
    });
    __publicField(this, "errorOncePerMinute", (firstPart, ...parts) => {
      const lastLoggedTime = this.didLog[firstPart];
      if (lastLoggedTime && lastLoggedTime > Date.now()) return;
      this.didLog[firstPart] = Date.now() + 1e3 * 60;
      parts.unshift(firstPart);
      const entry = createLogEntry(this, 4 /* Error */, parts);
      if (this.level > 4 /* Error */) return;
      console?.error(...entry.toMessage());
    });
    /** Reports to Sentry, without logging to the console */
    __publicField(this, "reportWithoutLogging", (maybeError, extras, tags, critical) => {
      const enrichedExtras = enrichWithLogs(extras ?? {});
      const enrichedError = reportError({
        caller: this.reportWithoutLogging,
        error: maybeError,
        tags: {
          ...tags,
          handler: "logger",
          where: this.id
        },
        extras,
        critical: critical ?? this.errorIsCritical
      });
      return [enrichedExtras, enrichedError];
    });
    /** Reports to Sentry */
    __publicField(this, "reportError", (maybeError, extras, tags, critical) => {
      const [enrichedExtras, enrichedError] = this.reportWithoutLogging(maybeError, extras, tags, critical);
      if (enrichedExtras) {
        this.error(enrichedError, enrichedExtras);
      } else {
        this.error(enrichedError);
      }
    });
    /** Reports to Sentry */
    __publicField(this, "reportErrorOncePerMinute", (error, extras) => {
      if (!isErrorWithMessage(error)) return;
      const lastLoggedTime = this.didLog[error.message];
      if (lastLoggedTime && lastLoggedTime > Date.now()) return;
      this.didLog[error.message] = Date.now() + 1e3 * 60;
      this.reportError(error, extras);
    });
    /** Reports to Sentry */
    __publicField(this, "reportCriticalError", (maybeError, extras, tags) => this.reportError(maybeError, extras, tags, true));
    this.errorIsCritical = errorIsCritical ?? (id === "fatal" || id.endsWith(":fatal"));
  }
  extend(name) {
    const id = this.id + ":" + name;
    return getLogger(id);
  }
  /** Returns the messages this logger created that are still in the global replay buffer. */
  getBufferedMessages() {
    return replayBuffer.filter((entry) => entry.logger === this);
  }
  /** Set new level and return previous level. */
  setLevel(level) {
    const previous = this.level;
    this.level = level;
    return previous;
  }
  /** Check if a trace messages will be output. */
  isLoggingTraceMessages() {
    return this.level >= 0 /* Trace */;
  }
};
function isErrorWithMessage(maybeError) {
  return Object.prototype.hasOwnProperty.call(maybeError, "message");
}
function escapeRegExp(string) {
  return string.replace(/[/\-\\^$*+?.()|[\]{}]/gu, "\\$&");
}

// ../../shared/src/Mixed.ts
var Mixed = Symbol("Mixed");

// ../../shared/src/moduleNames.ts
var DEPENDENCIES_MODULE_NAME = "dependencies";
var DEPENDENCIES_MODULE_TYPE = "config";
var DEPENDENCIES_MODULE_TYPE_SLASH_NAME = `${DEPENDENCIES_MODULE_TYPE}/${DEPENDENCIES_MODULE_NAME}`;
var IMPORT_MAP_FILE_NAME = "importMap.json";
var DEPENDENCIES_FILE_NAME = "dependencies.json";
var IMPORT_MAP_FILE_ID = `${DEPENDENCIES_MODULE_TYPE_SLASH_NAME}/${IMPORT_MAP_FILE_NAME}`;
var DEPENDENCIES_FILE_ID = `${DEPENDENCIES_MODULE_TYPE_SLASH_NAME}/${DEPENDENCIES_FILE_NAME}`;

// ../../shared/src/readonly.ts
var USE_FREEZE = false;
var List;
((List2) => {
  function push(ls, ...elements) {
    return ls.concat(elements);
  }
  List2.push = push;
  function pop(a) {
    return a.slice(0, -1);
  }
  List2.pop = pop;
  function unshift(ls, ...elements) {
    return elements.concat(ls);
  }
  List2.unshift = unshift;
  function insert(a, index, ...elements) {
    const length = a.length;
    if (index < 0 || index > length) throw Error("index out of range: " + index);
    const copy = a.slice();
    copy.splice(index, 0, ...elements);
    return copy;
  }
  List2.insert = insert;
  function replace(a, index, replacement) {
    const length = a.length;
    if (index < 0 || index >= length) throw Error("index out of range: " + index);
    const itemsToAdd = Array.isArray(replacement) ? replacement : [replacement];
    const copy = a.slice();
    copy.splice(index, 1, ...itemsToAdd);
    return copy;
  }
  List2.replace = replace;
  function remove2(a, index) {
    const length = a.length;
    if (index < 0 || index >= length) throw Error("index out of range: " + index);
    const copy = a.slice();
    copy.splice(index, 1);
    return copy;
  }
  List2.remove = remove2;
  function move(a, from, to) {
    const length = a.length;
    if (from < 0 || from >= length) throw Error("from index out of range: " + from);
    if (to < 0 || to >= length) throw Error("to index out of range: " + to);
    const copy = a.slice();
    if (to === from) return copy;
    const element = copy[from];
    if (from < to) {
      copy.splice(to + 1, 0, element);
      copy.splice(from, 1);
    } else {
      copy.splice(from, 1);
      copy.splice(to, 0, element);
    }
    return copy;
  }
  List2.move = move;
  function zip(a, b) {
    const res = [];
    const length = Math.min(a.length, b.length);
    for (let i = 0; i < length; i++) {
      res.push([a[i], b[i]]);
    }
    return res;
  }
  List2.zip = zip;
  function update(a, index, body) {
    const res = a.slice();
    const targetElement = res[index];
    if (targetElement === void 0) return res;
    res[index] = body(targetElement);
    return res;
  }
  List2.update = update;
  function unique(a) {
    return Array.from(new Set(a));
  }
  List2.unique = unique;
  function union(a, ...collections) {
    return Array.from(/* @__PURE__ */ new Set([...a, ...collections.flat()]));
  }
  List2.union = union;
  function filter(a, predicate) {
    return a.filter(predicate);
  }
  List2.filter = filter;
})(List || (List = {}));
var objectHasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(object, property) {
  return objectHasOwnProperty.call(object, property);
}
var ValueObject;
((ValueObject2) => {
  function morphUsingTemplate(values, template) {
    for (const field of Object.keys(values)) {
      if (!hasOwnProperty(template, field)) {
        delete values[field];
      }
    }
    for (const field of Object.keys(template)) {
      if (values[field] === void 0) {
        values[field] = template[field];
      }
    }
    Object.setPrototypeOf(values, Object.getPrototypeOf(template));
    if (USE_FREEZE) {
      Object.freeze(values);
    }
    return values;
  }
  ValueObject2.morphUsingTemplate = morphUsingTemplate;
  function writeOnce(object, values) {
    if (values) {
      Object.assign(object, values);
    }
    if (USE_FREEZE) {
      Object.freeze(object);
    }
  }
  ValueObject2.writeOnce = writeOnce;
  function update(object, values) {
    const result = Object.assign(Object.create(Object.getPrototypeOf(object)), object, values);
    if (USE_FREEZE) {
      Object.freeze(result);
    }
    return result;
  }
  ValueObject2.update = update;
})(ValueObject || (ValueObject = {}));
var ReadonlySet;
((ReadonlySet2) => {
  function add3(set, ...items) {
    return /* @__PURE__ */ new Set([...set, ...items]);
  }
  ReadonlySet2.add = add3;
  function remove2(set, ...items) {
    const result = new Set(set);
    for (const item of items) {
      result.delete(item);
    }
    return result;
  }
  ReadonlySet2.remove = remove2;
  function union(...sets) {
    const result = /* @__PURE__ */ new Set();
    for (const set of sets) {
      for (const item of set) {
        result.add(item);
      }
    }
    return result;
  }
  ReadonlySet2.union = union;
  function toggle(set, item) {
    if (set.has(item)) {
      return ReadonlySet2.remove(set, item);
    }
    return ReadonlySet2.add(set, item);
  }
  ReadonlySet2.toggle = toggle;
})(ReadonlySet || (ReadonlySet = {}));
var ReadonlyMap;
((ReadonlyMap2) => {
  function merge(map2, ...otherMaps) {
    const result = /* @__PURE__ */ new Map();
    map2.forEach((value, key7) => result.set(key7, value));
    let didMergeMaps = false;
    for (const otherMap of otherMaps) {
      if (!otherMap) continue;
      otherMap.forEach((value, key7) => result.set(key7, value));
      didMergeMaps = true;
    }
    return didMergeMaps ? result : map2;
  }
  ReadonlyMap2.merge = merge;
  function set(map2, key7, value) {
    const result = new Map(map2);
    result.set(key7, value);
    return result;
  }
  ReadonlyMap2.set = set;
  function remove2(map2, key7) {
    const result = new Map(map2);
    result.delete(key7);
    return result;
  }
  ReadonlyMap2.remove = remove2;
})(ReadonlyMap || (ReadonlyMap = {}));

// ../../shared/src/ResolvablePromise.ts
var ResolvablePromise = class extends Promise {
  constructor() {
    let res;
    let rej;
    super((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    __publicField(this, "_state", "initial");
    __publicField(this, "resolve");
    __publicField(this, "reject");
    this.resolve = (val) => {
      this._state = "fulfilled";
      res(val);
    };
    this.reject = (reason) => {
      this._state = "rejected";
      rej(reason);
    };
  }
  get state() {
    return this._state;
  }
  /**
   * A function that sets the state to "pending".
   * Useful for when you want to signal that the task started but is not yet completed.
   */
  pending() {
    this._state = "pending";
    return this;
  }
  isResolved() {
    return this._state === "fulfilled" || this._state === "rejected";
  }
};
ResolvablePromise.prototype.constructor = Promise;

// ../../shared/src/scheduler.ts
var hasNativeYield = false;
var hasNativePostTask = false;
var hasIsInputPending = false;
if (typeof window !== "undefined" && window.scheduler) {
  hasNativeYield = "yield" in window.scheduler;
  hasNativePostTask = "postTask" in window.scheduler;
  hasIsInputPending = "isInputPending" in window.scheduler;
}

// ../../shared/src/TaskQueues.ts
var log = getLogger("task-queue");

// ../assets/src/utils.ts
function getAssetFilename(asset) {
  return asset.key + asset.extension;
}
function createAbsoluteAssetURL(filename) {
  const serviceMap = getServiceMap();
  return `${serviceMap.userContent}/assets/${filename}`;
}
function createAbsoluteAssetURLFromAsset(asset) {
  return createAbsoluteAssetURL(getAssetFilename(asset));
}

// ../assets/src/getVariantsDimensions.ts
var FixedSizeScaleVariants = [1, 2, 2.2];
var ValidSteps = [512, 1024, 2048, 4096];
function getVariantsDimensions(width, height) {
  if (width === void 0 || height === void 0) return;
  let lead = width, follow = height, orient = 0 /* Horizontal */;
  if (height > width) {
    lead = height;
    follow = width;
    orient = 1 /* Vertical */;
  }
  const ratio = lead / follow;
  const sizes = [];
  for (const step2 of ValidSteps) {
    if (lead <= step2) return sizes;
    sizes.push({
      maxSideSize: step2,
      width: orient === 0 /* Horizontal */ ? step2 : Math.trunc(step2 / ratio)
    });
  }
  return sizes;
}

// ../../library/src/render/style/getSrcSet.ts
function urlWithScaleDownTo(url, scaleDownTo) {
  try {
    const urlObj = new URL(url);
    if (scaleDownTo) {
      urlObj.searchParams.set("scale-down-to", `${scaleDownTo}`);
    } else {
      urlObj.searchParams.delete("scale-down-to");
    }
    return urlObj.toString();
  } catch {
    return url;
  }
}
var MinVariantSizeForSourceSet = 512;
function getResponsiveSrcSet(source, image, variants) {
  if (!variants || variants.length === 0) return void 0;
  if (!image.pixelWidth) return void 0;
  const srcSet = [];
  for (const variant of variants) {
    if (variant.width < MinVariantSizeForSourceSet) continue;
    const url = urlWithScaleDownTo(source, variant.maxSideSize);
    srcSet.push(`${url} ${variant.width}w`);
  }
  srcSet.push(`${urlWithScaleDownTo(source, null)} ${image.pixelWidth}w`);
  return srcSet.join(", ") || void 0;
}
function getFixedSrcSets(source, image, nodeFixedSize) {
  if (!image.pixelWidth || !image.pixelHeight) return void 0;
  if (!nodeFixedSize?.width || !nodeFixedSize?.height) return void 0;
  const srcSet = [];
  const imageMaxSide = Math.max(image.pixelWidth, image.pixelHeight);
  const scaleRatio = Math.max(nodeFixedSize.width / image.pixelWidth, nodeFixedSize.height / image.pixelHeight);
  for (const variant of FixedSizeScaleVariants) {
    const scaleMaxSideSizeTo = Math.round(imageMaxSide * variant * scaleRatio);
    const url = urlWithScaleDownTo(source, scaleMaxSideSizeTo);
    srcSet.push({
      src: url,
      scale: variant
    });
  }
  return srcSet;
}
function getSrcSet(nodeFixedSize, image, source) {
  if (!["auto", "lossless"].includes(image.preferredSize ?? "")) {
    return { src: source, srcSet: void 0 };
  }
  if (nodeFixedSize) {
    const fixedSrcSets = getFixedSrcSets(source, image, nodeFixedSize);
    if (!fixedSrcSets?.length) return { src: source, srcSet: void 0 };
    const [x1, ...rest] = fixedSrcSets;
    return { src: x1?.src, srcSet: rest.map(({ src, scale: scale2 }) => `${src} ${scale2}x`).join(", ") };
  } else {
    const variants = getVariantsDimensions(image.pixelWidth, image.pixelHeight);
    return { src: source, srcSet: getResponsiveSrcSet(source, image, variants) };
  }
}

// ../../library/src/render/style/BackgroundImageComponent.tsx
import { jsx as jsx14 } from "react/jsx-runtime";
var wrapperStyle = /* @__PURE__ */ (() => ({
  position: "absolute",
  ...cornerPropertiesToInherit,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
}))();
function getPlaceholderStyle() {
  return {
    backgroundRepeat: "repeat",
    backgroundPosition: "left top",
    backgroundSize: "64px auto",
    backgroundImage: encodeSVGForCSS(runtime.imagePlaceholderSvg)
  };
}
function cssObjectFit(imageFit) {
  switch (imageFit) {
    case "fit":
      return "contain";
    case "stretch":
      return "fill";
    default:
      return "cover";
  }
}
function cssObjectPosition(positionX, positionY) {
  const x = positionX ?? "center";
  const y = positionY ?? "center";
  if (x === "center" && y === "center") return "center";
  return x + " " + y;
}
function getImageStyle(image) {
  return {
    display: "block",
    width: "100%",
    height: "100%",
    ...cornerPropertiesToInherit,
    objectPosition: cssObjectPosition(image.positionX, image.positionY),
    objectFit: cssObjectFit(image.fit)
  };
}
function useDecodingAttribute(avoidAsyncDecoding) {
  const currentDecoding = React19.useRef(avoidAsyncDecoding ? "auto" : "async");
  const switchDecodingToAuto = useCallback7((node) => {
    currentDecoding.current = "auto";
    node.decoding = "auto";
  }, []);
  const onImageLoad = useCallback7(
    (event) => {
      switchDecodingToAuto(event.currentTarget);
    },
    [switchDecodingToAuto]
  );
  const onImageMount = useCallback7(
    (node) => {
      if (node?.complete) switchDecodingToAuto(node);
    },
    [switchDecodingToAuto]
  );
  return { decoding: currentDecoding.current, onImageLoad, onImageMount };
}
function StaticImage({ image, containerSize, nodeId, alt, draggable, avoidAsyncDecoding }) {
  const source = runtime.useImageSource(image, containerSize, nodeId);
  const imageStyle = getImageStyle(image);
  const { decoding, onImageLoad, onImageMount } = useDecodingAttribute(avoidAsyncDecoding);
  const { srcSet, src } = !("srcSet" in image) ? getSrcSet(image.nodeFixedSize, image, source) : { src: source, srcSet: image.srcSet };
  return (
    // eslint-disable-next-line framer-studio/require-async-decoding -- we conditionally apply it
    /* @__PURE__ */ jsx14(
      "img",
      {
        ref: onImageMount,
        decoding,
        fetchpriority: image.fetchPriority,
        loading: image.loading,
        width: image.pixelWidth,
        height: image.pixelHeight,
        sizes: srcSet ? image.sizes : void 0,
        srcSet,
        src,
        onLoad: onImageLoad,
        alt: alt ?? image.alt ?? "",
        style: imageStyle,
        draggable
      }
    )
  );
}
function CanvasImage({ image, containerSize, nodeId }) {
  const wrapperRef = React19.useRef(null);
  const imageElement = runtime.useImageElement(image, containerSize, nodeId);
  const imageStyle = getImageStyle(image);
  React19.useLayoutEffect(() => {
    const wrapper = wrapperRef.current;
    if (wrapper === null) return;
    wrapper.appendChild(imageElement);
    return () => {
      wrapper.removeChild(imageElement);
    };
  }, [imageElement]);
  Object.assign(imageElement.style, imageStyle);
  return /* @__PURE__ */ jsx14("div", { ref: wrapperRef, style: { display: "contents", ...cornerPropertiesToInherit } });
}
function OptimizedCanvasImage({ nodeId, image, containerSize }) {
  const wrapperRef = React19.useRef(null);
  const source = runtime.useImageSource(image, containerSize, nodeId);
  React19.useLayoutEffect(() => {
    const wrapper = wrapperRef.current;
    if (wrapper === null) return;
    const imageStyle = getImageStyle(image);
    runtime.renderOptimizedCanvasImage(wrapper, source, imageStyle, nodeId);
  }, [nodeId, image, source]);
  return /* @__PURE__ */ jsx14("div", { ref: wrapperRef, style: { display: "contents", ...cornerPropertiesToInherit } });
}
function BackgroundImageComponent({ layoutId, image, ...props }) {
  if (layoutId) {
    layoutId += "-background";
  }
  let fallbackWrapperStyles = null;
  let needsMotion = !!layoutId;
  let imageNode = null;
  if (isString(image.src)) {
    if (image.fit === "tile" && image.pixelWidth && image.pixelHeight) {
      const backgroundSize = isNumber(image.backgroundSize) ? image.backgroundSize : 1;
      const tileSize = {
        width: Math.round(backgroundSize * image.pixelWidth),
        height: Math.round(backgroundSize * image.pixelHeight)
      };
      const roundedBackgroundSize = roundToHalfPixel(backgroundSize * (image.pixelWidth / 2));
      const imageSource = runtime.useImageSource(image, tileSize);
      fallbackWrapperStyles = {
        ...wrapperStyle,
        backgroundImage: `url(${imageSource})`,
        backgroundRepeat: "repeat",
        backgroundPosition: cssObjectPosition(image.positionX, image.positionY),
        opacity: void 0,
        border: 0,
        backgroundSize: `${roundedBackgroundSize}px auto`
      };
      imageNode = null;
      needsMotion = true;
    } else if (RenderTarget.current() !== RenderTarget.canvas) {
      imageNode = /* @__PURE__ */ jsx14(
        StaticImage,
        {
          image,
          avoidAsyncDecoding: RenderTarget.current() === RenderTarget.export,
          ...props
        }
      );
    } else if (
      // biome-ignore lint/correctness/useHookAtTopLevel: This is ok since this function acts just like a util to get the source.
      runtime.canRenderOptimizedCanvasImage(runtime.useImageSource(image))
    ) {
      imageNode = /* @__PURE__ */ jsx14(OptimizedCanvasImage, { image, ...props });
    } else {
      imageNode = /* @__PURE__ */ jsx14(CanvasImage, { image, ...props });
    }
  }
  const style = imageNode ? wrapperStyle : fallbackWrapperStyles ?? { ...wrapperStyle, ...getPlaceholderStyle() };
  return needsMotion ? /* @__PURE__ */ jsx14(motion.div, { layoutId, style, "data-framer-background-image-wrapper": true, children: imageNode }) : /* @__PURE__ */ jsx14("div", { style, "data-framer-background-image-wrapper": true, children: imageNode });
}

// ../../library/src/render/style/BorderComponent.tsx
import { jsx as jsx15 } from "react/jsx-runtime";
function collectBorderStyleForProps(props, style, collapseEqualBorders = true) {
  const { borderWidth, borderStyle, borderColor } = props;
  if (!borderWidth) {
    return;
  }
  let borderTop;
  let borderBottom;
  let borderLeft;
  let borderRight;
  if (typeof borderWidth === "number") {
    borderTop = borderBottom = borderLeft = borderRight = borderWidth;
  } else {
    borderTop = borderWidth.top || 0;
    borderBottom = borderWidth.bottom || 0;
    borderLeft = borderWidth.left || 0;
    borderRight = borderWidth.right || 0;
  }
  if (borderTop === 0 && borderBottom === 0 && borderLeft === 0 && borderRight === 0) {
    return;
  }
  if (collapseEqualBorders && borderTop === borderBottom && borderTop === borderLeft && borderTop === borderRight) {
    style.border = `${borderTop}px ${borderStyle} ${borderColor}`;
    return;
  }
  style.borderStyle = props.borderStyle;
  style.borderColor = props.borderColor;
  style.borderTopWidth = `${borderTop}px`;
  style.borderBottomWidth = `${borderBottom}px`;
  style.borderLeftWidth = `${borderLeft}px`;
  style.borderRightWidth = `${borderRight}px`;
}
function Border(props) {
  const layoutId = props.layoutId ? `${props.layoutId}-border` : void 0;
  if (!props.borderWidth) {
    return null;
  }
  const style = {
    position: "absolute",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    ...cornerPropertiesToInherit,
    pointerEvents: "none"
  };
  if (props.border) {
    ;
    style.border = props.border;
    return /* @__PURE__ */ jsx15(motion.div, { style });
  }
  collectBorderStyleForProps(props, style, false);
  return /* @__PURE__ */ jsx15(motion.div, { "data-frame-border": true, style, layoutId });
}

// ../../library/src/render/types/BackgroundImage.ts
var key = "src";
var BackgroundImage = {
  isImageObject: function(image) {
    if (!image || typeof image === "string") return false;
    return typeof image === "object" && key in image;
  }
};

// ../../library/src/render/style/backgroundImageFromProps.ts
function applyForwardOverrides(background, props) {
  const { _forwardedOverrideId, _forwardedOverrides, id } = props;
  const forwardedOverrideId = _forwardedOverrideId ?? id;
  const src = _forwardedOverrides && forwardedOverrideId ? _forwardedOverrides[forwardedOverrideId] : void 0;
  if (src && typeof src === "string") {
    background = { ...background, src };
  }
  return background;
}
function backgroundImageFromProps(props) {
  const { background, image } = props;
  if (image !== void 0 && background && !BackgroundImage.isImageObject(background)) {
    return;
  }
  let backgroundImage = null;
  if (isString(image)) {
    backgroundImage = { alt: "", src: image };
  } else {
    backgroundImage = Animatable.get(background, null);
  }
  if (!BackgroundImage.isImageObject(backgroundImage)) {
    return;
  }
  return applyForwardOverrides(backgroundImage, props);
}

// ../../library/src/render/utils/getIntrinsicSizeForBackgroundImage.ts
function getIntrinsicSizeForBackgroundImage(background) {
  if (!background) return void 0;
  if (background.pixelHeight && background.pixelWidth) {
    return { width: background.pixelWidth, height: background.pixelHeight };
  }
  if (background.src === void 0) return { width: 1, height: 1 };
  return void 0;
}

// ../../library/src/render/utils/htmlElementAsMotionComponent.ts
function htmlElementAsMotionComponent(asElem) {
  return asElem && asElem !== "search" && asElem !== "slot" && asElem !== "template" ? motion[asElem] : motion["div"];
}

// ../../library/src/utils/safeNavigator.ts
var safeNavigator = typeof navigator !== "undefined" ? navigator : void 0;

// ../../library/src/utils/environment.ts
var isBrowser2 = () => typeof document === "object";
var isWebKit = () => safeNavigator?.userAgent.includes("AppleWebKit/") && !isChrome() && !isEdge();
var webkitVersion = () => {
  let version2 = -1;
  const regexp = /AppleWebKit\/([\d.]+)/u;
  const result = safeNavigator && regexp.exec(safeNavigator.userAgent);
  if (result && result[1]) {
    version2 = parseFloat(result[1]);
  }
  return version2;
};
var safariVersion = () => {
  let version2 = -1;
  const regexp = /Version\/([\d.]+)/u;
  const result = safeNavigator && regexp.exec(safeNavigator.userAgent);
  if (result && result[1]) {
    version2 = parseFloat(result[1]);
  }
  return version2;
};
var isChrome = () => safeNavigator && /Chrome/u.test(safeNavigator.userAgent) && /Google Inc/u.test(safeNavigator.vendor) && !isEdge();
var isSafari = () => safeNavigator && /Safari/u.test(safeNavigator.userAgent) && /Apple Computer/u.test(safeNavigator.vendor);
var isFirefox = () => safeNavigator && /Firefox\/\d+\.\d+$/u.test(safeNavigator.userAgent);
var isFramerX = () => safeNavigator && /FramerX/u.test(safeNavigator.userAgent);
var isEdge = () => safeNavigator && /Edg\//u.test(safeNavigator.userAgent);
var isAndroid = () => safeNavigator && /android/iu.test(safeNavigator.userAgent);
var iOSRegex = /iPhone|iPod|iPad/iu;
var macIntelRegex = /MacIntel/iu;
var isIOS = () => {
  if (!safeNavigator) return false;
  if (iOSRegex.test(safeNavigator.platform)) return true;
  return macIntelRegex.test(safeNavigator.platform) && safeNavigator.maxTouchPoints && safeNavigator.maxTouchPoints > 2;
};
var isMacOS = () => safeNavigator && /Mac/u.test(safeNavigator.platform);
var isWindows = () => safeNavigator && /Win/u.test(safeNavigator.platform);
var isTouch = () => safeWindow.ontouchstart === null && safeWindow.ontouchmove === null && safeWindow.ontouchend === null;
var isDesktop = () => deviceType() === "desktop";
var isPhone = () => deviceType() === "phone";
var isTablet = () => deviceType() === "tablet";
var isMobile = () => isPhone() || isTablet();
var isFileUrl = (url) => url.startsWith("file://");
var isDataUrl = (url) => url.startsWith("data:");
var isTest = () => false;
var isRelativeUrl = (url) => !/^[a-z]{1,8}:\/\/.*$/i.test(url);
var isLocalServerUrl = (url) => /[a-z]{1,8}:\/\/127\.0\.0\.1/i.test(url) || /[a-zA-Z]{1,8}:\/\/localhost/u.test(url);
var isLocalUrl = (url) => {
  if (isFileUrl(url)) return true;
  if (isLocalServerUrl(url)) return true;
  return false;
};
var isLocalAssetUrl = (url, baseUrl) => {
  if (baseUrl === null) baseUrl = safeWindow.location.href;
  if (isDataUrl(url)) return false;
  if (isLocalUrl(url)) return true;
  if (isRelativeUrl(url) && isLocalUrl(baseUrl)) return true;
  return false;
};
var devicePixelRatio = () => safeWindow.devicePixelRatio;
var isJP2Supported = function() {
  if (isFirefox()) return false;
  return isWebKit();
};
var isWebPSupported = () => isChrome();
var deviceType = () => {
  if (safeNavigator && /tablet|iPad|Nexus 9/i.test(safeNavigator.userAgent)) return "tablet";
  if (safeNavigator && /mobi/iu.test(safeNavigator.userAgent)) return "phone";
  return "desktop";
};
var deviceOS = () => {
  if (isMacOS()) return "macos";
  if (isIOS()) return "ios";
  if (isAndroid()) return "android";
  if (isWindows()) return "windows";
};
var deviceFont = (os) => {
  if (!os) {
    os = deviceOS();
  }
  const fonts = {
    apple: "-apple-system, BlinkMacSystemFont, SF Pro Text, SF UI Text, Helvetica Neue",
    google: "Roboto, Helvetica Neue",
    microsoft: "Segoe UI, Helvetica Neue"
  };
  if (os === "macos") return fonts.apple;
  if (os === "ios") return fonts.apple;
  if (os === "android") return fonts.google;
  if (os === "windows") return fonts.microsoft;
  return fonts.apple;
};
var environment = {
  isWebKit,
  webkitVersion,
  isChrome,
  isSafari,
  isFirefox,
  isFramerX,
  isEdge,
  isAndroid,
  isIOS,
  isMacOS,
  isWindows,
  isTouch,
  isDesktop,
  isPhone,
  isTablet,
  isMobile,
  isFileUrl,
  isDataUrl,
  isRelativeUrl,
  isLocalServerUrl,
  isLocalUrl,
  isLocalAssetUrl,
  devicePixelRatio,
  isJP2Supported,
  isWebPSupported,
  deviceType,
  deviceOS,
  deviceFont,
  safariVersion
};

// ../../library/src/render/utils/layoutHintDataPropsForCenter.ts
var isChrome2 = /* @__PURE__ */ isChrome();
function collectLayoutHintDataProps(props, center) {
  props["data-framer-layout-hint-center-x"] = center === true || center === "x" ? true : void 0;
  props["data-framer-layout-hint-center-y"] = center === true || center === "y" ? true : void 0;
}
function layoutHintDataPropsForCenter(center) {
  const props = {};
  if (!center || !isChrome2 || RenderTarget.current() !== RenderTarget.canvas) {
    return props;
  }
  collectLayoutHintDataProps(props, center);
  return props;
}

// ../../library/src/render/utils/nodeIdFromString.ts
function nodeIdFromString(str) {
  return str.replace(/^id_/u, "").replace(/\\/gu, "");
}

// ../../library/src/render/utils/performanceDebugging.ts
function countNodeRender() {
  if (true) return;
  const perf = asRecord(safeWindow)["perf"];
  if (!perf) return;
  perf.nodeRender();
}

// ../../library/src/render/utils/processOverrideForwarding.ts
import React20 from "react";
function processOverrideForwarding(props, children) {
  if (!children) {
    children = props.children;
    if (!children) return { props, children };
  }
  const _forwardedOverrides = props._forwardedOverrides;
  if (!_forwardedOverrides) return { props, children };
  children = React20.Children.map(children, (child) => {
    if (!React20.isValidElement(child)) return child;
    return React20.cloneElement(child, { _forwardedOverrides });
  });
  return { props, children };
}

// ../../library/src/render/utils/transformTemplate.ts
function transformTemplate(center) {
  return (_, generated) => {
    if (center === true) {
      return `translate(-50%, -50%) ${generated}`;
    } else {
      if (center === "x") {
        return `translateX(-50%) ${generated}`;
      } else if (center === "y") {
        return `translateY(-50%) ${generated}`;
      }
    }
    return generated || "none";
  };
}

// ../../library/src/render/utils/useLayoutId.ts
import { useContext as useContext6, useMemo as useMemo7 } from "react";
function useLayoutId(props, { specificLayoutId, postfix } = {}) {
  const { name, layoutIdKey, duplicatedFrom, __fromCodeComponentNode = false, drag } = props;
  const { getLayoutId, enabled } = useContext6(LayoutIdContext);
  return useMemo7(() => {
    if (!enabled) return props.layoutId;
    const existingLayoutId = specificLayoutId || props.layoutId;
    if (!existingLayoutId) {
      if (drag || !layoutIdKey || __fromCodeComponentNode) return void 0;
    }
    const layoutIdCandidate = existingLayoutId || getLayoutId({ id: layoutIdKey, name, duplicatedFrom });
    if (!layoutIdCandidate) return void 0;
    return postfix ? `${layoutIdCandidate}-${postfix}` : layoutIdCandidate;
  }, [enabled]);
}

// ../../library/src/render/utils/useMeasureLayout.ts
import { useContext as useContext7 } from "react";

// ../../library/src/useIsomorphicLayoutEffect.ts
import { useEffect as useEffect9, useLayoutEffect as useLayoutEffect4 } from "react";
var useIsomorphicLayoutEffect2 = typeof document !== "undefined" ? useLayoutEffect4 : useEffect9;

// ../../library/src/render/presentation/ComponentContainerContext.tsx
import React21 from "react";
var ComponentContainerContext = /* @__PURE__ */ React21.createContext(false);

// ../../library/src/components/hoc/withMeasuredSize.tsx
import React23, { useEffect as useEffect10 } from "react";

// ../../library/src/modules/useForceUpdate.ts
import React22 from "react";
function useForceUpdate2() {
  const [_, setForcedRenderCount] = React22.useState(0);
  return React22.useCallback(() => setForcedRenderCount((v) => v + 1), []);
}

// ../../library/src/components/hoc/withMeasuredSize.tsx
import { jsx as jsx16 } from "react/jsx-runtime";
var DEFAULT_SIZE = 200;
var SharedObserver = class {
  constructor() {
    // Note: we dont want to use #-style private fields here because (as of esbuild 0.17)
    // they leave non-tree-shakeable symbols in the bundle: https://framer-team.slack.com/archives/C05V49Q4NJ2/p1715653184830179
    __publicField(this, "sharedResizeObserver");
    __publicField(this, "callbacks", /* @__PURE__ */ new WeakMap());
    this.sharedResizeObserver = new ResizeObserver(this.updateResizedElements.bind(this));
  }
  updateResizedElements(entries) {
    for (const entry of entries) {
      const callbackForElement = this.callbacks.get(entry.target);
      if (callbackForElement) callbackForElement(entry.contentRect);
    }
  }
  observeElementWithCallback(element, callback) {
    this.sharedResizeObserver.observe(element);
    this.callbacks.set(element, callback);
  }
  unobserve(element) {
    this.sharedResizeObserver.unobserve(element);
    this.callbacks.delete(element);
  }
};
var sharedResizeObserver = /* @__PURE__ */ (() => isBrowser2() ? new SharedObserver() : void 0)();
function useRerenderOnResize(ref) {
  const update = useForceUpdate2();
  useEffect10(() => {
    const element = ref?.current;
    if (!element) return;
    sharedResizeObserver?.observeElementWithCallback(ref.current, update);
    return () => {
      sharedResizeObserver?.unobserve(element);
    };
  }, [ref, update]);
}
function useMeasuredSize(ref) {
  const forceUpdate = useForceUpdate2();
  const size = React23.useRef(null);
  function updateSize(newSize) {
    if (newSize.width === 0 && newSize.height === 0) return;
    if (!size.current || newSize.height !== size.current.height || newSize.width !== size.current.width) {
      size.current = { width: newSize.width, height: newSize.height };
      forceUpdate();
    }
  }
  useIsomorphicLayoutEffect2(() => {
    if (!ref.current) return;
    const { offsetWidth, offsetHeight } = ref.current;
    updateSize({
      width: offsetWidth,
      height: offsetHeight
    });
    sharedResizeObserver.observeElementWithCallback(ref.current, updateSize);
    return () => {
      if (!ref.current) return;
      sharedResizeObserver.unobserve(ref.current);
    };
  }, []);
  return size.current;
}
var SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE = "data-framer-size-compatibility-wrapper";
var withMeasuredSize = (Component18) => (props) => {
  const ref = React23.useRef(null);
  const size = useMeasuredSize(ref);
  const dataProps = { [SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE]: true };
  const shouldRender = Boolean(size);
  const fallbackWidth = props.width ?? DEFAULT_SIZE;
  const fallbackHeight = props.height ?? DEFAULT_SIZE;
  return /* @__PURE__ */ jsx16("div", { style: { width: "100%", height: "100%", pointerEvents: "none" }, ref, ...dataProps, children: shouldRender && /* @__PURE__ */ jsx16(
    Component18,
    {
      ...props,
      width: size?.width ?? fallbackWidth,
      height: size?.height ?? fallbackHeight
    }
  ) });
};

// ../../library/src/render/utils/getMeasurableCodeComponentChildren.ts
function getMeasurableCodeComponentChildren(element) {
  const childrenCollection = element.firstElementChild && element.firstElementChild.hasAttribute(SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE) ? element.firstElementChild.children : element.children;
  return [...childrenCollection].filter(isMeasurable).map(unwrapInlinedDisplayContents);
}
function isMeasurable(element) {
  if (element instanceof HTMLBaseElement || element instanceof HTMLHeadElement || element instanceof HTMLLinkElement || element instanceof HTMLMetaElement || element instanceof HTMLScriptElement || element instanceof HTMLStyleElement || element instanceof HTMLTitleElement) {
    return false;
  }
  return element instanceof HTMLElement || element instanceof SVGElement;
}
function unwrapInlinedDisplayContents(element) {
  if (!(element instanceof HTMLElement)) return element;
  if (element.children.length === 0) return element;
  if (element.style.display !== "contents") return element;
  const firstMeasurableChild = [...element.children].find(isMeasurable);
  if (firstMeasurableChild) {
    return unwrapInlinedDisplayContents(firstMeasurableChild);
  }
  return element;
}

// ../../library/src/render/utils/useMeasureLayout.ts
function useMeasureLayout(props, ref, getChildren = () => [], options = {}) {
  const { id, visible, _needsMeasure } = props;
  const { skipHook = false } = options;
  const inCodeComponent = useContext7(ComponentContainerContext);
  const onCanvas = RenderTarget.current() === RenderTarget.canvas;
  useIsomorphicLayoutEffect2(() => {
    if (!onCanvas || inCodeComponent || skipHook) {
      return;
    }
    if (!(ref.current && id && visible && _needsMeasure)) {
      return;
    }
    runtime.queueMeasureRequest(nodeIdFromString(id), ref.current, getChildren(ref.current));
  });
}
function measureClosestComponentContainer(element) {
  const container = element.closest("[data-framer-component-container]");
  if (!container) return;
  runtime.queueMeasureRequest(
    nodeIdFromString(container.id),
    container,
    getMeasurableCodeComponentChildren(container)
  );
}

// ../../library/src/render/presentation/Layer.tsx
import { Component as Component3 } from "react";

// ../../library/src/render/utils/setLayerBacked.ts
var smallValue = "0.000001px";
var translateZ = /* @__PURE__ */ (() => ` translateZ(${smallValue})`)();
var useTranslateZHack = /* @__PURE__ */ (() => isFramerX() || isSafari() || isTest())();
function forceLayerBackingWithMotionStyle(motionStyle) {
  motionStyle.willChange = "transform";
  const onCanvas = RenderTarget.current() === RenderTarget.canvas;
  if (useTranslateZHack && onCanvas) {
    motionStyle.translateZ = smallValue;
  }
}
function forceLayerBackingWithCSSProperties(cssProperties) {
  cssProperties.willChange = "transform";
  setTranslateZHack(cssProperties, true);
}
function setTranslateZHack(style, enabled) {
  const onCanvas = RenderTarget.current() === RenderTarget.canvas;
  if (!useTranslateZHack || !onCanvas) {
    return;
  }
  const transform2 = isString(style.transform) ? style.transform || "" : "";
  if (enabled) {
    const hasTranslateZ = transform2.includes(translateZ);
    if (!hasTranslateZ) {
      style.transform = transform2 + translateZ;
    }
  } else {
    style.transform = transform2.replace(translateZ, "");
  }
}

// ../../library/src/render/utils/useWebkitFixes.ts
function resetSetStyle(element, key7, toValue, microtask2 = true) {
  if (!element) {
    return;
  }
  const style = asRecord(element.style);
  const value = toValue ? toValue : style[key7];
  const reset = () => {
    if (!isValidCSSStyleValue(value)) return;
    style[key7] = value;
  };
  style[key7] = null;
  if (microtask2) {
    void Promise.resolve().then(reset);
  } else {
    setTimeout(reset, 0);
  }
}
function isValidCSSStyleValue(value) {
  return isString(value) || isNumber(value) || isNull(value);
}

// ../../library/src/render/presentation/Layer.tsx
var Layer = /* @__PURE__ */ (() => {
  class Layer2 extends Component3 {
    constructor() {
      super(...arguments);
      /** @private (Just using `private` breaks compilation unless using `stripInternal`) */
      __publicField(this, "layerElement", null);
      __publicField(this, "setLayerElement", (element) => {
        this.layerElement = element;
      });
    }
    static applyWillChange(props, style, usingMotionStyle) {
      if (props.willChangeTransform) {
        if (usingMotionStyle) {
          forceLayerBackingWithMotionStyle(style);
        } else {
          forceLayerBackingWithCSSProperties(style);
        }
      }
    }
    /** @internal */
    shouldComponentUpdate(nextProps, nextState) {
      return nextProps._needsMeasure || this.state !== nextState || !isEqual(this.props, nextProps);
    }
    /** @internal */
    componentDidUpdate(prevProps) {
      if (asRecord(this.props)["clip"] && asRecord(this.props)["radius"] === 0 && asRecord(prevProps)["radius"] !== 0) {
        resetSetStyle(this.layerElement, "overflow", "hidden", false);
      }
    }
  }
  __publicField(Layer2, "defaultProps", {});
  return Layer2;
})();

// ../../library/src/utils/memoize.ts
function manageCache(cache2, maxEntries) {
  const size = cache2.size;
  if (size < maxEntries) return;
  let i = Math.round(Math.random());
  for (const key7 of cache2.keys()) {
    if ((++i & 1) === 1) continue;
    cache2.delete(key7);
  }
}
function memoize2(maxEntries, cache2, key7, create) {
  const r = cache2.get(key7);
  if (r) return r;
  manageCache(cache2, maxEntries);
  const g = create(key7);
  cache2.set(key7, g);
  return g;
}

// ../../library/src/utils/string.ts
var hash = (value) => {
  let hasher = 0, i, chr;
  if (value.length === 0) return hasher;
  for (i = 0; i < value.length; i++) {
    chr = value.charCodeAt(i);
    hasher = (hasher << 5) - hasher + chr;
    hasher |= 0;
  }
  return hasher;
};

// ../../library/src/render/types/Color/ConvertColor.ts
var ConvertColor = {
  hueRotate: (color2, angle) => {
    return Color.toHslString(Color.hueRotate(Color(color2), angle));
  },
  setAlpha: (color2, alpha2) => {
    return Color.toRgbString(Color.alpha(Color(color2), alpha2));
  },
  getAlpha: (color2) => {
    const obj = stringToObject(color2);
    return obj ? obj.a : 1;
  },
  multiplyAlpha: (color2, alpha2) => {
    return Color.toRgbString(Color.multiplyAlpha(Color(color2), alpha2));
  },
  /**
   * @internal
   */
  toHexValue: (color2) => {
    return Color.toHex(Color(color2)).toUpperCase();
  },
  toHex: (color2) => {
    return Color.toHexString(Color(color2)).toUpperCase();
  },
  toRgb: (color2) => {
    return Color.toRgb(Color(color2));
  },
  toRgbString: (color2) => {
    return Color.toRgbString(Color(color2));
  },
  toHSV: (color2) => {
    return Color.toHsv(Color(color2));
  },
  toHSL: (color2) => {
    return Color.toHsl(Color(color2));
  },
  toHslString: (color2) => {
    return Color.toHslString(Color(color2));
  },
  toHsvString: (color2) => {
    return Color.toHsvString(Color(color2));
  },
  hsvToHSLString: (hsv) => {
    return Color.toHslString(Color(hsvToStr(hsv.h, hsv.s, hsv.v, hsv.a)));
  },
  /**
   * @internal
   */
  hsvToHexValue: (hsv) => {
    return Color.toHex(Color(hsvToStr(hsv.h, hsv.s, hsv.v, hsv.a))).toUpperCase();
  },
  hsvToHex: (hsv) => {
    return Color.toHexString(Color(hsvToStr(hsv.h, hsv.s, hsv.v, hsv.a))).toUpperCase();
  },
  hsvToRgbString: (hsv) => {
    return Color.toRgbString(Color(hsvToStr(hsv.h, hsv.s, hsv.v, hsv.a)));
  },
  hsvToString: (hsv) => {
    return hsvToStr(hsv.h, hsv.s, hsv.v);
  },
  rgbaToString: (color2) => {
    return Color.toRgbString(Color(color2));
  },
  /**
   * @internal
   */
  rgbToHexValue: (color2) => {
    return Color.toHex(Color(color2));
  },
  rgbToHexString: (color2) => {
    return Color.toHexString(Color(color2));
  },
  hslToString: (color2) => {
    return Color.toHslString(Color(color2));
  },
  hslToRgbString: (color2) => {
    return Color.toRgbString(Color(color2));
  },
  toColorPickerSquare: (h) => {
    return Color.toRgbString(Color({ h, s: 1, l: 0.5, a: 1 }));
  },
  isValid: (color2) => {
    return Color(color2).isValid !== false;
  },
  equals: (a, b) => {
    if (Color.isP3String(a) || Color.isP3String(b)) return a === b;
    if (typeof a === "string") {
      a = Color(a);
    }
    if (typeof b === "string") {
      b = Color(b);
    }
    return Color.equal(a, b);
  },
  toHexOrRgbaString: (input) => {
    const color2 = Color(input);
    return color2.a !== 1 ? Color.toRgbString(color2) : Color.toHexString(color2);
  },
  /**
   * Converts a color to a string to consistent formats for animating.
   */
  toFormatString: (color2) => {
    if (Color.isP3String(color2)) return color2;
    return Color.toRgbString(Color(color2));
  }
};

// ../../library/src/render/utils/gradientColorStops.ts
var CSSVariableRegExp = /var\(.+\)/u;
var colorCache = /* @__PURE__ */ new Map();
function cachedMultiplyAlpha(s, a) {
  const key7 = [s, a];
  if (CSSVariableRegExp.test(s)) {
    return s;
  }
  return memoize2(1e3, colorCache, key7, () => ConvertColor.multiplyAlpha(s, a));
}
function gradientColorStops(gradient, alpha2 = 1) {
  let stops;
  if ("stops" in gradient) {
    stops = gradient.stops;
  } else {
    stops = [
      { value: gradient.start, position: 0 },
      { value: gradient.end, position: 1 }
    ];
  }
  if (alpha2 === 1) {
    return stops;
  } else {
    return stops.map((stop) => ({ ...stop, value: cachedMultiplyAlpha(stop.value, alpha2) }));
  }
}
function gradientColorStopsHash(gradient, alpha2) {
  let result = 0;
  gradientColorStops(gradient, alpha2).forEach((stop) => {
    result ^= hash(stop.value) ^ stop.position;
  });
  return result;
}

// ../../library/src/render/types/MultiStopGradient.ts
var multiStopGradientKeys = ["stops"];
function isMultiStopGradient(value) {
  return value && multiStopGradientKeys.every((key7) => key7 in value);
}

// ../../library/src/render/types/SimpleGradient.ts
var simpleGradientKeys = ["start", "end"];
function isSimpleGradient(value) {
  return value && simpleGradientKeys.every((key7) => key7 in value);
}

// ../../library/src/render/types/LinearGradient.ts
var linearGradientKeys = ["angle", "alpha"];
var LinearGradient = {
  /**
   * @param value -
   */
  isLinearGradient: (value) => {
    return isObject2(value) && linearGradientKeys.every((key7) => key7 in value) && (isSimpleGradient(value) || isMultiStopGradient(value));
  },
  /** @internal */
  hash: (linearGradient) => {
    return linearGradient.angle ^ gradientColorStopsHash(linearGradient, linearGradient.alpha);
  },
  /** @internal */
  toCSS: (linearGradient, overrideAngle, getStopValue) => {
    const stops = gradientColorStops(linearGradient, linearGradient.alpha);
    const angle = overrideAngle !== void 0 ? overrideAngle : linearGradient.angle;
    const roundedAngle = Math.round(angle);
    const cssStops = stops.map((stop) => `${getStopValue?.(stop.value) ?? stop.value} ${stop.position * 100}%`);
    return `linear-gradient(${roundedAngle}deg, ${cssStops.join(", ")})`;
  }
};

// ../../library/src/render/types/RadialGradient.ts
var radialGradientKeys = [
  "widthFactor",
  "heightFactor",
  "centerAnchorX",
  "centerAnchorY",
  "alpha"
];
var RadialGradient = {
  /**
   * @param value -
   * @public
   */
  isRadialGradient: (value) => {
    return isObject2(value) && radialGradientKeys.every((key7) => key7 in value) && (isSimpleGradient(value) || isMultiStopGradient(value));
  },
  /** @internal */
  hash: (radialGradient) => {
    return radialGradient.centerAnchorX ^ radialGradient.centerAnchorY ^ radialGradient.widthFactor ^ radialGradient.heightFactor ^ gradientColorStopsHash(radialGradient, radialGradient.alpha);
  },
  /** @internal */
  toCSS: (radialGradient, getStopValue) => {
    const { alpha: alpha2, widthFactor, heightFactor, centerAnchorX, centerAnchorY } = radialGradient;
    const stops = gradientColorStops(radialGradient, alpha2);
    const cssStops = stops.map((stop, index) => {
      const nextStop = stops[index + 1];
      const position = stop.position === 1 && nextStop?.position === 1 ? stop.position - 1e-4 : stop.position;
      return `${getStopValue?.(stop.value) ?? stop.value} ${position * 100}%`;
    });
    return `radial-gradient(${widthFactor * 100}% ${heightFactor * 100}% at ${centerAnchorX * 100}% ${centerAnchorY * 100}%, ${cssStops.join(", ")})`;
  }
};

// ../../library/src/render/traits/Background.ts
function collectBackgroundFromProps({ background, backgroundColor }, style) {
  if (backgroundColor) {
    if (typeof backgroundColor === "string" || isMotionValue2(backgroundColor)) {
      style.backgroundColor = backgroundColor;
    } else if (Color.isColorObject(background)) {
      style.backgroundColor = background.initialValue || Color.toRgbString(background);
    }
  } else if (background) {
    background = Animatable.get(background, null);
    if (typeof background === "string" || isMotionValue2(background)) {
      style.background = background;
    } else if (LinearGradient.isLinearGradient(background)) {
      style.background = LinearGradient.toCSS(background);
    } else if (RadialGradient.isRadialGradient(background)) {
      style.background = RadialGradient.toCSS(background);
    } else if (Color.isColorObject(background)) {
      style.backgroundColor = background.initialValue || Color.toRgbString(background);
    }
  }
}

// ../../library/src/render/utils/extractStyleFromProps.ts
function extractStyleFromProps(props, name, styleRef, into) {
  if (into === void 0) {
    into = name;
  }
  if (props[name] !== void 0) {
    ;
    styleRef[into] = props[name];
    return;
  }
}

// ../../library/src/render/presentation/Frame/getStyleForFrameProps.ts
function hasLeftAndRight(style) {
  if (!style) return false;
  return style.left !== void 0 && style.right !== void 0;
}
function hasTopAndBottom(style) {
  if (!style) return false;
  return style.top !== void 0 && style.bottom !== void 0;
}
function getStyleForFrameProps(props) {
  if (!props) {
    return {};
  }
  const style = {};
  if (props.preserve3d === true) {
    style.transformStyle = "preserve-3d";
  } else if (props.preserve3d === false) {
    style.transformStyle = "flat";
  }
  if (props.backfaceVisible === true) {
    style.backfaceVisibility = "visible";
  } else if (props.backfaceVisible === false) {
    style.backfaceVisibility = "hidden";
  }
  if (style.backfaceVisibility) {
    style.WebkitBackfaceVisibility = style.backfaceVisibility;
  }
  if (props.perspective !== void 0) {
    style.perspective = style.WebkitPerspective = props.perspective;
  }
  if (!props.__fromCanvasComponent) {
    if (props.center === true) {
      style.left = "50%";
      style.top = "50%";
    } else {
      if (props.center === "x") {
        style.left = "50%";
      } else if (props.center === "y") {
        style.top = "50%";
      }
    }
  }
  const { cornerShape } = props;
  if (isMotionValue(cornerShape)) {
    style.cornerShape = transformValue(() => `superellipse(${cornerShape.get()})`);
  } else if (cornerShape !== void 0) {
    style.cornerShape = `superellipse(${cornerShape})`;
  }
  extractStyleFromProps(props, "size", style);
  extractStyleFromProps(props, "width", style);
  extractStyleFromProps(props, "height", style);
  extractStyleFromProps(props, "minWidth", style);
  extractStyleFromProps(props, "minHeight", style);
  extractStyleFromProps(props, "top", style);
  extractStyleFromProps(props, "right", style);
  extractStyleFromProps(props, "bottom", style);
  extractStyleFromProps(props, "left", style);
  extractStyleFromProps(props, "position", style);
  extractStyleFromProps(props, "overflow", style);
  extractStyleFromProps(props, "opacity", style);
  if (!props._border || !props._border.borderWidth) extractStyleFromProps(props, "border", style);
  extractStyleFromProps(props, "borderRadius", style);
  extractStyleFromProps(props, "radius", style, "borderRadius");
  extractStyleFromProps(props, "color", style);
  extractStyleFromProps(props, "shadow", style, "boxShadow");
  extractStyleFromProps(props, "x", style);
  extractStyleFromProps(props, "y", style);
  extractStyleFromProps(props, "z", style);
  extractStyleFromProps(props, "rotate", style);
  extractStyleFromProps(props, "rotateX", style);
  extractStyleFromProps(props, "rotateY", style);
  extractStyleFromProps(props, "rotateZ", style);
  extractStyleFromProps(props, "scale", style);
  extractStyleFromProps(props, "scaleX", style);
  extractStyleFromProps(props, "scaleY", style);
  extractStyleFromProps(props, "skew", style);
  extractStyleFromProps(props, "skewX", style);
  extractStyleFromProps(props, "skewY", style);
  extractStyleFromProps(props, "originX", style);
  extractStyleFromProps(props, "originY", style);
  extractStyleFromProps(props, "originZ", style);
  collectBackgroundFromProps(props, style);
  return style;
}

// ../../library/src/render/presentation/Frame/FrameWithMotion.tsx
import { Fragment as Fragment4, jsx as jsx17, jsxs as jsxs3 } from "react/jsx-runtime";
function hasEvents(props) {
  for (const key7 in props) {
    if (key7 === "drag" || key7.startsWith("while") || typeof asRecord(props)[key7] === "function" && key7.startsWith("on") && !key7.includes("Animation")) {
      return true;
    }
  }
  return false;
}
var pointerEvents = [
  "onClick",
  "onDoubleClick",
  "onMouse",
  "onMouseDown",
  "onMouseUp",
  "onTapDown",
  "onTap",
  "onTapUp",
  "onPointer",
  "onPointerDown",
  "onPointerUp",
  "onTouch",
  "onTouchDown",
  "onTouchUp"
];
var pointerEventsSet = /* @__PURE__ */ (() => /* @__PURE__ */ new Set([
  ...pointerEvents,
  ...pointerEvents.map((event) => `${event}Capture`)
  // Add capture event variants
]))();
function getCursorFromEvents(props) {
  if (props.drag) {
    return "grab";
  }
  for (const key7 in props) {
    if (pointerEventsSet.has(key7)) {
      return "pointer";
    }
  }
  return void 0;
}
var overflowKey = "overflow";
function hasScrollableContent(props) {
  if (hasScrollingOverflow(props)) return true;
  if (!props.style) return false;
  if (hasScrollingOverflow(props.style)) return true;
  return false;
}
function hasScrollingOverflow(props) {
  if (overflowKey in props && (props[overflowKey] === "scroll" || props[overflowKey] === "auto")) return true;
  return false;
}
function unwrapFrameProps(frameProps) {
  const {
    left,
    top,
    bottom,
    right,
    width,
    height,
    center,
    _constraints,
    size,
    widthType,
    heightType,
    positionFixed,
    positionAbsolute
  } = frameProps;
  const minWidth = resolveMotionValue(frameProps.minWidth);
  const minHeight = resolveMotionValue(frameProps.minHeight);
  const maxWidth = resolveMotionValue(frameProps.maxWidth);
  const maxHeight = resolveMotionValue(frameProps.maxHeight);
  const constraintProps = {
    top: resolveMotionValue(top),
    left: resolveMotionValue(left),
    bottom: resolveMotionValue(bottom),
    right: resolveMotionValue(right),
    width: resolveMotionValue(width),
    height: resolveMotionValue(height),
    size: resolveMotionValue(size),
    center,
    _constraints,
    widthType,
    heightType,
    positionFixed,
    positionAbsolute,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight
  };
  return constraintProps;
}
var defaultFrameRect = { x: 0, y: 0, width: 200, height: 200 };
function useStyleAndRect(props) {
  React24.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, []);
  const inCodeComponent = useContext8(ComponentContainerContext);
  const { style, _initialStyle, __fromCanvasComponent, size } = props;
  const unwrappedProps = unwrapFrameProps(props);
  const constraintsRect = useConstraints(unwrappedProps);
  const defaultStyle = {
    display: "block",
    flex: style?.flex ?? "0 0 auto",
    userSelect: RenderTarget.current() !== RenderTarget.preview ? "none" : void 0
  };
  if (!props.__fromCanvasComponent) {
    defaultStyle.backgroundColor = props.background === void 0 ? "rgba(0, 170, 255, 0.3)" : void 0;
  }
  const shouldDisablePointerEvents = !hasEvents(props) && !props.__fromCanvasComponent && !hasScrollableContent(props);
  const safeToEditPointerEvents = props.style ? !("pointerEvents" in props.style) : true;
  if (shouldDisablePointerEvents && safeToEditPointerEvents) {
    defaultStyle.pointerEvents = "none";
  }
  const addTextCentering = React24.Children.count(props.children) > 0 && React24.Children.toArray(props.children).every((child) => {
    return typeof child === "string" || typeof child === "number";
  });
  const centerTextStyle = addTextCentering && {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    textAlign: "center"
  };
  const propsStyle = getStyleForFrameProps(props);
  if (size === void 0 && !__fromCanvasComponent) {
    if (!hasLeftAndRight(propsStyle)) {
      defaultStyle.width = defaultFrameRect.width;
    }
    if (!hasTopAndBottom(propsStyle)) {
      defaultStyle.height = defaultFrameRect.height;
    }
  }
  if (unwrappedProps.minWidth !== void 0) {
    defaultStyle.minWidth = unwrappedProps.minWidth;
  }
  if (unwrappedProps.minHeight !== void 0) {
    defaultStyle.minHeight = unwrappedProps.minHeight;
  }
  let constraintsStyle = {};
  if (constraintsEnabled(unwrappedProps)) {
    if (constraintsRect && !isAutoSized(props)) {
      constraintsStyle = {
        left: constraintsRect.x,
        top: constraintsRect.y,
        width: constraintsRect.width,
        height: constraintsRect.height,
        right: void 0,
        bottom: void 0
      };
    }
  }
  Object.assign(defaultStyle, centerTextStyle, _initialStyle, propsStyle, constraintsStyle, style);
  Object.assign(defaultStyle, {
    overflowX: defaultStyle.overflowX ?? defaultStyle.overflow,
    overflowY: defaultStyle.overflowY ?? defaultStyle.overflow,
    overflow: void 0
  });
  Layer.applyWillChange(props, defaultStyle, true);
  let resultStyle = defaultStyle;
  if (!defaultStyle.transform) {
    resultStyle = { x: 0, y: 0, ...defaultStyle };
  }
  const isRenderingStaticContent = isStaticRenderer();
  if (props.positionSticky) {
    if (!isRenderingStaticContent || runtime.isOnPageCanvas || inCodeComponent) {
      resultStyle.position = "sticky";
      resultStyle.willChange = "transform";
      resultStyle.zIndex = 1;
      resultStyle.top = props.positionStickyTop;
      resultStyle.right = props.positionStickyRight;
      resultStyle.bottom = props.positionStickyBottom;
      resultStyle.left = props.positionStickyLeft;
    }
  } else if (isRenderingStaticContent) {
    if (props.positionFixed) {
      resultStyle.position = runtime.isOnPageCanvas ? "fixed" : "absolute";
    } else if (props.positionAbsolute) {
      resultStyle.position = "absolute";
    }
  }
  if ("rotate" in resultStyle && resultStyle.rotate === void 0) {
    delete resultStyle.rotate;
  }
  return [resultStyle, constraintsRect];
}
var filteredProps = /* @__PURE__ */ new Set([
  "width",
  "height",
  "opacity",
  "overflow",
  "radius",
  "background",
  "color",
  "x",
  "y",
  "z",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "scale",
  "scaleX",
  "scaleY",
  "skew",
  "skewX",
  "skewY",
  "originX",
  "originY",
  "originZ"
]);
function getMotionProps(props) {
  const motionProps = {};
  for (const key7 in props) {
    const isValid = isValidMotionProp(key7) || isPropValid(key7);
    if (isValid && !filteredProps.has(key7)) {
      motionProps[key7] = asRecord(props)[key7];
    } else if (key7 === "positionTransition" || key7 === "layoutTransition") {
      motionProps["layout"] = true;
      if (typeof asRecord(props)[key7] !== "boolean" && !props.transition) {
        motionProps["transition"] = asRecord(props)[key7];
      }
    }
  }
  return motionProps;
}
function hasDataFramerName(props) {
  return "data-framer-name" in props;
}
var VisibleFrame = /* @__PURE__ */ forwardRef2(function VisibleFrame2(props, forwardedRef) {
  const { name, center, border, _border, __portal } = props;
  const { props: propsWithOverrides, children } = processOverrideForwarding(props);
  const motionProps = getMotionProps(propsWithOverrides);
  const layoutId = useLayoutId(props);
  const cursor = getCursorFromEvents(props);
  const fallbackRef = useRef8(null);
  const ref = forwardedRef ?? fallbackRef;
  const dataProps = {
    "data-framer-component-type": props.componentType ?? "Frame",
    "data-framer-cursor": cursor,
    "data-framer-highlight": cursor === "pointer" ? true : void 0,
    "data-layoutid": layoutId,
    "data-framer-offset-parent-id": asRecord(props)["data-framer-offset-parent-id"]
  };
  if (!hasDataFramerName(props) && name) {
    asRecord(dataProps)["data-framer-name"] = name;
  }
  const [currentStyle, rect] = useStyleAndRect(propsWithOverrides);
  const unwrappedProps = unwrapFrameProps(propsWithOverrides);
  const autoSized = isAutoSized(unwrappedProps);
  if (center && !(rect && !autoSized && constraintsEnabled(unwrappedProps))) {
    if (!motionProps.transformTemplate) motionProps.transformTemplate = transformTemplate(center);
    Object.assign(dataProps, layoutHintDataPropsForCenter(center));
  } else if (!motionProps.transformTemplate) {
    motionProps.transformTemplate = void 0;
  }
  useMeasureLayout(props, ref);
  const backgroundImage = backgroundImageFromProps(props);
  const inCodeComponent = useContext8(ComponentContainerContext);
  const parentSize = resolveParentSize(propsWithOverrides, unwrappedProps, rect, inCodeComponent);
  const wrappedContent = useProvideParentSize(
    /* @__PURE__ */ jsxs3(Fragment4, { children: [
      backgroundImage ? /* @__PURE__ */ jsx17(
        BackgroundImageComponent,
        {
          alt: props.alt ?? "",
          image: backgroundImage,
          containerSize: rect ?? void 0,
          nodeId: props.id && nodeIdFromString(props.id),
          layoutId
        }
      ) : null,
      children,
      /* @__PURE__ */ jsx17(Border, { ..._border, border, layoutId })
    ] }),
    parentSize
  );
  const MotionComponent = htmlElementAsMotionComponent(props.as);
  const intrinsicSize = getIntrinsicSizeForBackgroundImage(backgroundImage);
  if (props.fitImageDimension && intrinsicSize) {
    currentStyle[props.fitImageDimension] = "auto";
    currentStyle.aspectRatio = intrinsicSize.width / intrinsicSize.height;
  }
  return /* @__PURE__ */ jsxs3(MotionComponent, { ...dataProps, ...motionProps, layoutId, style: currentStyle, ref, children: [
    wrappedContent,
    __portal
  ] });
});
var FrameWithMotion = /* @__PURE__ */ forwardRef2(
  function FrameWithMotion2(props, ref) {
    countNodeRender();
    const { visible = true } = props;
    if (!visible) return null;
    return /* @__PURE__ */ jsx17(VisibleFrame, { ...props, ref });
  }
);
function resolveParentSize(props, unwrappedProps, rect, inCodeComponent) {
  if (inCodeComponent) {
    const parentSize = rect ? { width: rect.width, height: rect.height } : 1 /* Disabled */;
    return parentSize;
  }
  const { _usesDOMRect } = props;
  const {
    widthType = 0 /* FixedNumber */,
    heightType = 0 /* FixedNumber */,
    width,
    height
  } = unwrappedProps;
  if (rect && !_usesDOMRect) {
    return rect;
  }
  if (widthType === 0 /* FixedNumber */ && heightType === 0 /* FixedNumber */ && typeof width === "number" && typeof height === "number") {
    return { width, height };
  }
  if (_usesDOMRect || props.positionFixed || props.positionAbsolute) {
    return 2 /* DisabledForCurrentLevel */;
  }
  return 0 /* Unknown */;
}

// ../../library/src/components/EmptyState.tsx
import { jsx as jsx18, jsxs as jsxs4 } from "react/jsx-runtime";
function EmptyState({
  title = "",
  description = "Click and drag the connector to any frame on the canvas \u2192",
  children,
  size,
  hide,
  insideUserCodeComponent = false,
  position = "absolute"
}) {
  const { target } = RenderEnvironment;
  const childCount = React25.Children.count(children);
  if (insideUserCodeComponent && childCount === 0) {
    return /* @__PURE__ */ jsx18(FrameWithMotion, { ...size, "data-name": "placeholder" });
  }
  if (target !== RenderTarget.canvas) return null;
  if (hide) return null;
  if (childCount !== 0) return null;
  return /* @__PURE__ */ jsx18(
    FrameWithMotion,
    {
      className: "framerInternalUI-canvasPlaceholder",
      top: 0,
      left: 0,
      bottom: 0,
      right: 0,
      style: { position, ...size },
      children: /* @__PURE__ */ jsx18(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            lineHeight: "1.4",
            height: "100%",
            width: "100%"
          },
          children: /* @__PURE__ */ jsxs4(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                flexDirection: "column",
                width: "100%",
                // Use a mask to fade out the right edge of the content as it gets cropped.
                WebkitMaskImage: `linear-gradient(90deg, black, black calc(100% - 12px * ${scaleFactor}), transparent)`
              },
              children: [
                /* @__PURE__ */ jsx18(Title, { children: title }),
                /* @__PURE__ */ jsx18(Description, { children: description })
              ]
            }
          )
        }
      )
    },
    "empty-state"
  );
}
var scaleFactor = "var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)";
function Title({ children }) {
  return /* @__PURE__ */ jsx18(
    "span",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        textAlign: "center",
        flexGrow: 1,
        flexShrink: 0,
        fontWeight: 600,
        marginBottom: "5px"
      },
      children
    }
  );
}
function Description({ children }) {
  return /* @__PURE__ */ jsx18(
    "span",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        textAlign: "center",
        flexGrow: 1,
        flexShrink: 0,
        fontWeight: 400,
        maxWidth: "200px"
      },
      children
    }
  );
}

// ../../library/src/components/Navigation.tsx
import React31, { Component as Component6 } from "react";

// ../../library/src/components/AnimateLayout/SharedLayoutRoot.tsx
import React26, { Component as Component4 } from "react";
import { jsx as jsx19 } from "react/jsx-runtime";
var TREE_ROOT_ID = "__LAYOUT_TREE_ROOT";
var SharedLayoutContext = /* @__PURE__ */ React26.createContext({
  schedulePromoteTree: () => {
  },
  scheduleProjectionDidUpdate: () => {
  },
  initLead: () => {
  }
});
var SharedLayoutRoot = class extends Component4 {
  constructor() {
    super(...arguments);
    __publicField(this, "shouldAnimate", false);
    __publicField(this, "transition");
    __publicField(this, "lead");
    __publicField(this, "follow");
    __publicField(this, "scheduledPromotion", false);
    __publicField(this, "scheduledDidUpdate", false);
    __publicField(this, "scheduleProjectionDidUpdate", () => {
      this.scheduledDidUpdate = true;
    });
    // schedule a promotion to run later in getSnapshotBeforeUpdate
    __publicField(this, "schedulePromoteTree", (tree, transition, shouldAnimate) => {
      this.follow = this.lead;
      this.shouldAnimate = shouldAnimate;
      this.lead = tree;
      this.transition = transition;
      this.scheduledPromotion = true;
    });
    __publicField(this, "initLead", (tree, shouldAnimate) => {
      this.follow = this.lead;
      this.lead = tree;
      if (this.follow && shouldAnimate) {
        this.follow.layoutMaybeMutated = true;
      }
    });
    __publicField(this, "sharedLayoutContext", {
      schedulePromoteTree: this.schedulePromoteTree,
      scheduleProjectionDidUpdate: this.scheduleProjectionDidUpdate,
      initLead: this.initLead
    });
  }
  // Runs after all descendent SharedLayoutTree finish taking snapshots in
  // their getSnapshotBeforeUpdate lifecycle method.
  getSnapshotBeforeUpdate() {
    if (!this.scheduledPromotion || !this.lead || !this.follow) return null;
    const needsReset = this.lead?.layoutMaybeMutated && !this.shouldAnimate;
    this.lead.projectionNodes.forEach((projectionNode) => {
      projectionNode?.promote({
        needsReset,
        transition: this.shouldAnimate ? this.transition : void 0,
        preserveFollowOpacity: projectionNode.options.layoutId === TREE_ROOT_ID && !this.follow?.isExiting
      });
    });
    if (this.shouldAnimate) {
      this.follow.layoutMaybeMutated = true;
    } else {
      this.scheduleProjectionDidUpdate();
    }
    this.lead.layoutMaybeMutated = false;
    this.transition = void 0;
    this.scheduledPromotion = false;
    return null;
  }
  componentDidUpdate() {
    if (!this.lead) return null;
    if (this.scheduledDidUpdate) {
      this.lead.rootProjectionNode?.root?.didUpdate();
      this.scheduledDidUpdate = false;
    }
  }
  render() {
    return /* @__PURE__ */ jsx19(SharedLayoutContext.Provider, { value: this.sharedLayoutContext, children: this.props.children });
  }
};

// ../../library/src/components/MagicMotionCrossfadeRoot.tsx
import { jsx as jsx20 } from "react/jsx-runtime";
var rootStyles = {
  width: "100%",
  height: "100%",
  backgroundColor: "none"
};
function MagicMotionCrossfadeRoot(props) {
  return /* @__PURE__ */ jsx20(motion.div, { layoutId: TREE_ROOT_ID, style: rootStyles, children: props.children });
}

// ../../library/src/components/NavigationContainer.tsx
import React30, { useContext as useContext12, useEffect as useEffect12, useRef as useRef11 } from "react";

// ../../library/src/modules/useAppearEffect.ts
import React27 from "react";

// ../../library/src/modules/useSharedIntersectionObserver.ts
import { createContext as createContext3, useContext as useContext9 } from "react";

// ../../library/src/components/utils/refHelper.ts
import { useRef as useRef9 } from "react";
function setRef(ref, value) {
  if (isFunction(ref)) {
    ref(value);
  } else if (isMutableRef(ref)) {
    ref.current = value;
  }
}
function isMutableRef(ref) {
  return isObject2(ref) && "current" in ref;
}
function refHasValue(ref) {
  return isMutableRef(ref) && ref.current !== null;
}
function useStableRefWithObserver() {
  const callbacks = useConstant(() => /* @__PURE__ */ new Set());
  const cleanups = useConstant(() => /* @__PURE__ */ new Map());
  return useConstant(
    () => (ref, refCallback) => {
      return {
        get current() {
          return ref.current;
        },
        set current(value) {
          if (value === ref.current) return;
          ref.current = value;
          if (refCallback) refCallback(value);
          cleanups.forEach((cleanup, callback) => {
            if (cleanup) {
              cleanup();
            } else {
              callback(null);
            }
          });
          if (value === null) {
            cleanups.clear();
            callbacks.clear();
            return;
          }
          callbacks.forEach((callback) => {
            const cleanup = callback(value);
            cleanups.set(callback, cleanup);
          });
        },
        /**
         * Adds `fn` to the list of callbacks to be called when the ref is updated.
         * Executes `fn` immediately if the ref already has a value.
         */
        observe(fn) {
          callbacks.add(fn);
          const value = ref.current;
          if (value) {
            const cleanup = fn(value);
            cleanups.set(fn, cleanup);
          }
        },
        /**
         * Removes `fn` from the list of callbacks.
         * Runs the cleanup for `fn` if it has been called before.
         */
        unobserve(fn) {
          if (!fn) return;
          callbacks.delete(fn);
          if (!cleanups.has(fn)) return;
          const cleanupFn = cleanups.get(fn);
          if (cleanupFn) {
            cleanupFn();
          } else {
            fn(null);
          }
          cleanups.delete(fn);
        }
      };
    }
  );
}
function useObserverRef(forwardedRef) {
  const fallbackRef = useRef9(null);
  const createStableRefWithObserver = useStableRefWithObserver();
  return useConstant(() => {
    if (isMutableRef(forwardedRef)) return createStableRefWithObserver(forwardedRef);
    if (isFunction(forwardedRef)) return createStableRefWithObserver(fallbackRef, forwardedRef);
    return createStableRefWithObserver(fallbackRef);
  });
}
function useRefEffect(ref, effect, deps) {
  const effectRef = useRef9();
  const depsChangedRef = useRef9();
  useMemoOne(() => {
    if (depsChangedRef.current !== void 0) {
      depsChangedRef.current = true;
    }
  }, deps ?? [{}]);
  if (!ref) return;
  const depsChanged = depsChangedRef.current;
  if (depsChanged === false) return;
  depsChangedRef.current = false;
  ref.unobserve(effectRef.current);
  ref.observe(effect);
  effectRef.current = effect;
}

// ../../library/src/modules/useSharedIntersectionObserver.ts
var SharedIntersectionObserver = class {
  constructor(options) {
    // Note: we dont want to use #-style private fields here because (as of esbuild 0.17)
    // they leave non-tree-shakeable symbols in the bundle: https://framer-team.slack.com/archives/C05V49Q4NJ2/p1715653184830179
    __publicField(this, "sharedIntersectionObserver");
    __publicField(this, "callbacks", /* @__PURE__ */ new WeakMap());
    this.sharedIntersectionObserver = new IntersectionObserver(
      this.intersectionObserverCallback.bind(this),
      options
    );
  }
  intersectionObserverCallback(entries, observer) {
    for (const entry of entries) {
      const callbackForElement = this.callbacks.get(entry.target);
      if (callbackForElement) callbackForElement(entry, observer);
    }
  }
  observeElementWithCallback(element, callback) {
    if (!this.sharedIntersectionObserver) return;
    this.sharedIntersectionObserver.observe(element);
    this.callbacks.set(element, callback);
  }
  unobserve(element) {
    if (!this.sharedIntersectionObserver) return;
    this.sharedIntersectionObserver.unobserve(element);
    this.callbacks.delete(element);
  }
  get root() {
    return this.sharedIntersectionObserver?.root;
  }
};
var SharedIntersectionObserverContext = /* @__PURE__ */ createContext3(/* @__PURE__ */ new Map());
function observeElement(observers, key7, element, root, callback, rootMargin, threshold) {
  let observer = observers.get(key7);
  if (!observer || observer.root !== root?.current) {
    observer = new SharedIntersectionObserver({ root: root?.current, rootMargin, threshold });
    observers.set(key7, observer);
  }
  observer.observeElementWithCallback(element, callback);
  return () => {
    observer.unobserve(element);
  };
}
function _useSharedIntersectionObserver(ref, callback, options) {
  const key7 = useConstant(() => `${options.rootMargin}`);
  const observers = useContext9(SharedIntersectionObserverContext);
  const { enabled, root, rootMargin, threshold } = options;
  useRefEffect(
    ref,
    (element) => {
      if (!enabled) return;
      if (element === null) return;
      return observeElement(observers, key7, element, root, callback, rootMargin, threshold);
    },
    [enabled, callback, root, rootMargin, threshold]
  );
}
var useSharedIntersectionObserver = typeof IntersectionObserver === "undefined" ? noop2 : _useSharedIntersectionObserver;

// ../../library/src/modules/useAppearEffect.ts
var thresholds = /* @__PURE__ */ new Array(100).fill(void 0).map((_, i) => i * 0.01);
var ViewportContext = /* @__PURE__ */ React27.createContext(null);
function useAppearEffect(ref, appearCallback, options) {
  const internalState = React27.useRef({
    isInView: false,
    hasAnimatedOnce: false
  });
  const { enabled, animateOnce, threshold, rootMargin = `0px 0px 0px 0px` } = options;
  const callback = React27.useCallback(
    (entry) => {
      const { isInView, hasAnimatedOnce } = internalState.current;
      const isIntersecting = isIntersectingWithThreshold(entry, threshold?.y ?? 0);
      if (isIntersecting && !isInView) {
        if (animateOnce && hasAnimatedOnce) return;
        internalState.current.hasAnimatedOnce = true;
        internalState.current.isInView = true;
        appearCallback(true);
        return;
      }
      if (!isIntersecting && isInView) {
        internalState.current.isInView = false;
        if (animateOnce) return;
        appearCallback(false);
        return;
      }
    },
    [animateOnce, threshold?.y, appearCallback]
  );
  useSharedIntersectionObserver(ref, callback, {
    threshold: thresholds,
    rootMargin,
    enabled: enabled ?? true
  });
}
function calculatedIntersection(intersectionRect, boundingClientRect) {
  if (boundingClientRect.height === 0) return 0;
  return intersectionRect.height / Math.min(boundingClientRect.height, safeWindow.innerHeight);
}
function isIntersectingWithThreshold({ boundingClientRect, intersectionRect, isIntersecting }, threshold) {
  if (boundingClientRect.height === 0) return isIntersecting;
  return isIntersecting && calculatedIntersection(intersectionRect, boundingClientRect) >= threshold;
}

// ../../library/src/components/AnimateLayout/SharedLayoutTree.tsx
import React28, { Component as Component5 } from "react";
import { jsx as jsx21 } from "react/jsx-runtime";
var LayoutTree = class extends Component5 {
  constructor() {
    super(...arguments);
    /**
     * SharedLayoutTrees need to reset the projections styles previously applied
     * on their boxes if they are becoming lead but not animating.
     */
    __publicField(this, "layoutMaybeMutated", false);
    /**
     * A list of projection nodes in the tree
     */
    __publicField(this, "projectionNodes", /* @__PURE__ */ new Map());
    /**
     * The projection node with the smallest depth in the tree's children.
     */
    __publicField(this, "rootProjectionNode");
    /**
     * When a tree is tagged as being removed, either by usePresence, or by
     * Navigation, we set it on `this` in shouldComponentUpdate so that it's
     * accessible by SharedLayoutRoot before the LayoutTree has updated.
     */
    __publicField(this, "isExiting");
    __publicField(this, "shouldPreserveFollowOpacity", (child) => {
      return child.options.layoutId === TREE_ROOT_ID && !this.props.isExiting;
    });
    __publicField(this, "switchLayoutGroupContext", {
      register: (child) => this.addChild(child),
      deregister: (child) => this.removeChild(child),
      // Configs to use for the initial promotion on mount in Motion
      transition: this.props.isLead !== void 0 && this.props.animatesLayout ? this.props.transition : void 0,
      shouldPreserveFollowOpacity: this.shouldPreserveFollowOpacity
    });
  }
  componentDidMount() {
    if (this.props.isLead) {
      this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout);
    }
  }
  shouldComponentUpdate(nextProps) {
    const { isLead, isExiting, isOverlayed, animatesLayout, transition, sharedLayoutContext } = nextProps;
    this.isExiting = isExiting;
    if (isLead === void 0) return true;
    const hasBecomeLead = !this.props.isLead && isLead;
    const hasExitBeenCancelled = this.props.isExiting && !isExiting;
    const shouldPromote = hasBecomeLead || hasExitBeenCancelled;
    const shouldDemote = !!this.props.isLead && !isLead;
    const overlayChanged = this.props.isOverlayed !== isOverlayed;
    if (shouldPromote || shouldDemote) {
      this.projectionNodes.forEach((projection) => projection?.willUpdate());
    }
    if (shouldPromote) {
      sharedLayoutContext.schedulePromoteTree(this, transition, !!animatesLayout);
    } else if (overlayChanged) {
      sharedLayoutContext.scheduleProjectionDidUpdate();
    }
    return !!shouldPromote && !!animatesLayout;
  }
  addChild(child) {
    const layoutId = child.options.layoutId;
    if (layoutId) {
      this.projectionNodes.set(layoutId, child);
      this.setRootChild(child);
    }
  }
  /**
   * As children are added, make sure that `this.rootProjectionNode` is always the
   * child with the smallest depth.
   */
  setRootChild(child) {
    if (!this.rootProjectionNode) return this.rootProjectionNode = child;
    this.rootProjectionNode = this.rootProjectionNode.depth < child.depth ? this.rootProjectionNode : child;
  }
  removeChild(child) {
    const layoutId = child.options.layoutId;
    if (layoutId) {
      this.projectionNodes.delete(layoutId);
    }
  }
  render() {
    return /* @__PURE__ */ jsx21(SwitchLayoutGroupContext.Provider, { value: this.switchLayoutGroupContext, children: this.props.children });
  }
};
var SharedLayoutTree = (props) => {
  const sharedLayoutContext = React28.useContext(SharedLayoutContext);
  return /* @__PURE__ */ jsx21(LayoutTree, { ...props, sharedLayoutContext });
};

// ../../library/src/components/NavigationContainerContext.tsx
import React29, { useContext as useContext10 } from "react";
var NavigationContainerContext = /* @__PURE__ */ React29.createContext(true);
function useIsInCurrentNavigationTarget() {
  const isInCurrentNavigationTarget = useContext10(NavigationContainerContext);
  return isInCurrentNavigationTarget;
}

// ../../library/src/components/NavigationTargetContext.tsx
import { createContext as createContext4, useCallback as useCallback8, useContext as useContext11, useEffect as useEffect11, useRef as useRef10 } from "react";

// ../../library/src/components/utils/useMap.ts
function newMap() {
  return /* @__PURE__ */ new Map();
}
function useMap() {
  return useConstant(newMap);
}

// ../../library/src/components/NavigationTargetContext.tsx
import { jsx as jsx22 } from "react/jsx-runtime";
var NavigationTargetContext = /* @__PURE__ */ createContext4({ register: () => {
}, deregister: () => {
} });
var NavigationTargetWrapper = ({ isCurrent, isOverlayed, children }) => {
  const callbacks = useMap();
  const register = useCallback8(
    (fn) => {
      if (callbacks.has(fn)) {
        console.warn("NavigationTargetWrapper: already registered");
        return;
      }
      callbacks.set(fn, void 0);
    },
    [
      callbacks
      /* constant, so should never change */
    ]
  );
  const deregister = useCallback8(
    (fn) => {
      const cleanup = callbacks.get(fn);
      cleanup?.();
      callbacks.delete(fn);
    },
    [
      callbacks
      /* constant, so should never change */
    ]
  );
  const value = useRef10({ register, deregister }).current;
  useEffect11(() => {
    callbacks.forEach((_, cb) => {
      const newCleanup = cb(isCurrent, isOverlayed);
      callbacks.set(cb, isFunction(newCleanup) ? newCleanup : void 0);
    });
    return () => {
      callbacks.forEach((cleanup, cb) => {
        if (!cleanup) return;
        cleanup();
        callbacks.set(cb, void 0);
      });
    };
  }, [
    isCurrent,
    isOverlayed,
    callbacks
    /* constant, so should never change */
  ]);
  return /* @__PURE__ */ jsx22(NavigationTargetContext.Provider, { value, children });
};
function useOnCurrentTargetChange(callback, deps = []) {
  const { register, deregister } = useContext11(NavigationTargetContext);
  useEffect11(() => {
    if (!callback) return;
    register(callback);
    return () => deregister(callback);
  }, [register, deregister, ...deps]);
}

// ../../library/src/components/NavigationContainer.tsx
import { jsx as jsx23, jsxs as jsxs5 } from "react/jsx-runtime";
var NavigationContainer = /* @__PURE__ */ React30.memo(function NavigationContainer2({
  isLayeredContainer,
  isCurrent,
  isPrevious,
  isOverlayed = false,
  visible,
  transitionProps,
  children,
  backdropColor,
  onTapBackdrop,
  backfaceVisible,
  exitBackfaceVisible,
  animation,
  exitAnimation,
  instant,
  initialProps,
  exitProps,
  position = { top: 0, right: 0, bottom: 0, left: 0 },
  withMagicMotion,
  index,
  areMagicMotionLayersPresent,
  id,
  isInitial
}) {
  const animate3 = useAnimation();
  const presence = useContext12(PresenceContext);
  const { persistLayoutIdCache } = useContext12(LayoutIdContext);
  const previousState = useRef11({
    wasCurrent: void 0,
    wasPrevious: false,
    wasBeingRemoved: false,
    wasReset: true,
    origins: getOriginProps({}, initialProps, transitionProps)
  });
  const viewportRef = useRef11(null);
  const isBeingRemoved = presence !== null && !presence.isPresent;
  if (isCurrent && previousState.current.wasCurrent === void 0) persistLayoutIdCache();
  useEffect12(() => {
    if (isLayeredContainer || !animate3) return;
    if (isBeingRemoved) {
      previousState.current = {
        ...previousState.current,
        wasBeingRemoved: isBeingRemoved
      };
      return;
    }
    const { wasPrevious, wasCurrent } = previousState.current;
    const shouldAnimateIn = isCurrent && !wasCurrent || // If the screen was being removed as a result of a "go back" transition, but that removal is interrupted,
    // resulting in this screen being restored to the current screen, we need to trigger an animation.
    !isBeingRemoved && previousState.current.wasBeingRemoved && isCurrent;
    const shouldAnimateOut = isPrevious && !wasPrevious;
    const origins = getOriginProps(previousState.current.origins, initialProps, transitionProps);
    let wasReset = previousState.current.wasReset;
    if (shouldAnimateIn || shouldAnimateOut) {
      animate3.stop();
      void animate3.start({
        zIndex: index,
        ...origins,
        // @TODO: Ignored for now, but should re-check later.
        ...transitionProps
        // biome-ignore lint/suspicious/noExplicitAny: has been this way from before the biome introduction
      });
      wasReset = false;
    } else if (wasReset === false) {
      animate3.stop();
      animate3.set({ zIndex: index, ...allAnimatableProperties, opacity: 0 });
      wasReset = true;
    }
    previousState.current = {
      wasCurrent: !!isCurrent,
      wasPrevious: !!isPrevious,
      wasBeingRemoved: false,
      wasReset,
      origins
    };
  }, [isCurrent, isPrevious, isBeingRemoved]);
  const transition = instant ? { type: false } : "velocity" in animation ? { ...animation, velocity: 0 } : animation;
  const exitTransition = instant ? { type: false } : exitAnimation || animation;
  const layout = { ...position };
  if (layout.left === void 0 || layout.right === void 0) layout.width = "auto";
  if (layout.top === void 0 || layout.bottom === void 0) layout.height = "auto";
  const needsPerspective = contains3Dprops(transitionProps) || contains3Dprops(initialProps);
  const perspective = needsPerspective && (isLayeredContainer || isCurrent || isPrevious) ? 1200 : void 0;
  const identity = { ...allAnimatableProperties, ...previousState.current.origins };
  const animations2 = isLayeredContainer ? {
    // biome-ignore lint/suspicious/noExplicitAny: has been this way from before the biome introduction
    initial: { ...identity, ...initialProps },
    // biome-ignore lint/suspicious/noExplicitAny: has been this way from before the biome introduction
    animate: { ...identity, ...transitionProps, transition },
    // Overlay animations are sometimes instant
    // biome-ignore lint/suspicious/noExplicitAny: has been this way from before the biome introduction
    exit: { ...identity, ...exitProps, transition: animation }
    // Overlay exits are always animated
  } : {
    animate: animate3,
    // biome-ignore lint/suspicious/noExplicitAny: has been this way from before the biome introduction
    exit: { ...identity, ...exitProps, transition: exitTransition }
  };
  const isPresent = !(isBeingRemoved || areMagicMotionLayersPresent === false);
  const isCurrentTarget = !!isCurrent && isPresent;
  const forceOpacity = isCurrent && isInitial;
  return /* @__PURE__ */ jsxs5(
    FrameWithMotion,
    {
      "data-framer-component-type": "NavigationContainerWrapper",
      width: "100%",
      height: "100%",
      style: {
        position: "absolute",
        transformStyle: "flat",
        backgroundColor: "transparent",
        overflow: "hidden",
        // Unlike Overlays, Screens set zIndex via animation controls to ensure it's set in parallel with the animation being played.
        // However, when a screen exits, it needs to preserve it's zIndex, which can't be applied through an `exit` animation,
        // and might be impacted by the layer created by `perspective`.
        zIndex: isLayeredContainer || isBeingRemoved || isCurrent && withMagicMotion ? index : void 0,
        pointerEvents: void 0,
        visibility: visible ? "visible" : "hidden",
        perspective
      },
      children: [
        isLayeredContainer && /* @__PURE__ */ jsx23(
          FrameWithMotion,
          {
            width: "100%",
            height: "100%",
            "data-framer-component-type": "NavigationContainerBackdrop",
            transition: animation,
            initial: { opacity: instant && visible ? 1 : 0 },
            animate: { opacity: 1 },
            exit: { opacity: 0 },
            backgroundColor: backdropColor ? backdropColor : "transparent",
            onTap: !isBeingRemoved ? onTapBackdrop : void 0
          }
        ),
        /* @__PURE__ */ jsx23(
          FrameWithMotion,
          {
            ...layout,
            ...animations2,
            transition: {
              default: transition,
              originX: { type: false },
              originY: { type: false },
              originZ: { type: false }
            },
            backgroundColor: "transparent",
            backfaceVisible: !isBeingRemoved ? backfaceVisible : exitBackfaceVisible,
            "data-framer-component-type": "NavigationContainer",
            "data-framer-is-current-navigation-target": !!isCurrent,
            style: {
              pointerEvents: void 0,
              // When we mount a new screen that is going to be animated in with animation controls,
              // we need to ensure that the screen is hidden until the animation starts.
              opacity: forceOpacity || isLayeredContainer || isCurrent && withMagicMotion ? 1 : 0
            },
            "data-is-present": isPresent ? void 0 : false,
            ref: viewportRef,
            children: /* @__PURE__ */ jsx23(ViewportContext.Provider, { value: viewportRef, children: /* @__PURE__ */ jsx23(NavigationContainerContext.Provider, { value: isCurrentTarget, children: /* @__PURE__ */ jsx23(NavigationTargetWrapper, { isCurrent: isCurrentTarget, isOverlayed, children: /* @__PURE__ */ jsx23(
              SharedLayoutTree,
              {
                isLead: isCurrent,
                animatesLayout: !!withMagicMotion,
                transition,
                isExiting: !isPresent,
                isOverlayed,
                id,
                children
              }
            ) }) }) })
          }
        )
      ]
    }
  );
}, shouldUsePreviousValue);
function shouldUsePreviousValue(prevProps, nextProps) {
  if (nextProps.isCurrent === void 0) return false;
  if (prevProps.isCurrent !== nextProps.isCurrent) return false;
  if (prevProps.isPrevious !== nextProps.isPrevious) return false;
  if (nextProps.isCurrent && prevProps.isOverlayed !== nextProps.isOverlayed) return false;
  return true;
}
function getOriginProps(currentOriginProps, initialProps, transitionProps) {
  const result = { ...currentOriginProps };
  if (initialProps) {
    if (isFiniteNumber(initialProps.originX)) result.originX = initialProps.originX;
    if (isFiniteNumber(initialProps.originY)) result.originY = initialProps.originY;
    if (isFiniteNumber(initialProps.originZ)) result.originZ = initialProps.originZ;
  }
  if (transitionProps) {
    if (isFiniteNumber(transitionProps.originX)) result.originX = transitionProps.originX;
    if (isFiniteNumber(transitionProps.originY)) result.originY = transitionProps.originY;
    if (isFiniteNumber(transitionProps.originZ)) result.originZ = transitionProps.originZ;
  }
  return result;
}
function contains3Dprops(containerProps) {
  if (!containerProps) return false;
  const containsProps = "rotateX" in containerProps || "rotateY" in containerProps || "z" in containerProps;
  if (!containsProps) return false;
  const toPropsContain3d = containerProps.rotateX !== 0 || containerProps.rotateY !== 0 || containerProps.z !== 0;
  const fromPropsContain3d = containerProps?.transition?.rotateX.from !== 0 || containerProps?.transition?.rotateY.from !== 0 || containerProps?.transition?.z.from !== 0;
  return toPropsContain3d || fromPropsContain3d;
}
var allAnimatableProperties = {
  x: 0,
  y: 0,
  z: 0,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  scale: 1,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  skew: 0,
  skewX: 0,
  skewY: 0,
  originX: 0.5,
  originY: 0.5,
  originZ: 0,
  opacity: 1
};

// ../../library/src/components/NavigationContext.ts
import { createContext as createContext5 } from "react";

// ../../library/src/components/NavigatorMock.tsx
var NavigatorMock = class {
  constructor() {
    __publicField(this, "warning", () => {
      warnOnce2("The Navigator API is only available inside of Framer: https://www.framer.com/");
    });
    __publicField(this, "goBack", () => this.warning());
    __publicField(this, "instant", () => this.warning());
    __publicField(this, "fade", () => this.warning());
    __publicField(this, "push", () => this.warning());
    __publicField(this, "modal", () => this.warning());
    __publicField(this, "overlay", () => this.warning());
    __publicField(this, "flip", () => this.warning());
    __publicField(this, "customTransition", () => this.warning());
    __publicField(this, "magicMotion", () => this.warning());
  }
};
var navigatorMock = /* @__PURE__ */ new NavigatorMock();

// ../../library/src/components/NavigationContext.ts
var NavigationContext = /* @__PURE__ */ createContext5(navigatorMock);

// ../../library/src/components/NavigationTransitions.ts
var TransitionDefaults = {
  Fade: {
    exit: { opacity: 0 },
    enter: { opacity: 0 }
  },
  PushLeft: {
    exit: { x: "-30%" },
    enter: { x: "100%" }
  },
  PushRight: {
    exit: { x: "30%" },
    enter: { x: "-100%" }
  },
  PushUp: {
    exit: { y: "-30%" },
    enter: { y: "100%" }
  },
  PushDown: {
    exit: { y: "30%" },
    enter: { y: "-100%" }
  },
  Instant: {
    animation: { type: false },
    enter: { opacity: 0 }
  },
  Modal: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { center: true },
    enter: { opacity: 0, scale: 1.2 }
  },
  OverlayLeft: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { right: 0, top: 0, bottom: 0 },
    enter: { x: "100%" }
  },
  OverlayRight: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { left: 0, top: 0, bottom: 0 },
    enter: { x: "-100%" }
  },
  OverlayUp: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { bottom: 0, left: 0, right: 0 },
    enter: { y: "100%" }
  },
  OverlayDown: {
    overCurrentContext: true,
    goBackOnTapOutside: true,
    position: { top: 0, left: 0, right: 0 },
    enter: { y: "-100%" }
  },
  FlipLeft: {
    backfaceVisible: false,
    exit: { rotateY: -180 },
    enter: { rotateY: 180 }
  },
  FlipRight: {
    backfaceVisible: false,
    exit: { rotateY: 180 },
    enter: { rotateY: -180 }
  },
  FlipUp: {
    backfaceVisible: false,
    exit: { rotateX: 180 },
    enter: { rotateX: -180 }
  },
  FlipDown: {
    backfaceVisible: false,
    exit: { rotateX: -180 },
    enter: { rotateX: 180 }
  },
  MagicMotion: {
    withMagicMotion: true
  }
};
function pushTransition(options) {
  const side = options && options.appearsFrom ? options.appearsFrom : "right";
  switch (side) {
    case "right":
      return TransitionDefaults.PushLeft;
    case "left":
      return TransitionDefaults.PushRight;
    case "bottom":
      return TransitionDefaults.PushUp;
    case "top":
      return TransitionDefaults.PushDown;
  }
}
function overlayTransition(options) {
  const side = options && options.appearsFrom ? options.appearsFrom : "bottom";
  switch (side) {
    case "right":
      return TransitionDefaults.OverlayLeft;
    case "left":
      return TransitionDefaults.OverlayRight;
    case "bottom":
      return TransitionDefaults.OverlayUp;
    case "top":
      return TransitionDefaults.OverlayDown;
  }
}
function flipTransition(options) {
  const side = options && options.appearsFrom ? options.appearsFrom : "bottom";
  switch (side) {
    case "right":
      return TransitionDefaults.FlipLeft;
    case "left":
      return TransitionDefaults.FlipRight;
    case "bottom":
      return TransitionDefaults.FlipUp;
    case "top":
      return TransitionDefaults.FlipDown;
  }
}

// ../../library/src/components/reduceNavigationStateForAction.ts
var defaultState = () => ({
  current: -1,
  previous: -1,
  currentOverlay: -1,
  previousOverlay: -1,
  visualIndex: 0,
  overlayItemId: 0,
  historyItemId: 0,
  history: [],
  overlayStack: [],
  containers: {},
  containerIndex: {},
  containerVisualIndex: {},
  containerIsRemoved: {},
  transitionForContainer: {},
  previousTransition: null
});
function reduceNavigationStateForAction(state, action) {
  switch (action.type) {
    case "addOverlay":
      return addOverlay(state, action.transition, action.component);
    case "removeOverlay":
      return removeOverlay(state);
    case "add":
      return add(state, action.key, action.transition, action.component);
    case "remove":
      return remove(state);
    case "update":
      return updateComponent(state, action.key, action.component);
    case "back":
      return back(state);
    case "forward":
      return forward(state);
    default:
      return;
  }
}
function updateComponent(currentState, key7, component) {
  return {
    ...currentState,
    containers: {
      ...currentState.containers,
      [key7]: component
    }
  };
}
function addOverlay(currentState, transition, component) {
  const currentOverlay = currentState.overlayStack[currentState.currentOverlay];
  if (currentOverlay && currentOverlay.component === component) return;
  const overlayItemId = currentState.overlayItemId + 1;
  const overlayStack = [
    ...currentState.overlayStack,
    {
      key: `stack-${overlayItemId}`,
      component,
      transition
    }
  ];
  return {
    ...currentState,
    overlayStack,
    overlayItemId,
    currentOverlay: Math.max(0, Math.min(currentState.currentOverlay + 1, overlayStack.length - 1)),
    previousOverlay: currentState.currentOverlay
  };
}
function removeOverlay(currentState) {
  return {
    ...currentState,
    overlayStack: [],
    currentOverlay: -1,
    previousOverlay: currentState.currentOverlay
  };
}
function add(currentState, key7, transition, component) {
  if (!currentState.containers[key7]) currentState.containers[key7] = component;
  currentState.history = currentState.history.slice(0, currentState.current + 1);
  currentState.visualIndex = Math.max(currentState.history.length, 0);
  const currentItem = currentState.history[currentState.history.length - 1];
  const isCurrentScreen = currentItem && currentItem.key === key7;
  currentState.overlayStack = [];
  if (isCurrentScreen && currentState.currentOverlay > -1) {
    return {
      ...currentState,
      currentOverlay: -1,
      previousOverlay: currentState.currentOverlay
    };
  }
  if (isCurrentScreen) return;
  const nextIndex = currentState.containerVisualIndex[key7];
  const removed = currentState.containerIsRemoved[key7];
  const shouldMoveForward = currentItem?.key && transition.withMagicMotion ? isNextTargetForward(key7, nextIndex, removed, currentState.history) : true;
  currentState.history.push({
    key: key7,
    transition,
    visualIndex: shouldMoveForward ? Math.max(currentState.visualIndex, 0) : currentState.containerVisualIndex[key7]
  });
  const current = currentState.current + 1;
  const previous = currentState.current;
  for (const containerKey in currentState.containerIndex) {
    if (currentState.containerIndex[containerKey] === current) {
      currentState.containerIndex[containerKey] = findLatestHistoryIndex(containerKey, currentState.history);
    }
  }
  currentState.containerIndex[key7] = current;
  const { containerVisualIndex, containerIsRemoved } = magicMotionPropsForAdd(currentState, key7, shouldMoveForward);
  const transitionForContainer = updateTransitions(
    current,
    previous,
    currentState.history,
    currentState.containerIndex,
    currentState.transitionForContainer
  );
  return {
    ...currentState,
    current,
    previous,
    containerVisualIndex,
    containerIsRemoved,
    transitionForContainer,
    previousTransition: null,
    currentOverlay: -1,
    historyItemId: currentState.historyItemId + 1,
    previousOverlay: currentState.currentOverlay
  };
}
function back(currentState) {
  const containers = { ...currentState.containers };
  const nextState = remove(currentState);
  if (!nextState) return;
  nextState.containers = containers;
  return nextState;
}
function forward(currentState) {
  const nextItem = currentState.history[currentState.current + 1];
  if (!nextItem) return;
  const { key: key7, transition, component } = nextItem;
  const history = [...currentState.history];
  const nextState = add(currentState, key7, transition, component);
  if (!nextState) return;
  nextState.history = history;
  return nextState;
}
function remove(currentState) {
  const history = [...currentState.history.slice(0, currentState.current + 1)];
  if (history.length === 1) return;
  const currentItem = history.pop();
  if (!currentItem) return;
  const target = history[history.length - 1];
  assert(target, "The navigation history must have at least one component");
  currentState.containerIndex[target.key] = history.length - 1;
  const shouldRemoveContainer = history.every((item) => item.key !== currentItem.key);
  if (shouldRemoveContainer) {
    delete currentState.containers[currentItem.key];
  }
  const current = currentState.current - 1;
  const previous = currentState.current;
  const { containerIsRemoved, containerVisualIndex, previousTransition, visualIndex } = magicMotionPropsForRemove(
    currentState,
    target,
    currentItem
  );
  const transitionForContainer = updateTransitions(
    current,
    previous,
    currentState.history,
    currentState.containerIndex,
    currentState.transitionForContainer
  );
  return {
    ...currentState,
    current,
    previous,
    containerIsRemoved,
    containerVisualIndex,
    previousTransition,
    visualIndex,
    transitionForContainer
  };
}
function magicMotionPropsForAdd(currentState, nextKey, shouldMoveForward) {
  const update = {
    containerVisualIndex: { ...currentState.containerVisualIndex },
    containerIsRemoved: { ...currentState.containerIsRemoved }
  };
  if (shouldMoveForward) {
    update.containerVisualIndex[nextKey] = currentState.history.length - 1;
    update.containerIsRemoved[nextKey] = false;
  } else {
    const nextVisualIndex = currentState.containerVisualIndex[nextKey];
    for (const [key7, visualIndex] of Object.entries(currentState.containerVisualIndex)) {
      if (nextVisualIndex !== void 0 && visualIndex > nextVisualIndex) {
        update.containerIsRemoved[key7] = true;
      }
    }
  }
  return update;
}
function magicMotionPropsForRemove(currentState, target, currentItem) {
  const validTargets = [target.key, currentItem.key];
  const nextValidTarget = currentState.history[currentState.history.length - 2];
  const previousTransition = currentState.previousTransition === null ? null : { ...currentState.previousTransition };
  const update = {
    containerIsRemoved: { ...currentState.containerIsRemoved },
    containerVisualIndex: { ...currentState.containerVisualIndex },
    previousTransition,
    visualIndex: currentState.visualIndex
  };
  if (nextValidTarget) validTargets.push(nextValidTarget.key);
  const targetVisualIndex = currentState.containerVisualIndex[target.key];
  const currentVisualIndex = currentState.containerVisualIndex[currentItem.key];
  const shouldRemoveLastKey = targetVisualIndex !== void 0 && currentVisualIndex !== void 0 && targetVisualIndex <= currentVisualIndex || target.visualIndex !== void 0 && target.visualIndex < currentState.history.length - 1;
  const nextIndex = target.visualIndex;
  if (shouldRemoveLastKey) {
    update.containerIsRemoved[currentItem.key] = true;
    update.containerVisualIndex[target.key] = nextIndex !== void 0 ? nextIndex : currentState.history.length - 1;
  } else {
    update.visualIndex = currentState.visualIndex + 1;
    update.containerVisualIndex[target.key] = currentState.visualIndex + 1;
  }
  if (currentItem.transition.withMagicMotion) update.previousTransition = currentItem.transition || null;
  currentState.containerIsRemoved[target.key] = false;
  return update;
}
function findLatestHistoryIndex(key7, history) {
  for (let index = history.length; index > history.length; index--) {
    if (history[index]?.key === key7) return index;
  }
  return -1;
}
function updateTransitions(current, previous, history, containerIndex, transitionForContainer) {
  const transitions = { ...transitionForContainer };
  for (const [key7, screenIndex] of Object.entries(containerIndex)) {
    const transition = transitionForScreen(screenIndex, { current, previous, history });
    if (transition) {
      transitions[key7] = transition;
    }
  }
  return transitions;
}
function isNextTargetForward(key7, index, removed, history) {
  if (removed || index === void 0) return true;
  if (index === 0) return false;
  const forwardHistory = history.slice(index, history.length);
  if (forwardHistory.findIndex((item) => item.key === key7) > -1) return true;
  const backwardsHistory = history.slice(0, index - 1);
  if (backwardsHistory.findIndex((item) => item.key === key7) > -1) return false;
  return true;
}
function transitionForScreen(screenIndex, stackState) {
  const { current, previous, history } = stackState;
  if (screenIndex !== current && screenIndex !== previous) return void 0;
  if (screenIndex === current && current > previous) {
    const item = history[screenIndex];
    return sequence("enter", item?.transition.enter, item?.transition.animation);
  }
  if (screenIndex === previous && current > previous) {
    const item = history[screenIndex + 1];
    return sequence("exit", item?.transition.exit, item?.transition.animation);
  }
  if (screenIndex === current && current < previous) {
    const item = history[screenIndex + 1];
    return sequence("enter", item?.transition.exit, item?.transition.animation);
  }
  if (screenIndex === previous && current < previous) {
    const item = history[screenIndex];
    return sequence("exit", item?.transition.enter, item?.transition.animation);
  }
}
var allAnimatableKeys = /* @__PURE__ */ objectKeys(allAnimatableProperties);
function sequence(direction, transition, animation) {
  const value = {};
  const from = {};
  allAnimatableKeys.forEach((property) => {
    value[property] = allAnimatableProperties[property];
    from[property] = {
      ...animation,
      from: allAnimatableProperties[property]
    };
  });
  if (transition) {
    Object.keys(transition).forEach((property) => {
      if (transition[property] === void 0) return;
      const transitionTo = transition[property];
      const transitionFrom = typeof transition[property] === "string" ? `${asRecord(allAnimatableProperties)[property]}%` : asRecord(allAnimatableProperties)[property];
      asRecord(value)[property] = direction === "enter" ? transitionFrom : transitionTo;
      from[property] = {
        ...animation,
        from: direction === "enter" ? transitionTo : transitionFrom,
        velocity: 0
      };
    });
  }
  return {
    ...value,
    transition: {
      ...from
    }
  };
}

// ../../library/src/components/Navigation.tsx
import { jsx as jsx24, jsxs as jsxs6 } from "react/jsx-runtime";
var NavigationConsumer = /* @__PURE__ */ (() => NavigationContext.Consumer)();
var NavigationCallbackContext = /* @__PURE__ */ React31.createContext(void 0);
var NavigationCallbackProvider = /* @__PURE__ */ (() => NavigationCallbackContext.Provider)();
var IsInitialNavigationContext = /* @__PURE__ */ React31.createContext(void 0);
var Navigation = /* @__PURE__ */ (() => {
  var _lastEventTimeStamp, _a, _Navigation_instances, getStackState_fn, isSameEventTransition_fn, _navigationAction, transition_fn;
  return _a = class extends Component6 {
    constructor(props) {
      super(props);
      __privateAdd(this, _Navigation_instances);
      __privateAdd(this, _lastEventTimeStamp, null);
      __publicField(this, "state", defaultState());
      __privateAdd(this, _navigationAction, (action) => {
        if (!this.props.enabled && this.state.history.length > 0) return;
        const newState = reduceNavigationStateForAction(this.state, action);
        if (!newState) return;
        const { skipLayoutAnimation } = this.props;
        const historyItem = newState.history[newState.current];
        const withMagicMotion = action.type === "add" && action.transition.withMagicMotion || action.type === "forward" && historyItem?.transition.withMagicMotion || action.type === "remove" && !!newState.previousTransition;
        const updateState = () => {
          this.setState(newState);
          if (historyItem?.key) {
            this.context?.(historyItem.key);
          }
        };
        if (skipLayoutAnimation && !withMagicMotion) {
          skipLayoutAnimation(updateState);
        } else {
          updateState();
        }
      });
      __publicField(this, "goBack", () => {
        if (__privateMethod(this, _Navigation_instances, isSameEventTransition_fn).call(this)) return;
        __privateSet(this, _lastEventTimeStamp, globalThis.event?.timeStamp || null);
        if (this.state.currentOverlay !== -1) return __privateGet(this, _navigationAction).call(this, { type: "removeOverlay" });
        return __privateGet(this, _navigationAction).call(this, { type: "remove" });
      });
      const component = this.props.children;
      if (!component || !isReactChild(component) || !isReactElement(component)) return;
      const transition = { ...TransitionDefaults.Instant };
      const key7 = component.key?.toString() || `stack-${this.state.historyItemId + 1}`;
      const action = { type: "add", key: key7, transition, component };
      const newState = reduceNavigationStateForAction(this.state, action);
      if (!newState) return;
      this.state = newState;
    }
    componentDidMount() {
      const historyItem = this.state.history[this.state.current];
      if (!historyItem) return;
      this.context?.(historyItem.key);
    }
    UNSAFE_componentWillReceiveProps(props) {
      const component = props["children"];
      if (!isReactChild(component) || !isReactElement(component)) return;
      const key7 = component.key?.toString();
      if (!key7) return;
      if (this.state.history.length === 0) {
        __privateMethod(this, _Navigation_instances, transition_fn).call(this, component, TransitionDefaults.Instant);
      } else {
        __privateGet(this, _navigationAction).call(this, { type: "update", key: key7, component });
      }
    }
    componentWillUnmount() {
      this.props.resetProjection?.();
    }
    instant(component) {
      __privateMethod(this, _Navigation_instances, transition_fn).call(this, component, TransitionDefaults.Instant, void 0);
    }
    fade(component, options) {
      __privateMethod(this, _Navigation_instances, transition_fn).call(this, component, TransitionDefaults.Fade, options);
    }
    push(component, options) {
      __privateMethod(this, _Navigation_instances, transition_fn).call(this, component, pushTransition(options), options);
    }
    modal(component, options) {
      __privateMethod(this, _Navigation_instances, transition_fn).call(this, component, TransitionDefaults.Modal, options);
    }
    overlay(component, options) {
      __privateMethod(this, _Navigation_instances, transition_fn).call(this, component, overlayTransition(options), options);
    }
    flip(component, options) {
      __privateMethod(this, _Navigation_instances, transition_fn).call(this, component, flipTransition(options), options);
    }
    magicMotion(component, options) {
      __privateMethod(this, _Navigation_instances, transition_fn).call(this, component, TransitionDefaults.MagicMotion, options);
    }
    customTransition(component, transition) {
      __privateMethod(this, _Navigation_instances, transition_fn).call(this, component, transition);
    }
    render() {
      const stackState = __privateMethod(this, _Navigation_instances, getStackState_fn).call(this, { overCurrentContext: false });
      const overlayStackState = __privateMethod(this, _Navigation_instances, getStackState_fn).call(this, { overCurrentContext: true });
      const activeOverlay = activeOverlayItem(overlayStackState);
      const isOverlayVisible = overlayStackState.current > -1;
      const isInitial = this.state.history.length === 1;
      const contentContainers = [];
      for (const [key7, component] of Object.entries(this.state.containers)) {
        const index = this.state.containerIndex[key7];
        assert(index !== void 0, "Container's index must be registered");
        const visualIndex = this.state.containerVisualIndex[key7];
        assert(visualIndex !== void 0, "Container's visual index must be registered");
        const removed = this.state.containerIsRemoved[key7];
        const historyItem = this.state.history[index];
        const transitionProps = this.state.transitionForContainer[key7];
        const isCurrent = index === this.state.current;
        const isPrevious = index === this.state.previous;
        const areMagicMotionLayersPresent = isCurrent ? false : removed;
        const withMagicMotion = historyItem?.transition?.withMagicMotion || isCurrent && !!this.state.previousTransition;
        contentContainers.push(
          /* @__PURE__ */ jsx24(
            NavigationContainer,
            {
              id: key7,
              index: visualIndex,
              isInitial,
              isCurrent,
              isPrevious,
              isOverlayed: isOverlayVisible,
              visible: isCurrent || isPrevious,
              position: historyItem?.transition?.position,
              instant: isInstantContainerTransition(index, stackState),
              transitionProps,
              animation: animationPropsForContainer(index, stackState),
              backfaceVisible: getBackfaceVisibleForScreen(index, stackState),
              exitAnimation: historyItem?.transition?.animation,
              exitBackfaceVisible: historyItem?.transition?.backfaceVisible,
              exitProps: historyItem?.transition?.enter,
              withMagicMotion,
              areMagicMotionLayersPresent: areMagicMotionLayersPresent ? false : void 0,
              children: /* @__PURE__ */ jsx24(MagicMotionCrossfadeRoot, { children: containerContent({
                component,
                transition: historyItem?.transition
              }) })
            },
            key7
          )
        );
      }
      const overlayContainers = this.state.overlayStack.map((item, stackIndex) => {
        return /* @__PURE__ */ jsx24(
          NavigationContainer,
          {
            isLayeredContainer: true,
            isCurrent: stackIndex === this.state.currentOverlay,
            position: item.transition.position,
            initialProps: initialPropsForOverlay(stackIndex, overlayStackState),
            transitionProps: transitionPropsForOverlay(stackIndex, overlayStackState),
            instant: isInstantContainerTransition(stackIndex, overlayStackState, true),
            animation: animationPropsForContainer(stackIndex, overlayStackState),
            exitProps: item.transition.enter,
            visible: containerIsVisible(stackIndex, overlayStackState),
            backdropColor: backdropColorForTransition(item.transition),
            backfaceVisible: getBackfaceVisibleForOverlay(stackIndex, overlayStackState),
            onTapBackdrop: backdropTapAction(item.transition, this.goBack),
            index: this.state.current + 1 + stackIndex,
            children: containerContent({
              component: item.component,
              transition: item.transition
            })
          },
          item.key
        );
      });
      return /* @__PURE__ */ jsx24(
        FrameWithMotion,
        {
          "data-framer-component-type": "NavigationRoot",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          position: "relative",
          style: {
            overflow: "hidden",
            backgroundColor: "unset",
            pointerEvents: void 0,
            ...this.props.style
          },
          children: /* @__PURE__ */ jsx24(NavigationContext.Provider, { value: this, children: /* @__PURE__ */ jsxs6(IsInitialNavigationContext.Provider, { value: isInitial, children: [
            /* @__PURE__ */ jsx24(
              NavigationContainer,
              {
                isLayeredContainer: true,
                position: void 0,
                initialProps: {},
                instant: false,
                transitionProps: transitionPropsForStackWrapper(activeOverlay),
                animation: animationForStackWrapper(activeOverlay),
                backfaceVisible: backfaceVisibleForStackWrapper(activeOverlay),
                visible: true,
                backdropColor: void 0,
                onTapBackdrop: void 0,
                index: 0,
                children: /* @__PURE__ */ jsx24(LayoutIdProvider, { children: /* @__PURE__ */ jsx24(SharedLayoutRoot, { children: /* @__PURE__ */ jsx24(AnimatePresence, { presenceAffectsLayout: false, children: contentContainers }) }) })
              }
            ),
            /* @__PURE__ */ jsx24(AnimatePresence, { children: overlayContainers })
          ] }) })
        }
      );
    }
  }, _lastEventTimeStamp = new WeakMap(), _Navigation_instances = new WeakSet(), getStackState_fn = function(options) {
    const { current, previous, currentOverlay, previousOverlay } = this.state;
    if (options.overCurrentContext) {
      return {
        current: currentOverlay,
        previous: previousOverlay,
        history: this.state.overlayStack
      };
    }
    return {
      current,
      previous,
      history: this.state.history
    };
  }, /**
   * To prevent bubbling events from triggering multiple transitions,
   * we ensure that the current event has a different timestamp then the event that triggered the last transition.
   * We use Window.event to ensure that even transitions invoked by code components - and may not pass a reference to the event - are caught.
   * This works better than measuring the time of transition calls with performance.now()
   * because the time between calls can get longer and longer as more screens are added to the stack,
   * preventing a deterministic time between transitions to be used to determine if they were triggered at the same time or not.
   */
  isSameEventTransition_fn = function() {
    if (!globalThis.event) return false;
    return __privateGet(this, _lastEventTimeStamp) === globalThis.event.timeStamp;
  }, _navigationAction = new WeakMap(), transition_fn = function(component, transitionTraits, transitionOptions) {
    if (__privateMethod(this, _Navigation_instances, isSameEventTransition_fn).call(this)) return;
    __privateSet(this, _lastEventTimeStamp, globalThis.event?.timeStamp || null);
    if (!component || !isReactChild(component) || !isReactElement(component)) return;
    const transition = { ...transitionTraits, ...transitionOptions };
    const overCurrentContext = !!transition.overCurrentContext;
    if (overCurrentContext) return __privateGet(this, _navigationAction).call(this, { type: "addOverlay", transition, component });
    const key7 = component.key?.toString() || `stack-${this.state.historyItemId + 1}`;
    __privateGet(this, _navigationAction).call(this, { type: "add", key: key7, transition, component });
  }, __publicField(_a, "defaultProps", {
    enabled: true
  }), __publicField(_a, "contextType", NavigationCallbackContext), _a;
})();
var animationDefault = {
  stiffness: 500,
  damping: 50,
  restDelta: 1,
  type: "spring"
};
function activeOverlayItem(overlayStack) {
  let currentOverlayItem;
  let previousOverlayItem;
  if (overlayStack.current !== -1) {
    currentOverlayItem = overlayStack.history[overlayStack.current];
  } else {
    previousOverlayItem = overlayStack.history[overlayStack.previous];
  }
  return { currentOverlayItem, previousOverlayItem };
}
function transitionPropsForStackWrapper({ currentOverlayItem }) {
  return currentOverlayItem && currentOverlayItem.transition.exit;
}
function animationForStackWrapper({ currentOverlayItem, previousOverlayItem }) {
  if (currentOverlayItem && currentOverlayItem.transition.animation) {
    return currentOverlayItem.transition.animation;
  }
  if (previousOverlayItem && previousOverlayItem.transition.animation) {
    return previousOverlayItem.transition.animation;
  }
  return animationDefault;
}
function backfaceVisibleForStackWrapper({ currentOverlayItem, previousOverlayItem }) {
  if (currentOverlayItem) return currentOverlayItem.transition.backfaceVisible;
  return previousOverlayItem && previousOverlayItem.transition.backfaceVisible;
}
function backdropColorForTransition(transition) {
  if (transition.backdropColor) return transition.backdropColor;
  if (transition.overCurrentContext) return "rgba(4,4,15,.4)";
  return void 0;
}
function getBackfaceVisibleForOverlay(containerIndex, stackState) {
  const { current, history } = stackState;
  if (containerIndex === current) {
    const navigationItem = history[containerIndex];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.backfaceVisible;
    }
    return true;
  } else if (containerIndex < current) {
    const navigationItem = history[containerIndex + 1];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.backfaceVisible;
    }
    return true;
  } else {
    const navigationItem = history[containerIndex];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.backfaceVisible;
    }
    return true;
  }
}
function initialPropsForOverlay(containerIndex, stackState) {
  const navigationItem = stackState.history[containerIndex];
  if (navigationItem) return navigationItem.transition.enter;
}
function getBackfaceVisibleForScreen(screenIndex, stackState) {
  const { current, previous, history } = stackState;
  if (screenIndex === previous && current > previous || screenIndex === current && current < previous) {
    return history[screenIndex + 1]?.transition?.backfaceVisible;
  }
  return history[screenIndex]?.transition?.backfaceVisible;
}
function transitionPropsForOverlay(overlayIndex, stackState) {
  const { current, history } = stackState;
  if (overlayIndex === current) {
    return;
  } else if (overlayIndex < current) {
    const navigationItem = history[overlayIndex + 1];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.exit;
    }
  } else {
    const navigationItem = history[overlayIndex];
    if (navigationItem && navigationItem.transition) {
      return navigationItem.transition.enter;
    }
  }
}
function animationPropsForContainer(containerIndex, stackState) {
  const { current, previous, history } = stackState;
  const containerCurrent = previous > current ? previous : current;
  if (containerIndex < containerCurrent) {
    const navigationItem = history[containerIndex + 1];
    if (navigationItem && navigationItem.transition.animation) {
      return navigationItem.transition.animation;
    }
  } else if (containerIndex !== containerCurrent) {
    const navigationItem = history[containerIndex];
    if (navigationItem && navigationItem.transition.animation) {
      return navigationItem.transition.animation;
    }
  } else {
    const navigationItem = history[containerIndex];
    if (navigationItem?.transition.animation) {
      return navigationItem.transition.animation;
    }
  }
  return animationDefault;
}
function isInstantContainerTransition(containerIndex, stackState, overCurrentContext) {
  const { current, previous, history } = stackState;
  if (overCurrentContext && history.length > 1) return true;
  if (containerIndex !== previous && containerIndex !== current) return true;
  if (current === previous) return true;
  return false;
}
function containerIsVisible(containerIndex, stackState) {
  const { current, previous } = stackState;
  if (containerIndex > current && containerIndex > previous) return false;
  if (containerIndex === current) return true;
  return false;
}
function containerContent(item) {
  const content = React31.Children.map(
    item.component,
    (child) => {
      if (!isReactChild(child) || !isReactElement(child) || !child.props) {
        return child;
      }
      const props = {
        style: child.props.style ?? {}
      };
      const position = item?.transition?.position;
      const shouldStretchWidth = !position || position.left !== void 0 && position.right !== void 0;
      const shouldStretchHeight = !position || position.top !== void 0 && position.bottom !== void 0;
      const canStretchStyle = "style" in child.props ? isObject2(child.props.style) : true;
      if (shouldStretchWidth) {
        const canStretchWidth = "width" in child.props;
        if (canStretchWidth) props.width = "100%";
        if (canStretchStyle) props.style.width = "100%";
      }
      if (shouldStretchHeight) {
        const canStretchHeight = "height" in child.props;
        if (canStretchHeight) props.height = "100%";
        if (canStretchStyle) props.style.height = "100%";
      }
      return React31.cloneElement(child, props);
    }
  );
  return content;
}
function backdropTapAction(transition, goBackAction) {
  if (transition.goBackOnTapOutside !== false) return goBackAction;
}
function NavigationWrapper(props) {
  const resetProjection = useResetProjection();
  const skipLayoutAnimation = useInstantLayoutTransition();
  React31.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, []);
  return /* @__PURE__ */ jsx24(Navigation, { ...props, resetProjection, skipLayoutAnimation, children: props.children });
}

// ../../library/src/components/hoc/WithNavigator.tsx
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs(), 1);
import React32 from "react";

// ../../library/src/render/types/NavigationLink.ts
var NavigateTo = /* @__PURE__ */ ((NavigateTo2) => {
  NavigateTo2["Previous"] = "@Previous";
  return NavigateTo2;
})(NavigateTo || {});
var NavigationTransitionType = /* @__PURE__ */ ((NavigationTransitionType2) => {
  NavigationTransitionType2["push"] = "push";
  NavigationTransitionType2["instant"] = "instant";
  NavigationTransitionType2["fade"] = "fade";
  NavigationTransitionType2["modal"] = "modal";
  NavigationTransitionType2["overlay"] = "overlay";
  NavigationTransitionType2["flip"] = "flip";
  NavigationTransitionType2["magicMotion"] = "magicMotion";
  return NavigationTransitionType2;
})(NavigationTransitionType || {});

// ../../library/src/components/hoc/WithNavigator.tsx
import { jsx as jsx25 } from "react/jsx-runtime";
function WithNavigator(BaseComponent, navigationTransition, navigationTransitionDirection, NavigationTarget, navigationTransitionOptions) {
  const InternalWithNavigator = class extends React32.Component {
    render() {
      return /* @__PURE__ */ jsx25(NavigationContext.Consumer, { children: (navigation) => {
        const navigate = () => {
          if (navigationTransition === "goBack") {
            navigation.goBack();
            return;
          }
          if (!NavigationTarget) return;
          const component = NavigationTarget();
          const appearsFrom = transitionDirectionToSide(navigationTransitionDirection);
          switch (navigationTransition) {
            case "instant" /* instant */:
              navigation.instant(component);
              break;
            case "fade" /* fade */:
              navigation.fade(component);
              break;
            case "modal" /* modal */:
              navigation.modal(component, navigationTransitionOptions);
              break;
            case "push" /* push */:
              navigation.push(component, { appearsFrom });
              break;
            case "overlay" /* overlay */:
              navigation.overlay(component, {
                ...navigationTransitionOptions,
                appearsFrom
              });
              break;
            case "flip" /* flip */:
              navigation.flip(component, { appearsFrom });
              break;
            case "magicMotion" /* magicMotion */:
              navigation.magicMotion(component, {});
              break;
          }
        };
        const { onTap, ...props } = this.props;
        if (onTap) {
          props.onTap = (...args) => {
            onTap.apply(this, args);
            navigate.apply(this, args);
          };
        } else {
          props.onTap = navigate;
        }
        return /* @__PURE__ */ jsx25(BaseComponent, { ...props });
      } });
    }
  };
  (0, import_hoist_non_react_statics.default)(InternalWithNavigator, BaseComponent);
  return InternalWithNavigator;
}
function transitionDirectionToSide(direction) {
  switch (direction) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "up":
      return "bottom";
    case "down":
      return "top";
  }
}

// ../../library/src/components/AnimateLayout/AnimateSharedLayout.tsx
var AnimateSharedLayout = (props) => props.children;

// ../../library/src/render/presentation/Frame/index.tsx
import { forwardRef as forwardRef3 } from "react";

// ../../library/src/components/hoc/WithEvents.tsx
var import_hoist_non_react_statics3 = __toESM(require_hoist_non_react_statics_cjs(), 1);
import React34 from "react";

// ../../library/src/utils/events.ts
function pointForEvent(event, customTarget = null) {
  let target;
  if (customTarget instanceof HTMLElement) {
    target = customTarget;
  }
  if (!target && event.target instanceof HTMLElement) {
    target = event.target;
  }
  if (!target) {
    return { x: event.pageX, y: event.pageY };
  }
  if (typeof safeWindow.webkitConvertPointFromPageToNode === "function") {
    let webkitPoint = new safeWindow.WebKitPoint(event.pageX, event.pageY);
    webkitPoint = safeWindow.webkitConvertPointFromPageToNode(target, webkitPoint);
    return { x: webkitPoint.x, y: webkitPoint.y };
  }
  const rect = target.getBoundingClientRect();
  const width = parseFloat(target.style.width);
  const height = parseFloat(target.style.height);
  const scale2 = {
    x: width ? width / rect.width : 1,
    y: height ? height / rect.height : 1
  };
  const point = {
    x: scale2.x * (event.pageX - rect.left - target.clientLeft + target.scrollLeft),
    y: scale2.y * (event.pageY - rect.top - target.clientTop + target.scrollTop)
  };
  return point;
}

// ../../library/src/events/FramerEvent.ts
var FramerEvent = class _FramerEvent {
  /**
   * @internal
   */
  constructor(originalEvent, session) {
    this.originalEvent = originalEvent;
    this.session = session;
    /**
     * @internal
     */
    __publicField(this, "time", Date.now());
    /**
     * @internal
     */
    __publicField(this, "loopTime", MainLoop.time);
    /**
     * @internal
     */
    __publicField(this, "point");
    /**
     * @internal
     */
    __publicField(this, "devicePoint");
    /**
     * @internal
     */
    __publicField(this, "target");
    /**
     * @internal
     */
    __publicField(this, "delta");
    const customTarget = session && session.startEvent && session.startEvent.target || originalEvent.target;
    const eventLike = _FramerEvent.eventLikeFromOriginalEvent(originalEvent);
    this.point = pointForEvent(eventLike, customTarget);
    const deviceTarget = session && session.originElement ? session.originElement : document.body;
    this.devicePoint = pointForEvent(eventLike, deviceTarget);
    this.target = originalEvent.target || null;
    const lastEvent = session && session.lastEvent;
    if (originalEvent instanceof WheelEvent) {
      this.delta = { x: originalEvent.deltaX, y: originalEvent.deltaY };
    } else if (lastEvent && this.devicePoint && lastEvent.devicePoint) {
      this.delta = Point.subtract(this.devicePoint, lastEvent.devicePoint);
    } else {
      this.delta = { x: 0, y: 0 };
    }
  }
  static eventLikeFromOriginalEvent(originalEvent) {
    if ("touches" in originalEvent) {
      let touches = originalEvent.touches;
      if (!touches || !touches.length) {
        if (originalEvent.changedTouches && originalEvent.changedTouches.length) {
          touches = originalEvent.changedTouches;
        }
      }
      const firstTouch = touches[0];
      if (!touches || !firstTouch) {
        return { pageX: 0, pageY: 0, target: null };
      }
      const pageX = firstTouch.clientX || firstTouch.screenX || firstTouch.pageX;
      const pageY = firstTouch.clientY || firstTouch.screenY || firstTouch.pageY;
      return {
        pageX,
        pageY,
        target: originalEvent.target
      };
    }
    return originalEvent;
  }
  /**
   * @internal
   */
  velocity(t) {
    return this.session ? this.session.velocity(t) : { x: 0, y: 0 };
  }
  /**
   * @internal
   */
  get offset() {
    return this.session ? this.session.offset(this) : { x: 0, y: 0 };
  }
  /**
   * @internal
   */
  get isLeftMouseClick() {
    if (environment.isTouch()) {
      return void 0;
    }
    if ("button" in this.originalEvent && "buttons" in this.originalEvent && "ctrlKey" in this.originalEvent) {
      return (this.originalEvent.button === 0 || this.originalEvent.buttons === 1) && !this.originalEvent.ctrlKey;
    }
    return false;
  }
};

// ../../library/src/components/hoc/WithDragging.tsx
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs(), 1);
import React33 from "react";

// ../../library/src/utils/math.ts
var clamp2 = (value, a, b) => {
  const min = Math.min(a, b);
  const max = Math.max(a, b);
  if (value < min) {
    value = min;
  }
  if (value > max) {
    value = max;
  }
  return value;
};

// ../../library/src/components/hoc/WithDragging.tsx
import { jsx as jsx26 } from "react/jsx-runtime";
var DraggingContext = /* @__PURE__ */ React33.createContext({ dragging: false });
function WithDragging(Component18) {
  const _WithDraggingHOC = class _WithDraggingHOC extends React33.Component {
    constructor(props, defaultProps) {
      super(props, defaultProps);
      __publicField(this, "state", {
        isDragging: false
      });
      __publicField(this, "x", Animatable(0));
      __publicField(this, "y", Animatable(0));
      __publicField(this, "onChangePosition", (change, transaction) => {
        if (change.value === change.oldValue) {
          return;
        }
        if (this.props.onMove) {
          this.props.onMove(this.point, this);
        }
      });
      __publicField(this, "isMoving", false);
      __publicField(this, "isAnimating", false);
      __publicField(this, "directionLockAxis", null);
      __publicField(this, "layerStartPoint", null);
      __publicField(this, "correctedLayerStartPoint", null);
      __publicField(this, "previousPoint", null);
      __publicField(this, "_constraints", null);
      __publicField(this, "animation", null);
      __publicField(this, "panStart", (event) => {
        if (!this.props.enabled) {
          return;
        }
        this.isMoving = this.isAnimating;
        this.stopAnimation();
        this.resetdirectionLock();
        this.layerStartPoint = this.point;
        this.correctedLayerStartPoint = this.point;
        if (this._constraints && this.props.bounce) {
          this.correctedLayerStartPoint = this.constrainPosition(
            this.correctedLayerStartPoint,
            this._constraints,
            1 / this.props.overdragScale
          );
        }
        this.previousPoint = this.correctedLayerStartPoint;
        if (!this.state.isDragging) {
          this.setState({ isDragging: true });
        }
        if (this.props.onDragSessionStart) {
          this.props.onDragSessionStart(event, this);
        }
      });
      __publicField(this, "pan", (event) => {
        const {
          enabled,
          speedX,
          speedY,
          directionLock,
          overdragScale,
          vertical,
          horizontal,
          pixelAlign,
          onDragStart,
          onDragWillMove,
          onDragDidMove,
          onDragSessionMove
        } = this.props;
        if (!enabled) {
          return;
        }
        assert(this.previousPoint !== null, "previousPoint must be set in panStart()");
        let point = { ...this.previousPoint };
        point.x += event.delta.x * speedX;
        point.y += event.delta.y * speedY;
        this.previousPoint = { ...point };
        if (this._constraints) {
          point = this.constrainPosition(point, this._constraints, overdragScale);
        }
        if (directionLock) {
          if (this.directionLockAxis === null) {
            const offset = event.offset;
            offset.x = offset.x * speedX;
            offset.y = offset.y * speedY;
            this.updatedirectionLock(offset);
            return;
          } else {
            assert(this.layerStartPoint !== null, "layerStartPoint must be set in panStart()");
            if (this.directionLockAxis === "y") {
              point.x = this.layerStartPoint.x;
            }
            if (this.directionLockAxis === "x") {
              point.y = this.layerStartPoint.y;
            }
          }
        }
        if (!this.state.isDragging) {
          this.setState({ isDragging: true });
          this.isMoving = true;
          if (onDragStart) {
            onDragStart(event, this);
          }
        }
        if (onDragWillMove) {
          onDragWillMove(event, this);
        }
        if (pixelAlign) {
          point.x = Math.round(point.x);
          point.y = Math.round(point.y);
        }
        if (!horizontal && !vertical) {
          return;
        }
        let axis = null;
        if (horizontal && !vertical) {
          axis = "x";
        } else if (vertical && !horizontal) {
          axis = "y";
        }
        this.setPoint(point, axis);
        if (onDragDidMove) {
          onDragDidMove(event, this);
        }
        if (onDragSessionMove) {
          onDragSessionMove(event, this);
        }
      });
      __publicField(this, "panEnd", (event) => {
        if (!this.props.enabled) {
          return;
        }
        this.startAnimation(event);
        const { onDragSessionEnd, onDragEnd } = this.props;
        if (this.state.isDragging) {
          if (onDragEnd) {
            onDragEnd(event, this);
          }
        }
        if (onDragSessionEnd) {
          onDragSessionEnd(event, this);
        }
        if (this.state.isDragging) {
          this.setState({ isDragging: false });
        }
        this.isMoving = this.isAnimating;
      });
      // Mouse Wheel
      __publicField(this, "mouseWheelStart", (event) => {
        this.correctedLayerStartPoint = this.point;
        this.previousPoint = this.correctedLayerStartPoint;
        this.stopAnimation();
      });
      __publicField(this, "mouseWheel", (event) => {
        const {
          enabled,
          speedX,
          speedY,
          vertical,
          horizontal,
          pixelAlign,
          onDragWillMove,
          onDragDidMove,
          mouseWheel
        } = this.props;
        if (!mouseWheel || !enabled) {
          return;
        }
        let point = { ...this.point };
        point.x -= event.delta.x * speedX;
        point.y -= event.delta.y * speedY;
        if (this._constraints) {
          point = this.constrainPosition(point, this._constraints, 0, false);
        }
        if (onDragWillMove) {
          onDragWillMove(event, this);
        }
        if (pixelAlign) {
          point.x = Math.round(point.x);
          point.y = Math.round(point.y);
        }
        if (!horizontal && !vertical) {
          return;
        }
        let axis = null;
        if (horizontal && !vertical) {
          axis = "x";
        } else if (vertical && !horizontal) {
          axis = "y";
        }
        this.setPoint(point, axis);
        if (onDragDidMove) {
          onDragDidMove(event, this);
        }
      });
      __publicField(this, "mouseWheelEnd", (event) => {
      });
      __publicField(this, "onAnimationStep", (axis, value) => {
        if (axis === "x" && this.props.horizontal === false) {
          return;
        }
        if (axis === "y" && this.props.vertical === false) {
          return;
        }
        let delta = 0;
        if (this.constraints) {
          if (this.props.bounce) {
            delta = value - this.getValue(axis);
          } else {
            const { minX, minY, maxX, maxY } = this.calculateConstraints(this._constraints);
            if (axis === "x") {
              delta = clamp2(value, minX, maxX) - this.getValue(axis);
            }
            if (axis === "y") {
              delta = clamp2(value, minY, maxY) - this.getValue(axis);
            }
          }
        } else {
          delta = value - this.getValue(axis);
        }
        const updatePoint = this.point;
        if (axis === "x") {
          updatePoint[axis] = updatePoint[axis] + delta;
        }
        if (axis === "y") {
          updatePoint[axis] = updatePoint[axis] + delta;
        }
        this.setPoint(updatePoint, axis);
      });
      __publicField(this, "onAnimationStop", (axis) => {
        if (axis === "x" && this.props.horizontal === false) {
          return;
        }
        if (axis === "y" && this.props.vertical === false) {
          return;
        }
        if (!this.animation) {
          return;
        }
        if (this.props.pixelAlign) {
          const point = this.point;
          point.x = Math.round(point.x);
          point.y = Math.round(point.y);
          this.setPoint(point, axis);
        }
        if (this.animation.x.isFinished() && this.animation.y.isFinished()) {
          return this.stopAnimation();
        }
      });
      __publicField(this, "stopAnimation", () => {
        this.isAnimating = false;
        this.isMoving = false;
        if (!this.animation) {
          return;
        }
        this.animation.x.cancel();
        this.animation.y.cancel();
        if (this.props.onDragAnimationEnd) {
          this.props.onDragAnimationEnd(this.animation, this);
        }
        this.animation = null;
      });
      const x = this.props.left;
      const y = this.props.top;
      if (!x) {
        this.x = Animatable(0);
      } else if (isAnimatable(x)) {
        this.x = x;
      } else {
        this.x = Animatable(x);
      }
      if (!y) {
        this.y = Animatable(0);
      } else if (isAnimatable(y)) {
        this.y = y;
      } else {
        this.y = Animatable(y);
      }
      this.x.onUpdate(this.onChangePosition);
      this.y.onUpdate(this.onChangePosition);
      const constraints = this.props.constraints;
      if (constraints) {
        this.constraints = constraints;
      }
    }
    UNSAFE_componentWillReceiveProps(props) {
      if (this.props.left !== props.left && isFiniteNumber(props.left)) {
        this.x.set(props.left);
      }
      if (this.props.top !== props.top && isFiniteNumber(props.top)) {
        this.y.set(props.top);
      }
      const constraints = props.constraints;
      if (constraints) {
        this.constraints = constraints;
      }
    }
    get point() {
      return { x: this.x.get(), y: this.y.get() };
    }
    setPoint(point, axis = null) {
      switch (axis) {
        case "x":
          this.x.set(point.x);
          break;
        case "y":
          this.y.set(point.y);
          break;
        case null:
          this.x.set(point.x);
          this.y.set(point.y);
          break;
      }
    }
    getValue(axis) {
      switch (axis) {
        case "x":
          return this.x.get();
        case "y":
          return this.y.get();
      }
    }
    get width() {
      const width = this.props.width;
      if (!width) {
        return 100;
      }
      if (isAnimatable(width)) {
        return width.get();
      }
      if (typeof width === "string") {
        return parseFloat(width);
      }
      return width;
    }
    get height() {
      const height = this.props.height;
      if (!height) {
        return 100;
      }
      if (isAnimatable(height)) {
        return height.get();
      }
      if (typeof height === "string") {
        return parseFloat(height);
      }
      return height;
    }
    get constraints() {
      return this._constraints;
    }
    set constraints(value) {
      if (value !== null && typeof value === "object") {
        this._constraints = {
          x: value.x || 0,
          y: value.y || 0,
          width: value.width || 0,
          height: value.height || 0
        };
      } else {
        this._constraints = null;
      }
      if (this._constraints) {
        this.updateAnimationConstraints(this._constraints);
      }
    }
    get constraintsOffset() {
      if (!this.constraints) {
        return { x: 0, y: 0 };
      }
      const { minX, minY, maxX, maxY } = this.calculateConstraints(this._constraints);
      const point = this.point;
      const constrainedPoint = { x: clamp2(point.x, minX, maxX), y: clamp2(point.y, minY, maxY) };
      const offset = { x: point.x - constrainedPoint.x, y: point.y - constrainedPoint.y };
      return offset;
    }
    get isBeyondConstraints() {
      const constraintsOffset = this.constraintsOffset;
      if (constraintsOffset.x !== 0) {
        return true;
      }
      if (constraintsOffset.y !== 0) {
        return true;
      }
      return false;
    }
    clampAndScale(value, min, max, scale2, scaleAllowed) {
      if (!scaleAllowed) {
        return clamp2(value, min, max);
      }
      if (value < min) {
        value = min + (value - min) * scale2;
      }
      if (value > max) {
        value = max + (value - max) * scale2;
      }
      return value;
    }
    calculateConstraints(bounds) {
      if (!bounds) {
        return { minX: Infinity, maxX: Infinity, minY: Infinity, maxY: Infinity };
      }
      if (bounds.width < this.width) {
        bounds.width = this.width;
      }
      if (bounds.height < this.height) {
        bounds.height = this.height;
      }
      const constraints = {
        minX: Rect.minX(bounds),
        maxX: Rect.maxX(bounds),
        minY: Rect.minY(bounds),
        maxY: Rect.maxY(bounds)
      };
      constraints.maxX -= this.width;
      constraints.maxY -= this.height;
      return constraints;
    }
    constrainPosition(proposedPoint, bounds, scale2, overdrag = this.props.overdrag) {
      const { maxX, maxY, minX, minY } = this.calculateConstraints(this._constraints);
      const point = {
        x: this.clampAndScale(proposedPoint.x, minX, maxX, scale2, overdrag),
        y: this.clampAndScale(proposedPoint.y, minY, maxY, scale2, overdrag)
      };
      if (this.props.speedX === 0 || this.props.horizontal === false) {
        point.x = proposedPoint.x;
      }
      if (this.props.speedY === 0 || this.props.vertical === false) {
        point.y = proposedPoint.y;
      }
      return point;
    }
    /* private */
    updatedirectionLock(correctedDelta) {
      if (Math.abs(correctedDelta.y) > this.props.directionLockThreshold.y) {
        this.directionLockAxis = "y";
      } else if (Math.abs(correctedDelta.x) > this.props.directionLockThreshold.x) {
        this.directionLockAxis = "x";
      }
      if (this.directionLockAxis !== null) {
        if (this.props.onDragDirectionLockStart) {
          this.props.onDragDirectionLockStart(this.directionLockAxis, this);
        }
      }
    }
    resetdirectionLock() {
      this.directionLockAxis = null;
    }
    // Inertial scroll animation
    setupAnimation() {
      if (this.animation) {
        return;
      }
      this.animation = { x: this.setupAnimationForAxis("x"), y: this.setupAnimationForAxis("y") };
      this.updateAnimationConstraints(this._constraints);
    }
    setupAnimationForAxis(axis) {
      const animator = new InertialScrollAnimator({
        momentum: this.props.momentumOptions,
        bounce: this.props.bounceOptions
      });
      const updateCallback = (value) => {
        this.onAnimationStep(axis, value);
      };
      const doneCallback = () => {
        this.onAnimationStop(axis);
      };
      return new MainLoopAnimationDriver(animator, updateCallback, doneCallback);
    }
    updateAnimationConstraints(constraints) {
      if (!this.animation) {
        return;
      }
      if (constraints) {
        const { minX, minY, maxX, maxY } = this.calculateConstraints(constraints);
        this.animation.x.animator.setLimits(minX, maxX);
        this.animation.y.animator.setLimits(minY, maxY);
      } else {
        this.animation.x.animator.setLimits(-Infinity, Infinity);
        this.animation.y.animator.setLimits(-Infinity, Infinity);
      }
    }
    startAnimation(event) {
      const { momentum, bounce, momentumVelocityMultiplier, speedX, speedY, overdrag, onDragAnimationStart } = this.props;
      if (!(momentum || bounce)) {
        return;
      }
      if (this.isBeyondConstraints === false && momentum === false) {
        return;
      }
      if (this.isBeyondConstraints === false && this.state.isDragging === false) {
        return;
      }
      const { minX, minY, maxX, maxY } = this.calculateConstraints(this._constraints);
      const startAnimationX = overdrag === true || this.point.x > minX && this.point.x < maxX;
      const startAnimationY = overdrag === true || this.point.y > minY && this.point.y < maxY;
      if (startAnimationX === startAnimationY && startAnimationY === false) {
        return;
      }
      const velocity = event.velocity(0.1);
      let velocityX = velocity.x * momentumVelocityMultiplier * speedX;
      let velocityY = velocity.y * momentumVelocityMultiplier * speedY;
      if (this.directionLockAxis === "x") {
        velocityY = 0;
      }
      if (this.directionLockAxis === "y") {
        velocityX = 0;
      }
      this.setupAnimation();
      this.isAnimating = true;
      this.isMoving = true;
      if (!this.animation) {
        return;
      }
      this.animation.x.animator.setState({ x: this.point.x, v: velocityX });
      if (startAnimationX) {
        this.animation.x.play();
      }
      this.animation.y.animator.setState({ x: this.point.y, v: velocityY });
      if (startAnimationY) {
        this.animation.y.play();
      }
      if (onDragAnimationStart) {
        onDragAnimationStart(this.animation, this);
      }
    }
    wrapHandler(ownHandler, originalHandler) {
      if (!originalHandler) {
        return ownHandler;
      }
      return (event) => {
        ownHandler(event);
        originalHandler(event);
      };
    }
    render() {
      const originalProps = { ...this.props };
      Object.keys(_WithDraggingHOC.draggingDefaultProps).forEach((key7) => {
        delete asRecord(originalProps)[key7];
      });
      originalProps.onPanStart = this.wrapHandler(this.panStart, originalProps.onPanStart);
      originalProps.onPan = this.wrapHandler(this.pan, originalProps.onPan);
      originalProps.onPanEnd = this.wrapHandler(this.panEnd, originalProps.onPanEnd);
      originalProps.onMouseWheelStart = this.wrapHandler(this.mouseWheelStart, originalProps.onMouseWheelStart);
      originalProps.onMouseWheel = this.wrapHandler(this.mouseWheel, originalProps.onMouseWheel);
      originalProps.onMouseWheelEnd = this.wrapHandler(this.mouseWheelEnd, originalProps.onMouseWheelEnd);
      originalProps.left = this.x;
      originalProps.top = this.y;
      return /* @__PURE__ */ jsx26(DraggingContext.Provider, { value: { dragging: this.state.isDragging }, children: /* @__PURE__ */ jsx26(Component18, { ...originalProps }) });
    }
  };
  __publicField(_WithDraggingHOC, "draggingDefaultProps", {
    momentum: true,
    momentumOptions: { friction: 2.1, tolerance: 1 },
    momentumVelocityMultiplier: 800,
    speedX: 1,
    speedY: 1,
    bounce: true,
    bounceOptions: { friction: 40, tension: 200, tolerance: 1 },
    directionLock: false,
    directionLockThreshold: { x: 10, y: 10 },
    overdrag: true,
    overdragScale: 0.5,
    pixelAlign: true,
    velocityTimeout: 100,
    velocityScale: 890,
    horizontal: true,
    vertical: true,
    enabled: true,
    constraints: {},
    mouseWheel: false
  });
  __publicField(_WithDraggingHOC, "defaultProps", Object.assign(
    {},
    Component18.defaultProps,
    _WithDraggingHOC.draggingDefaultProps
  ));
  let WithDraggingHOC = _WithDraggingHOC;
  const withDragging = WithDraggingHOC;
  (0, import_hoist_non_react_statics2.default)(withDragging, Component18);
  return withDragging;
}

// ../../library/src/components/hoc/WithEvents.tsx
import { jsx as jsx27 } from "react/jsx-runtime";
var hoverProps = {
  onMouseEnter: "mouseenter",
  onMouseLeave: "mouseleave"
};
var hoverEventKeys = /* @__PURE__ */ Object.keys(hoverProps);
var eventHandlerMapping = {
  panstart: ["onPanStart"],
  pan: ["onPan"],
  panend: ["onPanEnd"],
  tapstart: ["onTapStart", "onMouseDown"],
  tap: ["onTap", "onClick"],
  tapend: ["onTapEnd", "onMouseUp"],
  mousewheelstart: ["onMouseWheelStart"],
  mousewheel: ["onMouseWheel"],
  mousewheelend: ["onMouseWheelEnd"]
};
var tapEventKeys = /* @__PURE__ */ new Set(["tapstart", "tap", "tapend"]);
function WithEvents(BaseComponent) {
  var _a;
  const withEvents = (_a = class extends React34.Component {
    constructor() {
      super(...arguments);
      // This local variable is used to track if we should ignore a tap after a drag
      // It's not in a state because we want to change it from the render function (so not cause a render)
      __publicField(this, "shouldCancelTap", false);
      __publicField(this, "activeEventListeners", /* @__PURE__ */ new Map());
      __publicField(this, "hasFramerEventListener", false);
      __publicField(this, "component", React34.createRef());
    }
    get element() {
      return this.component.current && this.component.current.element;
    }
    componentDidMount() {
      this.addEventListeners();
    }
    componentDidUpdate(prevProps) {
      this.addEventListeners(prevProps);
    }
    componentWillUnmount() {
      this.removeEventListeners();
    }
    addEventListeners(prevProps) {
      if (this.element && !this.hasFramerEventListener) {
        this.element.addEventListener("FramerEvent", ({ detail }) => {
          const type = detail.type;
          const framerEvent = detail.event;
          this.handleEvent(type, framerEvent);
        });
        hoverEventKeys.forEach((eventName) => this.addHoverEvent(eventName));
        this.hasFramerEventListener = true;
      } else if (this.element && prevProps) {
        hoverEventKeys.forEach((eventName) => this.checkHoverEvent(eventName, prevProps));
      } else if (!this.element) {
        this.hasFramerEventListener = false;
      }
    }
    removeEventListeners() {
      hoverEventKeys.forEach((eventName) => this.removeHoverEvent(eventName));
    }
    addHoverEvent(eventName) {
      const originalEventListener = this.props[eventName];
      if (this.element && originalEventListener) {
        const eventListener = (e) => {
          const framerEvent = new FramerEvent(e);
          originalEventListener(framerEvent);
        };
        this.activeEventListeners.set(eventName, eventListener);
        const domEventName = hoverProps[eventName];
        this.element.addEventListener(domEventName, eventListener);
      }
    }
    removeHoverEvent(eventName) {
      const eventListener = this.activeEventListeners.get(eventName);
      if (this.element && eventListener) {
        const domEventName = hoverProps[eventName];
        this.element.removeEventListener(domEventName, eventListener);
        this.activeEventListeners.delete(eventName);
      }
    }
    checkHoverEvent(eventName, prevProps) {
      if (prevProps[eventName] !== this.props[eventName]) {
        this.removeHoverEvent(eventName);
        this.addHoverEvent(eventName);
      }
    }
    handleEvent(type, framerEvent) {
      const eventListenerKeys = eventHandlerMapping[type];
      if (!eventListenerKeys) return;
      eventListenerKeys.forEach((eventKey) => {
        const eventListener = this.props[eventKey];
        const cancelEvent = this.shouldCancelTap && tapEventKeys.has(eventKey);
        if (eventListener && !cancelEvent) {
          eventListener(framerEvent);
        }
      });
    }
    render() {
      return /* @__PURE__ */ jsx27(DraggingContext.Consumer, { children: (value) => {
        this.shouldCancelTap = value.dragging;
        return /* @__PURE__ */ jsx27(BaseComponent, { ...this.props, ref: this.component });
      } });
    }
  }, __publicField(_a, "defaultProps", Object.assign({}, BaseComponent.defaultProps)), _a);
  (0, import_hoist_non_react_statics3.default)(withEvents, BaseComponent);
  return withEvents;
}

// ../../library/src/render/presentation/Frame/DeprecatedFrame.tsx
import React35 from "react";

// ../../library/src/data/ObservableObject.ts
var hasOwnProperty2 = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var $private = /* @__PURE__ */ Symbol("private");
var ObservableObject = /* @__PURE__ */ (() => {
  function ObservableObject2(initial = {}, makeAnimatables = false, observeAnimatables = true) {
    const unproxiedState = {
      [$private]: {
        makeAnimatables,
        observeAnimatables,
        observers: new Observers(),
        reset() {
          for (const key7 in state) {
            if (hasOwnProperty2(state, key7)) {
              const value = hasOwnProperty2(initial, key7) ? asRecord(initial)[key7] : void 0;
              if (value !== void 0) {
                state[key7] = value;
              } else {
                delete state[key7];
              }
            }
          }
        },
        transactions: /* @__PURE__ */ new Set()
      }
    };
    const state = new Proxy(unproxiedState, sharedProxyHandler);
    Object.assign(state, initial);
    return state;
  }
  ObservableObject2.resetObject = (target) => {
    return target[$private].reset();
  };
  ObservableObject2.addObserver = (target, observer) => {
    return target[$private].observers.add(observer);
  };
  return ObservableObject2;
})();
var ObservableObjectProxyHandler = class {
  constructor() {
    __publicField(this, "set", (target, key7, value, receiver) => {
      if (key7 === $private) {
        return false;
      }
      const privateObject = target[$private];
      let animatable;
      let rawValue;
      if (isAnimatable(value)) {
        animatable = value;
        rawValue = animatable.get();
      } else {
        rawValue = value;
      }
      if (privateObject.makeAnimatables && typeof value !== "function" && typeof value !== "object" && !animatable) {
        animatable = Animatable(value);
      }
      if (privateObject.observeAnimatables && animatable) {
        const transactions = privateObject.transactions;
        animatable.onUpdate({
          update: (change, transaction) => {
            if (transaction) {
              transactions.add(transaction);
            }
            privateObject.observers.notify({ value: receiver }, transaction);
          },
          finish: (transaction) => {
            if (transactions.delete(transaction)) {
              privateObject.observers.finishTransaction(transaction);
            }
          }
        });
      }
      let result = false;
      let changed = true;
      const targetValue = asRecord(target)[key7];
      if (targetValue !== void 0) {
        if (isAnimatable(targetValue)) {
          changed = targetValue.get() !== rawValue;
          targetValue.set(rawValue);
        } else {
          changed = targetValue !== rawValue;
          asRecord(target)[key7] = rawValue;
        }
        const rawValueIsObject = rawValue !== null && typeof rawValue === "object";
        if (Array.isArray(rawValue) || rawValueIsObject) changed = true;
        result = true;
      } else {
        if (animatable) {
          value = animatable;
        }
        result = Reflect.set(target, key7, value);
      }
      if (changed) {
        privateObject.observers.notify({ value: receiver });
      }
      return result;
    });
    __publicField(this, "get", (target, key7, receiver) => {
      if (key7 === $private) {
        return asRecord(target)[key7];
      }
      const value = Reflect.get(target, key7, receiver);
      return typeof value === "function" ? value.bind(receiver) : value;
    });
  }
  deleteProperty(target, key7) {
    const result = Reflect.deleteProperty(target, key7);
    target[$private].observers.notify({ value: target });
    return result;
  }
  ownKeys(target) {
    const keys3 = Reflect.ownKeys(target);
    const privateIndex = keys3.indexOf($private);
    if (privateIndex !== -1) {
      keys3.splice(privateIndex, 1);
    }
    return keys3;
  }
  getOwnPropertyDescriptor(target, key7) {
    if (key7 === $private) {
      return void 0;
    }
    return Reflect.getOwnPropertyDescriptor(target, key7);
  }
};
var sharedProxyHandler = /* @__PURE__ */ new ObservableObjectProxyHandler();

// ../../library/src/render/traits/Blending.ts
function collectBlendingFromProps(node, style) {
  if (!node.blendingMode || node.blendingMode === "normal") return;
  style.mixBlendMode = node.blendingMode;
}

// ../../library/src/render/traits/Opacity.ts
var key2 = "opacity";
function withOpacity(target) {
  return key2 in target;
}
function collectOpacityFromProps(props, style) {
  if (!withOpacity(props)) return;
  const opacity = Animatable.getNumber(props.opacity);
  if (opacity === 1) return;
  style.opacity = opacity;
}

// ../../library/src/render/traits/Overflow.ts
function collectOverflowFromProps(props, style) {
  if (props.overflow) {
    style.overflow = props.overflow;
  }
}

// ../../library/src/render/traits/Radius.ts
var key3 = "radius";
function hasRadius(props) {
  return key3 in props;
}
function getRadiusValue(value) {
  let num = Number(value);
  if (typeof value === "string" && Number.isNaN(num)) {
    return value;
  } else if (isAnimatable(value)) {
    num = Animatable.getNumber(value);
  }
  return num ? `${num}px` : "0";
}
function hasRadiusValue(value) {
  return value && value !== "0";
}
function collectRadiusFromProps(props, style) {
  if (!hasRadius(props)) return;
  const { radius } = props;
  if (typeof radius === "string" || isAnimatable(radius) || isFiniteNumber(radius)) {
    const radiusValue = getRadiusValue(radius);
    if (hasRadiusValue(radiusValue)) {
      style.borderTopLeftRadius = style.borderTopRightRadius = style.borderBottomRightRadius = style.borderBottomLeftRadius = radiusValue;
    }
  } else if (radius) {
    const topLeft = getRadiusValue(radius.topLeft);
    const topRight = getRadiusValue(radius.topRight);
    const bottomRight = getRadiusValue(radius.bottomRight);
    const bottomLeft = getRadiusValue(radius.bottomLeft);
    if (hasRadiusValue(topLeft) || hasRadiusValue(topRight) || hasRadiusValue(bottomRight) || hasRadiusValue(bottomLeft)) {
      style.borderTopLeftRadius = topLeft;
      style.borderTopRightRadius = topRight;
      style.borderBottomRightRadius = bottomRight;
      style.borderBottomLeftRadius = bottomLeft;
    }
  }
}

// ../../library/src/render/traits/TextColor.ts
function collectTextColorFromProps(props, style) {
  const { color: color2 } = props;
  if (typeof color2 === "string") {
    style.color = color2;
  } else if (Color.isColorObject(color2)) {
    style.color = color2.initialValue || Color.toRgbString(color2);
  }
}

// ../../library/src/render/types/Shadow.ts
var shadowKeys = ["color", "x", "y", "blur"];
var Shadow = {
  is: (shadow) => {
    return shadow && shadowKeys.every((key7) => key7 in shadow);
  }
};
var boxShadowKeys = ["x", "y", "color", "inset", "blur", "spread"];
var BoxShadow = {
  is: (shadow) => {
    return shadow && boxShadowKeys.every((key7) => key7 in shadow);
  },
  toCSS: (shadow) => {
    const inset2 = shadow.inset ? "inset " : "";
    return `${inset2}${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.spread}px ${shadow.color}`;
  }
};

// ../../library/src/render/style/shadow.tsx
import { Fragment as Fragment5, jsx as jsx28, jsxs as jsxs7 } from "react/jsx-runtime";
function shadowsAsFilter(shadows) {
  const filters = [];
  if (shadows && shadows.length) {
    const dropShadows = shadows.map((shadowItem) => {
      return `drop-shadow(${shadowItem.x}px ${shadowItem.y}px ${shadowItem.blur}px ${shadowItem.color})`;
    });
    filters.push(...dropShadows);
  }
  return filters;
}
function collectTextShadowsForProps(props, style) {
  if (!props.shadows || props.shadows.length === 0) return;
  const textShadow = props.shadows.map((shadow) => {
    return `${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.color}`;
  }).join(", ");
  if (!textShadow) return;
  style.textShadow = textShadow;
}
function collectBoxShadowsForProps(props, style) {
  if (!props.shadows || props.shadows.length === 0) return;
  const boxShadow = props.shadows.map((shadowItem) => BoxShadow.toCSS(shadowItem)).join(", ");
  if (!boxShadow) return;
  style.boxShadow = boxShadow;
}
function shadowForShape(boxShadows, rect, shapeId, fillEnabled, strokeEnabled, strokeWidth, strokeClipId, svgStrokeAttributes) {
  const definition = [];
  let outsetElement = null;
  let insetElement = null;
  let maskElement = null;
  const needsStrokeClip = false;
  const shadows = [];
  const insetShadows = [];
  const svgShadowClass = "svg-shadow";
  const svgShadowProps = RenderTarget.current() === RenderTarget.canvas ? { className: svgShadowClass } : {};
  for (const shadow of boxShadows) {
    shadow.inset ? insetShadows.push(shadow) : shadows.push(shadow);
  }
  if (shadows.length > 0) {
    shadows.reverse();
    const outsideShadowId = shapeId.add("_shadow_out");
    const normalizedFrame = Rect.atOrigin(rect);
    const shadowRects = [normalizedFrame];
    for (const shadow of shadows) {
      const shadowFrame = localShadowFrame(shadow, normalizedFrame, true);
      if (shadowFrame === null) {
        continue;
      }
      shadowRects.push(shadowFrame);
    }
    let maxBlur = 0;
    const filterElements = [];
    const mergeElements = [];
    for (let i = 0, il = shadows.length; i < il; i++) {
      const shadow = shadows[i];
      if (!shadow) continue;
      const shadowElements = outerShadowElements(shapeId, shadow, i);
      maxBlur = Math.max(maxBlur, shadow.blur);
      filterElements.push(shadowElements.filterElements);
      mergeElements.push(shadowElements.mergeElement);
    }
    let expandStrokeWidth = strokeWidth;
    if (!isFiniteNumber(expandStrokeWidth)) expandStrokeWidth = 0;
    let miter = svgStrokeAttributes.strokeMiterlimit;
    if (!isFiniteNumber(miter)) miter = 4;
    let shadowRect = Rect.merge(...shadowRects);
    shadowRect = Rect.inflate(shadowRect, (expandStrokeWidth * miter / 2 + maxBlur) * 1.1);
    const width = rect.width + (strokeWidth ? strokeWidth / 2 : 0);
    const height = rect.height + (strokeWidth ? strokeWidth / 2 : 0);
    const filterX = shadowRect.x / width * 100;
    const filterY = shadowRect.y / height * 100;
    const filterWidth = shadowRect.width / width * 100;
    const filterHeight = shadowRect.height / height * 100;
    const svgRect = {
      x: `${filterX.toFixed(1)}%`,
      y: `${filterY.toFixed(1)}%`,
      width: `${filterWidth.toFixed(1)}%`,
      height: `${filterHeight.toFixed(1)}%`
    };
    definition.push(
      /* @__PURE__ */ jsxs7(
        "filter",
        {
          id: outsideShadowId.id,
          filterUnits: "objectBoundingBox",
          ...svgRect,
          ...svgShadowProps,
          children: [
            filterElements,
            shadows.length > 1 ? /* @__PURE__ */ jsx28("feMerge", { children: mergeElements }) : null
          ]
        },
        outsideShadowId.id
      )
    );
    const maskId = shapeId.add("mask");
    maskElement = /* @__PURE__ */ jsxs7("mask", { id: maskId.id, ...svgRect, children: [
      /* @__PURE__ */ jsx28("rect", { ...svgRect, fill: "white" }),
      /* @__PURE__ */ jsx28("use", { href: shapeId.link, fill: "black", fillOpacity: fillEnabled ? void 0 : 0 })
    ] });
    outsetElement = /* @__PURE__ */ jsx28("g", { filter: outsideShadowId.urlLink, ...svgShadowProps, mask: maskId.urlLink, children: /* @__PURE__ */ jsx28(
      "use",
      {
        ...svgStrokeAttributes,
        fill: "black",
        fillOpacity: fillEnabled ? void 0 : 0,
        stroke: "black",
        strokeOpacity: strokeEnabled ? void 0 : 0,
        strokeWidth: strokeEnabled ? strokeWidth : 0,
        xlinkHref: shapeId.link,
        clipPath: strokeClipId.urlLink
      }
    ) });
  }
  if (insetShadows.length) {
    insetShadows.reverse();
    const insideShadowId = shapeId.add("_shadow_inside");
    const normalizedFrame = Rect.atOrigin(rect);
    const shadowFrames = [normalizedFrame];
    for (const shadow of insetShadows) {
      const shadowFrame = localShadowFrame(shadow, normalizedFrame, true);
      if (shadowFrame === null) {
        continue;
      }
      shadowFrames.push(shadowFrame);
    }
    const shadowRect = Rect.merge(...shadowFrames);
    const width = rect.width + (strokeWidth ? strokeWidth / 2 : 0.1);
    const height = rect.height + (strokeWidth ? strokeWidth / 2 : 0.1);
    const filterX = shadowRect.x / width * 100;
    const filterY = shadowRect.y / height * 100;
    const filterWidth = shadowRect.width / width * 100;
    const filterHeight = shadowRect.height / height * 100;
    const filterElements = [];
    const mergeElements = [];
    for (let i = 0, il = insetShadows.length; i < il; i++) {
      const shadow = insetShadows[i];
      if (!shadow) continue;
      const shadowElements = innerShadowElements(shapeId, shadow, i);
      filterElements.push(shadowElements.filterElements);
      mergeElements.push(shadowElements.mergeElement);
    }
    definition.push(
      /* @__PURE__ */ jsxs7(
        "filter",
        {
          id: insideShadowId.id,
          x: `${filterX.toFixed(1)}%`,
          y: `${filterY.toFixed(1)}%`,
          width: `${filterWidth.toFixed(1)}%`,
          height: `${filterHeight.toFixed(1)}%`,
          filterUnits: "objectBoundingBox",
          ...svgShadowProps,
          children: [
            filterElements,
            insetShadows.length > 1 ? /* @__PURE__ */ jsx28("feMerge", { children: mergeElements }) : null
          ]
        },
        insideShadowId.id
      )
    );
    let clipPath;
    if (needsStrokeClip) {
      clipPath = strokeClipId.urlLink;
    }
    insetElement = /* @__PURE__ */ jsx28(
      "use",
      {
        fill: "black",
        fillOpacity: "1",
        filter: insideShadowId.urlLink,
        xlinkHref: shapeId.link,
        clipPath,
        ...svgShadowProps
      }
    );
  }
  return { definition, outsetElement, insetElement, needsStrokeClip, maskElement };
}
function outerShadowElements(shapeID, shadow, index) {
  const shadowKey = shapeID.add("_outer_shadow" + index);
  const filterElements = /* @__PURE__ */ jsx28(OuterShadowFilterElements, { shadow, shadowKey }, shadowKey.id + "-filters");
  const mergeElement = /* @__PURE__ */ jsx28("feMergeNode", { in: shadowKey.id }, shadowKey.id + "-merge");
  return { filterElements, mergeElement };
}
var OuterShadowFilterElements = (props) => {
  const { shadow, shadowKey } = props;
  const offsetId = shadowKey.add("offset").id;
  const blurId = shadowKey.add("blur").id;
  const floodId = shadowKey.add("flood").id;
  return /* @__PURE__ */ jsxs7(Fragment5, { children: [
    /* @__PURE__ */ jsx28("feOffset", { dx: shadow.x, dy: shadow.y, in: "SourceAlpha", result: offsetId }),
    /* @__PURE__ */ jsx28("feGaussianBlur", { stdDeviation: shadow.blur / 2, in: offsetId, result: blurId }),
    /* @__PURE__ */ jsx28("feFlood", { floodColor: shadow.color, result: floodId }),
    /* @__PURE__ */ jsx28("feComposite", { in: floodId, in2: blurId, operator: "in", result: shadowKey.id })
  ] });
};
function innerShadowElements(shapeID, shadow, index) {
  const shadowKey = shapeID.add("_inside_shadow" + index);
  const filterElements = /* @__PURE__ */ jsx28(InnerShadowFilterElements, { shadow, shadowKey }, shadowKey.id + "-filters");
  const mergeElement = /* @__PURE__ */ jsx28("feMergeNode", { in: shadowKey.id }, shadowKey.id + "-merge");
  return { filterElements, mergeElement };
}
var InnerShadowFilterElements = (props) => {
  const { shadow, shadowKey } = props;
  const blurId = shadowKey.add("blur").id;
  const offsetId = shadowKey.add("offset").id;
  const compositeId = shadowKey.add("composite").id;
  const floodId = shadowKey.add("flood").id;
  return /* @__PURE__ */ jsxs7(Fragment5, { children: [
    /* @__PURE__ */ jsx28("feGaussianBlur", { stdDeviation: shadow.blur / 2, in: "SourceAlpha", result: blurId }),
    /* @__PURE__ */ jsx28("feOffset", { dx: shadow.x, dy: shadow.y, in: blurId, result: offsetId }),
    /* @__PURE__ */ jsx28("feComposite", { in: offsetId, in2: "SourceAlpha", operator: "arithmetic", k2: "-1", k3: "1", result: compositeId }),
    /* @__PURE__ */ jsx28("feFlood", { floodColor: shadow.color, result: floodId }),
    /* @__PURE__ */ jsx28("feComposite", { in: floodId, in2: compositeId, operator: "in", result: shadowKey.id })
  ] });
};
function calcMaxRealisticShadowBlur(distance2, focus) {
  return interpolate([0, 0.5, 1], [distance2 * 5, distance2, 0])(focus);
}
var maxSpread = 5;
function calcRealisticShadowSpread(diffusion) {
  return mix(-maxSpread, 0, diffusion);
}
function localShadowFrame(shadow, frame2, isSVG = false) {
  if (!isSVG && asRecord(shadow)["inset"]) return null;
  let growth = shadow.blur;
  let minX;
  let maxX;
  let minY;
  let maxY;
  if (isSVG) {
    minX = -Math.abs(shadow.x) - growth;
    maxX = Math.abs(shadow.x) + frame2.width + growth;
    minY = -Math.abs(shadow.y) - growth;
    maxY = Math.abs(shadow.y) + frame2.height + growth;
  } else if (BoxShadow.is(shadow) && shadow.type === "realistic") {
    growth = "focus" in shadow && "diffusion" in shadow ? calcMaxRealisticShadowBlur(distance(shadow.x, shadow.y), shadow.focus) + calcRealisticShadowSpread(shadow.diffusion) : 0;
    if (shadow.x >= 0) {
      minX = 0 - growth;
      maxX = shadow.x + frame2.width + growth;
    } else {
      minX = shadow.x - growth;
      maxX = frame2.width + growth;
    }
    if (shadow.y >= 0) {
      minY = 0 - growth;
      maxY = shadow.y + frame2.height + growth;
    } else {
      minY = shadow.y - growth;
      maxY = frame2.height + growth;
    }
  } else {
    if ("spread" in shadow) {
      growth += shadow.spread;
    }
    minX = shadow.x - growth;
    maxX = shadow.x + frame2.width + growth;
    minY = shadow.y - growth;
    maxY = shadow.y + frame2.height + growth;
  }
  if (maxX <= minX || maxY <= minY) return null;
  return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
}

// ../../library/src/render/utils/filtersForNode.ts
function collectLayerFilters(props, style) {
  const filters = [];
  if (isFiniteNumber(props.brightness)) {
    filters.push(`brightness(${props.brightness / 100})`);
  }
  if (isFiniteNumber(props.contrast)) {
    filters.push(`contrast(${props.contrast / 100})`);
  }
  if (isFiniteNumber(props.grayscale)) {
    filters.push(`grayscale(${props.grayscale / 100})`);
  }
  if (isFiniteNumber(props.hueRotate)) {
    filters.push(`hue-rotate(${props.hueRotate}deg)`);
  }
  if (isFiniteNumber(props.invert)) {
    filters.push(`invert(${props.invert / 100})`);
  }
  if (isFiniteNumber(props.saturate)) {
    filters.push(`saturate(${props.saturate / 100})`);
  }
  if (isFiniteNumber(props.sepia)) {
    filters.push(`sepia(${props.sepia / 100})`);
  }
  if (isFiniteNumber(props.blur)) {
    filters.push(`blur(${props.blur}px)`);
  }
  if (props.dropShadows) {
    filters.push(...shadowsAsFilter(props.dropShadows));
  }
  if (filters.length === 0) return;
  style.filter = style.WebkitFilter = filters.join(" ");
}
function collectBackgroundFilters(props, style) {
  if (isFiniteNumber(props.backgroundBlur)) {
    style.backdropFilter = style.WebkitBackdropFilter = `blur(${props.backgroundBlur}px)`;
  }
}
function collectFiltersFromProps(props, style) {
  collectBackgroundFilters(props, style);
  collectLayerFilters(props, style);
}

// ../../library/src/render/style/collectVisualStyleFromProps.ts
function collectVisualStyleFromProps(props, style, isTextNode = false) {
  collectBackgroundFromProps(props, style);
  collectRadiusFromProps(props, style);
  collectFiltersFromProps(props, style);
  collectBlendingFromProps(props, style);
  collectOverflowFromProps(props, style);
  collectOpacityFromProps(props, style);
  collectTextColorFromProps(props, style);
  if (isTextNode) {
    collectTextShadowsForProps(props, style);
  } else {
    collectBoxShadowsForProps(props, style);
  }
}

// ../../library/src/render/traits/Transform.ts
var getNumber = /* @__PURE__ */ (() => Animatable.getNumber)();
var transformDefaults = {
  z: 0,
  rotation: 0,
  rotationX: 0,
  rotationY: 0,
  rotationZ: 0,
  scale: 1,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  skew: 0,
  skewX: 0,
  skewY: 0,
  originX: 0.5,
  originY: 0.5,
  originZ: 0
};
function getRotation(rotation, rotate) {
  if (typeof rotate === "string") {
    rotate = parseFloat(rotate);
  }
  return isFiniteNumber(rotate) ? rotate : getNumber(rotation);
}
function collectTransformFromProps(props, rect, style) {
  const motionStyle = style;
  const x = typeof rect.x === "number" ? `${rect.x}px` : rect.x;
  const y = typeof rect.y === "number" ? `${rect.y}px` : rect.y;
  const z = getNumber(props.z);
  const scaleZ = getNumber(props.scaleZ);
  const originZ = getNumber(props.originZ);
  const rotationZ = getRotation(props.rotationZ, resolveMotionValue(motionStyle.rotateZ));
  const rotationX = getRotation(props.rotationX, resolveMotionValue(motionStyle.rotateX));
  const rotationY = getRotation(props.rotationY, resolveMotionValue(motionStyle.rotateY));
  const scale2 = getNumber(props.scale);
  const scaleX = getNumber(props.scaleX);
  const scaleY = getNumber(props.scaleY);
  const skew = getNumber(props.skew);
  const skewX = getNumber(props.skewX);
  const skewY = getNumber(props.skewY);
  const rotation = getRotation(props.rotation, resolveMotionValue(motionStyle.rotate));
  const force3d = RenderEnvironment.target === RenderTarget.export;
  if (force3d || z !== 0 || scaleZ !== 1 || originZ !== 0 || rotationZ !== 0 || rotationX !== 0 || rotationY !== 0) {
    style.transform = `
            ${`translate3d(${x}, ${y}, ${z}px)`}
            scale3d(${scaleX * scale2}, ${scaleY * scale2}, ${scaleZ})
            skew(${skew}deg,${skew}deg)
            skewX(${skewX}deg)
            skewY(${skewY}deg)
            translateZ(${originZ}px)
            rotateX(${rotationX}deg)
            rotateY(${rotationY}deg)
            rotateZ(${(rotation + rotationZ).toFixed(4)}deg)
            translateZ(${-originZ}px)`;
  } else {
    style.transform = `
            ${`translate(${x}, ${y})`}
            scale(${scaleX * scale2}, ${scaleY * scale2})
            skew(${skew}deg,${skew}deg)
            skewX(${skewX}deg)
            skewY(${skewY}deg)
            rotate(${rotation.toFixed(4)}deg)`;
  }
  const transformOrigin = `${getNumber(props.originX) * 100}% ${getNumber(props.originY) * 100}%`;
  style.transformOrigin = transformOrigin;
  style.WebkitTransformOrigin = transformOrigin;
}

// ../../library/src/render/presentation/Frame/DeprecatedFrame.tsx
import { jsx as jsx29, jsxs as jsxs8 } from "react/jsx-runtime";
function cssBackgroundSize(size) {
  switch (size) {
    case "fit":
      return "contain";
    case "stretch":
      return "100% 100%";
    default:
      return "cover";
  }
}
function collectBackgroundImageFromProps(props, style) {
  const image = backgroundImageFromProps(props);
  if (image) {
    style.backgroundImage = `url("${image.src}")`;
    style.backgroundSize = cssBackgroundSize(image.fit);
    style.backgroundRepeat = "no-repeat";
    style.backgroundPosition = "center";
  }
}
function toPixelString(value) {
  return isFiniteNumber(value) ? `${value}px` : value;
}
function applyLayoutProp(style, props, key7) {
  if (props[key7] !== void 0) {
    const value = Animatable.get(props[key7], void 0);
    asRecord(style)[key7] = toPixelString(value);
  }
}
var DeprecatedFrame = /* @__PURE__ */ (() => {
  const _DeprecatedFrameInner = class _DeprecatedFrameInner extends Layer {
    constructor() {
      super(...arguments);
      __publicField(this, "element", null);
      __publicField(this, "imageDidChange", false);
      __publicField(this, "state", {
        size: null
      });
      __publicField(this, "updateStyle", () => {
        if (!this.element) {
          return;
        }
        Object.assign(this.element.style, this.getStyle());
      });
      __publicField(this, "setElement", (element) => {
        this.element = element;
        this.setLayerElement(element);
      });
      // XXX internal state
      __publicField(this, "propsObserver");
      __publicField(this, "propsObserverCancel");
      __publicField(this, "sizeObserver");
      __publicField(this, "sizeObserverCancel");
      __publicField(this, "onPropsChange", (props) => {
        const rect = _DeprecatedFrameInner.rect(Animatable.objectToValues(props.value));
        if (this.state.size && isAnimatable(this.state.size.width) && isAnimatable(props.value.width)) {
          this.state.size.width.set(rect.width);
        }
        if (this.state.size && isAnimatable(this.state.size.height) && isAnimatable(props.value.height)) {
          this.state.size.height.set(rect.height);
        }
        this.updateStyle();
      });
      __publicField(this, "onSizeChange", () => {
        this.updateStyle();
      });
    }
    static rect(props) {
      const constraintValues = ConstraintValues.fromProperties(props);
      const parentSizeInfo = props.parentSize ? {
        sizing: props.parentSize,
        positioning: props.parentSize,
        viewport: null
      } : null;
      return ConstraintValues.toRect(constraintValues, parentSizeInfo, null, true);
    }
    get rect() {
      return _DeprecatedFrameInner.rect(this.props);
    }
    static getDerivedStateFromProps(nextProps, prevState) {
      const size = _DeprecatedFrameInner.updatedSize(nextProps, prevState);
      const { target } = RenderEnvironment;
      const nextBackgroundImageSrc = nextProps.background && BackgroundImage.isImageObject(nextProps.background) ? nextProps.background.src : null;
      if (nextBackgroundImageSrc) {
        return {
          size
        };
      }
      if (prevState.size) {
        if (target === RenderTarget.preview) {
          return null;
        }
        if (prevState.size.width === size.width && prevState.size.height === size.height) {
          return null;
        }
      }
      return {
        size
      };
    }
    static updatedSize(props, state) {
      const rect = _DeprecatedFrameInner.rect(props);
      let size = state.size;
      const newSize = { width: rect.width, height: rect.height };
      const { target } = RenderEnvironment;
      if (!size) {
        if (target === RenderTarget.preview) {
          size = ObservableObject(newSize, true);
        } else {
          size = newSize;
        }
      } else {
        if (isAnimatable(size.width) && isAnimatable(size.height)) {
          size.width.set(newSize.width);
          size.height.set(newSize.height);
        } else {
          size = newSize;
        }
      }
      return size;
    }
    getStyle() {
      const rect = this.rect;
      const style = {
        display: "block",
        position: "absolute",
        width: `${rect.width}px`,
        height: `${rect.height}px`,
        pointerEvents: void 0,
        // TODO: this should be "none" for non-event consuming instances, for performance.
        userSelect: "none"
      };
      let left = Animatable.get(this.props.left, void 0);
      let top = Animatable.get(this.props.top, void 0);
      Object.assign(style, this.props._initialStyle);
      const hasParentSize = this.context.parentSize !== 1 /* Disabled */;
      const perspective = Animatable.get(this.props.perspective, void 0);
      style.perspective = perspective;
      style.WebkitPerspective = perspective;
      let backfaceVisibility = void 0;
      const backfaceVisible = Animatable.get(this.props.backfaceVisible, void 0);
      if (backfaceVisible === true) {
        backfaceVisibility = "visible";
      } else if (backfaceVisible === false) {
        backfaceVisibility = "hidden";
      }
      style.backfaceVisibility = backfaceVisibility;
      style.WebkitBackfaceVisibility = backfaceVisibility;
      const preserve3d = Animatable.get(this.props.preserve3d, void 0);
      if (preserve3d === true) {
        style.transformStyle = "preserve-3d";
      } else if (preserve3d === false) {
        style.transformStyle = "flat";
      }
      if (!hasParentSize) {
        applyLayoutProp(style, this.props, "right");
        applyLayoutProp(style, this.props, "bottom");
        const width = Animatable.get(this.props.width, void 0);
        const stringWidth = toPixelString(width);
        const height = Animatable.get(this.props.height, void 0);
        const stringHeight = toPixelString(height);
        if (typeof left === "string" && left.endsWith("%") && this.props.right === null) {
          left = `calc(${left} - calc(${stringWidth}} / 2))`;
          style.width = stringWidth;
        }
        if (typeof top === "string" && top.endsWith("%") && this.props.bottom === null) {
          top = `calc(${top} - calc(${stringHeight} / 2))`;
          style.height = stringHeight;
        }
        if (top !== void 0 && style.bottom !== void 0) {
          style.height = void 0;
          top = toPixelString(Animatable.get(this.props.top, void 0));
        } else {
          style.height = stringHeight;
        }
        if (left !== void 0 && style.right !== void 0) {
          style.width = void 0;
          left = toPixelString(Animatable.get(this.props.left, void 0));
        } else {
          style.width = stringWidth;
        }
      }
      const transformRect = { ...rect };
      if (typeof left !== "undefined") {
        transformRect.x = left;
      }
      if (typeof top !== "undefined") {
        transformRect.y = top;
      }
      collectTransformFromProps(this.props, transformRect, style);
      collectVisualStyleFromProps(this.props, style);
      collectBackgroundImageFromProps(this.props, style);
      Layer.applyWillChange(this.props, style, false);
      if (this.props.style) {
        Object.assign(style, this.props.style);
      }
      return style;
    }
    componentDidMount() {
      const { target } = RenderEnvironment;
      if (target === RenderTarget.preview) {
        this.propsObserver = ObservableObject(this.props, true);
        this.propsObserverCancel = ObservableObject.addObserver(this.propsObserver, this.onPropsChange);
        if (this.props.parentSize && isAnimatable(this.props.parentSize.width) && isAnimatable(this.props.parentSize.height)) {
          this.sizeObserver = ObservableObject(this.props.parentSize, true);
          this.sizeObserverCancel = ObservableObject.addObserver(this.sizeObserver, this.onSizeChange);
        }
      }
    }
    componentDidUpdate() {
      const { target } = RenderEnvironment;
      this.propsObserverCancel && this.propsObserverCancel();
      this.sizeObserverCancel && this.sizeObserverCancel();
      if (target === RenderTarget.preview) {
        this.propsObserver = ObservableObject(this.props, true);
        this.propsObserverCancel = ObservableObject.addObserver(this.propsObserver, this.onPropsChange);
        if (this.props.parentSize && isAnimatable(this.props.parentSize.width) && isAnimatable(this.props.parentSize.height)) {
          this.sizeObserver = ObservableObject(this.props.parentSize, true);
          this.sizeObserverCancel = ObservableObject.addObserver(this.sizeObserver, this.onSizeChange);
        }
      }
    }
    componentWillUnmount() {
      this.propsObserverCancel && this.propsObserverCancel();
      this.propsObserverCancel = void 0;
      this.sizeObserverCancel && this.sizeObserverCancel();
      this.sizeObserverCancel = void 0;
    }
    render() {
      countNodeRender();
      const { visible, id, className: className2 } = this.props;
      if (!visible) {
        return null;
      }
      const style = this.getStyle();
      const rect = this.rect;
      const parentSize = { width: rect.width, height: rect.height };
      return /* @__PURE__ */ jsxs8("div", { id, style, ref: this.setElement, className: className2, children: [
        /* @__PURE__ */ jsx29(ProvideParentSize, { parentSize, children: this.layoutChildren() }),
        /* @__PURE__ */ jsx29(Border, { ...this.props })
      ] });
    }
    layoutChildren() {
      const _forwardedOverrides = this.props._forwardedOverrides;
      let children = React35.Children.map(this.props.children, (child) => {
        if (isConstraintSupportingChild(child)) {
          return React35.cloneElement(child, {
            parentSize: this.state.size,
            _forwardedOverrides
            // biome-ignore lint/suspicious/noExplicitAny: deprecated code
          });
        } else if (_forwardedOverrides && child) {
          return React35.cloneElement(child, { _forwardedOverrides });
        } else {
          return child;
        }
      });
      if (children && children.length === 1 && typeof children[0] === "string") {
        children = [/* @__PURE__ */ jsx29(Center, { children }, "0")];
      }
      return children;
    }
  };
  __publicField(_DeprecatedFrameInner, "supportsConstraints", true);
  __publicField(_DeprecatedFrameInner, "defaultFrameSpecificProps", {
    ...constraintDefaults,
    ...transformDefaults,
    opacity: 1,
    background: Color("rgba(0, 170, 255, 0.3)"),
    visible: true,
    borderWidth: 0,
    borderColor: "#222",
    borderStyle: "solid"
  });
  __publicField(_DeprecatedFrameInner, "defaultProps", {
    ...Layer.defaultProps,
    ..._DeprecatedFrameInner.defaultFrameSpecificProps
  });
  let DeprecatedFrameInner = _DeprecatedFrameInner;
  DeprecatedFrameInner.contextType = ConstraintsContext;
  return DeprecatedFrameInner;
})();
function Center(props) {
  const style = Object.assign(
    {},
    {
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      fontFamily: "Helvetica"
    },
    props.style || {}
  );
  return /* @__PURE__ */ jsx29("div", { style, children: props.children });
}

// ../../library/src/render/presentation/Frame/isDeprecatedFrameProps.ts
var frameWithMotionPropsFields = [
  "_border",
  "_constraints",
  "animate",
  "initial",
  "variants",
  "transition",
  "inherit",
  "center",
  "initial",
  "transformTemplate",
  "animate",
  "variants",
  "transition",
  "onUpdate",
  "onAnimationComplete",
  "onPanSessionStart",
  "onTapCancel",
  "whileTap",
  "whileHover",
  "onHoverStart",
  "onHoverEnd",
  "drag",
  "dragDirectionLock",
  "dragPropagation",
  "dragConstraints",
  "dragElastic",
  "dragMomentum",
  "dragTransition",
  "onDragStart",
  "onDragEnd",
  "onDrag",
  "onDirectionLock",
  "onDragTransitionEnd",
  "x",
  "y",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "position",
  "border",
  "borderRadius",
  "cornerShape",
  "shadow",
  "size"
];
var deprecatedFramePropsFields = [
  "autoSize",
  "aspectRatio",
  "borderWidth",
  "borderStyle",
  "borderColor",
  "centerX",
  "centerY"
];
function isDeprecatedFrameProps(props) {
  for (const propKey in props) {
    if (isAnimatable(props[propKey])) return true;
  }
  for (const field of frameWithMotionPropsFields) {
    if (props.hasOwnProperty(field)) return false;
  }
  for (const field of deprecatedFramePropsFields) {
    if (props.hasOwnProperty(field)) return true;
  }
  return false;
}

// ../../library/src/render/presentation/Frame/index.tsx
import { jsx as jsx30 } from "react/jsx-runtime";
var DeprecatedFrameWithEvents = /* @__PURE__ */ WithEvents(DeprecatedFrame);
var Frame = /* @__PURE__ */ (() => {
  const FrameInner = forwardRef3(function FrameInner2(props, ref) {
    const parentSize = useParentSize();
    if (isDeprecatedFrameProps(props)) {
      const currentParentSize = props.parentSize || deprecatedParentSize(parentSize);
      return /* @__PURE__ */ jsx30(DeprecatedFrameWithEvents, { ...props, parentSize: currentParentSize });
    }
    return /* @__PURE__ */ jsx30(FrameWithMotion, { ...props, ref });
  });
  FrameInner["displayName"] = "Frame";
  return FrameInner;
})();

// ../../library/src/components/Draggable.ts
var Draggable = /* @__PURE__ */ WithDragging(DeprecatedFrameWithEvents);

// ../../library/src/components/Pagination/InfiniteScroll.tsx
import React36, { useEffect as useEffect13, useRef as useRef12 } from "react";
import { jsx as jsx31 } from "react/jsx-runtime";
function useInfiniteScroll({ ref: observerRef, loadMore, rootMargin = "0px", paginationInfo }) {
  const isVisibleRef = useRef12(false);
  const callback = React36.useCallback(
    (entry) => {
      if (!entry.isIntersecting) {
        isVisibleRef.current = false;
        return;
      }
      isVisibleRef.current = true;
      loadMore();
      return;
    },
    [loadMore]
  );
  useEffect13(() => {
    frame.postRender(() => {
      frame.render(() => {
        if (isVisibleRef.current) {
          loadMore();
        }
      });
    });
  }, [paginationInfo.currentPage, loadMore]);
  useSharedIntersectionObserver(observerRef, callback, {
    rootMargin,
    enabled: paginationInfo.currentPage < paginationInfo.totalPages
  });
}
function withInfiniteScroll(Component18) {
  return React36.forwardRef(
    ({ __paginationInfo, __loadMore, ...props }, ref) => {
      const infiniteScrollRef = useObserverRef(ref);
      useInfiniteScroll({
        rootMargin: "500px",
        loadMore: __loadMore,
        ref: infiniteScrollRef,
        paginationInfo: __paginationInfo
      });
      return /* @__PURE__ */ jsx31(Component18, { ...props, ref: infiniteScrollRef });
    }
  );
}

// ../../library/src/components/Page/EmulatedPage.tsx
import React38, { startTransition } from "react";

// ../../library/src/components/Scroll/useWheelScroll.ts
import { useCallback as useCallback9, useRef as useRef13 } from "react";

// ../../library/src/render/utils/debounce.ts
function debounce2(fn, time2) {
  let timeout;
  const debounced = (...args) => {
    safeWindow.clearTimeout(timeout);
    timeout = safeWindow.setTimeout(fn, time2, ...args);
  };
  const cancel = () => {
    safeWindow.clearTimeout(timeout);
  };
  debounced.cancel = cancel;
  return debounced;
}

// ../../library/src/components/Scroll/useWheelScroll.ts
function useWheelScroll(ref, {
  enabled,
  initial,
  prev,
  direction,
  constraints,
  offsetX,
  offsetY,
  onScrollStart,
  onScroll,
  onScrollEnd
}) {
  const isWheelScrollActive = useRef13(false);
  const getPointData = useCallback9(() => {
    const point = getPoint(offsetX, offsetY);
    const data2 = {
      point,
      velocity: { x: offsetX.getVelocity(), y: offsetY.getVelocity() },
      offset: { x: point.x - initial.x, y: point.y - initial.y },
      delta: { x: point.x - prev.x, y: point.y - prev.y }
    };
    prev.x = point.x;
    prev.y = point.y;
    return data2;
  }, []);
  let handler;
  if (enabled) {
    let clampX2 = function(v) {
      return constraints.current === null ? v : clamp2(v, constraints.current.left, constraints.current.right);
    }, clampY2 = function(v) {
      return constraints.current === null ? v : clamp2(v, constraints.current.top, constraints.current.bottom);
    }, updateX2 = function(delta) {
      offsetX.stop();
      offsetX.set(clampX2(offsetX.get() - delta));
    }, updateY2 = function(delta) {
      offsetY.stop();
      offsetY.set(clampY2(offsetY.get() - delta));
    };
    var clampX = clampX2, clampY = clampY2, updateX = updateX2, updateY = updateY2;
    const debouncedOnScrollEnd = debounce2(() => {
      onScrollEnd && onScrollEnd(getPointData());
      isWheelScrollActive.current = false;
    }, 200);
    handler = (e) => {
      e.preventDefault();
      if (!isWheelScrollActive.current) {
        const x = offsetX.get();
        const y = offsetY.get();
        initial.x = x;
        initial.y = y;
        prev.x = x;
        prev.y = y;
        onScrollStart && onScrollStart(getPointData());
        isWheelScrollActive.current = true;
      }
      switch (direction) {
        case "horizontal":
          updateX2(e.deltaX);
          break;
        case "vertical":
          updateY2(e.deltaY);
          break;
        default:
          updateX2(e.deltaX);
          updateY2(e.deltaY);
      }
      onScroll && onScroll(getPointData());
      debouncedOnScrollEnd();
    };
  }
  useDomEvent(ref, "wheel", handler, { passive: false });
}
function getPoint(x, y) {
  return { x: x.get(), y: y.get() };
}

// ../../library/src/components/utils/paddingFromProps.ts
function hasPaddingPerSide(props) {
  const { paddingPerSide, paddingTop, paddingBottom, paddingLeft, paddingRight } = props;
  return paddingPerSide !== false && (paddingTop !== void 0 || paddingBottom !== void 0 || paddingLeft !== void 0 || paddingRight !== void 0);
}
function paddingFromProps(props) {
  const { padding = 0, paddingTop, paddingBottom, paddingLeft, paddingRight } = props;
  if (hasPaddingPerSide(props)) {
    return {
      top: paddingTop !== void 0 ? paddingTop : padding,
      bottom: paddingBottom !== void 0 ? paddingBottom : padding,
      left: paddingLeft !== void 0 ? paddingLeft : padding,
      right: paddingRight !== void 0 ? paddingRight : padding
    };
  }
  return {
    top: padding,
    bottom: padding,
    left: padding,
    right: padding
  };
}
function makePaddingString({
  top,
  left,
  bottom,
  right
}) {
  if (top === right && right === bottom && bottom === left) {
    return `${top}px`;
  }
  return `${top}px ${right}px ${bottom}px ${left}px`;
}

// ../../library/src/components/Stack/Stack.tsx
import React37 from "react";
import { jsx as jsx32 } from "react/jsx-runtime";
var Stack = /* @__PURE__ */ (() => {
  const StackInner = React37.forwardRef(
    function StackInner2(stackProps, forwardedRef) {
      const {
        as = "div",
        direction = "vertical",
        distribution = "start",
        alignment = "center",
        gap = 10,
        wrap: wrap2 = false,
        useFlexboxGap: externalUseFlexboxGap = true,
        children,
        style: styleProp,
        className: className2,
        willChangeTransform,
        __fromCodeComponentNode,
        parentSize,
        __contentWrapperStyle,
        ...containerProps
      } = stackProps;
      const useFlexboxGap = externalUseFlexboxGap || wrap2;
      const stackRef = React37.useRef(null);
      const flexDirection = toFlexDirection(direction);
      const isReverse = isReverseDirection(flexDirection);
      const justifyContent = toJustifyOrAlignment(distribution);
      const padding = hasPaddingPerSide(containerProps) || containerProps.padding ? makePaddingString(paddingFromProps(containerProps)) : void 0;
      const style = { ...styleProp };
      Layer.applyWillChange({ willChangeTransform }, style, true);
      if (__fromCodeComponentNode && !constraintsEnabled(unwrapFrameProps(containerProps))) {
        containerProps.width = "100%";
        containerProps.height = "100%";
        containerProps._constraints = { enabled: true };
      }
      const layoutId = useLayoutId(stackProps);
      const { children: _children, props } = processOverrideForwarding(containerProps, children);
      const widthType = containerProps.widthType ?? (containerProps.width === "auto" ? 2 /* Auto */ : 0 /* FixedNumber */);
      const heightType = containerProps.heightType ?? (containerProps.height === "auto" ? 2 /* Auto */ : 0 /* FixedNumber */);
      const fractionChildren = handleFraction(_children, direction, widthType, heightType);
      const gapChildren = wrapInGapElementForLegacyGap(
        fractionChildren,
        gap,
        flexDirection,
        justifyContent,
        useFlexboxGap,
        wrap2
      );
      const content = useProvideParentSize(gapChildren, parentSize ?? 1 /* Disabled */);
      const attributes = {
        "data-framer-component-type": "Stack"
      };
      const fromCanvasComponent = containerProps.__fromCanvasComponent;
      if (fromCanvasComponent) attributes["data-framer-generated"] = true;
      const alignItems = toJustifyOrAlignment(alignment);
      const contentWrapperStyle = {
        display: "flex",
        flexDirection,
        flexWrap: wrap2 ? "wrap" : "nowrap",
        justifyContent,
        alignItems,
        alignContent: alignItems,
        padding,
        ...__contentWrapperStyle
      };
      const gapEnabled = isGapEnabled(gap, justifyContent, wrap2);
      if (useFlexboxGap && gapEnabled) {
        const gapSupportedInMainAxis = isGapSupportedInMainAxis(justifyContent);
        if (gapSupportedInMainAxis || direction !== "horizontal") {
          asRecord(contentWrapperStyle)["--stack-native-column-gap"] = `${gap}px`;
        }
        if (gapSupportedInMainAxis || direction !== "vertical") {
          asRecord(contentWrapperStyle)["--stack-native-row-gap"] = `${gap}px`;
        }
      }
      if (contentWrapperStyle.width === void 0) {
        contentWrapperStyle.width = widthType === 2 /* Auto */ ? "min-content" : "100%";
      }
      if (contentWrapperStyle.height === void 0) {
        contentWrapperStyle.height = heightType === 2 /* Auto */ ? "min-content" : "100%";
      }
      if (fromCanvasComponent) {
        if (styleProp?.width) contentWrapperStyle.width = styleProp?.width;
        if (styleProp?.height) contentWrapperStyle.height = styleProp?.height;
      }
      return /* @__PURE__ */ jsx32(
        FrameWithMotion,
        {
          as,
          background: fromCanvasComponent ? void 0 : "none",
          ...props,
          layoutId,
          ref: useForwardedRef(forwardedRef, stackRef),
          ...attributes,
          style,
          className: className2,
          layoutScroll: true,
          children: /* @__PURE__ */ jsx32(
            motion.div,
            {
              "data-framer-stack-content-wrapper": true,
              "data-framer-stack-direction-reverse": isReverse,
              "data-framer-stack-gap-enabled": gapEnabled,
              style: contentWrapperStyle,
              children: content
            }
          )
        }
      );
    }
  );
  StackInner.defaultProps = {
    distribution: "start"
  };
  StackInner.displayName = "Stack";
  addPropertyControls(StackInner, {
    direction: {
      type: "segmentedenum" /* SegmentedEnum */,
      options: ["horizontal", "vertical"],
      title: "Direction",
      defaultValue: "vertical"
    },
    distribution: {
      type: "enum" /* Enum */,
      options: ["start", "center", "end", "space-between", "space-around", "space-evenly"],
      optionTitles: ["Start", "Center", "End", "Space Between", "Space Around", "Space Evenly"],
      title: "Distribute",
      defaultValue: "space-around"
    },
    alignment: {
      type: "segmentedenum" /* SegmentedEnum */,
      options: ["start", "center", "end"],
      title: "Align",
      defaultValue: "center"
    },
    gap: {
      type: "number" /* Number */,
      min: 0,
      title: "Gap",
      hidden: (props) => {
        return props.distribution !== void 0 && ["space-between", "space-around", "space-evenly"].includes(props.distribution);
      },
      defaultValue: 10
    },
    padding: {
      type: "fusednumber" /* FusedNumber */,
      toggleKey: "paddingPerSide",
      toggleTitles: ["Padding", "Padding per side"],
      valueKeys: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
      valueLabels: ["t", "r", "b", "l"],
      min: 0,
      title: "Padding",
      defaultValue: 0
    }
  });
  return StackInner;
})();
function isFractionDimension(dimension) {
  return typeof dimension === "string" && dimension.endsWith("fr");
}
function fraction(dimension) {
  const value = parseFloat(dimension);
  return isFiniteNumber(value) ? value : 0;
}
function handleFraction(children, direction, widthType, heightType) {
  return React37.Children.map(children, (child) => {
    if (!isReactChild(child) || !isReactElement(child)) return;
    const isVertical = direction === "vertical";
    const style = {};
    let hasFraction = false;
    const { style: propsStyle, size } = child.props;
    let { width, height } = child.props;
    if (size !== void 0) {
      if (width === void 0) width = size;
      if (height === void 0) height = size;
    }
    let newWidth = width;
    let newHeight = height;
    if (isFractionDimension(width)) {
      hasFraction = true;
      hasFraction = true;
      if (isVertical) {
        if (widthType === 2 /* Auto */) {
          style.alignSelf = "stretch";
          newWidth = "auto";
        } else {
          newWidth = `${fraction(width) * 100}%`;
        }
      } else {
        newWidth = 1;
        style.flexGrow = fraction(width);
        style.flexBasis = 0;
      }
      style.width = newWidth;
    }
    if (isFractionDimension(height)) {
      hasFraction = true;
      if (isVertical) {
        newHeight = 1;
        style.flexGrow = fraction(height);
        style.flexBasis = 0;
      } else {
        if (heightType === 2 /* Auto */) {
          style.alignSelf = "stretch";
          newHeight = "auto";
        } else {
          newHeight = `${fraction(height) * 100}%`;
        }
      }
      style.height = newHeight;
    }
    if (!hasFraction) return child;
    const nextStyle = { ...propsStyle, ...style };
    return React37.cloneElement(child, {
      width: newWidth,
      height: newHeight,
      style: nextStyle
    });
  });
}
function isGapSupportedInMainAxis(justifyContent) {
  if (!justifyContent) return false;
  return !["space-between", "space-around", "space-evenly", "stretch"].includes(justifyContent);
}
function isGapEnabled(gap, justifyContent, wrap2) {
  if (!gap) {
    return false;
  }
  if (!wrap2 && !isGapSupportedInMainAxis(justifyContent)) {
    return false;
  }
  return true;
}
function wrapInGapElementForLegacyGap(children, gap, direction, justifyContent, useFlexboxGap, wrap2) {
  const gapStyle = {
    // We need the wrapper to have `display: contents` to prevent the child
    // margins from collapsing when using the fallback gap solution.
    // https://codesandbox.io/s/dreamy-haslett-01ie5?file=/src/styles.css
    display: "contents"
  };
  const gapEnabled = isGapEnabled(gap, justifyContent, wrap2);
  if (gapEnabled) {
    const isVertical = isVerticalDirection(direction);
    asRecord(gapStyle)["--stack-gap-x"] = `${isVertical ? 0 : gap}px`;
    asRecord(gapStyle)["--stack-gap-y"] = `${isVertical ? gap : 0}px`;
  }
  return /* @__PURE__ */ jsx32(
    "div",
    {
      "data-framer-legacy-stack-gap-enabled": gapEnabled,
      "data-framer-stack-flexbox-gap": useFlexboxGap,
      style: gapStyle,
      children
    }
  );
}
function toFlexDirection(direction) {
  switch (direction) {
    case "vertical":
      return "column";
    case "horizontal":
      return "row";
    default:
      return direction;
  }
}
function isVerticalDirection(direction) {
  return direction === "column" || direction === "column-reverse";
}
function isReverseDirection(direction) {
  switch (direction) {
    case "column-reverse":
    case "row-reverse":
      return true;
    default:
      return false;
  }
}
function toJustifyOrAlignment(distribution) {
  switch (distribution) {
    case "start":
      return "flex-start";
    case "end":
      return "flex-end";
    default:
      return distribution;
  }
}
function useForwardedRef(forwardedRef, innerRef) {
  return (element) => {
    innerRef.current = element;
    if (typeof forwardedRef === "function") {
      forwardedRef(element);
    } else if (forwardedRef) {
      forwardedRef.current = element;
    }
  };
}

// ../../library/src/components/Page/PageContainer.tsx
import { jsx as jsx33 } from "react/jsx-runtime";
var pageContentWrapperType = "PageContentWrapper";
function PageContainer({
  children,
  effect,
  dragEnabled,
  direction,
  contentHeight,
  contentWidth,
  alignment,
  gap,
  isLastPage,
  contentOffsetRef,
  constraintsRef,
  directionLock,
  onDragStart,
  onDrag,
  onDragEnd,
  layoutId
}) {
  const isHorizontalDirection = direction === "horizontal";
  const dragAxis = isHorizontalDirection ? "x" : "y";
  const hasHorizontalGap = isHorizontalDirection && !isLastPage && gap;
  const hasVerticalGap = !isHorizontalDirection && !isLastPage && gap;
  const hasAutoWidth = contentWidth !== "stretch" && isHorizontalDirection;
  const hasAutoHeight = contentHeight !== "stretch" && !isHorizontalDirection;
  const wrapperWidth = hasAutoWidth ? "auto" : "100%";
  const wrapperHeight = hasAutoHeight ? "auto" : "100%";
  const containerWidth = hasHorizontalGap && wrapperWidth === "100%" ? `calc(100% + ${gap}px)` : wrapperWidth;
  const containerHeight = hasVerticalGap && wrapperHeight === "100%" ? `calc(100% + ${gap}px)` : wrapperHeight;
  return /* @__PURE__ */ jsx33(
    FrameWithMotion,
    {
      position: "relative",
      "data-framer-component-type": "PageContainer",
      width: containerWidth,
      height: containerHeight,
      layoutId: layoutId ? `${layoutId}-container` : void 0,
      backgroundColor: "transparent",
      drag: dragEnabled ? dragAxis : false,
      dragDirectionLock: directionLock,
      _dragX: contentOffsetRef.current.x,
      _dragY: contentOffsetRef.current.y,
      dragConstraints: constraintsRef.current,
      onDrag,
      onDragStart,
      onDragEnd,
      preserve3d: true,
      style: {
        pointerEvents: void 0,
        paddingRight: hasHorizontalGap ? gap : 0,
        paddingBottom: hasVerticalGap ? gap : 0
      },
      children: /* @__PURE__ */ jsx33(
        FrameWithMotion,
        {
          position: "relative",
          "data-framer-component-type": pageContentWrapperType,
          width: wrapperWidth,
          height: wrapperHeight,
          preserve3d: false,
          backgroundColor: "transparent",
          style: {
            ...effect,
            pointerEvents: void 0,
            display: "flex",
            flexDirection: isHorizontalDirection ? "row" : "column",
            alignItems: alignment && toJustifyOrAlignment(alignment)
          },
          children
        },
        effect ? Object.keys(effect).join("") : ""
      )
    }
  );
}

// ../../library/src/components/Page/EmulatedPage.tsx
import { jsx as jsx34, jsxs as jsxs9 } from "react/jsx-runtime";
var Page = /* @__PURE__ */ React38.forwardRef(function Page2(props, forwardedRef) {
  const {
    direction = "horizontal",
    contentWidth = "stretch",
    contentHeight = "stretch",
    alignment = "start",
    currentPage = 0,
    animateCurrentPageUpdate = true,
    gap: gapValue = 10,
    padding: _padding = 0,
    momentum = false,
    dragEnabled = true,
    defaultEffect: _defaultEffect = "none",
    background = "transparent",
    overflow = "hidden",
    __fromCodeComponentNode,
    effect: _effect,
    children,
    contentOffsetX,
    contentOffsetY,
    onChangePage,
    onScrollStart,
    onScroll,
    onDragStart,
    onDrag,
    onDragEnd,
    directionLock,
    onScrollEnd,
    onDirectionLock: _onDirectionLock,
    onUpdate: _onUpdate,
    wheelEnabled = false,
    layoutId: specificLayoutId,
    ...rest
  } = props;
  const layoutId = useLayoutId(props, { specificLayoutId, postfix: "page" });
  const containerProps = { ...rest, background };
  const hasMountedRef = React38.useRef(false);
  const hasFixedSize = RenderTarget.hasRestrictions() && props.__fromCodeComponentNode && isFiniteNumber(containerProps.width) && isFiniteNumber(containerProps.height);
  if (!hasFixedSize && __fromCodeComponentNode && !containerProps.__fromCanvasComponent) {
    containerProps.width = "100%";
    containerProps.height = "100%";
    containerProps._constraints = { enabled: true };
  }
  const { initial, prev } = React38.useRef({
    initial: { x: 0, y: 0 },
    prev: { x: 0, y: 0 }
  }).current;
  const isHorizontal = direction === "horizontal";
  let gap = gapValue;
  if (gap < 0) {
    warnOnce2(`The 'gap' property of Page component can not be negative, but is ${gapValue}.`);
    gap = 0;
  }
  React38.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, []);
  const pageCount = React38.Children.count(children);
  const maxOffsetRef = React38.useRef(0);
  const constraints = React38.useRef({ top: 0, left: 0, right: 0, bottom: 0 });
  const fallbackContainerRef = React38.useRef(null);
  const containerRef = forwardedRef || fallbackContainerRef;
  const scrollableRef = React38.useRef(null);
  const pageEffectValuesRef = React38.useRef([]);
  const pageRectsRef = React38.useRef([]);
  const internalX = useMotionValue(isMotionValue2(contentOffsetX) ? 0 : contentOffsetX ?? 0);
  const internalY = useMotionValue(isMotionValue2(contentOffsetY) ? 0 : contentOffsetY ?? 0);
  const contentOffsetRef = React38.useRef({
    x: isMotionValue2(contentOffsetX) ? contentOffsetX : internalX,
    y: isMotionValue2(contentOffsetY) ? contentOffsetY : internalY
  });
  const currentContentPageRef = React38.useRef(currentPage);
  const propsBoundedCurrentPageRef = React38.useRef(currentPage);
  const latestPropsRef = React38.useRef(props);
  latestPropsRef.current = props;
  const lastDirectionRef = React38.useRef(props.direction);
  const snapToPage = useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal);
  const [_, setForceUpdateCount] = React38.useState(0);
  const containerSizeRef = React38.useRef({ width: 200, height: 200 });
  if (hasFixedSize && isFiniteNumber(containerProps.width) && isFiniteNumber(containerProps.height)) {
    containerSizeRef.current.width = containerProps.width;
    containerSizeRef.current.height = containerProps.height;
  }
  const updateOnResize = React38.useCallback(() => {
    if (!hasFixedSize) startTransition(() => setForceUpdateCount((v) => v + 1));
  }, [hasFixedSize]);
  React38.useEffect(() => {
    if (RenderTarget.current() !== RenderTarget.preview) return;
    globalThis.addEventListener("resize", updateOnResize);
    return () => {
      globalThis.removeEventListener("resize", updateOnResize);
    };
  }, [updateOnResize]);
  const applyEffects = () => {
    pageEffectValuesRef.current.forEach((effectDictionary, index) => {
      const values = effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef);
      if (!effectDictionary || !values) return;
      for (const [key7, value] of Object.entries(values)) {
        const effectValue = effectDictionary[key7];
        if (isMotionValue2(effectValue)) {
          effectValue.set(value);
        }
      }
    });
  };
  const updateMaxOffsetFromPageContents = (containerSize) => {
    const newPageContentRects = getPageContentRects(containerRef, containerSize, direction, gap);
    if (newPageContentRects) pageRectsRef.current = newPageContentRects;
    const newMaxOffset = getMaxOffset(
      containerSizeRef.current,
      pageRectsRef.current,
      direction,
      latestPropsRef.current
    );
    if (newMaxOffset !== maxOffsetRef.current) {
      maxOffsetRef.current = newMaxOffset;
      constraints.current.top = -newMaxOffset;
      constraints.current.left = -newMaxOffset;
      if (RenderTarget.current() === RenderTarget.canvas) setForceUpdateCount((v) => v + 1);
    }
  };
  const measureContainerSize = () => {
    const element = containerRef.current;
    if (!element) return null;
    const { offsetWidth, offsetHeight } = element;
    const currentSize = containerSizeRef.current;
    if (offsetWidth !== currentSize.width || offsetHeight !== currentSize.height) {
      containerSizeRef.current = {
        width: offsetWidth,
        height: offsetHeight
      };
      return containerSizeRef.current;
    }
    return null;
  };
  const updateAndSnapToPage = (newPage, mount = false) => {
    const newBoundedCurrentPage = getBoundedCurrentPage(newPage, pageCount);
    const boundedCurrentPageDidChange = newBoundedCurrentPage !== propsBoundedCurrentPageRef.current;
    if (boundedCurrentPageDidChange) {
      propsBoundedCurrentPageRef.current = newBoundedCurrentPage;
      updateCurrentPage(newBoundedCurrentPage, currentContentPageRef, !mount ? onChangePage : void 0);
    }
    const offset = offsetForPage(newBoundedCurrentPage, pageCount, pageRectsRef, isHorizontal, maxOffsetRef);
    const animated = animateCurrentPageUpdate && RenderTarget.current() !== RenderTarget.canvas && !mount;
    snapToPage(newBoundedCurrentPage, offset, { animated });
  };
  useIsomorphicLayoutEffect2(() => {
    if (hasMountedRef.current) return;
    requestAnimationFrame(() => {
      currentContentPageRef.current = currentPage;
      const contentOffset = contentOffsetRef.current;
      contentOffset.x.on("change", applyEffects);
      contentOffset.y.on("change", applyEffects);
      applyEffects();
      hasMountedRef.current = true;
      const containerSize = measureContainerSize() ?? containerSizeRef.current;
      updateMaxOffsetFromPageContents(containerSize);
      updateAndSnapToPage(currentContentPageRef.current, true);
    });
  }, []);
  React38.useEffect(() => {
    if (currentPage !== currentContentPageRef.current) updateAndSnapToPage(currentPage);
  }, [currentPage]);
  const handleMeasureLifecycle = () => {
    const newContainerSize = measureContainerSize();
    updateMaxOffsetFromPageContents(newContainerSize ?? containerSizeRef.current);
    updateAndSnapToPage(currentContentPageRef.current);
    if (newContainerSize || direction !== lastDirectionRef.current) {
      if (direction === "horizontal") {
        contentOffsetRef.current.y.set(0);
      } else {
        contentOffsetRef.current.x.set(0);
      }
      lastDirectionRef.current = direction;
    }
  };
  useIsomorphicLayoutEffect2(() => {
    if (RenderTarget.current() !== RenderTarget.canvas) return;
    handleMeasureLifecycle();
  });
  const onDragStartHandler = (event, info) => {
    if (onScrollStart) onScrollStart(info);
    if (onDragStart) onDragStart(event, info);
    prev.x = initial.x = info.point.x;
    prev.y = initial.y = info.point.y;
  };
  const onDragHandler = (event, info) => {
    if (onScroll) onScroll(info);
    if (onDrag) onDrag(event, info);
    prev.x = info.point.x;
    prev.y = info.point.y;
  };
  const onDragTransitionEnd = () => {
    if (props.onDragTransitionEnd) props.onDragTransitionEnd();
    if (onScrollEnd) {
      const { x, y } = contentOffsetRef.current;
      const point = { x: x.get(), y: y.get() };
      onScrollEnd({
        point,
        velocity: { x: x.getVelocity(), y: y.getVelocity() },
        offset: { x: point.x - initial.x, y: point.y - initial.y },
        delta: { x: point.x - prev.x, y: point.y - prev.y }
      });
    }
  };
  const onDragEndHandler = async (event, info) => {
    const contentOffset = isHorizontal ? contentOffsetRef.current.x : contentOffsetRef.current.y;
    contentOffset.stop();
    const startPosition = contentOffset.get();
    const axis = isHorizontal ? "x" : "y";
    const velocity = info.velocity[axis];
    let index = nearestPageIndex(pageRectsRef.current, startPosition, startPosition, isHorizontal, momentum);
    if (velocity) {
      animateValue({
        type: "inertia",
        keyframes: [startPosition],
        velocity,
        modifyTarget: (endPosition) => {
          index = nearestPageIndex(pageRectsRef.current, startPosition, endPosition, isHorizontal, momentum);
          return endPosition;
        }
      }).stop();
    }
    updateCurrentPage(index, currentContentPageRef, onChangePage);
    const offset = offsetForPage(index, pageCount, pageRectsRef, isHorizontal, maxOffsetRef);
    if (onDragEnd) onDragEnd(event, info);
    const handler = contentOffsetRef.current[axis];
    handler.set(startPosition);
    animate(handler, offset, {
      type: "spring",
      velocity,
      stiffness: 500,
      damping: 50,
      onComplete: onDragTransitionEnd
    });
  };
  pageEffectValuesRef.current = [];
  const childComponents = React38.Children.map(children, (child, index) => {
    if (!isReactChild(child) || !isReactElement(child)) {
      return child;
    }
    const update = {
      right: void 0,
      bottom: void 0,
      top: void 0,
      left: void 0,
      _constraints: {
        enabled: false
      },
      style: void 0
    };
    if (containerProps.__fromCanvasComponent) {
      update.style = child.props.style ?? {};
      if (contentWidth === "stretch") update.style.width = "100%";
      if (contentHeight === "stretch") update.style.height = "100%";
    } else {
      if (contentWidth === "stretch") update.width = "100%";
      if (contentHeight === "stretch") update.height = "100%";
    }
    let effectDictionary;
    const values = effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef);
    if (values) {
      effectDictionary = {};
      for (const key7 in values) {
        effectDictionary[key7] = motionValue(values[key7]);
      }
    }
    pageEffectValuesRef.current.push(effectDictionary);
    return /* @__PURE__ */ jsx34(
      PageContainer,
      {
        effect: effectDictionary,
        dragEnabled,
        direction,
        contentHeight,
        contentWidth,
        alignment,
        gap,
        isLastPage: index === pageCount - 1,
        contentOffsetRef,
        constraintsRef: constraints,
        directionLock,
        onDragStart: onDragStartHandler,
        onDrag: onDragHandler,
        onDragEnd: onDragEndHandler,
        layoutId: layoutId ? `${layoutId}-${index}` : void 0,
        children: React38.cloneElement(child, update)
      },
      index
    );
  });
  useWheelScroll(scrollableRef, {
    enabled: wheelEnabled,
    initial,
    prev,
    direction,
    constraints,
    offsetX: contentOffsetRef.current.x,
    offsetY: contentOffsetRef.current.y,
    onScrollStart,
    onScroll,
    onScrollEnd
  });
  return /* @__PURE__ */ jsx34(
    FrameWithMotion,
    {
      "data-framer-component-type": "PageWrapper",
      preserve3d: false,
      perspective: hasEffect(props) ? 1200 : void 0,
      ...containerProps,
      style: { pointerEvents: void 0, ...containerProps.style, overflow },
      layoutId,
      ref: containerRef,
      onLayoutMeasure: handleMeasureLifecycle,
      children: /* @__PURE__ */ jsxs9(
        FrameWithMotion,
        {
          "data-framer-component-type": "Page",
          ref: scrollableRef,
          background: null,
          x: contentOffsetRef.current.x,
          y: contentOffsetRef.current.y,
          width: "100%",
          height: "100%",
          preserve3d: true,
          layout: true,
          layoutId: layoutId !== void 0 ? layoutId + "-page" : void 0,
          style: {
            padding: makePaddingString(paddingFromProps(props)),
            display: "flex",
            flexDirection: isHorizontal ? "row" : "column",
            pointerEvents: props.style?.pointerEvents
          },
          children: [
            /* @__PURE__ */ jsx34(
              EmptyState,
              {
                title: "Page",
                description: "Click and drag the connector to any frame on the canvas \u2192",
                size: containerSizeRef.current,
                insideUserCodeComponent: !__fromCodeComponentNode,
                children
              }
            ),
            childComponents
          ]
        }
      )
    }
  );
});
function cubeEffect(info) {
  const { normalizedOffset, direction } = info;
  const isHorizontal = direction === "horizontal";
  return {
    originX: normalizedOffset < 0 ? 1 : 0,
    originY: normalizedOffset < 0 ? 1 : 0,
    rotateY: isHorizontal ? Math.min(Math.max(-90, normalizedOffset * 90), 90) : 0,
    rotateX: isHorizontal ? 0 : Math.min(Math.max(-90, normalizedOffset * -90), 90),
    backfaceVisibility: "hidden",
    WebkitBackfaceVisibility: "hidden"
  };
}
function coverflowEffect(info) {
  const { normalizedOffset, direction } = info;
  const isHorizontal = direction === "horizontal";
  return {
    rotateY: isHorizontal ? Math.min(45, Math.max(-45, normalizedOffset * -45)) : 0,
    rotateX: isHorizontal ? 0 : Math.min(45, Math.max(-45, normalizedOffset * 45)),
    originX: isHorizontal ? normalizedOffset < 0 ? 0 : 1 : 0.5,
    originY: isHorizontal ? 0.5 : normalizedOffset < 0 ? 0 : 1,
    x: isHorizontal ? `${normalizedOffset * -25}%` : 0,
    y: isHorizontal ? 0 : `${normalizedOffset * -25}%`,
    z: -Math.abs(normalizedOffset),
    scale: 1 - Math.abs(normalizedOffset / 10)
  };
}
function calcPileAxisOffset(offset, length) {
  return offset * length - offset * 8;
}
function pileEffect(info) {
  const { normalizedOffset, direction, size } = info;
  const isHorizontal = direction === "horizontal";
  const absoluteOffset = Math.abs(normalizedOffset);
  return {
    x: normalizedOffset < 0 && isHorizontal ? calcPileAxisOffset(absoluteOffset, size.width) : 0,
    y: normalizedOffset < 0 && !isHorizontal ? calcPileAxisOffset(absoluteOffset, size.height) : 0,
    scale: normalizedOffset < 0 ? 1 - absoluteOffset / 50 : 1
  };
}
function wheelEffect(info) {
  const { normalizedOffset, direction, size } = info;
  const isHorizontal = direction === "horizontal";
  const originZ = (isHorizontal ? size.width : size.height) * 18 / (2 * Math.PI);
  const rotateX = isHorizontal ? 0 : normalizedOffset * -20;
  const rotateY = isHorizontal ? normalizedOffset * 20 : 0;
  const y = isHorizontal ? 0 : normalizedOffset * -size.height;
  const x = isHorizontal ? normalizedOffset * -size.width : 0;
  return {
    opacity: 1 - Math.abs(normalizedOffset) / 4,
    transform: `translate(${x}px, ${y}px) translateZ(-${originZ}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(${originZ}px)`
  };
}
function getDefaultEffect(type) {
  switch (type) {
    case "cube":
      return cubeEffect;
    case "coverflow":
      return coverflowEffect;
    case "pile":
      return pileEffect;
    case "wheel":
      return wheelEffect;
    default:
      return null;
  }
}
function nearestPageIndex(pageRects, startPosition, endPosition, isHorizontalDirection, allowSkippingPages) {
  const distanceToStart = function(rect) {
    const rectPosition = isHorizontalDirection ? rect.x : rect.y;
    return Math.abs(rectPosition + startPosition);
  };
  const distanceToEnd = function(rect) {
    const rectPosition = isHorizontalDirection ? rect.x : rect.y;
    return Math.abs(rectPosition + endPosition);
  };
  if (allowSkippingPages) {
    const closestPages = [...pageRects].sort((a, b) => distanceToEnd(a) - distanceToEnd(b));
    if (!closestPages[0]) return -1;
    return pageRects.indexOf(closestPages[0]);
  } else {
    const closestToStart = [...pageRects].sort((a, b) => distanceToStart(a) - distanceToStart(b));
    if (closestToStart.length === 1 && closestToStart[0]) return pageRects.indexOf(closestToStart[0]);
    const pageA = closestToStart[0];
    const pageB = closestToStart[1];
    if (!pageA || !pageB) return -1;
    const closestPages = [pageA, pageB].sort((a, b) => distanceToEnd(a) - distanceToEnd(b));
    if (!closestPages[0]) return -1;
    return pageRects.indexOf(closestPages[0]);
  }
}
function getPageContentRects(containerRef, containerSize, direction, gap) {
  const containerElement = containerRef.current;
  if (!containerElement) return;
  const contentWrappers = [];
  containerElement.firstChild?.childNodes.forEach((node) => {
    const childNode = node.firstChild;
    if (!(childNode instanceof HTMLElement)) return;
    const componentType = childNode.getAttribute("data-framer-component-type");
    if (componentType === pageContentWrapperType) {
      contentWrappers.push(childNode);
    }
  });
  const sizes = [];
  contentWrappers.forEach((contentWrapper) => {
    if (contentWrapper instanceof HTMLElement && contentWrapper.firstChild instanceof HTMLElement) {
      let width = contentWrapper.firstChild.offsetWidth;
      let height = contentWrapper.firstChild.offsetHeight;
      if (isTest()) {
        width = 100;
        height = 100;
      }
      sizes.push({ width, height });
    } else {
      sizes.push(null);
    }
  });
  let maxX = 0;
  let maxY = 0;
  const isHorizontal = direction === "horizontal";
  return sizes.map((queriedSize) => {
    const size = queriedSize || containerSize;
    const x = maxX;
    const y = maxY;
    if (isHorizontal) {
      maxX += size.width + gap;
    } else {
      maxY += size.height + gap;
    }
    return { ...size, x, y };
  });
}
function getMaxOffset(containerSize, pageContentRects, direction, paddingProps) {
  const lastPageRect = pageContentRects[pageContentRects.length - 1];
  if (!lastPageRect) return 0;
  const paddingSides = paddingFromProps(paddingProps);
  const isHorizontal = direction === "horizontal";
  const paddingStart = isHorizontal ? paddingSides.left : paddingSides.top;
  const paddingEnd = isHorizontal ? paddingSides.right : paddingSides.bottom;
  const pageWidth = isHorizontal ? lastPageRect.width : lastPageRect.height;
  const containerWidth = isHorizontal ? containerSize.width : containerSize.height;
  const freeSpace = containerWidth - paddingStart - paddingEnd - pageWidth;
  const target = isHorizontal ? lastPageRect.x : lastPageRect.y;
  if (freeSpace <= 0) return Math.max(target, 0);
  return Math.max(target - freeSpace, 0);
}
function offsetForPage(index, pageCount, pageRectsRef, isHorizontal, maxOffsetRef) {
  const pageIndex = Math.max(0, Math.min(pageCount - 1, index));
  const currentPageRect = pageRectsRef.current[pageIndex];
  if (!currentPageRect) {
    return 0;
  }
  if (isHorizontal) {
    return -Math.min(currentPageRect.x, maxOffsetRef.current);
  } else {
    return -Math.min(currentPageRect.y, maxOffsetRef.current);
  }
}
function useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal) {
  return (pageIndex, offset, options) => {
    currentContentPageRef.current = pageIndex;
    const contentOffset = isHorizontal ? contentOffsetRef.current.x : contentOffsetRef.current.y;
    if (!options || !options.animated) {
      contentOffset.set(offset);
      return;
    }
    const axis = isHorizontal ? "x" : "y";
    const value = contentOffsetRef.current[axis];
    value.set(contentOffset.get());
    animate(value, offset, {
      type: "spring",
      velocity: contentOffset.getVelocity(),
      stiffness: 500,
      damping: 50
    });
  };
}
function getBoundedCurrentPage(pageIndex, pageCount) {
  return pageIndex >= 0 ? Math.min(pageIndex, pageCount - 1) : (pageIndex % pageCount + pageCount) % pageCount;
}
function effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef) {
  const {
    direction: latestDirection = "horizontal",
    defaultEffect: latestDefaultEffect,
    effect: latestEffect,
    gap: latestGap = 10
  } = latestPropsRef.current;
  const latestIsHorizontal = latestDirection === "horizontal";
  const pageRect = pageRectsRef.current[index] || {
    x: latestIsHorizontal ? index * 200 + latestGap : 0,
    y: latestIsHorizontal ? 0 : index * 200 + latestGap,
    width: 200,
    height: 200
  };
  const effectFunction = latestEffect || getDefaultEffect(latestDefaultEffect);
  if (!effectFunction) return null;
  let offset;
  let normalizedOffset;
  const contentOffset = contentOffsetRef.current;
  const maxScrollOffset = maxOffsetRef.current;
  if (latestIsHorizontal) {
    offset = Math.min(pageRect.x, maxScrollOffset) + (contentOffset ? contentOffset.x.get() : 0);
    normalizedOffset = offset / (pageRect.width + latestGap);
  } else {
    offset = Math.min(pageRect.y, maxScrollOffset) + (contentOffset ? contentOffset.y.get() : 0);
    normalizedOffset = offset / (pageRect.height + latestGap);
  }
  const size = { width: pageRect.width, height: pageRect.height };
  return effectFunction({
    offset,
    normalizedOffset,
    size,
    index,
    direction: latestDirection,
    gap: latestGap,
    pageCount: pageRectsRef.current.length
  });
}
function hasEffect(props) {
  return !!props.effect || !!getDefaultEffect(props.defaultEffect);
}
function updateCurrentPage(newPageIndex, currentContentPageRef, onChangePage) {
  if (currentContentPageRef.current === newPageIndex) return;
  if (onChangePage) onChangePage(newPageIndex, currentContentPageRef.current);
  currentContentPageRef.current = newPageIndex;
}

// ../../library/src/components/Page/Page.tsx
var Page3 = /* @__PURE__ */ (() => {
  const ContentDimension = {
    Auto: "auto",
    Stretch: "stretch"
  };
  const pageContentDimensionOptions = [ContentDimension.Auto, ContentDimension.Stretch];
  const pageContentDimensionTitles = /* @__PURE__ */ pageContentDimensionOptions.map((option) => {
    switch (option) {
      case ContentDimension.Auto:
        return "Auto";
      case ContentDimension.Stretch:
        return "Stretch";
    }
  });
  const pageEffectOptions = ["none", "cube", "coverflow", "wheel", "pile"];
  const pageEffectTitles = /* @__PURE__ */ pageEffectOptions.map((option) => {
    switch (option) {
      case "none":
        return "None";
      case "cube":
        return "Cube";
      case "coverflow":
        return "Cover Flow";
      case "wheel":
        return "Wheel";
      case "pile":
        return "Pile";
    }
  });
  const pageAlignmentOptions = ["start", "center", "end"];
  const genericAlignmentTitles = /* @__PURE__ */ pageAlignmentOptions.map((option) => {
    switch (option) {
      case "start":
        return "Start";
      case "center":
        return "Center";
      case "end":
        return "End";
    }
  });
  Page.defaultProps = {
    gap: 10,
    directionLock: false
  };
  addPropertyControls(Page, {
    direction: {
      type: "enum" /* Enum */,
      options: ["horizontal", "vertical"],
      title: "Direction",
      defaultValue: "horizontal",
      displaySegmentedControl: true,
      optionIcons: ["direction-horizontal", "direction-vertical"]
    },
    directionLock: {
      type: "boolean" /* Boolean */,
      title: "Lock",
      enabledTitle: "1 Axis",
      disabledTitle: "Off",
      defaultValue: true
    },
    contentWidth: {
      type: "enum" /* Enum */,
      options: pageContentDimensionOptions,
      optionTitles: pageContentDimensionTitles,
      title: "Width",
      defaultValue: ContentDimension.Stretch,
      displaySegmentedControl: true
    },
    contentHeight: {
      type: "enum" /* Enum */,
      options: pageContentDimensionOptions,
      optionTitles: pageContentDimensionTitles,
      title: "Height",
      defaultValue: ContentDimension.Stretch,
      displaySegmentedControl: true
    },
    alignment: {
      type: "enum" /* Enum */,
      options: pageAlignmentOptions,
      optionTitles: genericAlignmentTitles,
      title: "Align",
      hidden(props) {
        const { direction, contentWidth, contentHeight } = props;
        const isHorizontalDirection = direction === "horizontal";
        const crossDimension = isHorizontalDirection ? contentHeight : contentWidth;
        return crossDimension === ContentDimension.Stretch;
      },
      defaultValue: "start",
      displaySegmentedControl: true,
      optionIcons: {
        direction: {
          horizontal: ["align-top", "align-middle", "align-bottom"],
          vertical: ["align-left", "align-center", "align-right"]
        }
      }
    },
    gap: {
      type: "number" /* Number */,
      min: 0,
      title: "Gap",
      defaultValue: 0
    },
    padding: {
      type: "fusednumber" /* FusedNumber */,
      toggleKey: "paddingPerSide",
      toggleTitles: ["Padding", "Padding per side"],
      valueKeys: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
      valueLabels: ["T", "R", "B", "L"],
      min: 0,
      title: "Padding",
      defaultValue: 0
    },
    overflow: {
      type: "enum" /* Enum */,
      title: "Overflow",
      defaultValue: "hidden",
      options: ["visible", "hidden"],
      optionTitles: ["Visible", "Hidden"],
      displaySegmentedControl: true
    },
    currentPage: {
      type: "number" /* Number */,
      min: 0,
      title: "Current",
      displayStepper: true,
      defaultValue: 0
    },
    momentum: {
      type: "boolean" /* Boolean */,
      enabledTitle: "On",
      disabledTitle: "Off",
      title: "Momentum",
      defaultValue: false
    },
    dragEnabled: {
      type: "boolean" /* Boolean */,
      title: "Drag",
      enabledTitle: "On",
      disabledTitle: "Off",
      defaultValue: true
    },
    wheelEnabled: {
      type: "boolean" /* Boolean */,
      title: "Wheel",
      enabledTitle: "On",
      disabledTitle: "Off",
      defaultValue: false
    },
    defaultEffect: {
      type: "enum" /* Enum */,
      options: pageEffectOptions,
      optionTitles: pageEffectTitles,
      title: "Effect",
      defaultValue: "none"
    },
    children: {
      type: "array" /* Array */,
      title: "Content",
      control: { type: "componentinstance" /* ComponentInstance */, title: "Page" }
    }
  });
  Page.supportsConstraints = true;
  return Page;
})();

// ../../library/src/components/Screen.tsx
import React39, { Component as Component9 } from "react";

// ../../library/src/events/recognizer/GestureRecognizer.ts
function stateName(state) {
  switch (state) {
    case 2 /* Possible */:
      return "Possible";
    case 4 /* Began */:
      return "Began";
    case 8 /* Changed */:
      return "Changed";
    case 16 /* Ended */:
      return "Ended";
    case 32 /* Failed */:
      return "Failed";
    case 64 /* Cancelled */:
      return "Cancelled";
    case 128 /* Recognized */:
      return "Recognized";
    default:
      return "Unknown";
  }
}
function containsBitmask(value, bitmask) {
  return (value & bitmask) !== 0;
}
var GestureRecognizer = class {
  constructor() {
    __publicField(this, "_state", 2 /* Possible */);
    __publicField(this, "handler", null);
    __publicField(this, "preventers", []);
  }
  get state() {
    return this._state;
  }
  setState(state) {
    this._state = state;
  }
  get isPrevented() {
    let prevented = false;
    for (const recognizer of this.preventers) {
      if (recognizer.state & (4 /* Began */ | 8 /* Changed */ | 16 /* Ended */)) {
        prevented = true;
        break;
      }
    }
    return prevented;
  }
  canBePreventedBy(recognizer) {
    this.preventers.push(recognizer);
  }
  hasState(bitmask) {
    return containsBitmask(this.state, bitmask);
  }
  stateSwitch(newState) {
    let allowedStates;
    switch (this.state) {
      case 2 /* Possible */:
        allowedStates = 4 /* Began */ | 128 /* Recognized */ | 32 /* Failed */;
        break;
      case 4 /* Began */:
        allowedStates = 8 /* Changed */ | 64 /* Cancelled */ | 16 /* Ended */;
        break;
      case 8 /* Changed */:
        allowedStates = 8 /* Changed */ | 64 /* Cancelled */ | 16 /* Ended */;
        break;
      case 128 /* Recognized */:
      case 16 /* Ended */:
      case 64 /* Cancelled */:
      case 32 /* Failed */:
        allowedStates = 2 /* Possible */;
        break;
      default:
        allowedStates = 0;
    }
    if (!containsBitmask(newState, allowedStates)) {
      console.warn(`Unallowed state change from ${stateName(this.state)} to ${stateName(newState)}`);
      return;
    }
    this.setState(newState);
  }
  cancel() {
    if (this.hasState(4 /* Began */ | 8 /* Changed */)) {
      this.setState(64 /* Cancelled */);
    }
    this.reset();
  }
  reset() {
    if (!this.hasState(2 /* Possible */)) {
      this.stateSwitch(2 /* Possible */);
    }
  }
};

// ../../library/src/events/recognizer/MouseWheelGestureRecognizer.ts
var MouseWheelGestureRecognizer = class extends GestureRecognizer {
  constructor() {
    super(...arguments);
    __publicField(this, "startEvent", null);
    __publicField(this, "eventType", "mousewheel");
    __publicField(this, "onMouseWheelEnd", debounce2((event) => {
      if (this.handler && this.startEvent) {
        this.stateSwitch(16 /* Ended */);
        this.handler.gestureEnded(this.eventType, event, this.startEvent.target);
        this.startEvent = null;
        this.reset();
      }
    }, 300));
  }
  pointerSessionBegan(session, event) {
  }
  pointerSessionMoved(session, event) {
  }
  pointerSessionEnded(session, event) {
  }
  mouseWheel(session, event) {
    if (!this.handler) return;
    if (this.hasState(2 /* Possible */)) {
      this.startEvent = event;
      this.stateSwitch(4 /* Began */);
      this.handler.gestureBegan(this.eventType, event, this.startEvent.target);
      return;
    }
    if (this.hasState(4 /* Began */ | 8 /* Changed */) && this.startEvent) {
      this.stateSwitch(8 /* Changed */);
      this.handler.gestureChanged(this.eventType, event, this.startEvent.target);
    }
    this.onMouseWheelEnd(event);
  }
};

// ../../library/src/events/recognizer/PanGestureRecognizer.ts
var PanGestureRecognizer = class extends GestureRecognizer {
  constructor() {
    super(...arguments);
    __publicField(this, "startEvent", null);
    __publicField(this, "eventType", "pan");
  }
  pointerSessionBegan(session, event) {
    this.recognize(session, event);
  }
  pointerSessionMoved(session, event) {
    this.recognize(session, event);
  }
  pointerSessionEnded(session, event) {
    this.panend(event);
  }
  recognize(session, event) {
    if (Math.abs(event.delta.x) > 0 || Math.abs(event.delta.y) > 0) {
      if (this.startEvent) {
        this.pan(event);
      } else {
        this.panstart(event);
      }
    }
  }
  reset() {
    this.startEvent = null;
    super.reset();
  }
  panstart(event) {
    if (!this.hasState(2 /* Possible */) || event.isLeftMouseClick !== void 0 && !event.isLeftMouseClick) {
      return;
    }
    this.stateSwitch(4 /* Began */);
    this.startEvent = event;
    if (this.handler && this.startEvent.target) {
      this.handler.gestureBegan(this.eventType, event, this.startEvent.target);
    }
  }
  pan(event) {
    if (!this.hasState(4 /* Began */ | 8 /* Changed */)) {
      return;
    }
    if (!this.startEvent) {
      return;
    }
    this.stateSwitch(8 /* Changed */);
    if (this.handler && this.startEvent.target) {
      this.handler.gestureChanged(this.eventType, event, this.startEvent.target);
    }
  }
  panend(event) {
    if (!this.hasState(4 /* Began */ | 8 /* Changed */)) {
      return;
    }
    if (!this.startEvent) {
      return;
    }
    this.stateSwitch(16 /* Ended */);
    if (this.handler && this.startEvent.target) {
      this.handler.gestureEnded(this.eventType, event, this.startEvent.target);
    }
  }
};

// ../../library/src/events/recognizer/TapGestureRecognizer.ts
var TapGestureRecognizer = class extends GestureRecognizer {
  constructor() {
    super(...arguments);
    __publicField(this, "eventType", "tap");
  }
  pointerSessionBegan(session, event) {
    if (this.handler && (event.isLeftMouseClick === void 0 || event.isLeftMouseClick)) {
      this.handler.gestureBegan(this.eventType, event, null);
    }
  }
  pointerSessionMoved(session, event) {
  }
  pointerSessionEnded(session, event) {
    if (this.isPrevented) {
      this.stateSwitch(32 /* Failed */);
    } else if (!session.startEvent || session.startEvent.target === event.target) {
      this.stateSwitch(128 /* Recognized */);
      if (this.handler) {
        this.handler.gestureChanged(this.eventType, event, null);
      }
    } else {
      this.stateSwitch(32 /* Failed */);
    }
    if (this.handler) {
      this.handler.gestureEnded(this.eventType, event, null);
    }
  }
};

// ../../library/src/events/FramerEventSession.ts
var FramerEventSession = class {
  constructor(dispatcher, customOrigin) {
    __publicField(this, "events", []);
    __publicField(this, "recognizers", []);
    __publicField(this, "mouseWheelRecognizer", new MouseWheelGestureRecognizer());
    __publicField(this, "dispatcher");
    /**
     * @internal
     */
    __publicField(this, "originElement");
    this.dispatcher = dispatcher;
    if (customOrigin) {
      this.originElement = customOrigin;
    } else {
      this.originElement = document.body;
    }
    const pan = new PanGestureRecognizer();
    const tap = new TapGestureRecognizer();
    pan.handler = this;
    tap.handler = this;
    this.mouseWheelRecognizer.handler = this;
    this.recognizers = [tap, pan];
  }
  get isStarted() {
    return this.events.length !== 0;
  }
  get startEvent() {
    return this.isStarted ? this.events[0] : void 0;
  }
  get lastEvent() {
    return this.events[this.events.length - 1];
  }
  // Event handling
  processEvent(event) {
    this.events.push(event);
    return event;
  }
  pointerDown(event) {
    if (this.isStarted) {
      return;
    }
    this.processEvent(event);
    this.recognizers.map((r) => {
      r.cancel();
      r.pointerSessionBegan(this, event);
    });
  }
  pointerMove(event) {
    if (!this.isStarted) {
      return;
    }
    this.processEvent(event);
    this.recognizers.map((r) => {
      r.pointerSessionMoved(this, event);
    });
  }
  pointerUp(event) {
    if (!this.isStarted) {
      return;
    }
    this.processEvent(event);
    this.recognizers.map((r) => {
      r.pointerSessionEnded(this, event);
    });
    this.clearEvents();
    this.recognizers.map((r) => {
      r.reset();
    });
  }
  mouseWheel(event) {
    this.processEvent(event);
    this.mouseWheelRecognizer.mouseWheel(this, event);
    this.clearEvents();
  }
  clearEvents() {
    this.events = [];
  }
  dispatch(type, event, target = null) {
    const dispatchTarget = target || this.startEvent && this.startEvent.target || event.target;
    if (dispatchTarget) {
      this.dispatcher(type, event, dispatchTarget);
    }
  }
  // Gesture Handler
  gestureBegan(type, event, target) {
    this.dispatch(`${type}start`, event, target);
  }
  gestureChanged(type, event, target) {
    this.dispatch(type, event, target);
  }
  gestureEnded(type, event, target) {
    this.dispatch(`${type}end`, event, target);
  }
  // Calculatinos
  /**
   * Average velocity over last n seconds in pixels per second.
   * @param n - number of events to use for calculation
   */
  velocity(t = Loop.TimeStep * 2) {
    if (!this.isStarted || this.events.length < 2) {
      return { x: 0, y: 0 };
    }
    const events = this.events;
    let i = events.length - 1;
    let event = null;
    while (i >= 0) {
      event = events[i] ?? null;
      if (!event || MainLoop.time - event.loopTime > t) {
        break;
      }
      i--;
    }
    if (!event) {
      return { x: 0, y: 0 };
    }
    const current = events[events.length - 1];
    if (!current) {
      return { x: 0, y: 0 };
    }
    const time2 = (MainLoop.time - event.loopTime) * 1e3;
    if (time2 === 0) {
      return { x: 0, y: 0 };
    }
    const velocity = {
      x: (current.devicePoint.x - event.devicePoint.x) / time2,
      y: (current.devicePoint.y - event.devicePoint.y) / time2
    };
    if (velocity.x === Infinity) {
      velocity.x = 0;
    }
    if (velocity.y === Infinity) {
      velocity.y = 0;
    }
    return velocity;
  }
  offset(event) {
    if (!this.startEvent) {
      return { x: 0, y: 0 };
    }
    const subtract = (pointA, pointB) => {
      return {
        x: pointA.x - pointB.x,
        y: pointA.y - pointB.y
      };
    };
    return subtract(event.devicePoint, this.startEvent.devicePoint);
  }
};

// ../../library/src/events/recognizer/MouseEventListener.ts
import { Component as Component7 } from "react";
var MouseEventListener = class extends Component7 {
  constructor() {
    super(...arguments);
    /**
     * @internal
     */
    __publicField(this, "domMouseDown", (originalEvent) => {
      safeWindow.addEventListener("mousemove", this.domMouseMove);
      safeWindow.addEventListener("mouseup", this.domMouseUp);
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerDown(event);
    });
    /**
     * @internal
     */
    __publicField(this, "domMouseMove", (originalEvent) => {
      const leftMouseButtonOnlyDown = originalEvent.buttons === void 0 ? originalEvent.which === 1 : originalEvent.buttons === 1;
      if (!leftMouseButtonOnlyDown) {
        this.domMouseUp(originalEvent);
        return;
      }
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerMove(event);
    });
    /**
     * @internal
     */
    __publicField(this, "domMouseUp", (originalEvent) => {
      safeWindow.removeEventListener("mousemove", this.domMouseMove);
      safeWindow.removeEventListener("mouseup", this.domMouseUp);
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerUp(event);
    });
    /**
     * @internal
     */
    __publicField(this, "domMouseWheel", (originalEvent) => {
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.mouseWheel(event);
    });
  }
  /**
   * @internal
   */
  render() {
    return this.props.children;
  }
  /**
   * @internal
   */
  componentDidMount() {
    safeWindow.addEventListener("mousedown", this.domMouseDown);
    safeWindow.addEventListener("wheel", this.domMouseWheel);
  }
  /**
   * @internal
   */
  componentWillUnmount() {
    safeWindow.removeEventListener("mousemove", this.domMouseMove);
    safeWindow.removeEventListener("mousedown", this.domMouseDown);
    safeWindow.removeEventListener("mouseup", this.domMouseUp);
    safeWindow.removeEventListener("wheel", this.domMouseWheel);
  }
};

// ../../library/src/events/recognizer/TouchEventListener.ts
import { Component as Component8 } from "react";
var TouchEventListener = class extends Component8 {
  constructor() {
    super(...arguments);
    /**
     * @internal
     */
    __publicField(this, "domTouchStart", (originalEvent) => {
      safeWindow.addEventListener("touchmove", this.domTouchMove);
      safeWindow.addEventListener("touchend", this.domTouchEnd);
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerDown(event);
    });
    /**
     * @internal
     */
    __publicField(this, "domTouchMove", (originalEvent) => {
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerMove(event);
    });
    /**
     * @internal
     */
    __publicField(this, "domTouchEnd", (originalEvent) => {
      safeWindow.removeEventListener("touchmove", this.domTouchMove);
      safeWindow.removeEventListener("touchend", this.domTouchEnd);
      const event = new FramerEvent(originalEvent, this.props.session);
      this.props.session.pointerUp(event);
    });
  }
  /**
   * @internal
   */
  render() {
    return this.props.children;
  }
  /**
   * @internal
   */
  componentDidMount() {
    safeWindow.addEventListener("touchstart", this.domTouchStart);
  }
  /**
   * @internal
   */
  componentWillUnmount() {
    safeWindow.removeEventListener("touchstart", this.domTouchStart);
    safeWindow.removeEventListener("touchmove", this.domTouchMove);
    safeWindow.removeEventListener("touchend", this.domTouchEnd);
  }
};

// ../../library/src/events/FramerEventListener.ts
var FramerEventListener = /* @__PURE__ */ environment.isTouch() ? TouchEventListener : MouseEventListener;

// ../../library/src/components/Screen.tsx
import { jsx as jsx35 } from "react/jsx-runtime";

// ../../library/src/components/Scroll/Scroll.tsx
import React43 from "react";

// ../../library/src/components/Scroll/EmulatedScroll.tsx
import React40, { useCallback as useCallback10, useInsertionEffect as useInsertionEffect3, useMemo as useMemo8, useRef as useRef14 } from "react";
import { jsx as jsx36, jsxs as jsxs10 } from "react/jsx-runtime";
var directionMap = {
  horizontal: "x",
  vertical: "y",
  both: true
};
function convertScrollDirectionToDrag(scrollDirection) {
  return scrollDirection ? directionMap[scrollDirection] : scrollDirection;
}
var useUpdateChildSize = ({
  dragDirection,
  children,
  fromCanvasComponent
}) => {
  return useMemo8(() => {
    return React40.Children.map(children, (child) => {
      if (child === null || typeof child !== "object" || typeof child.type === "string") {
        return child;
      }
      const updatedSize = {};
      switch (dragDirection) {
        case "vertical":
          updatedSize.width = "100%";
          break;
        case "horizontal":
          updatedSize.height = "100%";
          break;
        default:
          return child;
      }
      const update = fromCanvasComponent ? { style: Object.assign({}, child.props.style, updatedSize) } : updatedSize;
      return React40.cloneElement(child, update);
    });
  }, [dragDirection, children, fromCanvasComponent]);
};
var numberFromOptionalMotionValue = (value) => {
  return typeof value === "number" ? value : value.get();
};
var EmulatedScroll = /* @__PURE__ */ React40.forwardRef(
  function EmulatedScroll2(props, forwardedRef) {
    const {
      direction = "vertical",
      directionLock = false,
      dragEnabled = true,
      dragElastic,
      dragMomentum,
      dragTransition,
      wheelEnabled = true,
      contentOffsetX = 0,
      contentOffsetY = 0,
      contentWidth,
      contentHeight,
      onScrollStart,
      onScroll,
      onScrollEnd,
      onDragStart,
      onDrag,
      onDragEnd,
      onUpdate,
      onDirectionLock,
      style,
      children,
      scrollAnimate,
      resetOffset,
      overdragEnabled = true,
      layoutId: specificLayoutId,
      native: _native,
      ...containerProps
    } = props;
    const layoutId = useLayoutId(props, { specificLayoutId, postfix: "scroll" });
    const defaultX = useMotionValue(typeof contentOffsetX === "number" ? contentOffsetX : 0);
    const defaultY = useMotionValue(typeof contentOffsetY === "number" ? contentOffsetY : 0);
    const x = isMotionValue2(contentOffsetX) ? contentOffsetX : defaultX;
    const y = isMotionValue2(contentOffsetY) ? contentOffsetY : defaultY;
    const measuredConstraints = useRef14(null);
    const dragControls = useDragControls();
    const isInTarget = useIsInCurrentNavigationTarget();
    const wasInTargetRef = useRef14(true);
    useInsertionEffect3(() => {
      injectComponentCSSRules();
    }, []);
    function setMeasureDragConstraints(constraints) {
      constraints = offsetToZero(constraints);
      if (contentWidth !== void 0) constraints.left = -contentWidth;
      if (contentHeight !== void 0) constraints.top = -contentHeight;
      return measuredConstraints.current = constraints;
    }
    const { initial, prev } = useRef14({
      initial: { x: 0, y: 0 },
      prev: { x: 0, y: 0 }
    }).current;
    const isPreview = RenderTarget.current() === RenderTarget.preview;
    const containerFallbackRef = useRef14(null);
    const containerRef = forwardedRef || containerFallbackRef;
    const contentRef = useRef14(null);
    const lastOffsetRef = useRef14(null);
    function shouldResetScroll(inTarget) {
      const hasEnteredTarget = inTarget && wasInTargetRef.current === false;
      return resetOffset && hasEnteredTarget;
    }
    function measureAndUpdateScrollOffset() {
      if (!contentRef.current || !containerRef.current) return;
      const mustReset = shouldResetScroll(isInTarget);
      wasInTargetRef.current = isInTarget;
      const previous = lastOffsetRef.current;
      if (previous === null && contentOffsetX === void 0 && contentOffsetY === void 0) return;
      const shouldUpdateOffset = previous === null || !isMotionValue2(contentOffsetX) && contentOffsetX !== previous.offsetX || !isMotionValue2(contentOffsetY) && contentOffsetY !== previous.offsetY;
      const currentMaxXOffset = contentRef.current.offsetWidth - containerRef.current.offsetWidth;
      const currentMaxYOffset = contentRef.current.offsetHeight - containerRef.current.offsetHeight;
      const hasSizeChanged = currentMaxXOffset !== previous?.maxXOffset || currentMaxYOffset !== previous?.maxYOffset;
      const hasScrollOffsetChanged = previous?.x !== x.get() || previous?.y !== y.get();
      const shouldStayPinned = hasSizeChanged && !hasScrollOffsetChanged;
      if (mustReset || shouldUpdateOffset || shouldStayPinned) {
        const currentOffsetX = direction !== "vertical" ? numberFromOptionalMotionValue(contentOffsetX) : 0;
        const currentOffsetY = direction !== "horizontal" ? numberFromOptionalMotionValue(contentOffsetY) : 0;
        const nextXOffset = -Math.min(currentOffsetX, currentMaxXOffset);
        const nextYOffset = -Math.min(currentOffsetY, currentMaxYOffset);
        x.set(nextXOffset);
        y.set(nextYOffset);
        lastOffsetRef.current = {
          maxXOffset: currentMaxXOffset,
          maxYOffset: currentMaxYOffset,
          offsetX: currentOffsetX,
          offsetY: currentOffsetY,
          x: nextXOffset,
          y: nextYOffset
        };
      }
    }
    useIsomorphicLayoutEffect2(() => {
      if (RenderTarget.current() !== RenderTarget.canvas) return;
      measureAndUpdateScrollOffset();
    });
    useIsomorphicLayoutEffect2(() => {
      if (RenderTarget.current() === RenderTarget.canvas) return;
      measureAndUpdateScrollOffset();
    }, []);
    React40.useEffect(() => {
      if (shouldResetScroll(isInTarget)) measureAndUpdateScrollOffset();
      if (isInTarget === false) wasInTargetRef.current = false;
    }, [isInTarget]);
    const getLatestPoint = () => ({ x: x.get(), y: y.get() });
    const resetInitialPoint = useCallback10(() => {
      const point = getLatestPoint();
      initial.x = point.x;
      initial.y = point.y;
      prev.x = point.x;
      prev.y = point.y;
    }, []);
    const getPointData = useCallback10(() => {
      const point = getLatestPoint();
      const data2 = {
        point,
        velocity: { x: x.getVelocity(), y: y.getVelocity() },
        offset: { x: point.x - initial.x, y: point.y - initial.y },
        delta: { x: point.x - prev.x, y: point.y - prev.y }
      };
      prev.x = point.x;
      prev.y = point.y;
      return data2;
    }, [x, y]);
    const updateScrollListeners = useCallback10(() => {
      onUpdate && onUpdate({ x: x.get(), y: y.get() });
      onScroll && onScroll(getPointData());
    }, [onScroll, onUpdate, getPointData, x, y]);
    const scheduleUpdateScrollListeners = useCallback10(() => {
      frame.update(updateScrollListeners, false, true);
    }, [updateScrollListeners]);
    const onMotionDragStart = (event, info) => {
      resetInitialPoint();
      onDragStart && onDragStart(event, info);
      onScrollStart && onScrollStart(info);
    };
    const onMotionDragTransitionEnd = () => onScrollEnd && onScrollEnd(getPointData());
    const onWheelScrollStart = (info) => {
      onScrollStart?.(info);
    };
    useWheelScroll(containerRef, {
      enabled: wheelEnabled,
      initial,
      prev,
      direction,
      offsetX: x,
      offsetY: y,
      onScrollStart: onWheelScrollStart,
      onScroll,
      onScrollEnd,
      constraints: measuredConstraints
    });
    const overdragX = useMotionValue(0);
    const overdragY = useMotionValue(0);
    useIsomorphicLayoutEffect2(() => {
      const setScrollX = (xValue) => {
        const element = containerRef.current;
        if (!(element instanceof HTMLDivElement)) return;
        element.scrollLeft = -xValue;
        const constraints = measuredConstraints.current;
        if (constraints && overdragEnabled) {
          let overdragXValue = 0;
          if (xValue > constraints.right) overdragXValue = xValue;
          if (xValue < constraints.left) overdragXValue = xValue - constraints.left;
          overdragX.set(overdragXValue);
        }
        scheduleUpdateScrollListeners();
      };
      const currentX = x.get();
      if (currentX !== 0) setScrollX(currentX);
      return x.on("change", setScrollX);
    }, [x, overdragX, scheduleUpdateScrollListeners, overdragEnabled]);
    useIsomorphicLayoutEffect2(() => {
      const setScrollY = (yValue) => {
        const element = containerRef.current;
        if (!(element instanceof HTMLDivElement)) return;
        element.scrollTop = -yValue;
        const constraints = measuredConstraints.current;
        if (constraints && overdragEnabled) {
          let overdragYValue = 0;
          if (yValue > constraints.bottom) overdragYValue = yValue;
          if (yValue < constraints.top) overdragYValue = yValue - constraints.top;
          overdragY.set(overdragYValue);
        }
        scheduleUpdateScrollListeners();
      };
      const currentY = y.get();
      if (currentY !== 0) setScrollY(currentY);
      return y.on("change", setScrollY);
    }, [y, overdragY, scheduleUpdateScrollListeners, overdragEnabled]);
    const nativeOnScroll = React40.useCallback(() => {
      const element = containerRef.current;
      if (!(element instanceof HTMLDivElement)) return;
      const xDelta = Math.abs(x.get() + element.scrollLeft);
      const yDelta = Math.abs(y.get() + element.scrollTop);
      if (xDelta > 1) x.set(-element.scrollLeft);
      if (yDelta > 1) y.set(-element.scrollTop);
    }, [x, y]);
    const isEmpty2 = React40.Children.count(children) === 0;
    const width = direction !== "vertical" && !isEmpty2 ? "auto" : "100%";
    const height = direction !== "horizontal" && !isEmpty2 ? "auto" : "100%";
    const size = !containerProps.__fromCanvasComponent ? {
      width: containerProps.__fromCodeComponentNode ? "100%" : containerProps.width,
      height: containerProps.__fromCodeComponentNode ? "100%" : containerProps.height
    } : {};
    return /* @__PURE__ */ jsx36(
      FrameWithMotion,
      {
        "data-framer-component-type": "Scroll",
        background: "none",
        ...containerProps,
        ...size,
        style: {
          ...style,
          willChange: isPreview ? "transform" : void 0,
          // allows the scroll content to be hardware accelerated
          overflow: "hidden"
        },
        onScroll: nativeOnScroll,
        preserve3d: containerProps.preserve3d,
        ref: containerRef,
        layoutId,
        layoutScroll: true,
        onBeforeLayoutMeasure: measureAndUpdateScrollOffset,
        children: /* @__PURE__ */ jsxs10(
          FrameWithMotion,
          {
            "data-framer-component-type": "ScrollContentWrapper",
            animate: scrollAnimate,
            drag: dragEnabled && convertScrollDirectionToDrag(direction),
            dragDirectionLock: directionLock,
            dragElastic,
            dragMomentum,
            dragTransition,
            dragConstraints: containerRef,
            dragControls,
            onDragStart: onMotionDragStart,
            onDrag,
            onDragEnd,
            onDragTransitionEnd: onMotionDragTransitionEnd,
            onDirectionLock,
            onMeasureDragConstraints: setMeasureDragConstraints,
            width,
            height,
            _dragX: x,
            _dragY: y,
            position: "relative",
            x: overdragEnabled ? overdragX : void 0,
            y: overdragEnabled ? overdragY : void 0,
            ref: contentRef,
            style: {
              display: isEmpty2 ? "block" : "inline-block",
              willChange: isPreview ? "transform" : void 0,
              // makes the scroll content hardware accelerated
              backgroundColor: "transparent",
              overflow: "visible",
              minWidth: "100%",
              minHeight: "100%"
            },
            preserve3d: containerProps.preserve3d,
            children: [
              /* @__PURE__ */ jsx36(
                EmptyState,
                {
                  size: {
                    width: isFiniteNumber(containerProps.width) ? containerProps.width : "100%",
                    height: isFiniteNumber(containerProps.height) ? containerProps.height : "100%"
                  },
                  insideUserCodeComponent: !containerProps.__fromCodeComponentNode,
                  title: "Scroll",
                  description: "Click and drag the connector to any frame on the canvas \u2192",
                  children
                }
              ),
              useUpdateChildSize({
                dragDirection: direction,
                children,
                fromCanvasComponent: containerProps.__fromCanvasComponent
              })
            ]
          }
        )
      }
    );
  }
);
function offsetToZero({ top, left, right, bottom }) {
  const width = right - left;
  const height = bottom - top;
  return {
    top: -height,
    left: -width,
    right: 0,
    bottom: 0
  };
}

// ../../library/src/components/Scroll/NativeScroll.tsx
import React42, { useInsertionEffect as useInsertionEffect4 } from "react";

// ../../library/src/modules/cx.ts
function cx(...classNames) {
  return classNames.filter(Boolean).join(" ");
}

// ../../library/src/components/utils/useEmulatedTouchScroll.ts
import React41, { useEffect as useEffect14 } from "react";

// ../../library/src/components/utils/animatePointWithInertia.ts
function isRunningAnimation(...phases) {
  let runningAny = false;
  let cancelledAny = false;
  phases.forEach((phase) => {
    runningAny = runningAny || phase === 1 /* Running */;
    cancelledAny = cancelledAny || phase === 3 /* Cancelled */;
  });
  return runningAny && !cancelledAny;
}
function didFinishAnimations(...phases) {
  return phases.every((phase) => phase === 0 /* None */ || phase === 2 /* Completed */);
}
var timeConstant = 400;
function animatePointWithInertia({
  from,
  velocity,
  onUpdate,
  onComplete,
  onStop
}) {
  const latest = from;
  let animationPhaseX = 0 /* None */;
  let animationPhaseY = 0 /* None */;
  const animations2 = [];
  const updateHandler = () => {
    if (isRunningAnimation(animationPhaseX, animationPhaseY)) {
      onUpdate(latest);
    }
  };
  const completionHandler = () => {
    if (didFinishAnimations(animationPhaseX, animationPhaseY)) {
      onComplete();
    }
  };
  if (velocity.x) {
    animationPhaseX = 1 /* Running */;
    animations2.push(
      animateValue({
        keyframes: [from.x],
        velocity: -velocity.x,
        timeConstant,
        onUpdate: (value) => {
          latest.x = value;
          frame.update(updateHandler, false, true);
        },
        onComplete: () => {
          if (animationPhaseX !== 1 /* Running */) {
            throw Error("animation x should be running when completing");
          }
          animationPhaseX = 2 /* Completed */;
          completionHandler();
        }
      })
    );
  }
  if (velocity.y) {
    animationPhaseY = 1 /* Running */;
    animations2.push(
      animateValue({
        keyframes: [from.y],
        velocity: -velocity.y,
        timeConstant,
        onUpdate: (value) => {
          latest.y = value;
          frame.update(updateHandler, false, true);
        },
        onComplete: () => {
          if (animationPhaseY !== 1 /* Running */) {
            throw Error("animation y should be running when completing");
          }
          animationPhaseY = 2 /* Completed */;
          completionHandler();
        }
      })
    );
  }
  if (!isRunningAnimation(animationPhaseX, animationPhaseY)) {
    completionHandler();
  }
  return {
    stop: () => {
      if (!isRunningAnimation(animationPhaseX, animationPhaseY)) return;
      animations2.forEach((animation) => animation.stop());
      animationPhaseX = animationPhaseX === 1 /* Running */ ? 3 /* Cancelled */ : animationPhaseX;
      animationPhaseY = animationPhaseY === 1 /* Running */ ? 3 /* Cancelled */ : animationPhaseY;
      onStop();
    }
  };
}

// ../../library/src/components/utils/useEmulatedTouchScroll.ts
var scrollThreshold = 3;
var isTouchDevice = /* @__PURE__ */ isTouch();
var isSafariBrowser = /* @__PURE__ */ isSafari();
function getTouchAction(element) {
  if (!(element instanceof HTMLElement)) return null;
  return element.style.touchAction;
}
function canPanInDirection(element, direction) {
  switch (direction) {
    case "horizontal":
      return getTouchAction(element) === "pan-x";
    case "vertical":
      return getTouchAction(element) === "pan-y";
    default:
      return false;
  }
}
function isInteractiveElement(element) {
  const tag = element.tagName.toLowerCase();
  if (tag === "input") return true;
  if (tag === "text") return true;
  if (tag === "textarea") return true;
  return false;
}
function canStartScrollFromElement(element, direction) {
  if (!(element instanceof Element)) return false;
  if (isInteractiveElement(element)) return false;
  if (element.hasAttribute("draggable")) {
    if (!canPanInDirection(element, direction)) {
      return false;
    }
  }
  return true;
}
function getEventPoint(event) {
  return {
    x: event.pageX,
    y: event.pageY
  };
}
function setPointerEvents(element, value) {
  if (element?.style) {
    element.style["pointerEvents"] = value;
  }
}
function getPointerEvents(element) {
  return element?.style?.["pointerEvents"];
}
var emptyObject = /* @__PURE__ */ Object.freeze({});
function useEmulateTouchScroll(ref, direction, enabled) {
  if (isTouchDevice) return emptyObject;
  if (RenderTarget.current() !== RenderTarget.preview) return emptyObject;
  const scrollAnimationControlsRef = React41.useRef(null);
  useEffect14(() => {
    if (!ref.current) return;
    const element = ref.current;
    let phase = 0 /* Idle */;
    let targets = null;
    let downPoint = null;
    let scrollOffsetStart = null;
    let mouseMoveEvents = [];
    function onMouseMove(event) {
      switch (phase) {
        case 0 /* Idle */:
        case 4 /* DragAnimation */:
        case 3 /* DragLocked */:
          return;
      }
      if (event.metaKey) return;
      const point = getEventPoint(event);
      if (!downPoint) return;
      const offset = Point.subtract(point, downPoint);
      if (phase === 1 /* TouchDown */ || phase === 5 /* Interrupted */) {
        const deltaX = Math.abs(offset.x);
        const deltaY = Math.abs(offset.y);
        if ((deltaX > scrollThreshold || deltaY > scrollThreshold) && deltaX !== deltaY) {
          const scrollDirection = deltaX > deltaY ? "horizontal" : "vertical";
          const shouldIgnoreBecauseOfDirectionLock = direction === "horizontal" && scrollDirection === "vertical" || direction === "vertical" && scrollDirection === "horizontal";
          if (shouldIgnoreBecauseOfDirectionLock) {
            phase = 3 /* DragLocked */;
            return;
          }
          phase = 2 /* Drag */;
          targets?.forEach(([target]) => setPointerEvents(target, "none"));
        }
      }
      if (isSafariBrowser) event.preventDefault();
      if (phase !== 2 /* Drag */) return;
      safeWindow.getSelection()?.empty();
      mouseMoveEvents = getRecentEvents([...mouseMoveEvents, event]);
      if (scrollOffsetStart) {
        if (direction !== "vertical") element.scrollLeft = scrollOffsetStart.x - offset.x;
        if (direction !== "horizontal") element.scrollTop = scrollOffsetStart.y - offset.y;
      }
    }
    function onMouseUp(event) {
      safeWindow.removeEventListener("mousemove", onMouseMove, false);
      safeWindow.removeEventListener("mouseup", onMouseUp);
      if (phase === 2 /* Drag */ && targets) {
        targets.forEach(
          ([target, originalPointerEventsValue]) => setPointerEvents(target, originalPointerEventsValue || "auto")
        );
      }
      targets = null;
      const velocity = calculateVelocity({ mouseMoveEvents, mouseUpEvent: event });
      downPoint = null;
      if (phase === 2 /* Drag */) {
        const shouldAnimateY = direction !== "horizontal" && velocity.y !== 0;
        const shouldAnimateX = direction !== "vertical" && velocity.x !== 0;
        if (!shouldAnimateY && !shouldAnimateX) {
          phase = 0 /* Idle */;
          return;
        }
        phase = 4 /* DragAnimation */;
        scrollAnimationControlsRef.current = animatePointWithInertia({
          from: { x: element.scrollLeft, y: element.scrollTop },
          velocity: {
            x: shouldAnimateX ? velocity.x : 0,
            y: shouldAnimateY ? velocity.y : 0
          },
          onUpdate: (position) => {
            if (shouldAnimateX) element.scrollLeft = position.x;
            if (shouldAnimateY) element.scrollTop = position.y;
          },
          onStop: () => {
            if (phase !== 5 /* Interrupted */) {
              phase = 0 /* Idle */;
            }
            scrollAnimationControlsRef.current = null;
          },
          onComplete: () => {
            if (phase !== 4 /* DragAnimation */) {
              throw Error("On animation completion we should still be in the animation phase");
            }
            phase = 0 /* Idle */;
            scrollAnimationControlsRef.current = null;
          }
        });
      } else {
        phase = 0 /* Idle */;
      }
    }
    function onMouseWheel() {
      scrollAnimationControlsRef.current?.stop();
    }
    function onMouseDown(event) {
      if (!enabled) return;
      if (event.metaKey) return;
      if (!canStartScrollFromElement(event.target, direction)) {
        if (phase === 4 /* DragAnimation */) {
          phase = 0 /* Idle */;
          scrollAnimationControlsRef.current?.stop();
        }
        return;
      }
      const previousPhase = phase;
      phase = previousPhase === 4 /* DragAnimation */ ? 5 /* Interrupted */ : 1 /* TouchDown */;
      downPoint = getEventPoint(event);
      targets = document.elementsFromPoint(downPoint.x, downPoint.y).filter(
        (targetEl) => targetEl instanceof HTMLElement || targetEl instanceof SVGElement
      ).map((targetEl) => [targetEl, getPointerEvents(targetEl)]);
      scrollOffsetStart = { x: element.scrollLeft, y: element.scrollTop };
      mouseMoveEvents = [];
      if (scrollAnimationControlsRef.current) {
        if (previousPhase !== 4 /* DragAnimation */) {
          throw Error("When stopping a drag animation we need to be animating");
        }
        scrollAnimationControlsRef.current.stop();
      }
      safeWindow.addEventListener("mousemove", onMouseMove);
      safeWindow.addEventListener("mouseup", onMouseUp);
      element.addEventListener("mousewheel", onMouseWheel);
    }
    element.addEventListener("mousedown", onMouseDown);
    return () => {
      element.removeEventListener("mousedown", onMouseDown);
      element.removeEventListener("mousewheel", onMouseWheel);
      safeWindow.removeEventListener("mousemove", onMouseMove);
      safeWindow.removeEventListener("mouseup", onMouseUp);
      phase = 5 /* Interrupted */;
      scrollAnimationControlsRef.current?.stop();
    };
  }, [ref, direction, enabled]);
  return React41.useMemo(() => {
    return {
      cancelEmulatedTouchScrollAnimation: () => {
        scrollAnimationControlsRef.current?.stop();
      }
    };
  }, []);
}
var timeDelta = /* @__PURE__ */ (() => 4 / 60 * 1e3)();
function getRecentEvents(events) {
  const currentTime = new CustomEvent("getTime").timeStamp;
  const maxAge = currentTime - timeDelta;
  return events.filter((event) => event.timeStamp > maxAge);
}
var zeroPoint = { x: 0, y: 0 };
function calculateVelocity({
  mouseMoveEvents,
  mouseUpEvent
}) {
  const recentMouseMoveEvents = getRecentEvents(mouseMoveEvents);
  const oldestMouseMoveEvent = recentMouseMoveEvents[0];
  if (!oldestMouseMoveEvent) return zeroPoint;
  const deltaX = mouseUpEvent.clientX - oldestMouseMoveEvent.clientX;
  const deltaY = mouseUpEvent.clientY - oldestMouseMoveEvent.clientY;
  const time2 = mouseUpEvent.timeStamp - oldestMouseMoveEvent.timeStamp;
  if (time2 === 0) return zeroPoint;
  return {
    x: deltaX / time2 * 1e3,
    y: deltaY / time2 * 1e3
  };
}

// ../../library/src/components/utils/useUpdateScrollOffset.ts
function useUpdateScrollOffset(ref, side, offset, cancelEmulatedTouchScrollAnimation) {
  useIsomorphicLayoutEffect2(() => {
    if (isMotionValue2(offset)) {
      const updateScrollLeft = () => {
        cancelEmulatedTouchScrollAnimation?.();
        const element = ref.current;
        if (element) element[side] = Math.abs(offset.get());
      };
      updateScrollLeft();
      return offset.on("change", updateScrollLeft);
    } else if (isFiniteNumber(offset)) {
      const element = ref.current;
      if (!element) return;
      cancelEmulatedTouchScrollAnimation?.();
      element[side] = Math.abs(offset);
    }
  }, [offset]);
}

// ../../library/src/components/Scroll/NativeScroll.tsx
import { jsx as jsx37, jsxs as jsxs11 } from "react/jsx-runtime";
var NativeScroll = /* @__PURE__ */ React42.forwardRef(function NativeScroll2(props, forwardedRef) {
  const {
    direction = "vertical",
    scrollBarVisible = false,
    dragEnabled = true,
    contentOffsetX = 0,
    contentOffsetY = 0,
    contentWidth: _contentWidth,
    contentHeight: _contentHeight,
    children,
    resetOffset,
    onScroll,
    className: className2,
    // Not (yet) supported
    directionLock: _directionLock = false,
    wheelEnabled: _wheelEnabled = true,
    scrollAnimate: _scrollAnimate,
    dragTransition: _dragTransition,
    dragMomentum: _dragMomentum,
    dragElastic: _dragElastic,
    overdragEnabled: _overdragEnabled = true,
    onScrollStart: _onScrollStart,
    onScrollEnd: _onScrollEnd,
    onDragStart: _onDragStart,
    onDrag: _onDrag,
    onDragEnd: _onDragEnd,
    onUpdate: _onUpdate,
    onDirectionLock: _onDirectionLock,
    layoutId: specificLayoutId,
    native: _native,
    // Rest
    ...containerProps
  } = props;
  const layoutId = useLayoutId(props, { specificLayoutId, postfix: "scroll" });
  const fallbackRef = React42.useRef(null);
  const ref = forwardedRef || fallbackRef;
  const { cancelEmulatedTouchScrollAnimation } = useEmulateTouchScroll(ref, direction, dragEnabled);
  useInsertionEffect4(() => {
    injectComponentCSSRules();
  }, []);
  const isInTarget = useIsInCurrentNavigationTarget();
  const previousIsInTargetRef = React42.useRef(isInTarget);
  const updateScrollOffsetHandler = () => {
    if (!resetOffset) return;
    const previousIsTarget = previousIsInTargetRef.current;
    previousIsInTargetRef.current = isInTarget;
    const shouldResetOffset = isInTarget && !previousIsTarget;
    if (!shouldResetOffset) return;
    const element = ref.current;
    if (!element) return;
    if (direction !== "vertical") {
      cancelEmulatedTouchScrollAnimation?.();
      element.scrollLeft = Math.abs(isMotionValue2(contentOffsetX) ? contentOffsetX.get() : contentOffsetX);
    }
    if (direction !== "horizontal") {
      cancelEmulatedTouchScrollAnimation?.();
      element.scrollTop = Math.abs(isMotionValue2(contentOffsetY) ? contentOffsetY.get() : contentOffsetY);
    }
  };
  useIsomorphicLayoutEffect2(updateScrollOffsetHandler, [isInTarget]);
  useUpdateScrollOffset(ref, "scrollLeft", contentOffsetX, cancelEmulatedTouchScrollAnimation);
  useUpdateScrollOffset(ref, "scrollTop", contentOffsetY, cancelEmulatedTouchScrollAnimation);
  const size = !containerProps.__fromCanvasComponent ? {
    width: containerProps.__fromCodeComponentNode ? "100%" : containerProps.width,
    height: containerProps.__fromCodeComponentNode ? "100%" : containerProps.height
  } : {};
  return /* @__PURE__ */ jsxs11(
    FrameWithMotion,
    {
      ref,
      "data-framer-component-type": "NativeScroll",
      background: "none",
      ...containerProps,
      ...size,
      onScroll,
      layoutId,
      onBeforeLayoutMeasure: updateScrollOffsetHandler,
      layoutScroll: true,
      className: cx(className2, `direction-${direction}`, !scrollBarVisible && "scrollbar-hidden"),
      children: [
        /* @__PURE__ */ jsx37(
          EmptyState,
          {
            children,
            size: {
              width: isFiniteNumber(containerProps.width) ? containerProps.width : "100%",
              height: isFiniteNumber(containerProps.height) ? containerProps.height : "100%"
            },
            insideUserCodeComponent: !containerProps.__fromCodeComponentNode,
            title: "Scroll",
            description: "Click and drag the connector to any frame on the canvas \u2192"
          }
        ),
        children
      ]
    }
  );
});

// ../../library/src/components/Scroll/Scroll.tsx
import { jsx as jsx38 } from "react/jsx-runtime";
var Scroll = /* @__PURE__ */ (() => {
  const ScrollInner = React43.forwardRef(function ScrollInner2(props, forwardedRef) {
    if (props.native) {
      return /* @__PURE__ */ jsx38(NativeScroll, { ref: forwardedRef, ...props });
    } else {
      return /* @__PURE__ */ jsx38(EmulatedScroll, { ref: forwardedRef, ...props });
    }
  });
  ScrollInner.defaultProps = {
    directionLock: false
  };
  addPropertyControls(ScrollInner, {
    native: {
      type: "boolean" /* Boolean */,
      defaultValue: false
    },
    direction: {
      type: "segmentedenum" /* SegmentedEnum */,
      title: "Direction",
      options: ["vertical", "horizontal", "both"],
      defaultValue: "vertical"
    },
    contentOffsetX: {
      type: "number" /* Number */,
      title: "Offset X",
      defaultValue: 0,
      min: 0,
      step: 10,
      displayStepper: true,
      hidden: ({ direction }) => direction === "vertical"
    },
    contentOffsetY: {
      type: "number" /* Number */,
      title: "Offset Y",
      defaultValue: 0,
      min: 0,
      step: 10,
      displayStepper: true,
      hidden: ({ direction }) => direction === "horizontal"
    },
    directionLock: {
      type: "boolean" /* Boolean */,
      title: "Lock",
      enabledTitle: "1 Axis",
      disabledTitle: "Off",
      defaultValue: true,
      hidden: ({ native }) => native === true
    },
    dragEnabled: {
      type: "boolean" /* Boolean */,
      title: "Drag",
      enabledTitle: "On",
      disabledTitle: "Off",
      defaultValue: true
    },
    overdragEnabled: {
      type: "boolean" /* Boolean */,
      title: "Overdrag",
      enabledTitle: "On",
      disabledTitle: "Off",
      defaultValue: true,
      hidden: ({ native }) => native === true
    },
    wheelEnabled: {
      type: "boolean" /* Boolean */,
      title: "Wheel",
      enabledTitle: "On",
      disabledTitle: "Off",
      defaultValue: true,
      hidden: ({ native }) => native === true
    },
    scrollBarVisible: {
      type: "boolean" /* Boolean */,
      title: "Scroll Bar",
      enabledTitle: "Visible",
      disabledTitle: "Hidden",
      defaultValue: false,
      hidden: ({ native }) => native === false
    },
    resetOffset: {
      type: "boolean" /* Boolean */,
      title: "Reset",
      defaultValue: false
    }
  });
  ScrollInner.supportsConstraints = true;
  return ScrollInner;
})();

// ../../library/src/components/useNavigation.ts
import { useContext as useContext13 } from "react";
function useNavigation() {
  return useContext13(NavigationContext);
}

// ../../library/src/data/Data.ts
var data = /* @__PURE__ */ (() => {
  function Data2(initial = {}) {
    const _data = ObservableObject(initial, false, false);
    Data2.addData(_data);
    return _data;
  }
  Data2._stores = [];
  Data2.addData = (_data) => {
    Data2._stores.push(_data);
  };
  Data2.reset = () => {
    Data2._stores.forEach((target) => ObservableObject.resetObject(target));
  };
  Data2.addObserver = (target, observer) => {
    return ObservableObject.addObserver(target, observer);
  };
  return Data2;
})();
var Data = data;

// ../../library/src/data/PropertyStore.ts
var PropertyStore = /* @__PURE__ */ (() => {
  function PropertyStore2(initial = {}, makeAnimatables = false) {
    deprecationWarning("PropertyStore", "1.0.0", "Data() or ObservableObject()");
    return ObservableObject(initial, makeAnimatables);
  }
  PropertyStore2.addObserver = (target, observer) => {
    return ObservableObject.addObserver(target, observer);
  };
  return PropertyStore2;
})();

// ../../library/src/data/useData/index.ts
import { createContext as createContext6, useContext as useContext14, useEffect as useEffect15, useMemo as useMemo9, useState as useState3 } from "react";

// ../../library/src/data/useData/store.ts
function bindActionsToStore(get, set, actions) {
  const boundActions = {};
  for (const key7 in actions) {
    const action = actions[key7];
    if (!action) continue;
    boundActions[key7] = (data2) => set(action(get(), data2));
  }
  return boundActions;
}
function createStore(initialState2, unboundActions) {
  let state = initialState2;
  let version2 = 0;
  const subscribers = /* @__PURE__ */ new Set();
  const notifySubscriber = (sub) => sub(version2);
  const get = () => state;
  const set = (latestState) => {
    version2++;
    state = latestState;
    subscribers.forEach(notifySubscriber);
  };
  const actions = unboundActions ? bindActionsToStore(get, set, unboundActions) : set;
  return {
    get,
    set,
    getVersion: () => version2,
    getActions: () => actions,
    subscribe: (sub) => {
      subscribers.add(sub);
      return () => subscribers.delete(sub);
    }
  };
}

// ../../library/src/data/useData/index.ts
var defaultId = /* @__PURE__ */ Symbol("default");
var DataContext = /* @__PURE__ */ createContext6(defaultId);
function createData(defaultState2, actions) {
  const stores = /* @__PURE__ */ new Map();
  const useData = (id, initialState2) => {
    const contextId = useContext14(DataContext);
    id = id || contextId;
    const store = useMemo9(() => {
      if (!stores.has(id)) {
        stores.set(id, createStore(initialState2 || defaultState2, actions));
      }
      return stores.get(id);
    }, [id]);
    const [, notifyUpdates] = useState3(store.getVersion());
    const storeValueAtHookCallTime = useMemo9(() => store.get(), [store]);
    useEffect15(() => {
      const unsubscribe = store.subscribe(notifyUpdates);
      if (storeValueAtHookCallTime !== store.get()) {
        notifyUpdates(store.getVersion());
      }
      return unsubscribe;
    }, [store, storeValueAtHookCallTime]);
    return [store.get(), store.getActions()];
  };
  return useData;
}

// ../../library/src/deprecated/DataObserver.tsx
import React44, { Component as Component10 } from "react";
import { jsx as jsx39 } from "react/jsx-runtime";
var initialState = { update: 0 };
var DataObserverContext = /* @__PURE__ */ React44.createContext({ update: NaN });
function useObserveData() {
  const context = React44.useContext(DataObserverContext);
  return !Number.isNaN(context.update);
}
var DataObserver = class extends Component10 {
  constructor() {
    super(...arguments);
    __publicField(this, "observers", []);
    __publicField(this, "state", initialState);
    __publicField(this, "taskAdded", false);
    __publicField(this, "frameTask", () => {
      this.setState({ update: this.state.update + 1 });
      this.taskAdded = false;
    });
    __publicField(this, "observer", () => {
      if (this.taskAdded) return;
      this.taskAdded = true;
      MainLoop.addFrameTask(this.frameTask);
    });
  }
  componentWillUnmount() {
    this.observers.map((cancel) => cancel());
    Data.reset();
  }
  render() {
    const { children } = this.props;
    this.observers.map((cancel) => cancel());
    this.observers = [];
    Data._stores.forEach((d) => {
      const observer = Data.addObserver(d, this.observer);
      this.observers.push(observer);
    });
    return /* @__PURE__ */ jsx39(DataObserverContext.Provider, { value: { ...this.state }, children });
  }
};

// ../../library/src/deprecated/WithOverride.tsx
var import_hoist_non_react_statics4 = __toESM(require_hoist_non_react_statics_cjs(), 1);
import { useContext as useContext15 } from "react";

// ../../library/src/deprecated/convertColorProps.ts
function convertColorObject(prop) {
  if (typeof prop === "string" || isMotionValue2(prop)) {
    return prop;
  } else if (LinearGradient.isLinearGradient(prop)) {
    return LinearGradient.toCSS(prop);
  } else if (RadialGradient.isRadialGradient(prop)) {
    return RadialGradient.toCSS(prop);
  } else if (Color.isColorObject(prop)) {
    return Color.toRgbString(prop);
  }
  return prop;
}
function convertColorProps(props) {
  if (props.background || props.color) {
    const converted = Object.assign({}, props);
    if (props.background) {
      converted.background = convertColorObject(props.background);
    }
    if (props.color) {
      converted.color = convertColorObject(props.color);
    }
    return converted;
  }
  return props;
}

// ../../library/src/deprecated/WithOverride.tsx
import { jsx as jsx40 } from "react/jsx-runtime";
function WithOverride(Component18, override) {
  const useOverride = typeof override === "function" ? (props) => override(convertColorProps(props)) : () => convertColorProps(override);
  const ComponentWithOverride = function(props) {
    useContext15(DataObserverContext);
    const overrideProps = useOverride(props);
    const { style, ...rest } = props;
    return /* @__PURE__ */ jsx40(Component18, { ...rest, ...overrideProps, _initialStyle: style });
  };
  (0, import_hoist_non_react_statics4.default)(ComponentWithOverride, Component18);
  ComponentWithOverride["displayName"] = `WithOverride(${Component18.displayName || Component18.name})`;
  return ComponentWithOverride;
}

// ../../library/src/modules/withFX.tsx
import React57 from "react";

// ../../library/src/modules/hocOptions.ts
var prefix = "__framer__";
var prefixLength = /* @__PURE__ */ (() => prefix.length)();
function extractPrefixedProps(props, keys3) {
  const result = {};
  const rest = {};
  for (const key7 in props) {
    const strippedKey = stripPrefixFromPrefixedKey(key7);
    if (strippedKey && keys3.has(strippedKey)) {
      result[strippedKey] = props[key7];
      continue;
    }
    rest[key7] = props[key7];
  }
  return [result, rest];
}
function stripPrefixFromPrefixedKey(key7) {
  if (key7.startsWith(prefix)) {
    return key7.substr(prefixLength);
  }
  return void 0;
}

// ../../library/src/modules/optimizeAppear.tsx
import React51 from "react";

// ../../library/src/modules/GeneratedComponentContext.ts
import React45 from "react";
var GeneratedComponentContext = /* @__PURE__ */ React45.createContext(
  void 0
);

// ../../library/src/modules/PropertyOverrides.tsx
import React50 from "react";

// ../../library/src/components/utils/cloneChildrenWithProps.tsx
import * as React46 from "react";
import { Fragment as Fragment6, jsx as jsx41 } from "react/jsx-runtime";
function cloneChildrenWithProps(children, props, asNode) {
  const cloned = React46.Children.map(children, (child) => {
    if (React46.isValidElement(child)) {
      return React46.cloneElement(child, props);
    }
    return child;
  });
  if (asNode) return cloned;
  return /* @__PURE__ */ jsx41(Fragment6, { children: cloned });
}

// ../../library/src/components/utils/useCloneChildrenWithPropsAndRef.tsx
import * as React47 from "react";
import { Fragment as Fragment7, jsx as jsx42 } from "react/jsx-runtime";
function useCloneChildrenWithPropsAndRef(forwardedRef) {
  const hook = useConstant(() => createHook(forwardedRef));
  hook.useSetup(forwardedRef);
  return hook.cloneAsElement;
}
function createHook(forwardedRef) {
  const state = {
    forwardedRef,
    childRef: null,
    ref: null
  };
  state.ref = createRefFunction(state);
  const updateIfNeeded = (nextForwardedRef, ref) => {
    if (!state.forwardedRef && state.forwardedRef === nextForwardedRef) {
      state.ref = ref;
      return;
    }
    let shouldUpdate = false;
    if (state.childRef !== ref) {
      state.childRef = ref;
      shouldUpdate = true;
    }
    if (state.forwardedRef !== nextForwardedRef) {
      state.forwardedRef = nextForwardedRef;
      shouldUpdate = true;
    }
    if (!shouldUpdate) return;
    state.ref = createRefFunction(state);
  };
  let preventNextCall = false;
  function cloneChildrenWithPropsAndRef(children, props) {
    if (preventNextCall) {
      throw new ReferenceError(
        "useCloneChildrenWithPropsAndRef: You should not call cloneChildrenWithPropsAndRef more than once during the render cycle."
      );
    }
    preventNextCall = true;
    if (React47.Children.count(children) > 1 && forwardedRef) {
      if (false) {
        throw new ReferenceError(
          "useCloneChildrenWithPropsAndRef: You should not have more than one child when using a forwarded ref."
        );
      }
      state.forwardedRef = void 0;
      state.ref = state.childRef;
    }
    return React47.Children.map(children, (child) => {
      if (React47.isValidElement(child)) {
        const ownRef = "ref" in child ? child.ref : void 0;
        updateIfNeeded(state.forwardedRef, ownRef);
        const newProps = isFunction(props) ? props(child.props) : props;
        return React47.cloneElement(child, state.ref !== ownRef ? { ...newProps, ref: state.ref } : newProps);
      }
      return child;
    });
  }
  const cloneAsElement = function cloneAsElement2(children, props) {
    return /* @__PURE__ */ jsx42(Fragment7, { children: cloneChildrenWithPropsAndRef(children, props) });
  };
  cloneAsElement.cloneAsArray = cloneChildrenWithPropsAndRef;
  return {
    // used during render phase to sync props with state
    useSetup: (newRef) => {
      preventNextCall = false;
      updateIfNeeded(newRef, state.childRef);
    },
    /**
     * Clones children and adds props and refs and returns them as a JSX.Element
     * Making it easier to use as it wraps them in a Fragment.
     * */
    cloneAsElement
  };
}
function createRefFunction(state) {
  if (!state.forwardedRef) return state.childRef;
  const { forwardedRef: prevForwardedRef, childRef: prevChildRef } = state;
  return (value) => {
    setRef(prevChildRef, value);
    setRef(prevForwardedRef, value);
  };
}

// ../../library/src/modules/withCSS.tsx
import React49, { useInsertionEffect as useInsertionEffect5 } from "react";

// ../../library/src/render/StyleSheetContext.ts
import React48 from "react";
var StyleSheetContext = /* @__PURE__ */ React48.createContext(void 0);

// ../../library/src/modules/withCSS.tsx
import { jsx as jsx43 } from "react/jsx-runtime";
var framerPostSSRCSSSelector = "style[data-framer-css-ssr-minified]";
var componentsWithServerRenderedStyles = /* @__PURE__ */ (() => {
  if (!isBrowser2()) return /* @__PURE__ */ new Set();
  const componentsWithSSRStylesAttr = document.querySelector(framerPostSSRCSSSelector)?.getAttribute("data-framer-components");
  if (!componentsWithSSRStylesAttr) return /* @__PURE__ */ new Set();
  return new Set(componentsWithSSRStylesAttr.split(" "));
})();
var framerCSSMarker = "data-framer-css-ssr";
var withCSS = (Component18, escapedCSS, componentSerializationId) => React49.forwardRef((props, ref) => {
  const { sheet, cache: cache2 } = React49.useContext(StyleSheetContext) ?? {};
  const id = componentSerializationId;
  if (!isBrowser2()) {
    if (isFunction(escapedCSS)) escapedCSS = escapedCSS(RenderTarget.current(), props);
    const concatenatedCSS = Array.isArray(escapedCSS) ? escapedCSS.join("\n") : escapedCSS;
    cssCollector.add(concatenatedCSS, id);
  }
  useInsertionEffect5(() => {
    if (id && componentsWithServerRenderedStyles.has(id)) return;
    const css2 = isFunction(escapedCSS) ? escapedCSS(RenderTarget.current(), props) : Array.isArray(escapedCSS) ? escapedCSS : escapedCSS.split("\n");
    css2.forEach((rule) => rule && injectCSSRule(rule, sheet, cache2));
  }, []);
  return /* @__PURE__ */ jsx43(Component18, { ...props, ref });
});
var CSSCollector = class {
  constructor() {
    __publicField(this, "styles", /* @__PURE__ */ new Set());
    __publicField(this, "componentIds", /* @__PURE__ */ new Set());
  }
  add(css2, componentId) {
    this.styles.add(css2);
    if (componentId) this.componentIds.add(componentId);
  }
  getStyles() {
    return this.styles;
  }
  getComponentIds() {
    return this.componentIds;
  }
  clear() {
    this.styles.clear();
    this.componentIds.clear();
  }
};
var cssCollector = /* @__PURE__ */ new CSSCollector();

// ../../library/src/modules/PropertyOverrides.tsx
import { jsx as jsx44 } from "react/jsx-runtime";
var SSRParentVariantsContext = /* @__PURE__ */ React50.createContext(void 0);
var SSRVariantClassName = "ssr-variant";
function renderBranchedChildrenFromPropertyOverrides(overrides, children, props, variantClassNames, primaryVariantId, parentVariants, cloneChildren, activeVariantId) {
  const childrenArray = React50.Children.toArray(children);
  const child = childrenArray[0];
  if (childrenArray.length !== 1 || !React50.isValidElement(child)) {
    console.warn("PropertyOverrides: expected exactly one React element for a child", children);
    return cloneChildren(children, props);
  }
  const branches = [];
  const nonOverriddenVariants = [];
  for (const [variantId] of Object.entries(variantClassNames)) {
    if (variantId === primaryVariantId) continue;
    const propOverrides = overrides[variantId];
    if (!propOverrides || !arePropOverridesEffectivelyDifferent(child.props, propOverrides)) {
      nonOverriddenVariants.push(variantId);
      continue;
    }
    const effectiveVariants = intersection([variantId], parentVariants);
    if (effectiveVariants.length) branches.push({ variants: effectiveVariants, propOverrides });
  }
  if (branches.length === 0) return cloneChildren(child, props);
  const remainingVariants = [primaryVariantId, ...nonOverriddenVariants];
  const effectiveRemainingVariants = intersection(remainingVariants, parentVariants);
  if (effectiveRemainingVariants.length) branches.unshift({ variants: effectiveRemainingVariants });
  const renderedBranches = [];
  for (const { variants, propOverrides } of branches) {
    if (activeVariantId && !variants.includes(activeVariantId)) {
      continue;
    }
    const key7 = variants.join("+");
    let element = (
      // We could omit the SSRParentVariantsContext if variants is the same as parentVariants, but that'd require
      // comparing arrays, so it might not really be an optimization. And since it's just a context, it doesn't
      // affect the size of the generated HTML.
      /* @__PURE__ */ jsx44(SSRParentVariantsContext.Provider, { value: { primaryVariantId, variants: new Set(variants) }, children: cloneChildren(child, propOverrides ? { ...props, ...propOverrides } : props) }, key7)
    );
    const hiddenClassNames = generateHiddenClassNames(variants, parentVariants, variantClassNames);
    if (hiddenClassNames.length) {
      assert(branches.length > 1, "Must branch out when there are hiddenClassNames");
      element = /* @__PURE__ */ jsx44("div", { className: `${SSRVariantClassName} ${hiddenClassNames.join(" ")}`, children: element }, key7);
    } else {
      assert(branches.length === 1, "Cannot branch out when hiddenClassNames is empty");
    }
    renderedBranches.push(element);
  }
  assert(
    !activeVariantId || renderedBranches.length === 1,
    "Must render exactly one branch when activeVariantId is given"
  );
  return renderedBranches;
}
var SSRVariants = /* @__PURE__ */ React50.forwardRef(
  function SSRVariants2({ id: _nodeId, children, ...props }, ref) {
    const cloneWithRefs = useCloneChildrenWithPropsAndRef(ref);
    if (isBrowser2()) {
      return cloneWithRefs(children, props);
    }
    throw new Error("SSRVariants is no longer supported outside canvas and preview");
  }
);
function variantHashFromClassName(className2) {
  return className2.split("-")[2];
}
function generateHiddenClassNames(showOnlyInVariantIds, parentVariants, variantClassNames) {
  const classNames = [];
  for (const [variantId, variantClassName] of Object.entries(variantClassNames)) {
    const alreadyHiddenInParent = parentVariants && !parentVariants.has(variantId);
    if (showOnlyInVariantIds.includes(variantId) || alreadyHiddenInParent) continue;
    classNames.push(`hidden-${variantHashFromClassName(variantClassName)}`);
  }
  return classNames;
}
function intersection(variants, parentVariants) {
  if (!parentVariants) return variants;
  return variants.filter((variant) => parentVariants.has(variant));
}
function arePropOverridesEffectivelyDifferent(props, propOverrides) {
  for (const key7 of Object.keys(propOverrides)) {
    if (!isEqual(props[key7], propOverrides[key7], true)) {
      return true;
    }
  }
  return false;
}
function propsForBreakpoint(variant, props, overrides) {
  if (!overrides || !variant) return props;
  return { ...props, ...overrides[variant] };
}
var noopSubscribe = () => () => {
};
var returnTrue = () => true;
var returnFalse = () => false;
var PropertyOverridesWithoutCSS = /* @__PURE__ */ React50.forwardRef(
  function PropertyOverrides(props, ref) {
    const cloneWithRefs = useCloneChildrenWithPropsAndRef(ref);
    const ancestorCtx = React50.useContext(SSRParentVariantsContext);
    const isHydrationOrSSR = React50.useSyncExternalStore(noopSubscribe, returnFalse, returnTrue);
    const action = useConstant(() => {
      if (isHydrationOrSSR) {
        if (isBrowser2()) {
          return 1 /* RenderActiveBranch */;
        } else {
          return 2 /* RenderAllBranches */;
        }
      } else {
        return 0 /* PassThrough */;
      }
    });
    const generatedComponentContext = React50.useContext(GeneratedComponentContext);
    return useMemoOne(() => {
      const { breakpoint, overrides, children, ...restProps } = props;
      if (!generatedComponentContext) {
        console.warn("PropertyOverrides is missing GeneratedComponentContext");
        return cloneWithRefs(children, restProps);
      }
      const { primaryVariantId, variantClassNames } = generatedComponentContext;
      const parentVariants = ancestorCtx?.primaryVariantId === primaryVariantId ? ancestorCtx?.variants : void 0;
      switch (action) {
        case 0 /* PassThrough */:
          return cloneWithRefs(children, propsForBreakpoint(breakpoint, restProps, overrides));
        case 1 /* RenderActiveBranch */:
          return renderBranchedChildrenFromPropertyOverrides(
            overrides,
            children,
            restProps,
            variantClassNames,
            primaryVariantId,
            parentVariants,
            cloneWithRefs,
            breakpoint
            // only render the single, active branch
          );
        case 2 /* RenderAllBranches */:
          return renderBranchedChildrenFromPropertyOverrides(
            overrides,
            children,
            restProps,
            variantClassNames,
            primaryVariantId,
            parentVariants,
            // On the server, we use plain cloneChildrenWithProps instead of useCloneChildrenWithPropsAndRef,
            // because we can't clone one ref to multiple branched-out elements (useCloneChildrenWithPropsAndRef
            // even guards against it), but luckily, refs mean nothing on the server anyway.
            cloneChildrenWithProps,
            void 0
            // render all branches
          );
        default:
          assertNever(action);
      }
    }, [generatedComponentContext, ancestorCtx, cloneWithRefs, props]);
  }
);
var PropertyOverrides2 = /* @__PURE__ */ (() => withCSS(PropertyOverridesWithoutCSS, `.${SSRVariantClassName} { display: contents }`, "PropertyOverrides"))();

// ../../library/src/modules/optimizeAppear.tsx
import { jsx as jsx45 } from "react/jsx-runtime";
var defaultVariantKey = "default";
var defaultVariants = /* @__PURE__ */ new Set([defaultVariantKey]);
var _variantHashes;
var AnimationCollector = class {
  constructor() {
    __publicField(this, "entries", /* @__PURE__ */ new Map());
    __privateAdd(this, _variantHashes, {});
  }
  /** @deprecated */
  set(nodeId, prop, value, variantHash) {
    switch (prop) {
      case "transformTemplate": {
        assert(typeof value === "string", `transformTemplate must be a string, received: ${value}`);
        this.setHash(nodeId, variantHash, { transformTemplate: value, legacy: true });
        break;
      }
      case "initial":
      case "animate": {
        assert(typeof value === "object", `${prop} must be a valid object, received: ${value}`);
        this.setHash(nodeId, variantHash, { [prop]: value, legacy: true });
        break;
      }
      default:
        break;
    }
  }
  setHash(id, variantHash = defaultVariantKey, value) {
    const existing = this.entries.get(id) ?? {};
    const existingValue = existing[variantHash] ?? {};
    existing[variantHash] = value === null ? null : { ...existingValue, ...value };
    this.entries.set(id, existing);
  }
  variantHash(variantId, info) {
    if (variantId === info?.primaryVariantId) return defaultVariantKey;
    const existing = __privateGet(this, _variantHashes)[variantId];
    if (existing) return existing;
    const className2 = info?.variantClassNames[variantId];
    if (!className2) return defaultVariantKey;
    return __privateGet(this, _variantHashes)[variantId] = variantHashFromClassName(className2);
  }
  setAll(id, variants = defaultVariants, props, info) {
    if (props === null) {
      for (const variantId of variants) {
        this.setHash(id, this.variantHash(variantId, info), null);
      }
      return;
    }
    const transformTemplate2 = isFunction(props.transformTemplate) ? props.transformTemplate?.({}, framerAppearTransformTemplateToken) : void 0;
    const initial = props.__framer__presenceInitial ?? props.initial;
    const animate3 = props.__framer__presenceAnimate ?? props.animate;
    const config = {
      initial: isObject2(initial) ? initial : void 0,
      animate: isObject2(animate3) ? animate3 : void 0,
      transformTemplate: isString(transformTemplate2) ? transformTemplate2 : void 0
    };
    for (const variantId of variants) this.setHash(id, this.variantHash(variantId, info), config);
  }
  clear() {
    this.entries.clear();
  }
  toObject() {
    return Object.fromEntries(this.entries);
  }
};
_variantHashes = new WeakMap();
var framerAppearEffects = /* @__PURE__ */ new AnimationCollector();
function withOptimizedAppearEffect(Component18) {
  return React51.forwardRef(({ optimized, ...props }, ref) => {
    const generatedComponentContext = React51.useContext(GeneratedComponentContext);
    const variants = React51.useContext(SSRParentVariantsContext)?.variants;
    const id = props[framerAppearIdKey];
    if (id && !isBrowser2()) {
      framerAppearEffects.setAll(
        id,
        variants,
        // A layer may have an optimization id, and an `animate` prop,
        // but not require optimization. For example in the case of a
        // layer where one variant has an appear effect, and another
        // variant has a scroll appear effect, the scroll appear effect
        // should not be optimized.
        optimized ? props : null,
        generatedComponentContext
      );
    }
    const disabledProps = getDisabledFXPropsInStaticRenderer(props);
    return /* @__PURE__ */ jsx45(Component18, { ref, ...props, ...disabledProps });
  });
}
var optimizeAppear = (prop, id, animateTargetAndTransition, variantHash) => {
  if (!isBrowser2()) {
    framerAppearEffects.set(id, prop, animateTargetAndTransition, variantHash);
  }
  return animateTargetAndTransition;
};
var framerAppearTransformTemplateToken = "__Appear_Animation_Transform__";
var optimizeAppearTransformTemplate = (id, fn) => {
  if (!isBrowser2()) {
    const template = fn?.({}, framerAppearTransformTemplateToken);
    if (template === void 0) return fn;
    framerAppearEffects.set(id, "transformTemplate", template);
  }
  return fn;
};
var framerAppearIdKey = "data-framer-appear-id";
var framerAppearAnimationScriptKey = "data-framer-appear-animation";
var getDisabledFXPropsInStaticRenderer = (props) => {
  const isRenderingStaticContent = isStaticRenderer();
  if (!isRenderingStaticContent) return void 0;
  return {
    animate: isVariantOrVariantList(props.animate) ? props.animate : void 0,
    initial: isVariantOrVariantList(props.initial) ? props.initial : void 0,
    exit: void 0
  };
};
function isVariantOrVariantList(value) {
  return isString(value) || Array.isArray(value);
}

// ../../library/src/modules/useFXValues.ts
import React52 from "react";
var effectValuesKeys = [
  "opacity",
  "x",
  "y",
  "scale",
  "rotate",
  "rotateX",
  "rotateY",
  "skewX",
  "skewY",
  /** @deprecated */
  "transformPerspective"
];
var makeFXValues = (defaults) => {
  return {
    x: motionValue(defaults?.x ?? 0),
    y: motionValue(defaults?.y ?? 0),
    opacity: motionValue(defaults?.opacity ?? 1),
    scale: motionValue(defaults?.scale ?? 1),
    rotate: motionValue(defaults?.rotate ?? 0),
    rotateX: motionValue(defaults?.rotateX ?? 0),
    rotateY: motionValue(defaults?.rotateY ?? 0),
    skewX: motionValue(defaults?.skewX ?? 0),
    skewY: motionValue(defaults?.skewY ?? 0),
    /** @deprecated */
    transformPerspective: motionValue(defaults?.transformPerspective ?? 0)
  };
};
var defaultFXValues = {
  x: 0,
  y: 0,
  scale: 1,
  opacity: 1,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
  skewX: 0,
  skewY: 0,
  /** @deprecated */
  transformPerspective: 0
};
function isFXValuesKey(key7) {
  return key7 in defaultFXValues;
}
var effectEnabledStyle = {
  willChange: "transform"
};
Object.freeze(effectEnabledStyle);
var effectDisabledStyle = {};
Object.freeze(effectDisabledStyle);
function useFXValues(values, enabled) {
  const effect = useConstant(() => ({ values: makeFXValues(enabled ? values : void 0) }));
  React52.useEffect(() => {
    if (enabled) return;
    for (const key7 of effectValuesKeys) {
      const value = defaultFXValues[key7];
      if (isUndefined(value)) continue;
      effect.values[key7].set(value);
    }
  }, [enabled]);
  return effect;
}

// ../../library/src/modules/useLoopEffect.ts
import { startTransition as startTransition2, useCallback as useCallback11, useEffect as useEffect16, useMemo as useMemo10, useRef as useRef15, useState as useState4 } from "react";
var loopOptionsKeys = /* @__PURE__ */ new Set([
  "loopEffectEnabled",
  "loopTransition",
  "loop",
  "loopRepeatType",
  "loopRepeatDelay",
  "loopPauseOffscreen"
]);
var useDelay = () => {
  const timeoutRef = useRef15();
  useEffect16(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);
  return async (d) => new Promise((resolve) => {
    timeoutRef.current = setTimeout(() => {
      resolve(true);
    }, d * 1e3);
  });
};
function useLoop({
  loopEffectEnabled,
  loopRepeatDelay,
  loopTransition,
  loopRepeatType,
  loop,
  loopPauseOffscreen
}, ref) {
  const shouldReduceMotion = useReducedMotionConfig();
  const values = useConstant(makeFXValues);
  const mirrorStateRef = useRef15(false);
  const delay3 = useDelay();
  const animationPromiseRef = useRef15(null);
  const animateValues = useCallback11(async () => {
    if (!loop) return;
    const transition = loopTransition || void 0;
    const mirror = mirrorStateRef.current && loopRepeatType === "mirror";
    const to = mirror ? defaultFXValues : loop;
    const from = mirror ? loop : defaultFXValues;
    mirrorStateRef.current = !mirrorStateRef.current;
    animationPromiseRef.current = Promise.all(
      effectValuesKeys.map((key7) => {
        if (shouldReduceMotion && key7 !== "opacity") return;
        values[key7].jump(from[key7] ?? defaultFXValues[key7]);
        return new Promise((resolve) => {
          const opts = {
            ...transition,
            onComplete: () => resolve()
          };
          const target = to[key7] ?? from[key7];
          if (typeof target === "number") {
            animate(values[key7], target, opts);
          }
        });
      })
    );
    return animationPromiseRef.current;
  }, [loop, loopRepeatType, loopTransition, shouldReduceMotion]);
  const [isRunning, setIsRunning] = useState4(false);
  const shouldRunRef = useRef15(false);
  const animateLoop = useCallback11(async () => {
    if (!loopEffectEnabled || !shouldRunRef.current) return;
    await animateValues();
    await delay3(loopRepeatDelay ?? 0);
    void animateLoop();
  }, [animateValues, delay3, loopEffectEnabled, loopRepeatDelay]);
  const start = useCallback11(() => {
    if (shouldRunRef.current) return;
    shouldRunRef.current = true;
    startTransition2(() => setIsRunning(true));
    void animateLoop();
  }, [animateLoop]);
  const stop = useCallback11((overrideRunRef = true) => {
    effectValuesKeys.forEach((key7) => {
      values[key7].stop();
    });
    effectValuesKeys.forEach((key7) => {
      values[key7].set(defaultFXValues[key7]);
    });
    mirrorStateRef.current = false;
    if (overrideRunRef) {
      shouldRunRef.current = false;
      startTransition2(() => setIsRunning(false));
    }
  }, []);
  const hasLoop = loopEffectEnabled && loop;
  const startStopTabVisibilityListener = useCallback11(() => {
    if (document.hidden) {
      stop(false);
    } else if (shouldRunRef.current) {
      shouldRunRef.current = false;
      start();
    }
  }, [start, stop]);
  useEffect16(() => {
    if (!hasLoop) return;
    document.addEventListener("visibilitychange", startStopTabVisibilityListener);
    return () => {
      document.removeEventListener("visibilitychange", startStopTabVisibilityListener);
    };
  }, [hasLoop, startStopTabVisibilityListener]);
  useEffect16(() => {
    if (hasLoop && loopPauseOffscreen) return;
    if (hasLoop) {
      start();
    } else {
      stop();
    }
  }, [start, stop, loopPauseOffscreen, hasLoop]);
  useEffect16(() => {
    return () => stop();
  }, [stop]);
  const isIntersectingRef = useRef15(false);
  const stopAfterAnimationEnds = useCallback11(async () => {
    if (!animationPromiseRef.current) return;
    await animationPromiseRef.current;
    if (isIntersectingRef.current) return;
    stop();
  }, [stop]);
  const startAndStopBasedOnIntersection = useCallback11(
    (entry) => {
      if (entry.isIntersecting) {
        isIntersectingRef.current = true;
        start();
      } else {
        isIntersectingRef.current = false;
        void stopAfterAnimationEnds();
      }
    },
    [start, stopAfterAnimationEnds]
  );
  useSharedIntersectionObserver(ref, startAndStopBasedOnIntersection, {
    enabled: hasLoop && loopPauseOffscreen
  });
  const addWillChange = isRunning || !loopPauseOffscreen;
  return useMemo10(() => {
    return {
      values,
      style: hasLoop && addWillChange ? effectEnabledStyle : effectDisabledStyle
    };
  }, [hasLoop, addWillChange]);
}

// ../../library/src/modules/useParallax.ts
import React53, { useContext as useContext16 } from "react";

// ../../library/src/modules/parallaxTransform.ts
function parallaxTransform(scrollY, originalPosition, speed, offset, adjustPosition) {
  const speedFactor = speed / 100 - 1;
  const initialPosition = adjustPosition ? (originalPosition - offset) * speedFactor : 0;
  const scrollOffset = -scrollY * speedFactor;
  return initialPosition + scrollOffset;
}

// ../../library/src/modules/useParallax.ts
var parallaxOptionsKeys = /* @__PURE__ */ new Set([
  "speed",
  "adjustPosition",
  "offset",
  "parallaxTransformEnabled"
]);
function useParallax(options, ref, visibilityStyle) {
  const { speed = 100, offset = 0, adjustPosition = false, parallaxTransformEnabled } = options;
  const originalPosition = React53.useRef(null);
  const shouldReduceMotion = useReducedMotionConfig();
  const transform2 = React53.useCallback(
    (yValue) => {
      if (originalPosition.current === null) return 0;
      if (speed === 100) return 0;
      return parallaxTransform(yValue, originalPosition.current, speed, offset, adjustPosition);
    },
    [speed, offset, adjustPosition]
  );
  const { scrollY } = useScroll();
  const parallaxY = useTransform(scrollY, transform2);
  const visibility = useMotionValue(adjustPosition && originalPosition.current === null ? "hidden" : visibilityStyle);
  const defaultValue = useMotionValue(0);
  const observers = useContext16(SharedIntersectionObserverContext);
  useRefEffect(
    ref,
    (element) => {
      if (element === null || !parallaxTransformEnabled) return;
      const unobserve = observeElement(observers, "undefined", element, null, (entry) => {
        originalPosition.current = entry.boundingClientRect.top;
        frame.update(() => {
          parallaxY.set(transform2(scrollY.get()));
          if (adjustPosition) {
            visibility.set(visibilityStyle ?? "initial");
          }
        });
        unobserve();
      });
      return unobserve;
    },
    [adjustPosition, parallaxTransformEnabled]
  );
  useOnRouteChange(() => {
    if (!parallaxTransformEnabled) return;
    parallaxY.set(0);
  });
  return {
    values: {
      y: shouldReduceMotion || !parallaxTransformEnabled ? defaultValue : parallaxY
    },
    style: parallaxTransformEnabled ? {
      ...effectEnabledStyle,
      visibility
    } : effectDisabledStyle
  };
}

// ../../library/src/modules/usePresenceAnimation.ts
import { useMemo as useMemo11, useRef as useRef16 } from "react";
function isTargetAndTransition(value) {
  return typeof value === "object" && value !== null;
}
function getTransition(value) {
  if (!isTargetAndTransition(value)) return void 0;
  return value?.transition;
}
function runEffectAnimation(target, effect, shouldReduceMotion, ref, appearId, instant) {
  const transition = getTransition(target);
  return Promise.all(
    effectValuesKeys.map((key7) => {
      return new Promise((resolve) => {
        if (shouldReduceMotion && key7 !== "opacity") return resolve();
        const motionValue2 = effect.values[key7];
        motionValue2.stop();
        let value = !isTargetAndTransition(target) ? defaultFXValues[key7] : target?.[key7] ?? defaultFXValues[key7];
        if (isMotionValue(value)) value = value.get();
        if (!isNumber(value)) return resolve();
        const visualElement = visualElementStore.get(ref.current);
        if (visualElement) visualElement.setBaseTarget(key7, value);
        let startTime;
        if (isString(appearId) && !motionValue2?.hasAnimated && safeWindow.MotionHandoffAnimation) {
          const handoffAnimationStartTime = safeWindow.MotionHandoffAnimation(appearId, key7, frame);
          if (handoffAnimationStartTime) {
            startTime = handoffAnimationStartTime;
          }
        }
        if (instant) {
          motionValue2.set(value);
        } else {
          animate(motionValue2, value, {
            ...transition,
            velocity: 0,
            startTime,
            onComplete: () => resolve()
          });
        }
      });
    })
  );
}
var presenceOptionsKeys = /* @__PURE__ */ new Set([
  "presenceInitial",
  "presenceAnimate",
  "presenceExit"
]);
function usePresenceAnimation({
  initial: motionInitial,
  animate: motionAnimate,
  exit: motionExit,
  presenceInitial,
  presenceAnimate,
  presenceExit
}, ref, enabled, style, appearId) {
  const initial = presenceInitial ?? motionInitial;
  const animateConfig = presenceAnimate ?? motionAnimate;
  const exit = presenceExit ?? motionExit;
  const [isPresent, safeToRemove] = usePresence();
  const internalState = useRef16({
    lastPresence: false,
    lastAnimate: animateConfig,
    hasMounted: false,
    running: false
  });
  const effect = useConstant(() => {
    const base = initial ?? style;
    if (!isObject2(base)) return { values: makeFXValues() };
    const defaults = {};
    for (const key7 in base) {
      const value = isObject2(base) ? base[key7] : void 0;
      if (!isNumber(value)) continue;
      defaults[key7] = value;
    }
    return { values: makeFXValues(defaults) };
  });
  useRefEffect(
    ref,
    (element) => {
      const { hasMounted } = internalState.current;
      if (hasMounted && animateConfig) return;
      const visualElement = visualElementStore.get(element);
      if (!visualElement) return;
      Object.assign(internalState.current, { hasMounted: true });
      for (const key7 in effect.values) {
        if (!isFXValuesKey(key7)) continue;
        const value = style?.[key7];
        visualElement.setBaseTarget(key7, isNumber(value) ? value : defaultFXValues[key7]);
      }
    },
    [animateConfig]
  );
  const shouldReduceMotion = useReducedMotionConfig();
  useRefEffect(ref, (element) => {
    if (!enabled) {
      safeToRemove?.();
      return;
    }
    if (element === null) return;
    if (isPresent !== internalState.current.lastPresence) {
      Object.assign(internalState.current, { lastPresence: isPresent });
      if (isPresent) {
        if (initial && animateConfig) {
          Object.assign(internalState.current, { running: true });
          void runEffectAnimation(animateConfig, effect, shouldReduceMotion, ref, appearId).then(
            () => Object.assign(internalState.current, { running: false })
          );
        }
      } else if (exit) {
        Object.assign(internalState.current, { running: true });
        void runEffectAnimation(exit, effect, shouldReduceMotion, ref, appearId).then(() => Object.assign(internalState.current, { running: false })).then(() => safeToRemove());
      } else {
        safeToRemove();
      }
      return;
    }
    const { lastAnimate, running } = internalState.current;
    const hasAnimateChanged = !isEqual(animateConfig, lastAnimate);
    if (!hasAnimateChanged || !animateConfig) return;
    Object.assign(internalState.current, { lastAnimate: animateConfig });
    void runEffectAnimation(animateConfig, effect, shouldReduceMotion, ref, appearId, !running).then(
      () => Object.assign(internalState.current, { running: false })
    );
  });
  const effectEnabled = enabled && animateConfig;
  return useMemo11(() => {
    return { values: effect.values, style: effectEnabled ? effectEnabledStyle : effectDisabledStyle };
  }, [effectEnabled]);
}

// ../../library/src/modules/useStyleAppearEffect.ts
import React55, { useMemo as useMemo12 } from "react";

// ../../library/src/modules/calculateOffsetTop.ts
function calcOffsetTop(element, container) {
  let top = 0;
  let current = element;
  while (current && current !== container) {
    if (!(current instanceof HTMLElement)) break;
    top += current.offsetTop;
    current = current.offsetParent;
  }
  return top;
}

// ../../library/src/modules/createTransformInputRange.ts
var scrollObserverOffset = 1;
function createTransformInputRange(transformTargets, threshold = 0, callback) {
  const starts = [];
  const inputRange = [];
  for (let index = transformTargets.length; index >= 0; index--) {
    const { ref: targetRef, offset } = transformTargets[index] ?? {};
    if (!targetRef || !targetRef.current) continue;
    const offsetTop = calcOffsetTop(targetRef.current, document.documentElement);
    const top = offsetTop - scrollObserverOffset - (offset ?? 0) - threshold;
    const height = targetRef.current?.clientHeight ?? 0;
    const previousTop = starts[starts.length - 1];
    const end = Math.max(top + height, 0);
    starts.push(top);
    inputRange.unshift(
      Math.max(top, 0),
      previousTop === void 0 ? end : Math.min(end, Math.max(previousTop - 1, 0))
    );
    callback?.(index);
  }
  return inputRange;
}

// ../../library/src/modules/useScrollDirectionChange.ts
import React54 from "react";
function currentScrollDirection(offset, lastOffset = 0) {
  if (offset < lastOffset) return "up";
  return "down";
}
var scrollDirectionThreshold = 4;
function useScrollDirectionChange(scrollDirection, cb, options = {}) {
  const { direction, target } = scrollDirection ?? {};
  const { repeat = true, enabled = true } = options;
  const currentRouteKey = useCurrentRouteKey();
  React54.useEffect(() => {
    if (!direction || !enabled) return;
    const _ = currentRouteKey;
    let lastOffset = void 0;
    let directionChangeOffset = 0;
    let lastDirection = void 0;
    let currentTarget = void 0;
    return scroll((_2, { y: scrollY }) => {
      if (!repeat && currentTarget === target) return;
      if (scrollY.current > scrollY.scrollLength) return;
      if (scrollY.current < 0) return;
      const d = currentScrollDirection(scrollY.current, lastOffset);
      lastOffset = scrollY.current;
      const hasDirectionChanged = d !== lastDirection;
      lastDirection = d;
      if (hasDirectionChanged) {
        directionChangeOffset = scrollY.current;
      } else {
        const delta = Math.abs(scrollY.current - directionChangeOffset);
        if (delta < scrollDirectionThreshold) return;
        const nextTarget = d === direction ? target : void 0;
        if (nextTarget !== currentTarget) cb(nextTarget);
        currentTarget = nextTarget;
      }
    });
  }, [currentRouteKey, direction, repeat, target, enabled, cb]);
}

// ../../library/src/modules/useStyleAppearEffect.ts
var styleAppearOptionsKeys = /* @__PURE__ */ new Set([
  "threshold",
  "animateOnce",
  "opacity",
  "targetOpacity",
  "x",
  "y",
  "scale",
  "transition",
  "rotate",
  "rotateX",
  "rotateY",
  "perspective",
  "enter",
  "exit",
  "animate",
  "styleAppearEffectEnabled",
  "targets",
  "scrollDirection"
]);
var defaultOutputRange = ["animate", "animate"];
var defaultRanges = { inputRange: [], outputRange: [] };
function createInputOutputRange(targets, threshold, hasExit) {
  const inputRange = createTransformInputRange(targets, threshold);
  const outputRange = [...defaultOutputRange];
  const firstRange = inputRange[0];
  if (!isNumber(firstRange)) return defaultRanges;
  if (firstRange > 1) {
    inputRange.unshift(0, firstRange - 1);
    outputRange.unshift("initial", "initial");
  }
  if (hasExit) {
    const idx = inputRange.length - 1;
    const last = inputRange[idx];
    if (!isNumber(last)) return defaultRanges;
    inputRange.push(last + 1);
    outputRange.push("exit");
  }
  return {
    inputRange,
    outputRange
  };
}
function makeStyle(defaults) {
  return {
    x: defaults?.x ?? defaultFXValues.x,
    y: defaults?.y ?? defaultFXValues.y,
    scale: defaults?.scale ?? defaultFXValues.scale,
    opacity: defaults?.opacity ?? defaultFXValues.opacity,
    transformPerspective: defaults?.transformPerspective ?? defaultFXValues.transformPerspective,
    rotate: defaults?.rotate ?? defaultFXValues.rotate,
    rotateX: defaults?.rotateX ?? defaultFXValues.rotateX,
    rotateY: defaults?.rotateY ?? defaultFXValues.rotateY,
    skewX: defaults?.skewX ?? defaultFXValues.skewX,
    skewY: defaults?.skewY ?? defaultFXValues.skewY,
    transition: defaults?.transition ?? void 0
  };
}
function useAnimationVariants({
  opacity,
  targetOpacity,
  perspective: transformPerspective,
  enter,
  exit,
  animate: animateVariant,
  ...defaultStyles
}) {
  return React55.useMemo(
    () => ({
      initial: enter ?? makeStyle({
        ...defaultStyles,
        opacity: opacity ?? targetOpacity ?? 1,
        transformPerspective
      }),
      animate: animateVariant ?? makeStyle({
        opacity: targetOpacity
      }),
      exit: exit ?? makeStyle()
    }),
    // biome-ignore lint/correctness/useExhaustiveDependencies: `defaultStyles` makes this memo re-run on every render, but that appears to be fine.
    [animateVariant, defaultStyles, enter, exit, opacity, targetOpacity, transformPerspective]
  );
}
function useStyleAppearEffect(options, ref) {
  const shouldReduceMotion = useReducedMotionConfig();
  const variants = useAnimationVariants(options);
  const enabled = options.styleAppearEffectEnabled;
  const effect = useFXValues(enabled ? variants.initial : variants.animate, enabled);
  const playState = React55.useRef({
    isPlaying: false,
    scheduledAppearState: void 0,
    lastAppearState: !options.styleAppearEffectEnabled
  });
  const currentRouteKey = useCurrentRouteKey();
  const animation = React55.useRef();
  const runAnimation = React55.useCallback(
    async ({ transition, ...target }, fromInitial) => {
      const transitionWithFallback = transition ?? variants.animate.transition ?? options.transition;
      await animation.current;
      const visualElement = visualElementStore.get(ref.current);
      animation.current = Promise.all(
        effectValuesKeys.map((key7) => {
          if (fromInitial) effect.values[key7].set(variants.initial[key7] ?? defaultFXValues[key7]);
          const toValue = target[key7] ?? defaultFXValues[key7];
          if (visualElement && typeof toValue !== "object") {
            visualElement.setBaseTarget(key7, toValue);
          }
          return new Promise((resolve) => {
            if (shouldReduceMotion && key7 !== "opacity") {
              if (isNumber(toValue)) effect.values[key7].set(toValue);
              resolve();
            } else {
              const opts = {
                restDelta: key7 === "scale" ? 1e-3 : void 0,
                ...transitionWithFallback,
                onComplete: () => resolve()
              };
              if (typeof toValue === "number") {
                animate(effect.values[key7], toValue, opts);
              }
            }
          });
        })
      );
    },
    []
  );
  const hasAnimatedOnce = options.animateOnce && playState.current.lastAppearState === true;
  const animateWithIntersectionObserver = !options.targets && options.styleAppearEffectEnabled && !options.scrollDirection && !hasAnimatedOnce;
  useAppearEffect(
    ref,
    (appears) => {
      const { isPlaying, lastAppearState } = playState.current;
      if (isPlaying) {
        playState.current.scheduledAppearState = appears;
        return;
      }
      playState.current.scheduledAppearState = void 0;
      playState.current.lastAppearState = appears;
      if (lastAppearState === appears) return;
      void runAnimation(appears ? variants.animate : variants.exit, appears);
    },
    {
      enabled: animateWithIntersectionObserver,
      animateOnce: !!options.animateOnce,
      threshold: {
        y: options.threshold
      }
    }
  );
  const animateWithScrollInfo = options.targets && enabled && !options.scrollDirection;
  React55.useEffect(() => {
    if (!animateWithScrollInfo) return;
    const playedState = { initial: true };
    const _ = currentRouteKey;
    let lastVariant = "initial";
    return scroll((_2, { y: scrollY }) => {
      const { targets } = options;
      if (!targets) return;
      if (!targets[0] || targets[0].ref && !targets[0].ref.current) return;
      const { inputRange, outputRange } = createInputOutputRange(
        targets,
        (options.threshold ?? 0) * scrollY.containerLength,
        !!options.exit
      );
      if (inputRange.length === 0 || inputRange.length !== outputRange.length) return;
      const variant = transform(scrollY.current, inputRange, outputRange);
      if (options.animateOnce && playedState[variant]) return;
      playedState[variant] = true;
      if (lastVariant === variant) return;
      lastVariant = variant;
      const variantAnimation = asRecord(variants)[variant];
      if (!variantAnimation) return;
      void runAnimation(variantAnimation);
    });
  }, [currentRouteKey, animateWithScrollInfo]);
  useScrollDirectionChange(options.scrollDirection, (target) => void runAnimation(target ?? variants.animate), {
    enabled,
    repeat: !options.animateOnce
  });
  useOnRouteChange(() => {
    if (!enabled) return;
    if (!options.targets && !options.scrollDirection) return;
    for (const key7 of effectValuesKeys) {
      effect.values[key7].set(variants.initial?.[key7] ?? defaultFXValues[key7]);
    }
  });
  return useMemo12(() => {
    return { values: effect.values, style: enabled ? effectEnabledStyle : effectDisabledStyle };
  }, [enabled]);
}

// ../../library/src/modules/useStyleTransformEffect.ts
import React56, { useLayoutEffect as useLayoutEffect5 } from "react";
var styleTransformOptionsKeys = /* @__PURE__ */ new Set([
  "transformViewportThreshold",
  "styleTransformEffectEnabled",
  "transformTargets",
  "spring",
  "transformTrigger"
]);
var defaultValues = (transformTargets, shouldReduceMotion) => {
  const initial = transformTargets?.[0]?.target;
  return shouldReduceMotion ? { opacity: initial?.opacity ?? 1 } : initial;
};
var defaultRanges2 = () => ({
  opacity: [],
  x: [],
  y: [],
  scale: [],
  rotate: [],
  rotateX: [],
  rotateY: [],
  skewX: [],
  skewY: [],
  transformPerspective: []
});
function useAttachOptionalSpring(values, spring2) {
  const springs = React56.useRef({});
  React56.useEffect(() => {
    if (spring2 === void 0) return;
    for (const key7 of objectKeys(values)) {
      let startAnimation3 = function() {
        const active = springs.current[key7];
        if (active) active.stop();
        springs.current[key7] = animateValue({
          keyframes: [m2.get(), latestValue],
          velocity: m2.getVelocity(),
          ...spring2,
          restDelta: 1e-3,
          onUpdate: latestSetter
        });
      };
      var startAnimation2 = startAnimation3;
      const m2 = values[key7];
      let latestSetter;
      let latestValue;
      m2.attach((v, set) => {
        latestValue = v;
        latestSetter = set;
        frame.postRender(startAnimation3);
        return m2.get();
      });
    }
  }, [JSON.stringify(spring2)]);
}
function createInputOutputRanges(transformTargets, threshold) {
  const effectKeyOutputRange = defaultRanges2();
  const inputRange = createTransformInputRange(transformTargets, threshold, (index) => {
    const previousTarget = transformTargets[index - 1]?.target;
    const currentTarget = transformTargets[index]?.target;
    for (const key7 of effectValuesKeys) {
      effectKeyOutputRange[key7]?.unshift(previousTarget?.[key7] ?? 0, currentTarget?.[key7] ?? 0);
    }
  });
  return { inputRange, effectKeyOutputRange };
}
function createPageOutputRange(transformTargets) {
  const keyOutputRange = defaultRanges2();
  for (const { target } of transformTargets) {
    for (const key7 of effectValuesKeys) keyOutputRange[key7]?.push(target[key7]);
  }
  return keyOutputRange;
}
var pageInputRange = [0, 1];
function useStyleTransform({
  transformTrigger,
  styleTransformEffectEnabled,
  transformTargets,
  spring: spring2,
  transformViewportThreshold = 0
}, ref) {
  const shouldReduceMotion = useReducedMotionConfig();
  const effect = useFXValues(defaultValues(transformTargets, shouldReduceMotion), styleTransformEffectEnabled);
  const effectDisabled = !styleTransformEffectEnabled || !transformTargets;
  const triggerOnScroll = transformTrigger === "onScrollTarget";
  const currentRouteKey = useCurrentRouteKey();
  useLayoutEffect5(() => {
    if (effectDisabled || !triggerOnScroll) return;
    return scroll((_, { y: scrollY }) => {
      if (!transformTargets[0] || transformTargets[0].ref && !transformTargets[0].ref.current) {
        return;
      }
      const { inputRange: scrollYInputRange, effectKeyOutputRange } = createInputOutputRanges(
        transformTargets,
        transformViewportThreshold * scrollY.containerLength
      );
      if (scrollYInputRange.length === 0) return;
      for (const key7 of effectValuesKeys) {
        if (shouldReduceMotion && key7 !== "opacity") continue;
        if (scrollYInputRange.length !== effectKeyOutputRange[key7].length) continue;
        if (effectKeyOutputRange[key7][0] === void 0) continue;
        effect.values[key7].set(transform(scrollY.current, scrollYInputRange, effectKeyOutputRange[key7]));
      }
    });
  }, [shouldReduceMotion, triggerOnScroll, transformViewportThreshold, transformTargets, effectDisabled]);
  useRefEffect(
    ref,
    (element) => {
      if (effectDisabled || triggerOnScroll || element === null) {
        return;
      }
      const _ = currentRouteKey;
      const outputRange = createPageOutputRange(transformTargets);
      return scroll(
        (_2, { y: scrollY }) => {
          for (const key7 of effectValuesKeys) {
            if (shouldReduceMotion && key7 !== "opacity") continue;
            if (pageInputRange.length !== outputRange[key7].length) continue;
            if (outputRange[key7][0] === void 0) continue;
            effect.values[key7].set(transform(scrollY.progress, pageInputRange, outputRange[key7]));
          }
        },
        transformTrigger === "onInView" ? {
          target: element ?? void 0,
          offset: ["start end", "end end"]
        } : void 0
      );
    },
    [currentRouteKey, shouldReduceMotion, transformTrigger, triggerOnScroll, transformTargets, effectDisabled]
  );
  useAttachOptionalSpring(effect.values, spring2);
  useOnRouteChange(() => {
    if (effectDisabled) return;
    const values = defaultValues(transformTargets, shouldReduceMotion);
    for (const key7 of effectValuesKeys) {
      effect.values[key7].set(values?.[key7] ?? defaultFXValues[key7]);
    }
  });
  return React56.useMemo(() => {
    return {
      values: effect.values,
      style: styleTransformEffectEnabled ? effectEnabledStyle : effectDisabledStyle
    };
  }, [styleTransformEffectEnabled]);
}

// ../../library/src/modules/withFX.tsx
import { jsx as jsx46 } from "react/jsx-runtime";
var groups = {
  parallax: parallaxOptionsKeys,
  styleAppear: styleAppearOptionsKeys,
  styleTransform: styleTransformOptionsKeys,
  loop: loopOptionsKeys,
  presence: presenceOptionsKeys
};
var groupValues = /* @__PURE__ */ objectKeys(groups);
function backwardsCompatibleEnabledCheck(key7, secondaryKey, object) {
  return !(key7 in object) && secondaryKey in object || object[key7] === true;
}
function extractFXOptions(props) {
  const result = {
    parallax: {},
    styleAppear: {},
    styleTransform: {},
    presence: {
      animate: props.animate,
      initial: props.initial,
      exit: props.exit
    },
    loop: {},
    forwardedProps: {},
    targetOpacityValue: props.__targetOpacity,
    withPerspective: props.__perspectiveFX,
    inSmartComponent: props.__smartComponentFX
  };
  for (const key7 in props) {
    if (key7 === "__targetOpacity" || key7 === "__perspectiveFX" || key7 === "__smartComponentFX") continue;
    const strippedKey = stripPrefixFromPrefixedKey(key7);
    if (strippedKey) {
      for (const group of groupValues) {
        const keys3 = groups[group];
        if (keys3?.has(strippedKey)) {
          ;
          result[group][strippedKey] = asRecord(props)[key7];
          break;
        }
      }
    } else {
      ;
      result.forwardedProps[key7] = asRecord(props)[key7];
    }
  }
  result.parallax.parallaxTransformEnabled = backwardsCompatibleEnabledCheck(
    "parallaxTransformEnabled",
    "speed",
    result.parallax
  );
  result.styleAppear.styleAppearEffectEnabled = backwardsCompatibleEnabledCheck(
    "styleAppearEffectEnabled",
    "animateOnce",
    result.styleAppear
  );
  return result;
}
var add2 = (values) => values.reduce((sum, value) => sum += value, 0);
var multiply = (values) => values.reduce((sum, value) => sum = sum * value, 1);
var reactRefObjectKey = "current";
function isReactRefObject(value) {
  return isObject2(value) && reactRefObjectKey in value;
}
function addMotionValueStyle(style, values) {
  if (!style || !isObject2(style)) return values;
  for (const key7 in style) {
    const value = style[key7];
    if (!isMotionValue(value) || !isFXValuesKey(key7)) continue;
    if (!isNumber(value.get())) continue;
    values[key7].push(value);
  }
}
function isVariantOrVariantList2(value) {
  return isString(value) || Array.isArray(value);
}
var withFX = (Component18) => React57.forwardRef((props, forwardedRef) => {
  if (props.__withFX) {
    return /* @__PURE__ */ jsx46(Component18, { ...props, animate: void 0, initial: void 0, exit: void 0, ref: forwardedRef });
  }
  const disabledProps = getDisabledFXPropsInStaticRenderer(props);
  if (disabledProps) {
    return /* @__PURE__ */ jsx46(Component18, { ...props, ...disabledProps, ref: forwardedRef });
  }
  const {
    parallax = {},
    styleAppear = {},
    styleTransform = {},
    presence = {},
    loop = {},
    forwardedProps,
    targetOpacityValue,
    withPerspective,
    inSmartComponent = false
  } = extractFXOptions(props);
  const observerRef = useObserverRef(forwardedRef);
  const { values: presenceEffectValues, style: presenceEffectStyle } = usePresenceAnimation(
    presence,
    observerRef,
    inSmartComponent,
    props.style,
    props[optimizedAppearDataAttribute]
  );
  const { values: parallaxValues, style: parallaxStyle } = useParallax(
    parallax,
    observerRef,
    props.style?.visibility
  );
  const { values: transformValues2, style: scrollStyle } = useStyleTransform(styleTransform, observerRef);
  const { values: appearEffectValues, style: scrollAppearStyle } = useStyleAppearEffect(styleAppear, observerRef);
  const { values: loopValues, style: loopStyle } = useLoop(loop, observerRef);
  const fxValues = React57.useMemo(() => {
    const layerOpacity = new MotionValue(targetOpacityValue ?? 1);
    return {
      scale: [appearEffectValues.scale, loopValues.scale, presenceEffectValues.scale, transformValues2.scale],
      opacity: [
        appearEffectValues.opacity,
        loopValues.opacity,
        presenceEffectValues.opacity,
        layerOpacity,
        transformValues2.opacity
      ],
      x: [appearEffectValues.x, loopValues.x, presenceEffectValues.x, transformValues2.x],
      y: [appearEffectValues.y, loopValues.y, parallaxValues.y, presenceEffectValues.y, transformValues2.y],
      rotate: [
        appearEffectValues.rotate,
        loopValues.rotate,
        presenceEffectValues.rotate,
        transformValues2.rotate
      ],
      rotateX: [
        appearEffectValues.rotateX,
        loopValues.rotateX,
        presenceEffectValues.rotateX,
        transformValues2.rotateX
      ],
      rotateY: [
        appearEffectValues.rotateY,
        loopValues.rotateY,
        presenceEffectValues.rotateY,
        transformValues2.rotateY
      ],
      skewX: [appearEffectValues.skewX, loopValues.skewX, presenceEffectValues.skewX, transformValues2.skewX],
      skewY: [appearEffectValues.skewY, loopValues.skewY, presenceEffectValues.skewY, transformValues2.skewY],
      /** @deprecated */
      transformPerspective: [
        transformValues2.transformPerspective,
        appearEffectValues.transformPerspective
        // We stopped animating transformPerspective with `withFX`
        // before introducing `useLoop` etc, so it does not have a
        // value here on purpose.
      ]
    };
  }, [targetOpacityValue, transformValues2, parallaxValues, appearEffectValues, loopValues, presenceEffectValues]);
  addMotionValueStyle(props.style, fxValues);
  const scale2 = useTransform(fxValues.scale, multiply);
  const opacity = useTransform(fxValues.opacity, multiply);
  const x = useTransform(fxValues.x, add2);
  const y = useTransform(fxValues.y, add2);
  const rotate = useTransform(fxValues.rotate, add2);
  const rotateX = useTransform(fxValues.rotateX, add2);
  const rotateY = useTransform(fxValues.rotateY, add2);
  const skewX = useTransform(fxValues.skewX, add2);
  const skewY = useTransform(fxValues.skewY, add2);
  const transformPerspective = useTransform(fxValues.transformPerspective, add2);
  const { drag, dragConstraints } = forwardedProps;
  useRerenderOnResize(drag && isReactRefObject(dragConstraints) ? dragConstraints : void 0);
  const motionValueStyle = {
    opacity,
    scale: scale2,
    x,
    y,
    rotate,
    rotateX,
    rotateY,
    skewX,
    skewY
  };
  if (isUndefined(withPerspective)) motionValueStyle.transformPerspective = transformPerspective;
  const animate3 = isVariantOrVariantList2(props.animate) ? props.animate : void 0;
  const initial = isVariantOrVariantList2(props.initial) ? props.initial : void 0;
  const exit = isVariantOrVariantList2(props.exit) ? props.exit : void 0;
  const motionGestures = inSmartComponent && !presence.presenceInitial ? { initial, animate: animate3, exit } : {};
  return /* @__PURE__ */ jsx46(
    Component18,
    {
      ...forwardedProps,
      ...motionGestures,
      __withFX: true,
      style: {
        ...props.style,
        ...parallaxStyle,
        ...scrollStyle,
        ...loopStyle,
        ...motionValueStyle,
        ...scrollAppearStyle,
        ...presenceEffectStyle
      },
      values: presenceEffectValues,
      ref: observerRef
    }
  );
});

// ../../library/src/deprecated/deprecatedEffects.ts
var withParallaxTransform = withFX;
var withStyleAppearEffect = withFX;

// ../../library/src/modules/ComponentPresetsContext.tsx
import { createContext as createContext7, useContext as useContext17, useRef as useRef17 } from "react";
import { jsx as jsx47 } from "react/jsx-runtime";
var Context = /* @__PURE__ */ createContext7({});
function ComponentPresetsProvider({ presets, children }) {
  const lastPresets = useRef17(presets);
  if (!isEqual(presets, lastPresets.current, false)) {
    lastPresets.current = presets;
  }
  return /* @__PURE__ */ jsx47(Context.Provider, { value: lastPresets.current, children });
}
function ComponentPresetsConsumer({ componentIdentifier, children }) {
  const componentPresets = useContext17(Context);
  const presetProps = componentPresets[componentIdentifier] ?? {};
  return children(presetProps);
}

// ../../library/src/modules/ComponentViewportContext.tsx
import React58 from "react";
import { jsx as jsx48 } from "react/jsx-runtime";
var ComponentViewportContext = /* @__PURE__ */ React58.createContext({});
function useComponentViewport() {
  return React58.useContext(ComponentViewportContext);
}
var ComponentViewportProvider = /* @__PURE__ */ React58.forwardRef(function ComponentViewportProvider2({ width, height, y, children, ...rest }, ref) {
  const componentViewport = React58.useMemo(() => {
    return { width, height, y };
  }, [width, height, y]);
  const cloneWithPropsAndRef = useCloneChildrenWithPropsAndRef(ref);
  return /* @__PURE__ */ jsx48(ComponentViewportContext.Provider, { value: componentViewport, children: cloneWithPropsAndRef(children, rest) });
});

// ../../library/src/modules/Container.tsx
import React61 from "react";

// ../../library/src/render/utils/withGeneratedLayoutId.tsx
import React59 from "react";
import { jsx as jsx49 } from "react/jsx-runtime";
var withGeneratedLayoutId = (Component18) => React59.forwardRef((props, ref) => {
  const layoutId = useLayoutId(props);
  return /* @__PURE__ */ jsx49(Component18, { layoutId, ...props, layoutIdKey: void 0, duplicatedFrom: void 0, ref });
});

// ../../library/src/modules/code-boundary/CodeComponentBoundary.tsx
import { Component as Component12, Suspense as Suspense2 } from "react";

// ../../library/src/router/SuspenseThatPreservesDom.tsx
import { Suspense, createContext as createContext8, useContext as useContext18 } from "react";

// ../../library/src/router/error-boundary/SynchronousSuspenseErrorBoundary.tsx
import { Component as Component11 } from "react";
var shouldSuspenseBoundariesBeActive = false;
var SynchronousSuspenseErrorBoundary = class extends Component11 {
  constructor() {
    super(...arguments);
    __publicField(this, "state", { error: void 0 });
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  // Note: SynchronousSuspenseErrorBoundary is relying on some narrow implementation details of React
  // which we dont fully understand: https://www.notion.so/framer/SuspenseThatPreservesDOM-1b0adf6e8c968089ae0dc158fc514e6b?pvs=4#1d1adf6e8c96801a9ef2d6f2f0c27f8c
  //
  // As a side effect, `componentDidCatch` is usually *never* executed. If you do see the log below,
  // it means that youre experiencing a scenario not covered by our tests.
  componentDidCatch(error, errorInfo) {
    if (!isSuspense426Error(error)) return;
    const componentStack = errorInfo?.componentStack;
    console.error(
      "Caught an error in SynchronousSuspenseErrorBoundary:\n\n",
      error,
      "\n\nComponent stack:\n",
      componentStack,
      "\n\nThis error indicates a state update wasn\u2019t wrapped with `startTransition`. Some of the UI might flash as a result. " + getPleaseReportMessage(
        "If you are the author of this website, update external components and check recently added custom code or code overrides."
      )
    );
    const stack = error instanceof Error && typeof error.stack === "string" ? error.stack : void 0;
    sendTrackingEvent("published_site_load_recoverable_error", {
      message: String(error),
      stack,
      // only log componentStack if we don't have a stack
      componentStack: stack ? void 0 : componentStack
    });
  }
  render() {
    const error = this.state.error;
    if (error === void 0) return this.props.children;
    if (!isSuspense426Error(error)) throw error;
    shouldSuspenseBoundariesBeActive = true;
    return this.props.children;
  }
};
function isSuspense426Error(error) {
  const unminifiedMessage = "A component suspended while responding to synchronous input.";
  const minifiedMessage = "Minified React error #426";
  return error instanceof Error && (error.message.includes(unminifiedMessage) || error.message.includes(minifiedMessage));
}

// ../../library/src/router/SuspenseThatPreservesDom.tsx
import { Fragment as Fragment8, jsx as jsx50 } from "react/jsx-runtime";
var suspendPromise = /* @__PURE__ */ (() => typeof window !== "undefined" ? new Promise(() => {
}) : null)();
function Suspend() {
  if (typeof window === "undefined" || shouldSuspenseBoundariesBeActive) {
    return /* @__PURE__ */ jsx50(
      "div",
      {
        hidden: true,
        dangerouslySetInnerHTML: { __html: "<!-- SuspenseThatPreservesDOM fallback rendered -->" }
      }
    );
  }
  throw suspendPromise;
}
var suspend = /* @__PURE__ */ jsx50(Suspend, {});
var DisableSuspenseSuspenseThatPreservesDomContext = createContext8(false);
DisableSuspenseSuspenseThatPreservesDomContext.displayName = "DisableSuspenseSuspenseThatPreservesDomContext";
function SuspenseThatPreservesDom({ children }) {
  const isSuspenseBoundaryDisabled = useContext18(DisableSuspenseSuspenseThatPreservesDomContext);
  if (isSuspenseBoundaryDisabled) {
    return /* @__PURE__ */ jsx50(Fragment8, { children });
  }
  return /* @__PURE__ */ jsx50(Suspense, { fallback: suspend, children });
}

// ../../library/src/modules/code-boundary/NullFallback.tsx
import { jsx as jsx51 } from "react/jsx-runtime";
function NullFallback() {
  return /* @__PURE__ */ jsx51(
    "div",
    {
      hidden: true,
      dangerouslySetInnerHTML: { __html: "<!-- Code boundary fallback rendered -->" }
    }
  );
}
var nullFallback = /* @__PURE__ */ jsx51(NullFallback, {});

// ../../library/src/modules/code-boundary/collectErrorToAnalytics.tsx
function collectErrorToAnalytics(error, errorInfo) {
  if (!isWindow) return;
  if (Math.random() > 0.01) return;
  const stack = error instanceof Error && typeof error.stack === "string" ? error.stack : null;
  const componentStack = errorInfo?.componentStack;
  sendTrackingEvent("published_site_load_recoverable_error", {
    message: String(error),
    stack,
    // only log componentStack if we don't have a stack
    componentStack: stack ? void 0 : componentStack
  });
}

// ../../library/src/modules/code-boundary/logger.ts
function logError(...args) {
  if (false) return;
  console.error(...args);
}

// ../../library/src/modules/code-boundary/shouldEnableCodeBoundaries.ts
function shouldEnableCodeBoundaries() {
  return RenderTarget.current() !== RenderTarget.canvas;
}

// ../../library/src/modules/code-boundary/CodeComponentBoundary.tsx
import { jsx as jsx52 } from "react/jsx-runtime";
function CodeComponentBoundary({ getErrorMessage, fallback, children }) {
  if (!shouldEnableCodeBoundaries()) {
    return children;
  }
  return /* @__PURE__ */ jsx52(ServerSideErrorBoundary, { fallback, children: /* @__PURE__ */ jsx52(ClientSideErrorBoundary, { fallback, getErrorMessage, children }) });
}
var ClientSideErrorBoundary = class extends Component12 {
  constructor() {
    super(...arguments);
    __publicField(this, "state", { hasError: false });
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    logError(this.props.getErrorMessage(), errorInfo?.componentStack);
    collectErrorToAnalytics(error, errorInfo);
  }
  render() {
    const { children, fallback = nullFallback } = this.props;
    const { hasError } = this.state;
    return hasError ? fallback : children;
  }
};
function ServerSideErrorBoundary({ children, fallback = nullFallback }) {
  return typeof window === "undefined" ? (
    // On the server, Suspense fallback is activated by errors. So we use the actual Suspense,
    // and render the actual error fallback if Suspense activates.
    /* @__PURE__ */ jsx52(Suspense2, { fallback, children })
  ) : (
    // On the client, Suspense fallback is activated by data fetching. So we use SuspenseThatPreservesDom,
    // because we dont want to render a fallback if the boundary gets inadvertently activated.
    //
    // Why wont you just render plain children without Suspense? Because that would cause a hydration mismatch
    // (the server has Suspense, the client doesnt).
    /* @__PURE__ */ jsx52(SuspenseThatPreservesDom, { children })
  );
}

// ../../library/src/modules/code-boundary/DeprecatedContainerErrorBoundary.tsx
import { Component as Component13 } from "react";
var DeprecatedContainerErrorBoundary = class extends Component13 {
  constructor() {
    super(...arguments);
    __publicField(this, "state", { hasError: false });
  }
  // We use `componentDidCatch` instead of `static getDerivedStateFromError()` because the latter could also catch hydration errors.
  // Hydration errors are recoverable by React, so we don't want to hide the coponent in that case (since the tree will not unmount).
  componentDidCatch(error, errorInfo) {
    const componentStack = errorInfo?.componentStack;
    console.error(
      "Error in component (see previous log). This component has been hidden. Please check any custom code or code overrides to fix.",
      componentStack
    );
    this.setState({ hasError: true });
    collectErrorToAnalytics(error, errorInfo);
  }
  render() {
    const { children } = this.props;
    const { hasError } = this.state;
    return hasError ? null : children;
  }
};

// ../../library/src/modules/code-boundary/ExternalComponentContext.tsx
import React60 from "react";
import { jsx as jsx53 } from "react/jsx-runtime";
var ExternalComponentContext = /* @__PURE__ */ (() => React60.createContext(void 0))();
function useNearestExternalComponent() {
  return React60.useContext(ExternalComponentContext);
}
function useFurthestExternalComponent() {
  const nearestExternalComponent = useNearestExternalComponent();
  const furthestExternalComponent = React60.useMemo(() => {
    if (!nearestExternalComponent) return void 0;
    let item = nearestExternalComponent;
    while (item.parent && item.parent.level > 0) {
      item = item.parent;
    }
    return item;
  }, [nearestExternalComponent]);
  return furthestExternalComponent;
}
function IsExternalComponent({
  children,
  scopeId,
  nodeId
}) {
  const parent = useNearestExternalComponent();
  const newValue = React60.useMemo(
    () => ({ level: (parent?.level ?? 0) + 1, scopeId, nodeId, parent }),
    [scopeId, nodeId, parent]
  );
  return /* @__PURE__ */ jsx53(ExternalComponentContext.Provider, { value: newValue, children });
}

// ../../library/src/modules/code-boundary/errorMessages.ts
var CRASH_ERROR_MESSAGE_PREFIX = "code-crash:";
function formatCodeCrashLocationFromSourceNode(scopeId, nodeId) {
  return `${CRASH_ERROR_MESSAGE_PREFIX}${scopeId}:${nodeId}`;
}
function getErrorMessageForComponent(scopeId, nodeId) {
  return getErrorMessageFor("component", scopeId, nodeId);
}
function getErrorMessageForOverride(scopeId, nodeId) {
  return getErrorMessageFor("override", scopeId, nodeId);
}
function getErrorMessageFor(element, scopeId, nodeId) {
  return `A code ${element} crashed while rendering due to the error above. To find and fix it, open the project in the editor \u2192 open Quick Actions (press Cmd+K or Ctrl+K) \u2192 paste this: ${formatCodeCrashLocationFromSourceNode(scopeId, nodeId)} \u2192 click \u201CShow Layer\u201D.`;
}

// ../../library/src/modules/code-boundary/shouldWrapWithBoundary.ts
function shouldWrapComponentWithBoundary(scopeIdOfThisComponent, scopeIdOfNearestExternalComponent, externalComponentLevel, isAuthoredByUser, isExternalComponent, inComponentSlot) {
  const isLocalComponentInstance = isNodeLocalToProject(
    scopeIdOfThisComponent,
    scopeIdOfNearestExternalComponent,
    externalComponentLevel,
    inComponentSlot
  );
  return (
    // case 1: all (local instances) of (local) (code components)
    isLocalComponentInstance && !isExternalComponent && isAuthoredByUser || // case 2: all (local instances) of (external components)
    isLocalComponentInstance && isExternalComponent
  );
}
function shouldWrapOverrideWithBoundary(scopeIdOfNodeWithOverride, scopeIdOfNearestExternalComponent, externalComponentLevel, inComponentSlot) {
  return isNodeLocalToProject(
    scopeIdOfNodeWithOverride,
    scopeIdOfNearestExternalComponent,
    externalComponentLevel,
    inComponentSlot
  );
}
function isNodeLocalToProject(scopeIdOfThisNode, scopeIdOfNearestExternalComponent, externalComponentLevel, inComponentSlot) {
  if (isUndefined(externalComponentLevel)) return true;
  const nodeIsDefinedInSameScopeAsExternalComponent = scopeIdOfThisNode === scopeIdOfNearestExternalComponent;
  if (
    // We know a component instance is local when its nested inside one external component,
    externalComponentLevel === 1 && // and it lives in a slot,
    inComponentSlot && // and its a slot of *that sole external component* (and not some other local component
    // with slots that lives inside the external component).
    nodeIsDefinedInSameScopeAsExternalComponent
  ) {
    return true;
  }
  return false;
}

// ../../library/src/modules/code-boundary/maybeWrapComponentWithCodeBoundary.tsx
import { jsx as jsx54 } from "react/jsx-runtime";
function useMaybeWrapComponentWithCodeBoundary(children, scopeId, nodeId, isAuthoredByUser, isModuleExternal, inComponentSlot) {
  const nearestExternalComponent = useNearestExternalComponent();
  if (
    // Those props will either be all undefined, which means the Container hasnt yet been
    // re-serialized since we introduced code boundaries, and we should use the old
    // ContainerErrorBoundary  or all defined, which means we have enough information to use
    // the new boundary.
    isUndefined(scopeId) || isUndefined(nodeId)
  ) {
    return /* @__PURE__ */ jsx54(DeprecatedContainerErrorBoundary, { children });
  }
  const shouldWrapWithBoundary = shouldWrapComponentWithBoundary(
    scopeId,
    nearestExternalComponent?.scopeId,
    nearestExternalComponent?.level,
    isAuthoredByUser ?? false,
    isModuleExternal ?? false,
    inComponentSlot ?? false
  );
  if (shouldWrapWithBoundary) {
    children = /* @__PURE__ */ jsx54(
      CodeComponentBoundary,
      {
        getErrorMessage: getErrorMessageForComponent.bind(null, scopeId, nodeId),
        fallback: null,
        children
      }
    );
  }
  if (isModuleExternal) {
    children = /* @__PURE__ */ jsx54(IsExternalComponent, { scopeId, nodeId, children });
  }
  return children;
}

// ../../library/src/modules/Container.tsx
import { jsx as jsx55 } from "react/jsx-runtime";
var ContainerInner = /* @__PURE__ */ React61.forwardRef(
  ({ children, layoutId, as, scopeId, nodeId, isAuthoredByUser, isModuleExternal, inComponentSlot, ...props }, ref) => {
    const outerLayoutId = useConstant(() => layoutId ? `${layoutId}-container` : void 0);
    const MotionComponent = htmlElementAsMotionComponent(as);
    const clonedChildren = React61.Children.map(children, (child) => {
      return React61.isValidElement(child) ? React61.cloneElement(child, { layoutId }) : child;
    });
    const childrenWithCodeBoundary = useMaybeWrapComponentWithCodeBoundary(
      clonedChildren,
      scopeId,
      nodeId,
      isAuthoredByUser,
      isModuleExternal,
      inComponentSlot
    );
    return /* @__PURE__ */ jsx55(MotionComponent, { layoutId: outerLayoutId, ...props, ref, children: /* @__PURE__ */ jsx55(ComponentContainerContext.Provider, { value: true, children: /* @__PURE__ */ jsx55(NodeIdContext.Provider, { value: nodeId ?? null, children: /* @__PURE__ */ jsx55(AutomaticLayoutIds, { enabled: false, children: /* @__PURE__ */ jsx55(LayoutGroup, { id: layoutId ?? "", inherit: "id", children: childrenWithCodeBoundary }) }) }) }) });
  }
);
var Container = /* @__PURE__ */ withGeneratedLayoutId(ContainerInner);
var SmartComponentScopedContainer = /* @__PURE__ */ React61.forwardRef((props, ref) => {
  const {
    as,
    children,
    // Code boundary-specific props
    scopeId,
    nodeId,
    isAuthoredByUser,
    rendersWithMotion,
    isModuleExternal,
    inComponentSlot,
    // Other props, including some possibly used-passed ones
    ...otherProps
  } = props;
  const childrenWithCodeBoundary = useMaybeWrapComponentWithCodeBoundary(
    children,
    scopeId,
    nodeId,
    isAuthoredByUser,
    isModuleExternal,
    inComponentSlot
  );
  const tagName = props.as ?? "div";
  if (props.rendersWithMotion) {
    const Component18 = htmlElementAsMotionComponent(tagName);
    return /* @__PURE__ */ jsx55(NodeIdContext.Provider, { value: nodeId ?? null, children: /* @__PURE__ */ jsx55(
      Component18,
      {
        ...otherProps,
        ref,
        style: props.style,
        children: childrenWithCodeBoundary
      }
    ) });
  } else {
    const Component18 = tagName;
    const { layoutId, layoutDependency, ...plainHTMLRenderableProps } = otherProps;
    return /* @__PURE__ */ jsx55(NodeIdContext.Provider, { value: nodeId ?? null, children: /* @__PURE__ */ jsx55(Component18, { ...plainHTMLRenderableProps, ref, style: props.style, children: childrenWithCodeBoundary }) });
  }
});

// ../../library/src/modules/CustomCursor.tsx
import {
  Suspense as Suspense3,
  createContext as createContext9,
  memo as memo2,
  startTransition as startTransition3,
  useCallback as useCallback12,
  useContext as useContext19,
  useEffect as useEffect17,
  useId,
  useLayoutEffect as useLayoutEffect6,
  useRef as useRef18,
  useState as useState5
} from "react";
import { jsx as jsx56, jsxs as jsxs12 } from "react/jsx-runtime";
var CustomCursorContext = /* @__PURE__ */ createContext9({
  onRegisterCursors: () => () => {
  },
  registerCursors: () => {
  }
});
var replaceCursorClassName = "framer-cursor-none";
var cursorComponentClassName = "framer-pointer-events-none";
function getActiveDefinitions(map2, previousDefinitions, newDefinitions) {
  const allCursors = {};
  for (const [, hashes] of map2) {
    for (const hash2 of hashes) {
      const value = allCursors[hash2] ?? previousDefinitions[hash2] ?? newDefinitions[hash2];
      if (value) allCursors[hash2] = value;
    }
  }
  return allCursors;
}
var CustomCursorContextProvider = /* @__PURE__ */ memo2(function CustomCursorList({ children }) {
  const value = useConstant(() => {
    const events = /* @__PURE__ */ new Set();
    let allCursors = {};
    const byCaller = /* @__PURE__ */ new Map();
    return {
      onRegisterCursors: (callback) => {
        callback(allCursors);
        events.add(callback);
        return () => events.delete(callback);
      },
      registerCursors: (cursors, id) => {
        byCaller.set(id, Object.keys(cursors));
        allCursors = getActiveDefinitions(byCaller, allCursors, cursors);
        for (const callback of events) callback(allCursors);
        return () => {
          byCaller.delete(id);
        };
      }
    };
  });
  const shouldReduceMotion = useReducedMotionConfig();
  return /* @__PURE__ */ jsxs12(CustomCursorContext.Provider, { value, children: [
    children,
    !shouldReduceMotion && /* @__PURE__ */ jsx56(CustomCursorComponent, {})
  ] });
});
var CustomCursorHost = /* @__PURE__ */ (() => withCSS(
  CustomCursorContextProvider,
  [
    `.${replaceCursorClassName}, .${replaceCursorClassName} * { cursor: none !important; }`,
    `.${cursorComponentClassName}, .${cursorComponentClassName} * { pointer-events: none !important; }`
  ],
  "framer-lib-cursors-host"
))();
var staticCursorStyle = /* @__PURE__ */ (() => ({
  position: "fixed",
  top: 0,
  left: 0,
  zIndex: 12 + 1,
  // Max framer z-index + 1
  pointerEvents: "none"
}))();
function customCursorReplacesNativeCursor(cursor) {
  if (!cursor) return false;
  if (cursor.placement || cursor.alignment) return false;
  return true;
}
function valueForCursorAlignment(alignment) {
  switch (alignment) {
    case "start":
      return "0%";
    case "center":
      return "-50%";
    case "end":
      return "-100%";
    default:
      assertNever(alignment);
  }
}
function getCenteringTransform(placement, alignment = "center") {
  switch (placement) {
    case "top":
      return `${valueForCursorAlignment(alignment)}, -100%`;
    case "right":
      return `0%, ${valueForCursorAlignment(alignment)}`;
    case "bottom":
      return `${valueForCursorAlignment(alignment)}, 0%`;
    case "left":
      return `-100%, ${valueForCursorAlignment(alignment)}`;
    default:
      return "-50%, -50%";
  }
}
var portalIdAttribute = "data-framer-portal-id";
function getCursorHash(x, y) {
  let el = document.elementFromPoint(x, y);
  while (el) {
    if (el === document.body) return void 0;
    const value = el.getAttribute("data-framer-cursor");
    if (value) return value;
    if (el.hasAttribute(portalIdAttribute)) {
      const id = el.getAttribute(portalIdAttribute);
      el = el.parentElement;
      if (id) el = document.getElementById(id) ?? el;
    } else {
      el = el.parentElement;
    }
  }
  return void 0;
}
var CustomCursorComponent = /* @__PURE__ */ memo2(function CustomCursorComponent2() {
  const { onRegisterCursors } = useContext19(CustomCursorContext);
  const [hasHoverCapability, setHasHoverCapability] = useState5(false);
  const pointerX = useMotionValue(0);
  const pointerY = useMotionValue(0);
  const opacity = useMotionValue(0);
  const cursorRef = useRef18(null);
  const internalState = useRef18({ cursors: {}, cursorHash: void 0 });
  const forceRender = useForceUpdate2();
  useLayoutEffect6(() => {
    const noHoverMQ = safeWindow.matchMedia("(any-hover: none)");
    function updateRender(e) {
      if (e.matches) {
        startTransition3(() => setHasHoverCapability(false));
      } else {
        setHasHoverCapability(true);
      }
    }
    noHoverMQ.addEventListener("change", updateRender);
    if (!noHoverMQ.matches) {
      setHasHoverCapability(true);
    }
    return () => {
      noHoverMQ.removeEventListener("change", updateRender);
    };
  }, []);
  useEffect17(() => {
    if (!hasHoverCapability) return;
    let x2 = 0;
    let y2 = 0;
    function updateValues() {
      pointerX.set(x2);
      pointerY.set(y2);
      animate(opacity, 1, { type: "tween", duration: 0.2 });
    }
    const updateVariant = () => {
      if (isEmptyObject(internalState.current.cursors)) return;
      const hash2 = getCursorHash(x2, y2);
      if (hash2 !== internalState.current.cursorHash) {
        internalState.current.cursorHash = hash2;
        frame.update(() => forceRender());
      }
    };
    function updateCursor(e) {
      if (e.pointerType === "touch") {
        cancelFrame(updateVariant);
        return;
      }
      frame.read(updateVariant, true);
      x2 = e.clientX;
      y2 = e.clientY;
      frame.update(updateValues);
    }
    function fireEventToTarget(e) {
      if (e.target === cursorRef.current || !cursorRef.current) return;
      const event = new PointerEvent(e.type, {
        bubbles: true,
        cancelable: e.cancelable,
        pointerType: e.pointerType,
        pointerId: e.pointerId,
        composed: e.composed,
        isPrimary: e.isPrimary,
        buttons: e.buttons,
        button: e.button
      });
      frame.update(() => {
        cursorRef.current?.dispatchEvent(event);
      });
    }
    safeWindow.addEventListener("pointermove", updateCursor);
    document.addEventListener("pointerdown", fireEventToTarget);
    document.addEventListener("pointerup", fireEventToTarget);
    frame.read(updateVariant, true);
    return () => {
      safeWindow.removeEventListener("pointermove", updateCursor);
      document.removeEventListener("pointerdown", fireEventToTarget);
      document.removeEventListener("pointerup", fireEventToTarget);
      cancelFrame(updateVariant);
    };
  }, [opacity, pointerX, pointerY, forceRender, hasHoverCapability]);
  useEffect17(() => {
    if (!hasHoverCapability) return;
    function hideCursor() {
      void animate(opacity, 0, { type: "tween", duration: 0.2 });
    }
    document.addEventListener("mouseleave", hideCursor);
    safeWindow.addEventListener("blur", hideCursor);
    return () => {
      document.removeEventListener("mouseleave", hideCursor);
      safeWindow.removeEventListener("blur", hideCursor);
    };
  }, [opacity, hasHoverCapability]);
  useLayoutEffect6(() => {
    function updateCursors(newCursors) {
      internalState.current.cursors = newCursors;
      internalState.current.cursorHash = !isEmptyObject(newCursors) ? getCursorHash(pointerX.get(), pointerY.get()) : null;
      forceRender();
    }
    const unregister = onRegisterCursors(updateCursors);
    return () => {
      unregister();
      document.body.classList.toggle(replaceCursorClassName, false);
    };
  }, [pointerX, pointerY, onRegisterCursors, forceRender]);
  const { cursors, cursorHash } = internalState.current;
  const cursor = cursorHash ? cursors[cursorHash] : null;
  const replaceNativeCursor = customCursorReplacesNativeCursor(cursor);
  useLayoutEffect6(() => {
    if (!hasHoverCapability) return;
    document.body.classList.toggle(replaceCursorClassName, replaceNativeCursor);
  }, [replaceNativeCursor, hasHoverCapability]);
  const Cursor = cursor?.component;
  const spring2 = cursor?.transition ?? { duration: 0 };
  const sprungX = useSpring(pointerX, spring2);
  const sprungY = useSpring(pointerY, spring2);
  const x = useTransform(() => sprungX.get() + (cursor?.offset?.x ?? 0));
  const y = useTransform(() => sprungY.get() + (cursor?.offset?.y ?? 0));
  const alignment = cursor?.alignment;
  const placement = cursor?.placement;
  const transformTemplate2 = useCallback12(
    (_, t) => `translate(${getCenteringTransform(placement, alignment)}) ${t}`,
    [alignment, placement]
  );
  if (!hasHoverCapability || !cursor || !Cursor) return null;
  return /* @__PURE__ */ jsx56(Suspense3, { children: /* @__PURE__ */ jsx56(
    Cursor,
    {
      transformTemplate: transformTemplate2,
      style: {
        ...staticCursorStyle,
        x,
        y,
        opacity
      },
      globalTapTarget: true,
      variant: cursor?.variant,
      ref: cursorRef,
      className: cursorComponentClassName
    }
  ) });
});
function useCustomCursors(webPageCursors) {
  const { registerCursors } = useContext19(CustomCursorContext);
  const cursors = useConstant(() => webPageCursors);
  const id = useId();
  useLayoutEffect6(() => {
    return registerCursors(cursors, id);
  }, [registerCursors, id]);
}

// ../../library/src/modules/Floating.tsx
import React63, { useContext as useContext21 } from "react";
import ReactDOM from "react-dom";

// ../../library/src/modules/Link/useReplaceNestedLinks.tsx
import { Children as Children3, createContext as createContext10, createElement, isValidElement as isValidElement4, useCallback as useCallback13, useContext as useContext20, useMemo as useMemo13 } from "react";

// ../../library/src/modules/LinkToWebPage.ts
var linkKey = "webPageId";
function isLinkToWebPage(link) {
  return Boolean(link && typeof link === "object" && linkKey in link);
}

// ../../library/src/modules/NestedLinksCollector.ts
function linkInfoKey(link) {
  return `${link.scopeId}:${link.nodeId}:${link.furthestExternalComponent?.scopeId}:${link.furthestExternalComponent?.nodeId}`;
}
var NestedLinksCollector = class {
  constructor() {
    __publicField(this, "collectedLinks", /* @__PURE__ */ new Map());
    __publicField(this, "nestingInfo", /* @__PURE__ */ new Map());
  }
  clear() {
    this.collectedLinks.clear();
    this.nestingInfo.clear();
  }
  /**
   * Returns a Map of outer links to their inner links.
   *
   * NOTE: This function is called in the SSG renderer sandbox (<root>/src/ssg/src/ssg-sandbox-renderer/sandbox/worker/renderer.ts)
   */
  getLinks() {
    const result = /* @__PURE__ */ new Map();
    for (const [outerLinkKey, innerLinkKeys] of this.nestingInfo) {
      const outerLinkInfo = this.collectedLinks.get(outerLinkKey);
      assert(outerLinkInfo, `Outer link not found: ${outerLinkKey}`);
      const links = Array.from(innerLinkKeys).map((innerLinkKey) => {
        const innerLinkInfo = this.collectedLinks.get(innerLinkKey);
        assert(innerLinkInfo, `Inner link not found: ${innerLinkKey}`);
        return innerLinkInfo;
      });
      result.set(outerLinkInfo, links);
    }
    return result;
  }
  collectNestedLink(outerLink, innerLink) {
    if (isWindow && !isTest() || !outerLink.nodeId || !innerLink.nodeId) {
      return;
    }
    this.collectedLinks.set(linkInfoKey(outerLink), outerLink);
    this.collectedLinks.set(linkInfoKey(innerLink), innerLink);
    const outerLinkNestingInfo = this.nestingInfo.get(linkInfoKey(outerLink)) ?? /* @__PURE__ */ new Set();
    outerLinkNestingInfo.add(linkInfoKey(innerLink));
    this.nestingInfo.set(linkInfoKey(outerLink), outerLinkNestingInfo);
  }
};
var nestedLinksCollector = /* @__PURE__ */ new NestedLinksCollector();

// ../../library/src/modules/useIsOnFramerCanvas.ts
function useIsOnFramerCanvas() {
  return RenderTarget.current() === RenderTarget.canvas;
}

// ../../library/src/modules/Link/urlChecks.tsx
function isInternalURL(href) {
  if (href === void 0) return false;
  if (href.startsWith("#") || href.startsWith("/") || href.startsWith(".")) return true;
  return false;
}
function isValidURL(href, isInternal) {
  try {
    const url = new URL(href);
    return Boolean(url.protocol);
  } catch {
  }
  return isInternal;
}

// ../../library/src/modules/Link/getRouteFromPageLink.tsx
function getRouteFromPageLink(pageLink, router, currentRoute, locales) {
  if (isString(pageLink)) {
    const isInternal = isInternalURL(pageLink);
    if (!router.routes || !router.getRoute || !currentRoute || !isInternal) {
      return;
    }
    const [pathnameWithQueryParams] = pageLink.split("#", 2);
    if (pathnameWithQueryParams === void 0) return;
    const [pathname] = pathnameWithQueryParams.split("?", 2);
    if (pathname === void 0) return;
    const { routeId } = inferInitialRouteFromPath(router.routes, pathname, void 0, locales);
    return router.getRoute(routeId);
  }
  const { webPageId } = pageLink;
  return router.getRoute?.(webPageId);
}

// ../../library/src/modules/framerPageLink.ts
var elementKey = "element";
var collectionKey = "collection";
var collectionItemIdKey = "collectionItemId";
var pathVariablesKey = "pathVariables";
var mediaType = "framer/page-link,";
function isFramerPageLink(value) {
  return isString(value) && value.startsWith(`data:${mediaType}`);
}
function createFramerPageLink(targetId = null, options = {}) {
  const target = targetId ? targetId : "none";
  const link = new URL(`data:${mediaType}${target}`);
  if (options.element) {
    link.searchParams.append(elementKey, options.element);
  }
  if (options.collectionItem) {
    link.searchParams.append(collectionKey, options.collectionItem.collection);
    link.searchParams.append(collectionItemIdKey, options.collectionItem.collectionItemId);
    link.searchParams.append(pathVariablesKey, new URLSearchParams(options.collectionItem.pathVariables).toString());
  }
  return link.href;
}
function parseFramerPageLink(link) {
  if (!isFramerPageLink(link)) return;
  try {
    const url = new URL(link);
    const target = url.pathname.substring(mediaType.length);
    const searchParams = url.searchParams;
    const element = searchParams.has(elementKey) ? searchParams.get(elementKey) : void 0;
    let collectionItem;
    const collection = searchParams.get(collectionKey);
    const collectionItemId = searchParams.get(collectionItemIdKey);
    const pathVariablesValue = searchParams.get(pathVariablesKey);
    if (collection && collectionItemId && pathVariablesValue) {
      const pathVariables = Object.fromEntries(new URLSearchParams(pathVariablesValue).entries());
      collectionItem = {
        collection,
        collectionItemId,
        pathVariables
      };
    }
    return {
      target: target === "none" ? null : target,
      /**
       * For historical reason we used to set "element=none" into the
       * datalink, we no longer do that today, but we still keep this code
       * so we could parse legacy links correctly.
       */
      element: element === "none" ? void 0 : element,
      collectionItem
    };
  } catch {
    return;
  }
}
function shouldOpenLinkInNewTab(link) {
  return !isFramerPageLink(link);
}
function navigateFromAttributes(navigate, element, implicitPathVariables) {
  let routeId = element.getAttribute("data-framer-page-link-target" /* Page */);
  let elementId;
  let pathVariables;
  if (routeId) {
    elementId = element.getAttribute("data-framer-page-link-element" /* Element */) ?? void 0;
    const pathVariablesRaw = element.getAttribute("data-framer-page-link-path-variables" /* PathVariables */);
    if (pathVariablesRaw) {
      pathVariables = Object.fromEntries(new URLSearchParams(pathVariablesRaw).entries());
    }
  } else {
    const href = element.getAttribute("href");
    if (!href) return false;
    const link = parseFramerPageLink(href);
    if (!link || !link.target) return false;
    routeId = link.target;
    elementId = link.element ?? void 0;
    pathVariables = link.collectionItem?.pathVariables;
  }
  const smoothScroll = elementId ? element.dataset.framerSmoothScroll !== void 0 : void 0;
  navigate(routeId, elementId, Object.assign({}, implicitPathVariables, pathVariables), smoothScroll);
  return true;
}

// ../../library/src/modules/Link/linkFromFramerPageLink.tsx
function linkFromFramerPageLink(link) {
  if (!isFramerPageLink(link)) return link;
  const parsed = parseFramerPageLink(link);
  if (!parsed) return void 0;
  const { target, element, collectionItem } = parsed;
  if (!target) return void 0;
  return {
    webPageId: target,
    hash: element ?? void 0,
    pathVariables: createVariablesFromPageLinkCollectionItem(collectionItem)
  };
}
function createVariablesFromPageLinkCollectionItem(collectionItem) {
  if (!collectionItem) return void 0;
  const variables = {};
  for (const pathVariablesKey2 in collectionItem.pathVariables) {
    const value = collectionItem.pathVariables[pathVariablesKey2];
    if (value) variables[pathVariablesKey2] = value;
  }
  return variables;
}

// ../../library/src/modules/Link/useReplaceNestedLinks.tsx
import { jsx as jsx57 } from "react/jsx-runtime";
var OuterLinkContext = /* @__PURE__ */ createContext10(void 0);
function ResetOuterLinkContext({ children }) {
  return /* @__PURE__ */ jsx57(OuterLinkContext.Provider, { value: void 0, children });
}
function useReplaceNestedLinks(children, scopeId, nodeId, href, propsAddedByLink, observerRef) {
  const outerLink = useContext20(OuterLinkContext);
  const furthestExternalComponent = useFurthestExternalComponent();
  const innerLink = useMemo13(
    () => ({ scopeId, nodeId, furthestExternalComponent }),
    [scopeId, nodeId, furthestExternalComponent]
  );
  const router = useRouter();
  const currentRoute = useCurrentRoute();
  const { locales } = useLocaleInfo();
  const route = useMemo13(() => {
    const pageLink = isLinkToWebPage(href) ? href : linkFromFramerPageLink(href);
    if (!pageLink) return;
    return getRouteFromPageLink(pageLink, router, currentRoute, locales);
  }, [currentRoute, href, router, locales]);
  const isOnFramerCanvas = useIsOnFramerCanvas();
  const shouldReplaceLink = Boolean(!isOnFramerCanvas && outerLink?.nodeId && innerLink.nodeId);
  const onClick = useCallback13(
    (event) => {
      if (!propsAddedByLink.href) return;
      event.preventDefault();
      event.stopPropagation();
      const isAppleDevice = /Mac|iPod|iPhone|iPad/u.test(navigator.userAgent);
      if (isAppleDevice ? event.metaKey : event.ctrlKey) {
        openExternalLink(propsAddedByLink.href, "", "_blank");
        return;
      }
      if (route) {
        propsAddedByLink.navigate?.();
      } else {
        openExternalLink(propsAddedByLink.href, propsAddedByLink.rel, propsAddedByLink.target);
      }
    },
    [propsAddedByLink, route]
  );
  const onAuxClick = useCallback13(
    (event) => {
      if (!propsAddedByLink.href) return;
      event.preventDefault();
      event.stopPropagation();
      openExternalLink(propsAddedByLink.href, "", "_blank");
    },
    [propsAddedByLink]
  );
  const onKeyDown = useCallback13(
    (event) => {
      if (!propsAddedByLink.href) return;
      if (event.key !== "Enter") return;
      event.preventDefault();
      event.stopPropagation();
      if (route) {
        propsAddedByLink.navigate?.();
      } else {
        openExternalLink(propsAddedByLink.href, propsAddedByLink.rel, propsAddedByLink.target);
      }
    },
    [propsAddedByLink, route]
  );
  useRefEffect(
    observerRef,
    (node) => {
      if (node === null) return;
      if (!shouldReplaceLink) return;
      node.dataset.hydrated = "true";
    },
    [shouldReplaceLink]
  );
  let replacedChildren = children;
  if (shouldReplaceLink) {
    Children3.forEach(children, (child) => {
      if (!isChildReplaceable(child)) return;
      assert(
        linkInfoIsCollectable(outerLink),
        "outerLink must have nodeId defined at this point; this was verified with `shouldReplaceLink` above"
      );
      assert(
        linkInfoIsCollectable(innerLink),
        "innerLink must have nodeId defined at this point; this was verified with `shouldReplaceLink` above"
      );
      nestedLinksCollector.collectNestedLink(outerLink, innerLink);
    });
    replacedChildren = Children3.map(children, (child) => {
      if (!isChildReplaceable(child)) return child;
      const tag = maybeReplaceAnchorWithSpan(child.type);
      const { children: childChildren, ...childProps } = child.props;
      const props = {
        ...childProps,
        // This attribute is used in `ssg/src/ssg-sandbox-renderer/worker/nestedLinks.ts` to handle the nested links clicks
        "data-nested-link": true,
        role: "link",
        tabIndex: 0,
        onClick,
        onAuxClick,
        onKeyDown,
        as: childProps.as && maybeReplaceAnchorWithSpan(childProps.as)
      };
      const ref = "ref" in child ? child.ref : void 0;
      return createElement(
        tag,
        // We need to pass the ref here again, otherwise it will be lost
        { ...props, ref },
        childChildren
      );
    });
  }
  return /* @__PURE__ */ jsx57(OuterLinkContext.Provider, { value: innerLink, children: replacedChildren });
}
function linkInfoIsCollectable(linkInfo) {
  return !isUndefined(linkInfo?.nodeId);
}
function isChildReplaceable(child) {
  return isValidElement4(child) && (maybeReplaceAnchorWithSpan(child.type) !== child.type || maybeReplaceAnchorWithSpan(child.props.as) !== child.props.as);
}
function openExternalLink(href, rel, target) {
  const link = document.createElement("a");
  link.href = href;
  if (rel) {
    link.rel = rel;
  }
  if (target) {
    link.target = target;
  }
  document.body.appendChild(link);
  link.click();
  link.remove();
}
function maybeReplaceAnchorWithSpan(component) {
  if (component === "a") return "span";
  if (isMotionComponent(component) && unwrapMotionComponent(component) === "a") return motion.span;
  return component;
}

// ../../library/src/modules/InjectSelectionStyle.tsx
import React62 from "react";
var textSelectionColorVariable = "--text-selection-color";
var textSelectionBackgroundColorVariable = "--text-selection-background-color";
function updateTextSelectionStyles(triggerId) {
  if (!triggerId) return;
  frame.read(() => {
    const el = document.getElementById(triggerId);
    if (!el) return;
    const styles4 = getComputedStyle(el);
    const textSelectionColor = styles4.getPropertyValue("--selection-color").trim();
    const textSelectionBackgroundColor = styles4.getPropertyValue("--selection-background-color").trim();
    frame.render(() => {
      const overlayPortal = document.querySelectorAll(`[data-framer-portal-id="${triggerId}"]`);
      if (overlayPortal.length === 0) return;
      if (textSelectionColor) {
        overlayPortal.forEach((el2) => el2.style.setProperty(textSelectionColorVariable, textSelectionColor));
      }
      if (textSelectionBackgroundColor) {
        overlayPortal.forEach(
          (el2) => el2.style.setProperty(textSelectionBackgroundColorVariable, textSelectionBackgroundColor)
        );
      }
    });
  });
}
function getTextSelectionStylesFromTrigger(triggerId) {
  return [
    `[data-framer-portal-id="${triggerId}"] * ::selection {
    color: var(${textSelectionColorVariable});
    background-color: var(${textSelectionBackgroundColorVariable});
}`
  ];
}
function InjectSelectionStyleWithoutCSS({ triggerId, children }) {
  React62.useLayoutEffect(() => {
    if (triggerId) updateTextSelectionStyles(triggerId);
  }, [triggerId]);
  return children;
}
var InjectSelectionStyle = /* @__PURE__ */ (() => withCSS(
  InjectSelectionStyleWithoutCSS,
  (_target, props) => getTextSelectionStylesFromTrigger(props?.triggerId),
  "InjectSelectionStyle"
))();

// ../../library/src/render/types/Polygon.ts
var Polygon = {
  /**
   * Determine if the vertices are ordered clockwise or counter-clockwise. This works for simple
   * (non-self-intersecting) convex polygons. If the polygon is collapsed into a line (signedArea = 0), we consider it
   * clockwise for it works with how Framer draws the polygons.
   * See: https://paulbourke.net/geometry/polygonmesh/
   * @internal */
  isClockwise: (points) => {
    return Polygon.signedArea(points) <= 0;
  },
  /**
   * Calculate the signed area to determine if the vertices go clockwise or counter clockwise. We flip all the y
   * values because the y axis in our canvas coordinate is fipped.
   * See: https://mathworld.wolfram.com/PolygonArea.html
   * @internal */
  signedArea: (points) => {
    let sum = 0;
    const len = points.length;
    for (let i = 0; i < len; i++) {
      const pointA = points[i];
      const pointB = points[(i + 1) % len];
      if (!pointA || !pointB) continue;
      sum += pointA.x * -pointB.y - pointB.x * -pointA.y;
    }
    return 1 / 2 * sum;
  },
  /**
   * Determine if some Point lies inside (or on) the polygon formed by other
   * Points. The other points must be provided in a clockwise/counter
   * clockwise order otherwise the line segments we create to test the polygon
   * will not be representative.
   *
   * Solution for convex polygons based on:
   * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html
   *
   * We create a line segment for each side of the polygon. The point we are
   * testing must be on or on the same side of each line segment.
   *
   * @internal
   */
  containsPoint: (polygonPoints2, point) => {
    let sign = void 0;
    for (let i = 0; i < polygonPoints2.length; i++) {
      if (Point.isEqual(polygonPoints2[i], point)) return true;
      const x1 = polygonPoints2[i]?.x ?? 0;
      const y1 = polygonPoints2[i]?.y ?? 0;
      const i2 = (i + 1) % polygonPoints2.length;
      if (Point.isEqual(polygonPoints2[i2], point)) return true;
      const x2 = polygonPoints2[i2]?.x ?? 0;
      const y2 = polygonPoints2[i2]?.y ?? 0;
      const d = (point.x - x1) * (y2 - y1) - (point.y - y1) * (x2 - x1);
      if (d === 0) continue;
      const localSign = d > 0;
      sign ??= localSign;
      if (sign !== localSign) return false;
    }
    return true;
  },
  /** @internal */
  intersects: (pointsA, pointsB) => {
    if (pointsA.length < 1 || pointsB.length < 1) return false;
    const boundingRectA = Rect.boundingRectFromPoints(pointsA);
    const boundingRectB = Rect.boundingRectFromPoints(pointsB);
    if (!Rect.intersects(boundingRectA, boundingRectB)) return false;
    const edgesA = [];
    const pointsALength = pointsA.length;
    pointsA.forEach((point, index) => {
      const nextPoint = pointsA[(index + 1) % pointsALength];
      if (!nextPoint) return;
      edgesA.push(Line(point, nextPoint));
    });
    const edgesB = [];
    const pointsBLength = pointsB.length;
    pointsB.forEach((point, index) => {
      const nextPoint = pointsB[(index + 1) % pointsBLength];
      if (!nextPoint) return;
      edgesB.push(Line(point, nextPoint));
    });
    for (const edgeA of edgesA) {
      for (const edgeB of edgesB) {
        const intersection2 = Line.intersection(edgeA, edgeB, true);
        if (intersection2) return true;
      }
    }
    if (Polygon.containsPoint(pointsB, pointsA[0])) return true;
    if (Polygon.containsPoint(pointsA, pointsB[0])) return true;
    return false;
  },
  /** @internal */
  contains: (pointsA, pointsB) => {
    for (let i = 0; i < pointsB.length; i++) {
      if (!Polygon.containsPoint(pointsA, pointsB[i])) return false;
    }
    return true;
  },
  /** @internal */
  clipToRect: (points, rect) => {
    const edges = Rect.edges(rect);
    const seen = /* @__PURE__ */ new Set();
    const count = points.length;
    const clippedPoints = [];
    const originalPoints = [];
    for (let i = 0; i < count; i++) {
      const point = points[i];
      const nextPoint = points[(i + 1) % count];
      if (Rect.containsPoint(rect, point)) {
        const intersectionKey = keyForPoint(point);
        seen.add(intersectionKey);
        originalPoints.push(point);
        if (Rect.containsPoint(rect, nextPoint)) continue;
      }
      const line = Line(point, nextPoint);
      edges.forEach((edge) => {
        const intersection2 = Line.intersection(line, edge, true);
        if (!intersection2) return;
        const intersectionKey = keyForPoint(intersection2);
        if (seen.has(intersectionKey)) return;
        seen.add(intersectionKey);
        clippedPoints.push(intersection2);
      });
    }
    if (clippedPoints.length === 0) return originalPoints;
    Rect.points(rect).forEach((point) => {
      if (!Polygon.containsPoint(points, point)) return;
      seen.add(keyForPoint(point));
      clippedPoints.push(point);
    });
    return Point.sortClockwise([...originalPoints, ...clippedPoints]);
  }
};
function keyForPoint(point) {
  return `${point?.x}-${point?.y}`;
}

// ../../library/src/modules/floatingPositionSafeAreaStyle.ts
function invertPlacement(placement) {
  switch (placement) {
    case "top":
      return "bottom";
    case "right":
      return "left";
    case "bottom":
      return "top";
    case "left":
      return "right";
    default:
      assertNever(placement);
  }
}
function preferredOffset(point, length, max, collisionDetectionPadding = 0) {
  const min = Math.max(point, collisionDetectionPadding);
  if (point < min) return min;
  const size = length + collisionDetectionPadding;
  if (min + size > max) return max - size;
  return min;
}
function collisionAxis(placement, rect, windowSize) {
  switch (placement) {
    case "top":
    case "bottom":
      if (rect.y < 0 || rect.y + rect.height > windowSize.height) return "y";
      return void 0;
    case "left":
    case "right":
      if (rect.x < 0 || rect.x + rect.width > windowSize.width) return "x";
      return void 0;
    default:
      assertNever(placement);
  }
}
function getPlacementAndOffsetAvoidingScreenCollision(rect, placement, offset, windowSize) {
  switch (collisionAxis(placement, rect, windowSize)) {
    case "x":
      return {
        placement: invertPlacement(placement),
        x: offset.x * -1,
        y: offset.y
      };
    case "y":
      return {
        placement: invertPlacement(placement),
        x: offset.x,
        y: offset.y * -1
      };
    default:
      return {
        placement,
        x: offset.x,
        y: offset.y
      };
  }
}
function getSafePlacementFloatingPositionRect(anchor, element, placement, alignment, offset, collisionDetectionSize, collisionDetectionPadding) {
  const rebasedRect = Rect.rebaseRectOnto(element, anchor, placement, alignment);
  const preferredRect = {
    x: rebasedRect.x + offset.x,
    y: rebasedRect.y + offset.y,
    width: element.width,
    height: element.height
  };
  if (!collisionDetectionSize) return [placement, preferredRect];
  const {
    x,
    y,
    placement: safePlacement
  } = getPlacementAndOffsetAvoidingScreenCollision(preferredRect, placement, offset, collisionDetectionSize);
  const rebasedCollisionRect = Rect.rebaseRectOnto(element, anchor, safePlacement, alignment);
  return [
    safePlacement,
    {
      x: preferredOffset(
        rebasedCollisionRect.x + x,
        element.width,
        collisionDetectionSize.width,
        collisionDetectionPadding
      ),
      y: preferredOffset(
        rebasedCollisionRect.y + y,
        element.height,
        collisionDetectionSize.height,
        collisionDetectionPadding
      ),
      width: element.width,
      height: element.height
    }
  ];
}
function preferredPoint(a, b, points) {
  if (Polygon.containsPoint([b, ...points], a)) return b;
  return a;
}
var minInset = 5;
function safeAreaPolygonConstraints(rect) {
  return {
    constrainX: (value) => Math.min(Math.max(value, rect.x + minInset), rect.x + rect.width - minInset),
    constrainY: (value) => Math.min(Math.max(value, rect.y + minInset), rect.y + rect.height - minInset)
  };
}
var mouseOffset = 4;
function polygonPoints({ x, y }, placement, rect, { constrainX, constrainY }) {
  const [tl, bl, tr, br] = Rect.points(rect);
  switch (placement) {
    case "left": {
      const mousePoint = { x: constrainX(x - mouseOffset), y };
      return [mousePoint, preferredPoint(br, bl, [mousePoint, tr]), preferredPoint(tr, tl, [mousePoint, br])];
    }
    case "right": {
      const mousePoint = { x: constrainX(x + mouseOffset), y };
      return [mousePoint, preferredPoint(bl, br, [mousePoint, tl]), preferredPoint(tl, tr, [mousePoint, bl])];
    }
    case "top": {
      const mousePoint = { x, y: constrainY(y - mouseOffset) };
      return [mousePoint, preferredPoint(bl, tl, [mousePoint, br]), preferredPoint(br, tr, [mousePoint, bl])];
    }
    case "bottom": {
      const mousePoint = { x, y: constrainY(y + mouseOffset) };
      return [mousePoint, preferredPoint(tl, bl, [mousePoint, tr]), preferredPoint(tr, br, [mousePoint, tl])];
    }
    default:
      assertNever(placement);
  }
}
function safeAreaInset(placement, delta) {
  switch (placement) {
    case "left":
      return `${Math.min(delta.y, 0)}px auto auto 0px`;
    case "right":
      return `${Math.min(delta.y, 0)}px 0px auto auto`;
    case "top":
      return `0px auto auto ${Math.min(delta.x, 0)}px`;
    case "bottom":
      return `auto auto 0px ${Math.min(delta.x, 0)}px`;
    default:
      assertNever(placement);
  }
}
function floatingPositionSafeAreaStyle(x, y, placement, anchorRect, floatingRect) {
  const minX = Math.min(floatingRect.x, anchorRect.x);
  const minY = Math.min(floatingRect.y, anchorRect.y);
  const rect = Rect.merge(anchorRect, floatingRect);
  const points = polygonPoints({ x, y }, placement, floatingRect, safeAreaPolygonConstraints(anchorRect)).map((point) => `${point.x - minX}px ${point.y - minY}px`).join(", ");
  return {
    height: `${rect.height}px`,
    width: `${rect.width}px`,
    clipPath: `polygon(${points})`,
    inset: safeAreaInset(placement, Rect.delta(anchorRect, floatingRect))
  };
}
function valueForFloatingAlignment(alignment) {
  switch (alignment) {
    case "start":
      return 0;
    case "center":
      return 0.5;
    case "end":
      return 1;
    default:
      assertNever(alignment);
  }
}
function motionOriginFromFloatingPosition(placement = "bottom", alignment = "center") {
  switch (placement) {
    case "top":
      return { originX: valueForFloatingAlignment(alignment), originY: 1 };
    case "right":
      return { originX: 0, originY: valueForFloatingAlignment(alignment) };
    case "bottom":
      return { originX: valueForFloatingAlignment(alignment), originY: 0 };
    case "left":
      return { originX: 1, originY: valueForFloatingAlignment(alignment) };
    default:
      assertNever(placement);
  }
}

// ../../library/src/modules/Floating.tsx
import { jsx as jsx58, jsxs as jsxs13 } from "react/jsx-runtime";
function domReadGetAncestorInfo(anchorRef) {
  let el = anchorRef.current;
  const info = {
    position: "absolute",
    scrolls: false
  };
  while (el) {
    if (el?.tagName === "BODY") return info;
    if (getComputedStyle(el)?.position === "fixed") info.position = "fixed";
    if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) info.scrolls = true;
    if (info.scrolls && info.position === "fixed") return info;
    el = el.parentElement;
  }
  return info;
}
function domReadStartAnimationFrameLoop(onRead) {
  frame.read(onRead, true);
  return () => cancelFrame(onRead);
}
function domWriteCreateUpdateSafeArea(safeAreaRef) {
  let x = 0;
  let y = 0;
  return (anchorRect, calculatedRect, placement, event) => {
    if (!safeAreaRef.current?.style) return;
    x = event?.clientX ?? x;
    y = event?.clientY ?? y;
    Object.assign(
      safeAreaRef.current.style,
      floatingPositionSafeAreaStyle(x, y, placement, anchorRect, calculatedRect)
    );
  };
}
function domWriteUpdatePosition(floatingPositionRef, position, rect, scrollX, scrollY) {
  if (!floatingPositionRef.current) return;
  Object.assign(floatingPositionRef.current.style, {
    position,
    visibility: "visible",
    // Append "px" because we are assigning this object straight to style.
    left: (rect?.x ?? 0) + scrollX + "px",
    top: (rect?.y ?? 0) + scrollY + "px"
  });
}
var FloatingStackingContext = /* @__PURE__ */ (() => {
  const Context2 = React63.createContext(/* @__PURE__ */ new Set());
  Context2.displayName = "FloatingStackingContext";
  return Context2;
})();
function useDismissFloatingLayer(anchorRef, floatingPositionRef, safeAreaRef, { safeArea, onDismiss }) {
  const descendantStackingContext = useConstant(() => /* @__PURE__ */ new Set());
  const ancestorStackingContext = React63.useContext(FloatingStackingContext);
  const [isPresent, safeToRemove] = usePresence();
  React63.useEffect(() => {
    if (isPresent) {
      if (!floatingPositionRef.current) return;
      floatingPositionRef.current.style.pointerEvents = "";
      ancestorStackingContext.add(floatingPositionRef.current);
    } else {
      if (!floatingPositionRef.current) return;
      floatingPositionRef.current.style.pointerEvents = "none";
      ancestorStackingContext.delete(floatingPositionRef.current);
      safeToRemove();
    }
  }, [isPresent, safeToRemove, floatingPositionRef, ancestorStackingContext]);
  React63.useEffect(() => {
    if (!safeArea) {
      const handleEscape = (e) => {
        if (e.key !== "Escape") return;
        onDismiss();
      };
      safeWindow.addEventListener("keyup", handleEscape);
      return () => safeWindow.removeEventListener("keyup", handleEscape);
    }
    let latestEvent;
    function maybeDismiss() {
      if (!latestEvent || descendantStackingContext.size !== 0) return;
      for (const element of document.elementsFromPoint(latestEvent.x, latestEvent.y)) {
        if (element === anchorRef.current) return;
        if (element === floatingPositionRef.current) return;
        if (element === safeAreaRef.current) return;
      }
      onDismiss();
    }
    function scheduleMaybeDismiss(event) {
      latestEvent = event;
      frame.read(maybeDismiss);
    }
    safeWindow.addEventListener("mousemove", scheduleMaybeDismiss);
    return () => {
      safeWindow.removeEventListener("mousemove", scheduleMaybeDismiss);
    };
  }, [onDismiss, safeArea, anchorRef, safeAreaRef, floatingPositionRef]);
  return descendantStackingContext;
}
function makeGetSafePlacementFloatingPositionRect({
  placement,
  alignment,
  offset,
  collisionDetectionSize,
  collisionDetectionPadding
}) {
  return (anchor, element) => getSafePlacementFloatingPositionRect(
    anchor,
    element,
    placement,
    alignment,
    offset,
    collisionDetectionSize,
    collisionDetectionPadding
  );
}
function useDynamicMotionOrigin(initialPlacement, alignment) {
  return useConstant(() => {
    const { originX, originY } = motionOriginFromFloatingPosition(initialPlacement, alignment);
    const origin = { x: motionValue(originX), y: motionValue(originY) };
    return [
      origin,
      (placement) => {
        const values = motionOriginFromFloatingPosition(placement, alignment);
        origin.x.set(values.originX);
        origin.y.set(values.originY);
      }
    ];
  });
}
function childrenWithOrigin(child, { x, y }) {
  if (!child || !isReactChild(child) || !isReactElement(child)) return null;
  if (!isObject2(child.props.style) && !isUndefined(child.props.style)) return null;
  const style = {
    ...child.props.style,
    originX: x,
    originY: y
  };
  return React63.cloneElement(child, { style });
}
var overlayContainerId = "overlay";
var templateOverlayContainerId = "template-overlay";
function getPortalContainer(deprecatedSelector, inComponent) {
  if (inComponent || isUndefined(deprecatedSelector)) {
    const container2 = document.querySelector(`#${templateOverlayContainerId}`) ?? document.querySelector(`#${overlayContainerId}`);
    if (container2) return container2;
  }
  const container = isString(deprecatedSelector) ? document.querySelector(deprecatedSelector) : void 0;
  if (container) return container;
  return document.body;
}
function Floating({
  alignment,
  placement,
  safeArea,
  offsetX,
  offsetY,
  anchorRef,
  className: className2,
  children,
  portalSelector,
  zIndex,
  collisionDetection = false,
  collisionDetectionPadding,
  onDismiss,
  ...rest
}) {
  const floatingPositionRef = React63.useRef(null);
  const safeAreaRef = React63.useRef(null);
  const contentRef = React63.useRef(null);
  const [origin, updateOrigin] = useDynamicMotionOrigin(placement, alignment);
  React63.useLayoutEffect(() => {
    if (!refHasValue(anchorRef) || !contentRef.current || !placement || !alignment) return;
    const offset = {
      x: offsetX ?? 0,
      y: offsetY ?? 0
    };
    let cleanup;
    let cleanupHasRun = false;
    let initialUpdateHasRun = false;
    let anchorRect;
    let safePlacement;
    let calculatedRect;
    let latestEvent;
    let updateSafeArea;
    let scrollX = 0;
    let scrollY = 0;
    const ancestorInfo = domReadGetAncestorInfo(anchorRef);
    const position = ancestorInfo.position;
    const elementRect = contentRef.current.getBoundingClientRect();
    const getSafePlacementRect = makeGetSafePlacementFloatingPositionRect({
      placement,
      alignment,
      offset,
      collisionDetectionSize: collisionDetection ? { width: safeWindow.innerWidth, height: safeWindow.innerHeight } : void 0,
      collisionDetectionPadding
    });
    const onRender = () => {
      if (cleanupHasRun) return;
      domWriteUpdatePosition(floatingPositionRef, position, calculatedRect, scrollX, scrollY);
      if (safeArea) updateSafeArea(anchorRect, calculatedRect, safePlacement, latestEvent);
      latestEvent = void 0;
    };
    const initialRender = () => {
      updateSafeArea = domWriteCreateUpdateSafeArea(safeAreaRef);
      if (latestEvent) {
        onRender();
      } else {
        domWriteUpdatePosition(floatingPositionRef, position, calculatedRect, scrollX, scrollY);
      }
      initialUpdateHasRun = true;
    };
    const onUpdate = () => {
      if (cleanupHasRun) return;
      updateOrigin(safePlacement);
    };
    const domReadUpdateSafePlacementAndRect = () => {
      if (!getSafePlacementRect || cleanupHasRun) return;
      if (position === "fixed") {
        scrollX = 0;
        scrollY = 0;
      } else {
        scrollX = safeWindow.scrollX;
        scrollY = safeWindow.scrollY;
      }
      anchorRect = anchorRef.current.getBoundingClientRect();
      const safePlacementAndRect = getSafePlacementRect(anchorRect, elementRect);
      safePlacement = safePlacementAndRect[0];
      calculatedRect = safePlacementAndRect[1];
    };
    domReadUpdateSafePlacementAndRect();
    onUpdate();
    initialRender();
    if (ancestorInfo.scrolls) {
      cleanup = domReadStartAnimationFrameLoop(domReadUpdateSafePlacementAndRect);
    }
    if (!safeArea) {
      return () => {
        cleanup?.();
        cleanupHasRun = true;
      };
    }
    const handleMouseMove = (event) => {
      latestEvent = event;
      if (!initialUpdateHasRun) return;
      frame.read(domReadUpdateSafePlacementAndRect, false, true);
      frame.update(onUpdate, false, true);
      frame.render(onRender, false, true);
    };
    const anchor = anchorRef.current;
    anchor.addEventListener("mousemove", handleMouseMove);
    return () => {
      anchor.removeEventListener("mousemove", handleMouseMove);
      cleanup?.();
      cleanupHasRun = true;
    };
  }, [
    safeArea,
    placement,
    alignment,
    offsetX,
    offsetY,
    anchorRef,
    collisionDetection,
    collisionDetectionPadding,
    updateOrigin
  ]);
  const descendantContext = useDismissFloatingLayer(anchorRef, floatingPositionRef, safeAreaRef, {
    safeArea,
    onDismiss
  });
  const inComponent = useContext21(ComponentContainerContext);
  return ReactDOM.createPortal(
    /* @__PURE__ */ jsxs13(
      motion.div,
      {
        ref: floatingPositionRef,
        className: className2,
        style: {
          // Start from the top left of the screen to prevent jumps.
          top: 0,
          left: 0,
          // Initially rendered as hidden, but the layout effect will set
          // to visible when the position is calculated.
          visibility: "hidden",
          width: "auto",
          height: "auto",
          position: "absolute",
          zIndex
        },
        ...rest,
        children: [
          safeArea ? /* @__PURE__ */ jsx58("div", { ref: safeAreaRef, style: { position: "absolute" }, "data-safearea": true }) : (
            // biome-ignore lint/a11y/useKeyWithClickEvents: overlays don't support key events yet.
            /* @__PURE__ */ jsx58("div", { style: { position: "fixed", inset: 0 }, "aria-hidden": true, onClick: onDismiss })
          ),
          /* @__PURE__ */ jsx58(FloatingStackingContext.Provider, { value: descendantContext, children: /* @__PURE__ */ jsx58(ResetOuterLinkContext, { children: /* @__PURE__ */ jsx58(InjectSelectionStyle, { triggerId: anchorRef.current?.id ?? void 0, children: /* @__PURE__ */ jsx58("div", { ref: contentRef, children: childrenWithOrigin(children, origin) }) }) }) })
        ]
      }
    ),
    getPortalContainer(portalSelector, inComponent)
  );
}

// ../../library/src/modules/Instance.tsx
import React64 from "react";
import { jsx as jsx59 } from "react/jsx-runtime";
var Instance = /* @__PURE__ */ React64.forwardRef(function Instance2({ Component: Component18, ...props }, ref) {
  return Component18 ? /* @__PURE__ */ jsx59(Component18, { ...props, ref }) : null;
});

// ../../library/src/modules/GracefullyDegradingErrorBoundary.tsx
import { Component as Component14 } from "react";
import { jsx as jsx60 } from "react/jsx-runtime";
var GracefullyDegradingErrorBoundary = class extends Component14 {
  constructor() {
    super(...arguments);
    __publicField(this, "state", { error: void 0 });
    __publicField(this, "message", "Made UI non-interactive due to an error.");
    __publicField(this, "messageFatal", "Fatal error.");
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error) {
    window.__framer_hadFatalError = true;
    if ("cause" in error) {
      error = error.cause;
    }
    console.error(getPleaseReportMessage(isBot ? this.message : this.messageFatal, error));
    const sampleRate = Math.random();
    if (sampleRate > 0.5) return;
    const stack = error instanceof Error && typeof error.stack === "string" ? error.stack : null;
    sendTrackingEvent("published_site_load_error", {
      message: String(error),
      stack
    });
  }
  render() {
    const error = this.state.error;
    if (!error) return this.props.children;
    const unwrappedError = "cause" in error ? error.cause : error;
    const closingHTMLComment = /-->/gu;
    const closingHTMLCommentReplacement = "--!>";
    const dom = isBot ? document.getElementById("main")?.innerHTML || "" : (
      // @FIXME: We should have a UI for fatal error recovery.
      // We don't have a UI for fatal error recovery currently, so we just render nothing for regular users. If we were to throw, React would unmount too.
      // We do render instead of throwing, so that:
      // - `componentDidCatch` runs (if we throw here, it does not)
      // - we can skip logging `Recoverable error during hydration`, because we know it was fatal.
      ""
    );
    return (
      // This has the caveat that we will slightly modify the DOM, but it appears to be fine in this case.
      // The alternative would be to queue a new task that runs after and then set the innerHTML (= avoids the dummy-div), but that means we'll have DOM -> no DOM -> DOM transitions. With the div, we have DOM -> DOM and remove possible race-conditions.
      /* @__PURE__ */ jsx60(
        "div",
        {
          style: { display: "contents" },
          suppressHydrationWarning: true,
          dangerouslySetInnerHTML: {
            __html: `<!-- DOM replaced by GracefullyDegradingErrorBoundary due to "${unwrappedError.message.replace(closingHTMLComment, closingHTMLCommentReplacement)}". ${getPleaseReportMessage()}: --><!-- Stack: ${error.stack?.replace(closingHTMLComment, "--!>")} -->` + dom
          }
        }
      )
    );
  }
};

// ../../library/src/modules/Link/index.tsx
import { forwardRef as forwardRef5, isValidElement as isValidElement5, useMemo as useMemo14 } from "react";

// ../../library/src/render/utils/findAnchorElement.ts
function findAnchorElement(target, withinElement) {
  if (target instanceof HTMLAnchorElement) {
    return target;
  }
  if (target instanceof Element) {
    if (target === withinElement) {
      return null;
    }
    return findAnchorElement(target.parentElement, withinElement);
  }
  return null;
}

// ../../library/src/modules/ChildrenCanSuspend.tsx
import { forwardRef as forwardRef4 } from "react";
import { jsx as jsx61 } from "react/jsx-runtime";
function ChildrenCanSuspend({ children }) {
  return /* @__PURE__ */ jsx61(SuspenseThatPreservesDom, { children });
}
function withChildrenCanSuspend(Component18) {
  return forwardRef4(function withChildrenCanSuspendInner(props, ref) {
    return /* @__PURE__ */ jsx61(ChildrenCanSuspend, { children: /* @__PURE__ */ jsx61(Component18, { ...props, ref }) });
  });
}

// ../../library/src/modules/observeRouteForPreloading.ts
var PRELOAD_AFTER_MS = 500;
var OBSERVER_THRESHOLD = 0.9;
var LOW_MEMORY_THRESHOLD = 1.7;
var MAX_CONCURRENT_PRELOADS_SLOW_NETWORK = 4;
var MAX_CONCURRENT_PRELOADS_FAST_NETWORK = Infinity;
var nodeToRoute = /* @__PURE__ */ new WeakMap();
var preloadedRoutes = /* @__PURE__ */ new Set();
var routeToNodesInViewport = /* @__PURE__ */ new Map();
function getObserveRouteForPreloadingFn() {
  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {};
  const lowDeviceMemory = navigator.deviceMemory && navigator.deviceMemory > LOW_MEMORY_THRESHOLD;
  let effectiveType, preloadDisabled, maxPreloadAmount;
  function updateConnection() {
    effectiveType = connection.effectiveType || "";
    preloadDisabled = connection.saveData || effectiveType.includes("2g");
    maxPreloadAmount = effectiveType === "3g" || lowDeviceMemory ? MAX_CONCURRENT_PRELOADS_SLOW_NETWORK : MAX_CONCURRENT_PRELOADS_FAST_NETWORK;
  }
  connection.addEventListener?.("change", updateConnection);
  updateConnection();
  const observer = new IntersectionObserver(onPreloadIntersectionChange, { threshold: OBSERVER_THRESHOLD });
  let activePreloadsAmount = 0;
  async function preloadTimeout(route, target) {
    if (preloadDisabled) return;
    const nodesInViewport = routeToNodesInViewport.get(route);
    if (!nodesInViewport?.size || preloadedRoutes.has(route)) return;
    ++activePreloadsAmount;
    preloadedRoutes.add(route);
    const preloadDone = preloadRoute(route).catch(() => {
      if (false) {
        throw new Error(
          "Error in preloadRoute during preloadTimeout. This should never happen as it introduces bugs. Please make sure preloadRoute does not throw."
        );
      }
    });
    observer.unobserve(target);
    nodeToRoute.delete(target);
    for (const node of nodesInViewport) {
      observer.unobserve(node);
      nodeToRoute.delete(node);
    }
    nodesInViewport.clear();
    routeToNodesInViewport.delete(route);
    await preloadDone;
    --activePreloadsAmount;
  }
  function onPreloadIntersectionChange(entries) {
    for (const entry of entries) {
      const target = entry.target;
      const route = nodeToRoute.get(target);
      if (!route || preloadedRoutes.has(route)) {
        observer.unobserve(target);
        nodeToRoute.delete(target);
        continue;
      }
      const nodes = routeToNodesInViewport.get(route);
      const amountOfNodesInViewport = routeToNodesInViewport.get(route)?.size ?? 0;
      if (entry.isIntersecting) {
        if (activePreloadsAmount >= maxPreloadAmount) continue;
        if (nodes) nodes.add(target);
        else routeToNodesInViewport.set(route, /* @__PURE__ */ new Set([target]));
        setTimeout(preloadTimeout.bind(void 0, route, target), PRELOAD_AFTER_MS);
      } else {
        if (nodes) nodes.delete(target);
        if (amountOfNodesInViewport <= 1) routeToNodesInViewport.delete(route);
      }
    }
  }
  return (route, node) => {
    if (preloadedRoutes.has(route)) return;
    nodeToRoute.set(node, route);
    observer.observe(node);
    return () => {
      nodeToRoute.delete(node);
      observer.unobserve(node);
    };
  };
}
var observeRouteForPreloading = (
  // this also guards `window`
  !shouldPreloadBasedOnUA || typeof IntersectionObserver === "undefined" ? null : /* @__PURE__ */ getObserveRouteForPreloadingFn()
);

// ../../library/src/modules/Link/findMatchingRouteAttributes.tsx
function findMatchingRouteAttributesForWebPageLink(router, currentRoute, pageLink, activeLocale, resolvedSlugs, implicitPathVariables) {
  const { webPageId, hash: hash2, pathVariables, hashVariables } = pageLink;
  return getRouteAttributes(
    router,
    currentRoute,
    webPageId,
    hash2,
    implicitPathVariables,
    pathVariables,
    hashVariables,
    resolvedSlugs,
    activeLocale
  );
}
function findMatchingRouteAttributesForResolvedPath(router, path, implicitPathVariables, locales) {
  if (!router.routes || !router.getRoute) {
    return;
  }
  const isInternal = isInternalURL(path);
  if (!isInternal) {
    return;
  }
  try {
    const [pathnameWithQueryParams, hash2] = path.split("#", 2);
    assert(pathnameWithQueryParams !== void 0, "A href must have a defined pathname.");
    const [pathname] = pathnameWithQueryParams.split("?", 2);
    assert(pathname !== void 0, "A href must have a defined pathname.");
    const { routeId, pathVariables } = inferInitialRouteFromPath(router.routes, pathname, void 0, locales);
    const route = router.getRoute(routeId);
    if (route) {
      const combinedPathVariables = Object.assign({}, implicitPathVariables, pathVariables);
      return {
        routeId,
        route,
        href: path,
        // If the link is resolved (in ResolveLink), we trust that the hash is also resolved. Otherwise, it
        // should be resolved by getHashForRoute.
        elementId: hash2,
        pathVariables: combinedPathVariables
      };
    }
  } catch {
  }
}
function getRouteAttributes(router, currentRoute, routeId, hash2, implicitPathVariables, pathVariables, hashVariables, resolvedSlugs, activeLocale) {
  const combinedPathVariables = { ...implicitPathVariables, ...pathVariables, ...resolvedSlugs?.path };
  const combinedHashVariables = { ...implicitPathVariables, ...hashVariables, ...resolvedSlugs?.hash };
  const route = router.getRoute?.(routeId);
  const resolvedHref = getPathForRoute(route, {
    currentRoutePath: currentRoute?.path,
    currentRoutePathLocalized: currentRoute?.pathLocalized,
    currentPathVariables: currentRoute?.pathVariables,
    hash: hash2,
    pathVariables: combinedPathVariables,
    hashVariables: combinedHashVariables,
    preserveQueryParams: router.preserveQueryParams,
    siteCanonicalURL: router.siteCanonicalURL,
    localeId: activeLocale?.id
  });
  const resolvedHash = resolvedHref.split("#", 2)[1];
  return {
    routeId,
    route,
    href: resolvedHref,
    elementId: resolvedHash,
    pathVariables: combinedPathVariables
  };
}

// ../../library/src/modules/Link/linkMatchesRoute.tsx
import { useContext as useContext23 } from "react";

// ../../library/src/modules/Link/pathVariables.tsx
import { createContext as createContext11, useContext as useContext22 } from "react";
var pathVariablesRegExp2 = /:([a-z]\w*)/gi;
var PathVariablesContext = /* @__PURE__ */ createContext11(void 0);
function useImplicitPathVariables() {
  const contextPathVariables = useContext22(PathVariablesContext);
  const currentPathVariables = useCurrentRoute()?.pathVariables;
  const pathVariables = contextPathVariables || currentPathVariables;
  return pathVariables;
}

// ../../library/src/modules/Link/linkMatchesRoute.tsx
function linkMatchesRoute(route, {
  webPageId,
  hash: hash2,
  pathVariables
}, implicitPathVariables) {
  if (webPageId !== route.id) return false;
  if (hash2) return false;
  if (route.path && route.pathVariables) {
    const combinedPathVariable = Object.assign({}, implicitPathVariables, pathVariables);
    for (const [, key7] of route.path.matchAll(pathVariablesRegExp2)) {
      if (!key7) return false;
      if (route.pathVariables[key7] !== combinedPathVariable[key7]) {
        return false;
      }
    }
  }
  return true;
}
function useLinkMatchesRoute(link) {
  const route = useCurrentRoute();
  const contextPathVariables = useContext23(PathVariablesContext);
  if (!route) return false;
  const pageLink = isString(link) ? linkFromFramerPageLink(link) : link;
  return isLinkToWebPage(pageLink) ? linkMatchesRoute(route, pageLink, contextPathVariables) : false;
}

// ../../library/src/modules/Link/types.ts
var AnchorLinkTarget = /* @__PURE__ */ ((AnchorLinkTarget2) => {
  AnchorLinkTarget2["_blank"] = "_blank";
  AnchorLinkTarget2["_self"] = "_self";
  return AnchorLinkTarget2;
})(AnchorLinkTarget || {});

// ../../library/src/modules/Link/propsForLink.tsx
function propsForLink(href, options) {
  const isInternal = isInternalURL(href);
  const props = {
    href: href === "" || isValidURL(href, isInternal) ? href : `https://${href}`,
    target: getTargetAttrValue(options?.openInNewTab, isInternal),
    rel: !isInternal ? combineRels("noopener", options?.rel) : void 0
  };
  if (options?.preserveParams) {
    props.href = forwardCurrentQueryParams(props.href ?? href);
    props["data-framer-preserve-params"] = true;
  }
  if (options?.trackLinkClick) {
    props.onClick = () => {
      void options.trackLinkClick(href);
    };
  }
  return props;
}
function getTargetAttrValue(openInNewTab, isInternal) {
  if (openInNewTab !== void 0) {
    return openInNewTab ? "_blank" /* _blank */ : void 0;
  }
  return isInternal ? void 0 : "_blank" /* _blank */;
}
function combineRels(rel, otherRel) {
  if (rel && !otherRel) return rel;
  if (!rel && otherRel) return otherRel;
  if (rel && otherRel) return `${rel} ${otherRel}`;
  return void 0;
}

// ../../library/src/modules/Link/resolveSlugs.ts
import { useCallback as useCallback14 } from "react";

// ../../library/src/modules/resolveSlug.ts
function handleResolveSlugError(error, fallbackMessage) {
  console.warn(
    getPleaseReportMessage(
      `Failed to resolve slug: ${error instanceof Error ? error.message : fallbackMessage ?? "Unknown error"}`
    )
  );
  return void 0;
}
function resolveSlug(unresolvedSlug, collectionUtils, activeLocale) {
  try {
    const utils = collectionUtils?.get(unresolvedSlug.collectionId);
    if (!utils) {
      return handleResolveSlugError(
        void 0,
        `Couldn't find collection utils for collection id: "${unresolvedSlug.collectionId}"`
      );
    }
    const maybeSlug = utils.getSlugByRecordId(unresolvedSlug.collectionItemId, activeLocale ?? void 0);
    if (isPromise(maybeSlug)) {
      return maybeSlug.catch(handleResolveSlugError);
    }
    return maybeSlug;
  } catch (error) {
    handleResolveSlugError(error);
  }
}

// ../../library/src/modules/Link/resolveSlugs.ts
async function resolveSlugs(unresolvedPathSlugs, unresolvedHashSlugs, activeLocale, collectionUtils) {
  async function handleSlugs(unresolvedSlugs) {
    if (!unresolvedSlugs) return {};
    const result = {};
    for (const slugKey in unresolvedSlugs) {
      const unresolvedSlug = unresolvedSlugs[slugKey];
      assert(unresolvedSlug, "unresolvedSlug should be defined");
      const maybeSlug = resolveSlug(unresolvedSlug, collectionUtils, activeLocale);
      const value = isPromise(maybeSlug) ? await maybeSlug : maybeSlug;
      if (value) {
        result[slugKey] = value;
      }
    }
    return result;
  }
  const [pathResult, slugResult] = await Promise.allSettled([
    handleSlugs(unresolvedPathSlugs),
    handleSlugs(unresolvedHashSlugs)
  ]);
  return {
    path: pathResult.status === "fulfilled" ? pathResult.value : void 0,
    hash: slugResult.status === "fulfilled" ? slugResult.value : void 0
  };
}
function resolveSlugsWithSuspense(unresolvedPathSlugs, unresolvedHashSlugs, activeLocale, collectionUtils, promises = []) {
  function handleSlugs(unresolvedSlugs) {
    if (!unresolvedSlugs) return;
    const result2 = {};
    for (const slugKey in unresolvedSlugs) {
      const unresolvedSlug = unresolvedSlugs[slugKey];
      if (!unresolvedSlug) continue;
      const maybeSlug = resolveSlug(unresolvedSlug, collectionUtils, activeLocale);
      if (isPromise(maybeSlug)) {
        promises.push(maybeSlug);
      } else if (maybeSlug) {
        result2[slugKey] = maybeSlug;
      }
    }
    return result2;
  }
  const result = {
    path: handleSlugs(unresolvedPathSlugs),
    hash: handleSlugs(unresolvedHashSlugs)
  };
  if (promises.length > 0) {
    return Promise.allSettled(promises);
  }
  return result;
}
function useResolveSlugsWithSuspense() {
  const collectionUtils = useCollectionUtils();
  return useCallback14(
    (unresolvedPathSlugs, unresolvedHashSlugs, activeLocale, promises = []) => {
      return resolveSlugsWithSuspense(
        unresolvedPathSlugs,
        unresolvedHashSlugs,
        activeLocale,
        collectionUtils,
        promises
      );
    },
    [collectionUtils]
  );
}

// ../../library/src/modules/Link/useTrackLinkClick.ts
import { useCallback as useCallback15 } from "react";
function useTrackLinkClick({
  nodeId,
  clickTrackingId,
  router,
  href,
  activeLocale
}) {
  const collectionUtils = useCollectionUtils();
  return useCallback15(
    async (hrefAttribute) => {
      if (!router.pageviewEventData?.current) return;
      const pageviewEventData = router.pageviewEventData.current instanceof Promise ? await router.pageviewEventData.current : router.pageviewEventData.current;
      const pageLink = isLinkToWebPage(href) ? href : linkFromFramerPageLink(href);
      if (!isLinkToWebPage(pageLink)) {
        return sendTrackingEvent(
          "published_site_click",
          {
            ...pageviewEventData,
            href: hrefAttribute ? makeUrlAbsolute(hrefAttribute) : null,
            nodeId: nodeId ?? null,
            trackingId: clickTrackingId || null,
            targetRoutePath: null,
            targetWebPageId: null,
            targetCollectionItemId: null
          },
          "eager"
        );
      }
      const targetWebPageId = pageLink.webPageId;
      const targetRoute = router?.getRoute?.(targetWebPageId);
      const targetRoutePath = targetRoute?.path ?? null;
      let targetCollectionItemId = null;
      if (targetRoute?.collectionId && pageLink.pathVariables) {
        const utils = collectionUtils?.get(targetRoute.collectionId);
        if (!utils) return;
        const [slug] = Object.values(pageLink.pathVariables);
        if (isString(slug)) {
          const maybeCollectionItemId = utils.getRecordIdBySlug(slug, activeLocale || void 0);
          const collectionItemId = isPromise(maybeCollectionItemId) ? await maybeCollectionItemId : maybeCollectionItemId;
          targetCollectionItemId = collectionItemId ?? null;
        }
      }
      return sendTrackingEvent(
        "published_site_click",
        {
          ...pageviewEventData,
          href: hrefAttribute ? makeUrlAbsolute(hrefAttribute) : null,
          nodeId: nodeId ?? null,
          trackingId: clickTrackingId ?? null,
          targetRoutePath,
          targetWebPageId,
          targetCollectionItemId
        },
        "eager"
      );
    },
    [nodeId, clickTrackingId, router, href, activeLocale, collectionUtils]
  );
}
function makeUrlAbsolute(href) {
  try {
    const url = new URL(href, safeWindow.document.baseURI);
    return url.origin === safeWindow.location.origin ? url.pathname + url.search + url.hash : url.href;
  } catch {
    return href;
  }
}

// ../../library/src/modules/Link/index.tsx
function performNavigation(router, routeId, elementId, combinedPathVariables, smoothScroll, beforeUrlUpdate) {
  const route = router.getRoute?.(routeId);
  if (route && isLazyComponentType(route?.page)) {
    void route.page.preload();
  }
  router.navigate?.(routeId, elementId, combinedPathVariables, smoothScroll, beforeUrlUpdate);
}
function createOnClickLinkHandler(router, routeId, href, trackLinkClick, elementId, combinedPathVariables, smoothScroll) {
  return async (event) => {
    const usedMetaKey = event.metaKey;
    const anchorElement = findAnchorElement(event.target);
    const isExternalLink = !anchorElement || anchorElement.getAttribute("target") === "_blank" /* _blank */;
    const shouldPerformNavigation = !usedMetaKey && !isExternalLink;
    const track = () => void trackLinkClick(href);
    if (!shouldPerformNavigation) {
      await yieldToMain({ priority: "user-blocking", ensureContinueBeforeUnload: true, continueAfter: "paint" });
      track();
      return;
    }
    event.preventDefault();
    performNavigation(router, routeId, elementId, combinedPathVariables, smoothScroll, track);
  };
}
function propsForRoutePath(href, router, currentRoute, linkOptions, localeId, locales, implicitPathVariables) {
  if (!currentRoute) return propsForLink(href, linkOptions);
  const matchedRoute = findMatchingRouteAttributesForResolvedPath(router, href, implicitPathVariables, locales);
  if (!matchedRoute) return propsForLink(href, linkOptions);
  const { routeId, route, elementId, pathVariables } = matchedRoute;
  if (!route) return propsForLink(href, linkOptions);
  const path = getPathForRoute(route, {
    // If the link is resolved, we trust that the slugs are resolved.
    currentRoutePath: currentRoute.path,
    currentRoutePathLocalized: currentRoute.pathLocalized,
    currentPathVariables: currentRoute.pathVariables,
    // The hash value is already fully resolved so we don't need to
    // provide any hashVariables.
    hash: elementId,
    pathVariables,
    preserveQueryParams: router.preserveQueryParams && !isBot,
    // don't preserve query params for bots
    siteCanonicalURL: router.siteCanonicalURL,
    localeId
  });
  const anchorTarget = getTargetAttrValue(linkOptions.openInNewTab, true);
  return {
    href: path,
    target: anchorTarget,
    onClick: createOnClickLinkHandler(
      router,
      routeId,
      path,
      linkOptions.trackLinkClick,
      elementId,
      pathVariables,
      linkOptions.smoothScroll
    ),
    navigate: () => performNavigation(router, routeId, elementId, pathVariables, linkOptions.smoothScroll),
    "data-framer-page-link-current": currentRoute && linkMatchesRoute(
      currentRoute,
      { webPageId: routeId, hash: elementId, pathVariables },
      implicitPathVariables
    ) || void 0
  };
}
var Link = /* @__PURE__ */ withChildrenCanSuspend(
  /* @__PURE__ */ forwardRef5(function Link2({
    children,
    href,
    openInNewTab,
    smoothScroll,
    clickTrackingId,
    relValues,
    preserveParams,
    nodeId,
    scopeId,
    motionChild,
    ...restProps
  }, forwardedRef) {
    const router = useRouter();
    const currentRoute = useCurrentRoute();
    const implicitPathVariables = useImplicitPathVariables();
    const { activeLocale, locales } = useLocaleInfo();
    const resolveSlugsWithSuspense2 = useResolveSlugsWithSuspense();
    const trackLinkClick = useTrackLinkClick({
      nodeId,
      clickTrackingId,
      router,
      href,
      activeLocale
    });
    const propsAddedByLink = useMemo14(() => {
      if (!href) return {};
      const pageLink = isLinkToWebPage(href) ? href : linkFromFramerPageLink(href);
      if (!pageLink) return {};
      if (isString(pageLink)) {
        return propsForRoutePath(
          pageLink,
          router,
          currentRoute,
          { openInNewTab, trackLinkClick, rel: relValues?.join(" "), preserveParams, smoothScroll },
          activeLocale?.id,
          locales,
          implicitPathVariables
        );
      }
      const { unresolvedPathSlugs, unresolvedHashSlugs } = pageLink;
      const maybeResolvedSlugs = resolveSlugsWithSuspense2(unresolvedPathSlugs, unresolvedHashSlugs, activeLocale);
      if (isPromise(maybeResolvedSlugs)) {
        throw maybeResolvedSlugs;
      }
      const maybeRouteAttributes = findMatchingRouteAttributesForWebPageLink(
        router,
        currentRoute,
        pageLink,
        activeLocale,
        maybeResolvedSlugs,
        implicitPathVariables
      );
      const { routeId, href: resolvedHref, elementId, pathVariables } = maybeRouteAttributes;
      const anchorTarget = getTargetAttrValue(openInNewTab, true);
      return {
        href: resolvedHref,
        target: anchorTarget,
        onClick: createOnClickLinkHandler(
          router,
          routeId,
          resolvedHref,
          trackLinkClick,
          elementId,
          pathVariables,
          smoothScroll
        ),
        navigate: () => performNavigation(router, routeId, elementId, pathVariables, smoothScroll),
        "data-framer-page-link-current": currentRoute && linkMatchesRoute(currentRoute, pageLink, implicitPathVariables) || void 0
      };
    }, [
      href,
      router,
      activeLocale,
      implicitPathVariables,
      openInNewTab,
      currentRoute,
      smoothScroll,
      trackLinkClick,
      relValues,
      locales,
      preserveParams,
      resolveSlugsWithSuspense2
    ]);
    const hasRef = isValidElement5(children) && "ref" in children;
    const observerRef = useObserverRef(hasRef ? children.ref : void 0);
    useRefEffect(
      observerRef,
      (node) => {
        if (node === null) return;
        const pageLink = isLinkToWebPage(href) ? href : linkFromFramerPageLink(href);
        if (!pageLink) return;
        const route = getRouteFromPageLink(pageLink, router, currentRoute, locales);
        if (!route) return;
        return observeRouteForPreloading?.(route, node);
      },
      [currentRoute, href, router, locales]
    );
    const { navigate, ...propsAddedByLinkExceptNavigate } = propsAddedByLink;
    const isInternalNavigation = Boolean(navigate);
    const clone = useCloneChildrenWithPropsAndRef(forwardedRef);
    const replacedChildren = clone.cloneAsArray(
      children,
      (childProps) => cloneChildPropsWithAggregatedEvents(
        childProps,
        {
          ...restProps,
          ...rebindEventHandlersIfNeeded(propsAddedByLinkExceptNavigate, motionChild, isInternalNavigation)
        },
        observerRef
      )
    );
    return useReplaceNestedLinks(replacedChildren, scopeId, nodeId, href, propsAddedByLink, observerRef);
  })
);
function cloneChildPropsWithAggregatedEvents(childProps, linkProps, observerRef) {
  const mergedStyle = mergeStyles(childProps.style, linkProps.style);
  const aggregatedProps = {
    ...childProps,
    ...linkProps,
    ...mergedStyle && { style: mergedStyle },
    ref: observerRef
  };
  const { onTap, onClick } = linkProps;
  if (!onTap && !onClick) {
    return aggregatedProps;
  }
  const { onClick: childOnClick, onTap: childOnTap } = childProps;
  return {
    ...aggregatedProps,
    onClick: onClick || childOnClick ? (event) => {
      if (isFunction(childOnClick)) {
        childOnClick?.(event);
      }
      onClick?.(event);
    } : void 0,
    onTap: onTap || childOnTap ? (event, info) => {
      if (isFunction(childOnTap)) {
        childOnTap?.(event, info);
      }
      onTap?.(event, info);
    } : void 0
  };
}
function mergeStyles(childStyle, linkStyle) {
  const maybeChildStyle = isObject2(childStyle) ? childStyle : void 0;
  const hasChildStyles = maybeChildStyle && !isEmptyObject(maybeChildStyle);
  const hasLinkStyles = linkStyle && !isEmptyObject(linkStyle);
  if (!hasChildStyles && !hasLinkStyles) return void 0;
  return { ...maybeChildStyle, ...linkStyle };
}
function rebindEventHandlersIfNeeded(linkProps, motionChild, isInternalNavigation) {
  const shouldReplaceClickWithTap = Boolean(motionChild && isIOS());
  if (!shouldReplaceClickWithTap) return linkProps;
  const { onClick, ...restProps } = linkProps;
  if (!onClick) return linkProps;
  if (isInternalNavigation) {
    return {
      ...restProps,
      onTap: onClick,
      // When the link is an internal link, we're already doing SPA routing in onClick
      // prevent the default click behavior so that we don't trigger a native anchor link navigation again.
      onClick: preventClickOnNativeAnchorLink
    };
  }
  return { ...restProps, onTap: onClick };
}
function preventClickOnNativeAnchorLink(event) {
  const anchorElement = findAnchorElement(event.target);
  if (!anchorElement || anchorElement.getAttribute("target") === "_blank" /* _blank */) return;
  event.preventDefault();
}

// ../../library/src/modules/Link/resolveLink.ts
function resolveLink(href, router, implicitPathVariables, activeLocale) {
  return resolveLinkInternal(href, router, implicitPathVariables, void 0, activeLocale);
}
function resolveLinkInternal(href, router, implicitPathVariables, onlyHash, activeLocale, resolveSlugs2) {
  const pageLink = isLinkToWebPage(href) ? href : linkFromFramerPageLink(href);
  if (!isLinkToWebPage(pageLink)) return isString(href) ? propsForLink(href).href : void 0;
  if (!router.getRoute || !router.currentRouteId) return void 0;
  const currentRoute = router.getRoute(router.currentRouteId);
  const { webPageId, hash: hash2, pathVariables, hashVariables, unresolvedHashSlugs, unresolvedPathSlugs } = pageLink;
  const route = router.getRoute(webPageId);
  const resolvedSlugs = unresolvedPathSlugs || unresolvedHashSlugs ? resolveSlugs2?.(unresolvedPathSlugs, unresolvedHashSlugs) : void 0;
  if (isPromise(resolvedSlugs)) return;
  const combinedPathVariables = Object.assign(
    {},
    router.currentPathVariables,
    implicitPathVariables,
    pathVariables,
    resolvedSlugs?.path
  );
  const combinedHashVariables = Object.assign(
    {},
    router.currentPathVariables,
    implicitPathVariables,
    hashVariables,
    resolvedSlugs?.hash
  );
  const path = getPathForRoute(route, {
    currentRoutePath: currentRoute?.path,
    currentRoutePathLocalized: currentRoute?.pathLocalized,
    currentPathVariables: router.currentPathVariables,
    hash: hash2,
    pathVariables: combinedPathVariables,
    hashVariables: combinedHashVariables,
    relative: false,
    preserveQueryParams: router.preserveQueryParams,
    onlyHash,
    siteCanonicalURL: router.siteCanonicalURL,
    localeId: activeLocale?.id
  });
  if (onlyHash) return path;
  const slugPrefix = activeLocale?.slug ? `/${activeLocale.slug}` : "";
  return slugPrefix + path;
}

// ../../library/src/modules/Link/resolvePageScope.tsx
function resolvePageScope(pageLink, router, localeId) {
  if (!router.getRoute || !router.currentRouteId) return void 0;
  const currentRoute = router.getRoute(router.currentRouteId);
  const { webPageId } = pageLink;
  const route = router.getRoute(webPageId);
  return getPathForRoute(route, {
    currentRoutePath: currentRoute?.path,
    currentRoutePathLocalized: currentRoute?.pathLocalized,
    currentPathVariables: router.currentPathVariables,
    relative: false,
    preserveQueryParams: false,
    siteCanonicalURL: void 0,
    localeId
  });
}

// ../../library/src/modules/PageRoot.tsx
import React70 from "react";

// ../../library/src/render/presentation/Forms/FormContainer.tsx
import React66, { startTransition as startTransition4, useContext as useContext24 } from "react";

// ../../library/src/render/presentation/Forms/antibot.ts
var salt = "framer";
var difficulty = 3;
var tokenLength = 30;
var maxTime = 1e4;
function createWorkerTask() {
  return (function() {
    async function sha256(text) {
      const buffer = new TextEncoder().encode(text);
      const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
      return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    function randomCharacters(count) {
      const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      let result = "";
      const charactersLength = characters.length;
      for (let i = 0; i < count; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    }
    addEventListener("message", async (event) => {
      const { salt: salt2, difficulty: difficulty2, tokenLength: tokenLength2, maxTime: maxTime2 } = event.data;
      const target = "0".repeat(difficulty2);
      const startTime = performance.now();
      let processing = true;
      while (processing) {
        const timestamp = performance.now();
        if (timestamp - startTime > maxTime2) {
          processing = false;
          postMessage({ success: false });
          return;
        }
        const nonce = randomCharacters(tokenLength2);
        const secret = `${Date.now()}:${nonce}`;
        const hash2 = await sha256(salt2 + secret);
        if (hash2.startsWith(target)) {
          postMessage({ success: true, secret, hash: hash2 });
          return;
        }
      }
    });
  }).toString();
}
async function calculateProofOfWork() {
  return new Promise((resolve, reject) => {
    const webWorkerURL = URL.createObjectURL(
      new Blob(["(", createWorkerTask(), ")()"], {
        type: "application/javascript"
      })
    );
    const worker = new Worker(webWorkerURL);
    worker.onmessage = (event) => {
      worker.terminate();
      URL.revokeObjectURL(webWorkerURL);
      if (event.data.success) {
        resolve({ secret: event.data.secret, hash: event.data.hash });
      } else {
        resolve(void 0);
      }
    };
    worker.onerror = (event) => {
      worker.terminate();
      URL.revokeObjectURL(webWorkerURL);
      reject(event);
    };
    worker.postMessage({
      salt,
      difficulty,
      tokenLength,
      maxTime
    });
  });
}

// ../../library/src/render/presentation/Forms/formData.ts
function getEncodedFormFieldsHeader(data2) {
  return Array.from(data2.keys()).map(encodeURIComponent).join(",");
}
function addUTMTagsToFormData(data2, document2) {
  try {
    const matches = document2.cookie.match("(^|;) ?framerFormsUTMTags=([^;]*)(;|$)");
    if (matches !== null && matches[2]) {
      const parsed = JSON.parse(decodeURIComponent(matches[2]));
      if (!parsed || typeof parsed !== "object") return;
      ["utm_source", "utm_medium", "utm_campaign", "utm_term", "utm_content", "gclid"].forEach((key7) => {
        if (typeof parsed[key7] === "string") data2.append(key7, parsed[key7]);
      });
    }
  } catch (e) {
  }
}

// ../../library/src/render/presentation/Forms/honeypot.tsx
import React65 from "react";
import { Fragment as Fragment9, jsx as jsx62 } from "react/jsx-runtime";
var HONEYPOT_VERSION = "3";
var HONEYPOT_FIELD_NAME = "__framer";
var COMMON_FIELD_NAMES = [
  "website",
  "company",
  "message",
  "subject",
  "title",
  "description",
  "feedback",
  "notes",
  "details",
  "remarks",
  "comments"
];
var MODULE_LOAD_TIME = /* @__PURE__ */ (() => Date.now())();
var FIELD_DATA_ENUM = {
  name: 0,
  value: 1,
  setAttribute: 2,
  valueProperty: 3,
  isInputEventTrusted: 4,
  inputChangeTimeSinceModuleLoad: 5,
  wasFilledBeforeHydration: 6
};
var METADATA_KEYS_ENUM = {
  fieldData: 0,
  fieldCount: 1,
  fieldFilledCount: 2,
  hpVersion: 3,
  siteId: 4,
  timeToSubmissionSinceModuleLoad: 5
};
var getTimeSinceModuleLoadInSeconds = () => {
  return ((Date.now() - MODULE_LOAD_TIME) / 1e3).toFixed(2);
};
var HoneypotInput = ({ inputStateRef }) => {
  const { inputRef, originalName } = inputStateRef;
  React65.useLayoutEffect(() => {
    const honeypotInput = inputRef.current;
    if (!honeypotInput) return;
    const methodsUsed = inputStateRef.methodsUsed;
    if (honeypotInput.value) {
      methodsUsed.wasFilledBeforeHydration = true;
    }
  }, [inputRef, inputStateRef]);
  React65.useEffect(() => {
    const myInput = inputRef.current;
    if (!myInput) return;
    const methodsUsed = inputStateRef.methodsUsed;
    const originalSetAttributeMethod = Element.prototype.setAttribute;
    const originalSetAttribute = originalSetAttributeMethod.bind(myInput);
    myInput.setAttribute = function(attrName, attrValue) {
      if (attrName === "value") {
        methodsUsed.setAttribute = true;
        methodsUsed.inputChangeTimeSinceModuleLoad = getTimeSinceModuleLoadInSeconds();
      }
      originalSetAttribute(attrName, attrValue);
    };
    const originalDescriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value");
    if (originalDescriptor) {
      Object.defineProperty(myInput, "value", {
        configurable: true,
        enumerable: true,
        get: function() {
          return originalDescriptor.get?.call(this) ?? "";
        },
        set: function(newValue) {
          methodsUsed.valueProperty = true;
          methodsUsed.inputChangeTimeSinceModuleLoad = getTimeSinceModuleLoadInSeconds();
          originalDescriptor.set?.call(this, newValue);
        }
      });
    }
    const handleInput = (event) => {
      methodsUsed.isInputEventTrusted = event.isTrusted;
      methodsUsed.inputChangeTimeSinceModuleLoad = getTimeSinceModuleLoadInSeconds();
    };
    myInput.addEventListener("input", handleInput);
    return () => {
      myInput.setAttribute = originalSetAttributeMethod.bind(myInput);
      if (originalDescriptor) {
        Object.defineProperty(myInput, "value", originalDescriptor);
      }
      myInput.removeEventListener("input", handleInput);
    };
  }, [inputRef, inputStateRef]);
  return /* @__PURE__ */ jsx62(
    "input",
    {
      ref: inputRef,
      type: "text",
      name: originalName,
      suppressHydrationWarning: true,
      tabIndex: -1,
      autoComplete: "one-time-code",
      "aria-hidden": "true",
      style: {
        position: "absolute",
        transform: "scale(0)"
      },
      defaultValue: "",
      "data-1p-ignore": true,
      "data-lpignore": "true",
      "data-form-type": "other",
      "data-bwignore": true
    }
  );
};
function useHoneypotFields() {
  const framerSiteId = React65.useContext(FormContext);
  const states = React65.useMemo(
    () => COMMON_FIELD_NAMES.map((fieldName) => {
      return {
        inputRef: React65.createRef(),
        originalName: fieldName,
        methodsUsed: {
          setAttribute: false,
          valueProperty: false
        }
      };
    }),
    []
  );
  const convertHoneypotFieldsForSubmission = React65.useCallback(() => {
    states.forEach((state) => {
      const currentHoneypotInput = state.inputRef.current;
      if (currentHoneypotInput) {
        currentHoneypotInput.name = `${HONEYPOT_FIELD_NAME}_${state.originalName}`;
      }
    });
  }, [states]);
  const replaceHoneypotWithMetadata = React65.useCallback(
    (formData) => {
      const honeypotCount = states.length;
      let honeypotFilled = 0;
      const filledFieldsData = [];
      states.forEach((state) => {
        const currentHoneypotInput = state.inputRef.current;
        if (currentHoneypotInput) {
          const currentName = currentHoneypotInput.name;
          const currentValue = currentHoneypotInput.value;
          if (currentValue) {
            honeypotFilled++;
            const fieldData = {
              [FIELD_DATA_ENUM.name]: state.originalName,
              [FIELD_DATA_ENUM.value]: currentValue,
              [FIELD_DATA_ENUM.setAttribute]: state.methodsUsed.setAttribute,
              [FIELD_DATA_ENUM.valueProperty]: state.methodsUsed.valueProperty,
              [FIELD_DATA_ENUM.isInputEventTrusted]: state.methodsUsed.isInputEventTrusted,
              [FIELD_DATA_ENUM.inputChangeTimeSinceModuleLoad]: state.methodsUsed.inputChangeTimeSinceModuleLoad,
              [FIELD_DATA_ENUM.wasFilledBeforeHydration]: state.methodsUsed.wasFilledBeforeHydration
            };
            filledFieldsData.push(JSON.stringify(fieldData));
          }
          formData.delete(currentName);
          currentHoneypotInput.name = state.originalName;
        }
      });
      formData.append(`${HONEYPOT_FIELD_NAME}_${METADATA_KEYS_ENUM.fieldData}`, `[${filledFieldsData.join(",")}]`);
      formData.append(`${HONEYPOT_FIELD_NAME}_${METADATA_KEYS_ENUM.fieldCount}`, honeypotCount.toString());
      formData.append(`${HONEYPOT_FIELD_NAME}_${METADATA_KEYS_ENUM.fieldFilledCount}`, honeypotFilled.toString());
      formData.append(`${HONEYPOT_FIELD_NAME}_${METADATA_KEYS_ENUM.hpVersion}`, HONEYPOT_VERSION);
      formData.append(`${HONEYPOT_FIELD_NAME}_${METADATA_KEYS_ENUM.siteId}`, framerSiteId || "");
      formData.append(
        `${HONEYPOT_FIELD_NAME}_${METADATA_KEYS_ENUM.timeToSubmissionSinceModuleLoad}`,
        getTimeSinceModuleLoadInSeconds()
      );
    },
    [states, framerSiteId]
  );
  return {
    states,
    convertHoneypotFieldsForSubmission,
    replaceHoneypotWithMetadata
  };
}
function HoneypotFields({ states }) {
  return /* @__PURE__ */ jsx62(Fragment9, { children: states.map((stateRef) => (
    // Names are unique at the moment, so using the originalName is fine
    /* @__PURE__ */ jsx62(HoneypotInput, { inputStateRef: stateRef }, `hp_${stateRef.originalName}`)
  )) });
}

// ../../library/src/render/presentation/Forms/trackFormSubmit.ts
function trackFormSubmit({ router, nodeId, submitTrackingId }) {
  if (!router?.pageviewEventData?.current) return;
  if (router.pageviewEventData.current instanceof Promise) {
    void router.pageviewEventData.current.then((pageviewEventData) => {
      sendFormSubmitTrackingEvent(pageviewEventData, nodeId, submitTrackingId);
    });
  } else {
    sendFormSubmitTrackingEvent(router.pageviewEventData.current, nodeId, submitTrackingId);
  }
}
function sendFormSubmitTrackingEvent(pageviewEventData, nodeId, trackingId) {
  return sendTrackingEvent(
    "published_site_form_submit",
    {
      ...pageviewEventData,
      nodeId: nodeId ?? null,
      trackingId: trackingId || null
    },
    "eager"
  );
}

// ../../library/src/render/presentation/Forms/FormContainer.tsx
import { jsx as jsx63, jsxs as jsxs14 } from "react/jsx-runtime";
var pendingState = { state: "pending" };
var successState = { state: "success" };
var incompleteState = { state: "incomplete" };
var completeState = { state: "complete" };
var errorState = { state: "error" };
function formReducer({ state }, { type }) {
  switch (type) {
    case "complete":
      if (state === "error") return errorState;
      return completeState;
    case "incomplete":
      if (state === "error") return errorState;
      return incompleteState;
    case "submit":
      return pendingState;
    case "success":
      return successState;
    case "error":
      return errorState;
    default:
      assertNever(type);
  }
}
function stateCanSubmitForm({ state }) {
  return state === "incomplete" || state === "complete";
}
function preventDefault(e) {
  e.preventDefault();
}
function openExternalLinkInCurrentTab(link, formRef) {
  const href = isValidURL(link, false) ? link : `https://${link}`;
  const linkElement = document.createElement("a");
  linkElement.href = href;
  linkElement.target = "_self";
  linkElement.style.display = "none";
  if (!("current" in formRef && formRef.current)) return;
  formRef.current.appendChild(linkElement);
  linkElement.click();
  linkElement.remove();
}
var FormContext = React66.createContext(void 0);
var FormContainer = /* @__PURE__ */ React66.forwardRef(function FormContainer2({ action, children, redirectUrl, onSuccess, onError, onLoading, submitTrackingId, nodeId, ...props }, forwardedRef) {
  const fallbackRef = React66.useRef(null);
  const ref = forwardedRef ?? fallbackRef;
  const {
    states: honeypotStateRefs,
    convertHoneypotFieldsForSubmission,
    replaceHoneypotWithMetadata
  } = useHoneypotFields();
  const libraryFeatures = useLibraryFeatures();
  const isAdvancedSpamProtectionEnabled = libraryFeatures.advancedSpamProtection;
  const router = useRouter();
  const currentRoute = useCurrentRoute();
  const implicitPathVariables = useImplicitPathVariables();
  const collectionUtils = useCollectionUtils();
  const [state, dispatch] = React66.useReducer(formReducer, incompleteState);
  const { activeLocale, locales } = useLocaleInfo();
  const projectHash = useContext24(FormContext);
  const callbacks = React66.useRef({ onSuccess, onError, onLoading });
  callbacks.current = { onSuccess, onError, onLoading };
  const submissionInProgressRef = React66.useRef(false);
  async function redirectTo(link) {
    if (isString(link)) {
      const matchingRoute2 = findMatchingRouteAttributesForResolvedPath(
        router,
        link,
        implicitPathVariables,
        locales
      );
      if (!matchingRoute2) {
        openExternalLinkInCurrentTab(link, ref);
        return;
      }
      const { routeId: routeId2, elementId: elementId2, pathVariables: pathVariables2 } = matchingRoute2;
      router.navigate?.(routeId2, elementId2, pathVariables2);
      return;
    }
    assert(isLinkToWebPage(link), "Expected link to be either a LinkToWebPage or a string", link);
    const resolvedSlugs = await resolveSlugs(
      link.unresolvedPathSlugs,
      link.unresolvedHashSlugs,
      activeLocale,
      collectionUtils
    );
    const matchingRoute = findMatchingRouteAttributesForWebPageLink(
      router,
      currentRoute,
      link,
      activeLocale,
      resolvedSlugs,
      implicitPathVariables
    );
    const { routeId, elementId, pathVariables } = matchingRoute;
    router.navigate?.(routeId, elementId, pathVariables);
  }
  const handleSubmit = async (event) => {
    event.preventDefault();
    if (!action || !projectHash || submissionInProgressRef.current) return;
    submissionInProgressRef.current = true;
    if (isAdvancedSpamProtectionEnabled) {
      convertHoneypotFieldsForSubmission();
    }
    const data2 = new FormData(event.currentTarget);
    await yieldToMain({ priority: "user-visible", continueAfter: "paint" });
    if (isAdvancedSpamProtectionEnabled) {
      replaceHoneypotWithMetadata(data2);
    }
    startTransition4(() => dispatch({ type: "submit" }));
    addUTMTagsToFormData(data2, safeWindow.document);
    for (const [key7, value] of data2) {
      if (value instanceof File) data2.delete(key7);
    }
    try {
      callbacks.current.onLoading?.();
      trackFormSubmit({
        router,
        nodeId,
        submitTrackingId,
        activeLocale
      });
      await submitForm(action, data2, projectHash);
      startTransition4(() => dispatch({ type: "success" }));
      callbacks.current.onSuccess?.();
      if (redirectUrl) {
        await redirectTo(redirectUrl);
      }
    } catch (error) {
      startTransition4(() => dispatch({ type: "error" }));
      callbacks.current.onError?.();
      console.error(error);
    }
    submissionInProgressRef.current = false;
  };
  const handleKeyDown = (event) => {
    const { target: input, currentTarget: form, key: key7 } = event;
    const isTextArea = input instanceof HTMLTextAreaElement;
    if (isTextArea) return;
    if (key7 === "Enter" && form.checkValidity()) {
      event.preventDefault();
      void handleSubmit(event);
    }
  };
  const checkValidity = async (e) => {
    const target = e.currentTarget;
    await yieldToMain({ priority: "background", continueAfter: "paint" });
    startTransition4(() => dispatch({ type: anyEmptyRequiredFields(target) ? "incomplete" : "complete" }));
  };
  return /* @__PURE__ */ jsxs14(
    motion.form,
    {
      ...props,
      onSubmit: stateCanSubmitForm(state) ? handleSubmit : preventDefault,
      onKeyDown: handleKeyDown,
      onChange: checkValidity,
      ref,
      children: [
        children(state),
        isAdvancedSpamProtectionEnabled && /* @__PURE__ */ jsx63(HoneypotFields, { states: honeypotStateRefs })
      ]
    }
  );
});
function anyEmptyRequiredFields(element) {
  if (element.children.length === 0) return false;
  for (const child of element.children) {
    if (child instanceof HTMLInputElement || child instanceof HTMLTextAreaElement || child instanceof HTMLSelectElement) {
      if (child.required && child.value === "") return true;
    } else {
      const result = anyEmptyRequiredFields(child);
      if (result) return true;
    }
  }
  return false;
}
async function submitForm(action, data2, projectHash) {
  const proofOfWork = await calculateProofOfWork();
  if (!proofOfWork) {
    throw new Error("Failed to calculate proof of work");
  }
  const response = await fetch(action, {
    body: data2,
    method: "POST",
    headers: {
      "Framer-Site-Id": projectHash,
      "Framer-POW": proofOfWork.secret,
      "Framer-Form-Fields": getEncodedFormFieldsHeader(data2)
    }
  });
  if (response.ok) {
    return response;
  } else {
    const body = await response.json();
    const error = "Failed to submit form";
    if (responseHasError(body)) {
      throw new Error(`${error} - ${body.error.message}`);
    }
    throw new Error(error);
  }
}
function responseHasError(response) {
  return typeof response === "object" && response !== null && "error" in response && isObject2(response.error) && "message" in response.error && typeof response.error.message === "string";
}

// ../../library/src/router/Router.tsx
import { Fragment as Fragment10, startTransition as startTransition5, useCallback as useCallback17, useEffect as useEffect19, useLayoutEffect as useLayoutEffect7, useMemo as useMemo16, useRef as useRef20 } from "react";

// ../../shared/src/constants.ts
var FORCE_SHOW_EDITORBAR_LOCALSTORAGE_KEY = "__framer_force_showing_editorbar_since";

// ../../library/src/modules/EditorBarLauncher.tsx
import { Suspense as Suspense4, useContext as useContext25, useMemo as useMemo15, useSyncExternalStore as useSyncExternalStore2 } from "react";

// ../../library/src/components/IgnoreErrors.tsx
import { Component as Component15 } from "react";
var IgnoreErrors = class extends Component15 {
  constructor() {
    super(...arguments);
    __publicField(this, "state", { error: void 0 });
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  render() {
    if (this.state.error) return null;
    return this.props.children;
  }
};

// ../../library/src/modules/EditorBarLauncher.tsx
import { jsx as jsx64 } from "react/jsx-runtime";
var isPrioritized = () => {
  try {
    return !!localStorage[FORCE_SHOW_EDITORBAR_LOCALSTORAGE_KEY];
  } catch (e) {
    return false;
  }
};
var isntPrioritized = () => !isPrioritized();
var getServerSnapshot = () => false;
var noOpSubscribe = () => () => {
};
function EditorBarLauncher({
  EditorBar,
  fast = false
}) {
  const libraryFeatures = useLibraryFeatures();
  const framerSiteId = useContext25(FormContext);
  const enabled = useSyncExternalStore2(noOpSubscribe, fast ? isPrioritized : isntPrioritized, getServerSnapshot);
  const editorBarFeatures = useMemo15(() => {
    const features = {};
    let key7;
    for (key7 in libraryFeatures) {
      if (libraryFeatures.hasOwnProperty(key7) && (key7.startsWith("editorBar") || key7.startsWith("onPage"))) {
        features[key7] = libraryFeatures[key7];
      }
    }
    return features;
  }, [libraryFeatures]);
  if (!EditorBar || !framerSiteId || !enabled) return null;
  return /* @__PURE__ */ jsx64(IgnoreErrors, { children: /* @__PURE__ */ jsx64(Suspense4, { children: /* @__PURE__ */ jsx64(EditorBar, { framerSiteId, features: editorBarFeatures }) }) });
}

// ../../library/src/modules/custom-code/useLoadSnippets.ts
import { useCallback as useCallback16 } from "react";

// ../../library/src/modules/custom-code/context.tsx
import React67 from "react";
import { jsx as jsx65 } from "react/jsx-runtime";
var SnippetsContext = /* @__PURE__ */ (() => React67.createContext(void 0))();
function SnippetsProvider({
  children,
  loadSnippetsModule
}) {
  return /* @__PURE__ */ jsx65(SnippetsContext.Provider, { value: loadSnippetsModule, children });
}
function useSnippets() {
  return React67.useContext(SnippetsContext);
}

// ../../shared/src/custom-code/markers.ts
function getSnippetMarkers(id) {
  return {
    start: `<!-- Snippet: ${id} -->`,
    end: `<!-- SnippetEnd: ${id} -->`
  };
}

// ../../library/src/modules/custom-code/markers.ts
function findMarkers(placement) {
  let startMarker;
  let endMarker;
  switch (placement) {
    case "bodyStart":
      startMarker = startOfBodyStartMarker;
      endMarker = endOfBodyStartMarker;
      break;
    case "bodyEnd":
      startMarker = startOfBodyEndMarker;
      endMarker = endOfBodyEndMarker;
      break;
    case "headStart":
      startMarker = startOfHeadStartMarker;
      endMarker = endOfHeadStartMarker;
      break;
    case "headEnd":
      startMarker = startOfHeadEndMarker;
      endMarker = endOfHeadEndMarker;
      break;
  }
  const element = placement === "bodyStart" || placement === "bodyEnd" ? document.body : document.head;
  let start = null;
  let end = null;
  for (const node of element.childNodes) {
    if (node.nodeType !== Node.COMMENT_NODE) {
      continue;
    }
    const comment = `<!--${node.nodeValue}-->`;
    if (comment === startMarker) {
      start = node;
    } else if (comment === endMarker) {
      end = node;
    }
  }
  return { start, end };
}
function findSnippetMarkerNodes(snippetId, startMarker, endMarker) {
  if (!startMarker || !endMarker) {
    return { start: null, end: null };
  }
  let start = null;
  let end = null;
  const { start: startComment, end: endComment } = getSnippetMarkers(snippetId);
  let node = startMarker.nextSibling;
  while (node && node !== endMarker) {
    if (node.nodeType !== Node.COMMENT_NODE) {
      node = node.nextSibling;
      continue;
    }
    const comment = `<!--${node.nodeValue}-->`;
    if (comment === startComment) {
      start = node;
    } else if (comment === endComment) {
      end = node;
      break;
    }
    node = node.nextSibling;
  }
  return { start, end };
}

// ../../library/src/modules/custom-code/loadSnippets.ts
async function loadSnippets(placement, snippets, sorting) {
  if (snippets.length === 0) return;
  const { start, end } = findMarkers(placement);
  const placementParent = placement === "bodyStart" || placement === "bodyEnd" ? document.body : document.head;
  for (const snippet of snippets) {
    const { start: startSnippetMarker, end: endSnippetMarker } = findSnippetMarkerNodes(snippet.id, start, end);
    const isLoaded = startSnippetMarker && endSnippetMarker;
    if (isLoaded && snippet.loadMode === "once") {
      continue;
    }
    removeSnippetElements(startSnippetMarker, endSnippetMarker);
    if (isLoaded) {
      await insertHTML(snippet.code, endSnippetMarker, "beforebegin");
      continue;
    }
    const { start: codeStart, end: codeEnd } = getSnippetMarkers(snippet.id);
    const code = `${codeStart}
${snippet.code}
${codeEnd}`;
    const insertReference = findInsertReferece(snippet.id, sorting, start, end);
    if (insertReference) {
      await insertHTML(code, insertReference, "afterend");
    } else {
      const node = start ?? placementParent;
      const position = start ? "afterend" : "beforeend";
      await insertHTML(code, node, position);
    }
  }
}
function removeSnippetElements(start, end) {
  if (!start || !end) return;
  let node = start.nextSibling;
  while (node && node !== end) {
    const nextNode = node.nextSibling;
    if (isRemovableNode(node)) {
      node.remove();
    }
    node = nextNode;
  }
}
function isRemovableNode(node) {
  if (node.nodeType !== Node.ELEMENT_NODE) return true;
  if (node.nodeName === "SCRIPT") {
    const script = node;
    const type = script.type;
    if (!type || type === "text/javascript" || type === "module") return false;
  }
  return true;
}
function findInsertReferece(snippetId, sorting, start, end) {
  const startIndex = sorting.indexOf(snippetId) - 1;
  if (startIndex < 0) return null;
  for (let i = startIndex; i >= 0; i--) {
    const item = sorting[i];
    if (!item) continue;
    const reference = findSnippetMarkerNodes(item, start, end).end;
    if (reference) return reference;
  }
  return null;
}

// ../../library/src/modules/custom-code/useLoadSnippets.ts
function useLoadSnippets() {
  const loadSnippetsModule = useSnippets();
  const { customCodeSiteSettings } = useLibraryFeatures();
  return useCallback16(
    async (pageId, pathVariables, activeLocale, isInitialNavigation) => {
      if (!customCodeSiteSettings) return;
      if (!loadSnippetsModule) return;
      const mainTag = document.getElementById(mainTagId);
      const isGeneratedPage = mainTag && mainTag.dataset[generatedPageDatasetKey] !== void 0;
      if (isInitialNavigation && isGeneratedPage) return;
      const { getSnippets, snippetsSorting } = await loadSnippetsModule.readMaybeAsync();
      const snippets = await getSnippets(pageId, pathVariables, activeLocale);
      for (const key7 in snippets) {
        const placement = key7;
        const snippetsForPlacement = snippets[placement];
        const sorting = snippetsSorting[placement];
        await loadSnippets(placement, snippetsForPlacement, sorting);
      }
    },
    [loadSnippetsModule, customCodeSiteSettings]
  );
}

// ../../library/src/router/isSamePage.ts
function isSamePage(a, b) {
  if (a.routeId !== b.routeId) return false;
  if (a.pathVariables === b.pathVariables) return true;
  const aPathVariables = a.pathVariables || {};
  const bPathVariables = b.pathVariables || {};
  return aPathVariables.length === bPathVariables.length && Object.keys(aPathVariables).every((key7) => aPathVariables[key7] === bPathVariables[key7]);
}

// ../../library/src/router/pageAnalytics.ts
import { useContext as useContext26, useEffect as useEffect18, useRef as useRef19 } from "react";
var timezone = null;
var visitorLocale = null;
function setTimezoneAndLocaleForTracking() {
  const resolvedDateTimeOptions = Intl.DateTimeFormat().resolvedOptions();
  timezone = resolvedDateTimeOptions.timeZone;
  visitorLocale = resolvedDateTimeOptions.locale;
}
requestIdleCallback(setTimezoneAndLocaleForTracking);
var useSendPageView = (currentRoute, currentRouteId, currentPathnameWithHash, currentPathVariables, activeLocale) => {
  const framerSiteId = useContext26(FormContext);
  const pageviewEventData = useRef19();
  const collectionUtils = useCollectionUtils();
  const skipFirstPageView = useRef19(true);
  useEffect18(() => {
    function getFullPageviewEventData() {
      if (!timezone || !visitorLocale) setTimezoneAndLocaleForTracking();
      const currentLocation = currentPathnameWithHash ? new URL(safeWindow.location.origin + currentPathnameWithHash) : safeWindow.location;
      const eventData = {
        version: pageviewEventVersion,
        abTestId: currentRoute?.abTestId,
        framerSiteId: framerSiteId ?? null,
        // If we are in a variant route, let's use the variant ID as the route ID instead, so that the analytics panel will be able to show the correct tracking data.
        webPageId: currentRoute?.abTestingVariantId ?? currentRouteId,
        routePath: currentRoute?.path || "/",
        collectionItemId: null,
        framerLocale: activeLocale?.code || null,
        referrer: null,
        // The first pageview event will always be sent before hydration, in a script in `exportToHTML.ts`.
        url: currentLocation.href,
        hostname: currentLocation.hostname,
        // Capture the current location before the user moves to a new page to prevent
        // tracking wrong pathnames due to a race condition caused by async operations
        // when resolving the collection item ID below
        pathname: currentLocation.pathname,
        search: currentLocation.search || null,
        hash: currentLocation.hash || null,
        timezone,
        locale: visitorLocale
      };
      return currentRoute?.collectionId && currentPathVariables ? (async () => {
        let collectionItemId = null;
        const utils = currentRoute.collectionId && collectionUtils?.get(currentRoute.collectionId);
        const [slug] = Object.values(currentPathVariables);
        if (utils && isString(slug)) {
          const maybeCollectionItemId = utils.getRecordIdBySlug(slug, activeLocale || void 0);
          const _collectionItemId = isPromise(maybeCollectionItemId) ? await maybeCollectionItemId : maybeCollectionItemId;
          collectionItemId = _collectionItemId ?? null;
        }
        return { ...eventData, collectionItemId };
      })() : eventData;
    }
    void (async () => {
      const eventDataOrPromise = pageviewEventData.current = getFullPageviewEventData();
      const eventData = eventDataOrPromise instanceof Promise ? await eventDataOrPromise : eventDataOrPromise;
      pageviewEventData.current = eventData;
      if (skipFirstPageView.current) {
        skipFirstPageView.current = false;
      } else {
        sendTrackingEvent("published_site_pageview", eventData, "eager");
      }
    })();
    const listener = async (event) => {
      if (event.persisted) {
        const eventDataOrPromise = pageviewEventData.current = getFullPageviewEventData();
        const eventData = eventDataOrPromise instanceof Promise ? await eventDataOrPromise : eventDataOrPromise;
        pageviewEventData.current = eventData;
        sendTrackingEvent("published_site_pageview", eventData, "eager");
      }
    };
    window.addEventListener("pageshow", listener);
    return () => {
      window.removeEventListener("pageshow", listener);
    };
  }, [
    currentRoute,
    currentRouteId,
    currentPathnameWithHash,
    currentPathVariables,
    activeLocale,
    framerSiteId,
    collectionUtils
  ]);
  return pageviewEventData;
};

// ../../library/src/router/useForceUpdate.ts
import React68 from "react";
function useForceUpdate3() {
  const [_, setForcedRenderCount] = React68.useState(0);
  return [_, React68.useCallback(() => setForcedRenderCount((v) => v + 1), [])];
}

// ../../library/src/router/Router.tsx
import { jsx as jsx66, jsxs as jsxs15 } from "react/jsx-runtime";
function updateScrollPosition(hash2, smoothScroll, isHistoryTransition) {
  const element = hash2 && document.getElementById(hash2);
  if (element) {
    scrollElementIntoView(element, smoothScroll);
    return;
  }
  if (isHistoryTransition) return;
  window.scrollTo(0, 0);
}
function useScheduleRenderSideEffects(dep) {
  const actions = useRef20([]);
  useLayoutEffect7(() => {
    if (!actions.current?.length) return;
    actions.current.forEach((action) => action());
    actions.current = [];
  }, [dep]);
  return useCallback17((cb) => {
    actions.current.push(cb);
  }, []);
}
function executeBeforeUrlUpdateOnce(beforeUrlUpdate) {
  if (!beforeUrlUpdate) return noop2;
  let beforeUrlUpdateExecuted = false;
  return () => {
    if (beforeUrlUpdateExecuted) return;
    beforeUrlUpdateExecuted = true;
    beforeUrlUpdate?.();
  };
}
function useNavigationTransition() {
  const startNativeSpinner = useNativeLoadingSpinner();
  const navigationController = useRef20(void 0);
  return useCallback17(
    async (transitionFn, nextRender, updateURL, isAbortable = true) => {
      const hasUpdateURL = updateURL !== void 0;
      navigationController.current?.abort();
      const controller = isAbortable ? new AbortController() : void 0;
      navigationController.current = controller;
      const signal = controller?.signal;
      const stopMonitoringINPRelatedInputs = monitorINPRelatedInputs(signal);
      void nextRender.promise.finally(stopMonitoringINPRelatedInputs);
      if (!hasUpdateURL) {
        navigationController.current = void 0;
        transitionFn(signal);
        return nextRender.promise;
      }
      transitionFn(signal);
      let resolveNavigationPromise;
      const navigationPromise = new Promise((resolve, reject) => {
        resolveNavigationPromise = resolve;
        signal?.addEventListener("abort", reject);
      }).catch(noop2);
      startNativeSpinner(navigationPromise, updateURL, controller);
      await nextRender.promise;
      if (signal?.aborted) return;
      const navigationTransition = window.navigation?.transition;
      resolveNavigationPromise();
      try {
        await navigationTransition?.finished;
      } catch (error) {
        console.error("Navigation transition failed", error);
      }
      if (signal?.aborted) return;
      announceNavigation();
    },
    [startNativeSpinner]
  );
}
function Router({
  defaultPageStyle,
  disableHistory,
  initialPathVariables,
  initialRoute,
  notFoundPage,
  collectionUtils,
  routes,
  initialLocaleId,
  locales = EMPTY_ARRAY,
  preserveQueryParams = false,
  LayoutTemplate,
  EditorBar,
  siteCanonicalURL,
  adaptLayoutToTextDirection
}) {
  useMarkRouterEffects();
  useReplaceInitialState({
    disabled: disableHistory,
    routeId: initialRoute,
    initialPathVariables,
    initialLocaleId
  });
  const startViewTransition2 = useViewTransition();
  const [dep, forceUpdate] = useForceUpdate3();
  const scheduleSideEffect = useScheduleRenderSideEffects(dep);
  const startNavigation = useNavigationTransition();
  const monitorNextPaintAfterRender = useMonitorNextPaintAfterRender("framer-route-change");
  const { synchronousNavigationOnDesktop } = useLibraryFeatures();
  const transitionFn = useMemo16(() => {
    if (!synchronousNavigationOnDesktop || !isDesktop()) {
      return startTransition5;
    }
    return (fn) => fn();
  }, [synchronousNavigationOnDesktop]);
  const loadSnippets2 = useLoadSnippets();
  const isInitialNavigationRef = useRef20(true);
  const currentPathnameWithHashRef = useRef20();
  const currentRouteRef = useRef20(initialRoute);
  const currentPathVariablesRef = useRef20(initialPathVariables);
  const currentLocaleIdRef = useRef20(initialLocaleId);
  const currentLocaleId = currentLocaleIdRef.current;
  const activeLocale = useMemo16(() => {
    return locales.find(({ id }) => {
      if (!currentLocaleId) return id === defaultLocaleId;
      return id === currentLocaleId;
    }) ?? null;
  }, [currentLocaleId, locales]);
  const textDirection = activeLocale?.textDirection ?? "ltr";
  const layoutDirection = adaptLayoutToTextDirection ? textDirection : "ltr";
  useLayoutEffect7(() => {
    if (!adaptLayoutToTextDirection) return;
    document.documentElement.setAttribute("dir", textDirection);
  }, [textDirection, adaptLayoutToTextDirection]);
  const switchLocale2 = useSwitchLocale();
  const localeInfo = useMemo16(() => {
    return {
      activeLocale,
      locales,
      setLocale: async (localeOrLocaleId) => {
        const nextRender = monitorNextPaintAfterRender({
          localized: true
        });
        await yieldToMain({ priority: "user-blocking", continueAfter: "paint" });
        let localeId;
        if (isString(localeOrLocaleId)) {
          localeId = localeOrLocaleId;
        } else if (isObject2(localeOrLocaleId)) {
          localeId = localeOrLocaleId.id;
        }
        const defaultLocale = locales.find(({ id }) => id === defaultLocaleId);
        const nextLocale = locales.find(({ id }) => id === localeId);
        if (!nextLocale) return;
        const currentRouteId2 = currentRouteRef.current;
        const currentRoute2 = routes[currentRouteId2];
        if (!currentRoute2) return;
        try {
          const localeResult = await switchLocale2({
            currentLocale: activeLocale,
            nextLocale,
            route: currentRoute2,
            routeId: currentRouteId2,
            defaultLocale,
            pathVariables: currentPathVariablesRef.current,
            preserveQueryParams
          });
          if (!localeResult) return;
          const currentStatePaginationInfo = isHistoryState(window.history.state) ? window.history.state.paginationInfo : void 0;
          const currentPath = localeResult.path;
          isInitialNavigationRef.current = false;
          currentPathVariablesRef.current = localeResult.pathVariables;
          currentLocaleIdRef.current = nextLocale.id;
          const updateURL = async (ignorePushStateWrapper = false) => {
            if (!currentPath) return;
            return pushHistoryState(
              {
                routeId: currentRouteId2,
                pathVariables: localeResult.pathVariables,
                localeId: nextLocale.id,
                paginationInfo: currentStatePaginationInfo
              },
              currentPath,
              ignorePushStateWrapper
            );
          };
          void startNavigation(
            () => {
              void startViewTransition2(
                currentRouteId2,
                currentRouteId2,
                () => transitionFn(forceUpdate)
                // no signal here, because we update the refs above immediately
              );
            },
            nextRender,
            updateURL,
            false
          );
        } catch {
        }
      }
    };
  }, [
    activeLocale,
    forceUpdate,
    locales,
    preserveQueryParams,
    routes,
    startNavigation,
    startViewTransition2,
    monitorNextPaintAfterRender,
    transitionFn,
    switchLocale2
  ]);
  const setCurrentRouteId = useCallback17(
    (routeId, localeId, hash2, pathnameWithHash, pathVariables, isHistoryTransition, nextRender, smoothScroll = false, updateURL) => {
      isInitialNavigationRef.current = false;
      const currentRouteId2 = currentRouteRef.current;
      currentRouteRef.current = routeId;
      currentPathVariablesRef.current = pathVariables;
      currentLocaleIdRef.current = localeId;
      currentPathnameWithHashRef.current = pathnameWithHash;
      scheduleSideEffect(() => {
        updateScrollPosition(hash2, smoothScroll, isHistoryTransition);
      });
      if (isHistoryTransition) {
        transitionFn(forceUpdate);
        return;
      }
      void startNavigation(
        (signal) => {
          void startViewTransition2(currentRouteId2, routeId, () => transitionFn(forceUpdate), signal);
        },
        nextRender,
        updateURL,
        true
      );
    },
    [forceUpdate, scheduleSideEffect, startNavigation, startViewTransition2, transitionFn]
  );
  usePopStateHandler(currentRouteRef, setCurrentRouteId);
  const navigate = useCallback17(
    async (routeId, hash2, pathVariables, smoothScroll, beforeUrlUpdate) => {
      const newRoute = routes[routeId];
      const routeStatus = isLazyComponentType(newRoute?.page) ? newRoute.page.getStatus() : void 0;
      const hasRendered = routeStatus?.hasRendered;
      const nextRender = monitorNextPaintAfterRender({
        cached: hasRendered,
        preloaded: hasRendered ? void 0 : routeStatus?.hasLoaded
      });
      const executeBeforeUrlUpdate = executeBeforeUrlUpdateOnce(beforeUrlUpdate);
      void yieldToMain({ priority: "background", ensureContinueBeforeUnload: true, continueAfter: "paint" }).then(
        executeBeforeUrlUpdate
      );
      await yieldToMain({ priority: "user-blocking", continueAfter: "paint" });
      if (pathVariables) {
        const inUse = /* @__PURE__ */ new Set();
        const path = newRoute?.path ?? "/";
        for (const match of path.matchAll(pathVariablesRegExp)) {
          const usedVariable = match[1];
          if (usedVariable === void 0) {
            throw new Error("A matching path variable should not be undefined");
          }
          inUse.add(usedVariable);
        }
        pathVariables = Object.fromEntries(Object.entries(pathVariables).filter(([key7]) => inUse.has(key7)));
      }
      const routeElementId = getRouteElementId(newRoute, hash2);
      const currentPathVariables2 = currentPathVariablesRef.current;
      const currentRouteLocaleId = currentLocaleIdRef.current;
      if (isSamePage(
        { routeId: currentRouteRef.current, pathVariables: currentPathVariables2 },
        { routeId, pathVariables }
      )) {
        nextRender.ignore?.();
        const route = routes[routeId];
        if (window.history.state?.hash !== hash2 && !disableHistory && route) {
          executeBeforeUrlUpdate();
          await pushRouteState(routeId, route, {
            currentRoutePath: route.path,
            currentPathVariables: currentPathVariables2,
            pathVariables,
            hash: hash2,
            localeId: currentRouteLocaleId,
            preserveQueryParams,
            siteCanonicalURL,
            currentRoutePathLocalized: route.pathLocalized
          });
        }
        updateScrollPosition(routeElementId, smoothScroll, false);
        return;
      }
      if (!newRoute) return;
      const currentRoute2 = routes[currentRouteRef.current];
      const updateURL = async (ignorePushStateWrapper = false) => {
        executeBeforeUrlUpdate();
        return pushRouteState(
          routeId,
          newRoute,
          {
            currentRoutePath: currentRoute2?.path,
            currentPathVariables: currentPathVariables2,
            currentRoutePathLocalized: currentRoute2?.pathLocalized,
            hash: hash2,
            pathVariables,
            localeId: currentRouteLocaleId,
            preserveQueryParams,
            siteCanonicalURL
          },
          ignorePushStateWrapper
        );
      };
      const pathnameWithHash = getSitePrefix(siteCanonicalURL) + getPathForRoute(newRoute, {
        currentRoutePath: currentRoute2?.path,
        currentRoutePathLocalized: currentRoute2?.pathLocalized,
        currentPathVariables: currentPathVariables2,
        hash: hash2,
        pathVariables,
        localeId: currentRouteLocaleId,
        preserveQueryParams,
        siteCanonicalURL,
        relative: false
        // We need an absolute path for the hash
      });
      setCurrentRouteId(
        routeId,
        currentRouteLocaleId,
        routeElementId,
        pathnameWithHash,
        pathVariables,
        false,
        nextRender,
        smoothScroll,
        disableHistory ? void 0 : updateURL
      );
    },
    [routes, setCurrentRouteId, disableHistory, preserveQueryParams, siteCanonicalURL, monitorNextPaintAfterRender]
  );
  const getRoute = useGetRouteCallback(routes);
  const currentRouteId = currentRouteRef.current;
  const currentPathnameWithHash = currentPathnameWithHashRef.current;
  const currentPathVariables = currentPathVariablesRef.current;
  const currentRoute = routes[currentRouteId];
  const currentRoutePath = currentRoute?.path;
  const pageviewEventData = useSendPageView(
    currentRoute,
    currentRouteId,
    currentPathnameWithHash,
    currentPathVariables,
    activeLocale
  );
  const isInitialNavigation = isInitialNavigationRef.current;
  useEffect19(() => {
    void loadSnippets2(
      currentRouteId,
      currentPathVariables ?? {},
      localeInfo.activeLocale?.code || null,
      isInitialNavigation
    );
  }, [loadSnippets2, currentRouteId, currentPathVariables, localeInfo, isInitialNavigation]);
  const api = useMemo16(
    () => ({
      navigate,
      getRoute,
      currentRouteId,
      currentPathVariables,
      routes,
      collectionUtils,
      preserveQueryParams,
      pageviewEventData,
      siteCanonicalURL,
      isInitialNavigation
    }),
    [
      navigate,
      getRoute,
      currentRouteId,
      currentPathVariables,
      routes,
      collectionUtils,
      preserveQueryParams,
      siteCanonicalURL,
      pageviewEventData,
      isInitialNavigation
    ]
  );
  if (!currentRoute) {
    throw new Error(`Router cannot find route for ${currentRouteId}`);
  }
  const pageExistsInCurrentLocale = !activeLocale || !currentRoute.includedLocales || currentRoute.includedLocales.includes(activeLocale.id);
  const pathWithFilledVariables = currentRoutePath && currentPathVariables ? fillPathVariables(currentRoutePath, currentPathVariables) : currentRoutePath;
  const remountKey = String(currentLocaleId) + pathWithFilledVariables;
  const templatePageStyle = useConstant(() => ({ ...defaultPageStyle, display: "contents" }));
  return /* @__PURE__ */ jsx66(RouterAPIProvider, { api, children: /* @__PURE__ */ jsx66(LocaleInfoContext.Provider, { value: localeInfo, children: /* @__PURE__ */ jsx66(LayoutDirectionContext.Provider, { value: layoutDirection, children: /* @__PURE__ */ jsxs15(URLSearchParamsProvider, { children: [
    EditorBar && /* @__PURE__ */ jsx66(EditorBarLauncher, { EditorBar, fast: true }),
    /* @__PURE__ */ jsx66(SynchronousSuspenseErrorBoundary, { children: /* @__PURE__ */ jsxs15(SuspenseThatPreservesDom, { children: [
      /* @__PURE__ */ jsxs15(
        NotFoundErrorBoundary,
        {
          notFoundPage,
          defaultPageStyle,
          forceUpdateKey: dep,
          children: [
            /* @__PURE__ */ jsx66(MarkSuspenseEffects.Start, {}),
            /* @__PURE__ */ jsx66(
              WithLayoutTemplate,
              {
                LayoutTemplate,
                webPageId: currentRoute?.abTestingVariantId ?? currentRouteId,
                style: defaultPageStyle,
                children: (inLayoutTemplate) => {
                  return /* @__PURE__ */ jsx66(Fragment10, { children: pageExistsInCurrentLocale ? renderPage(
                    currentRoute.page,
                    inLayoutTemplate ? templatePageStyle : defaultPageStyle
                  ) : (
                    // LAYOUT_TEMPLATE @TODO: display: content for not found page?
                    notFoundPage && renderPage(notFoundPage, defaultPageStyle)
                  ) }, remountKey);
                }
              }
            )
          ]
        }
      ),
      EditorBar && /* @__PURE__ */ jsx66(EditorBarLauncher, { EditorBar }),
      /* @__PURE__ */ jsx66(TurnOnReactEventHandling, {}),
      /* @__PURE__ */ jsx66(MarkSuspenseEffects.End, {})
    ] }) })
  ] }) }) }) });
}
function WithLayoutTemplate({ LayoutTemplate, webPageId, style, children }) {
  if (!LayoutTemplate) return children(false);
  return /* @__PURE__ */ jsx66(LayoutTemplate, { webPageId, style, children });
}
function scrollElementIntoView(element, smoothScroll) {
  const scrollIntoViewOptions = smoothScroll ? { behavior: "smooth", block: "start", inline: "nearest" } : void 0;
  element.scrollIntoView(scrollIntoViewOptions);
}

// ../../library/src/modules/FetchClient.tsx
import * as React69 from "react";

// ../../library/src/render/utils/preloadImage.ts
function preloadImage(url) {
  return new Promise((resolve, reject) => {
    try {
      new URL(url);
      const image = new Image();
      image.onload = () => resolve();
      image.onerror = reject;
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}

// ../../library/src/utils/getPropertyByPath.ts
function isObjectOrArray(value) {
  return typeof value === "object" && value !== null;
}
function getPropertyByPath(input, keyPath) {
  if (keyPath === "") {
    return input;
  }
  const keyParts = keyPath.split(/[.[\]]+/u).filter((part) => part.length > 0);
  let current = input;
  for (const part of keyParts) {
    if (!isObjectOrArray(current)) {
      return void 0;
    }
    current = current[part];
  }
  return current;
}

// ../../library/src/modules/FetchClient.tsx
import { jsx as jsx67 } from "react/jsx-runtime";
function getRequestCacheKey(value) {
  return `${value.credentials}:${value.url}`;
}
var loadingFetchResult = {
  status: "loading",
  data: void 0
};
function isNumberString(value) {
  return isString(value) && !Number.isNaN(Number(value));
}
function isValidFetchDataValueResult(type, value) {
  switch (type) {
    case "string" /* String */:
      return isString(value) || isNumber(value);
    case "color" /* Color */:
      return isString(value);
    case "boolean" /* Boolean */:
      return isBoolean(value);
    case "number" /* Number */:
      return isNumber(value) || isNumberString(value);
    case "link" /* Link */:
    case "image" /* Image */:
      return isString(value) && isValidURL(value, false);
    default: {
      const _ = type;
      return false;
    }
  }
}
function resolveFetchDataValue(result, request) {
  if (result.status === "loading") {
    return request.fallbackValue;
  }
  if (result.status === "error") {
    throw result.error;
  }
  const resolvedValue = getPropertyByPath(result.data, request.resultKeyPath);
  if (isUndefined(resolvedValue)) {
    throw new Error(`Key '${request.resultKeyPath}' not found in response`);
  }
  if (!isValidFetchDataValueResult(request.resultOutputType, resolvedValue)) {
    throw new Error(`Resolved value '${resolvedValue}' is not valid for type '${request.resultOutputType}'`);
  }
  return resolvedValue;
}
var minimumCacheDurationMs = 5e3;
function isCacheExpired(insertionTimestamp, cacheDuration) {
  if (RenderTarget.current() === RenderTarget.canvas) {
    return false;
  }
  const cacheDurationMs = Math.max(cacheDuration * 1e3, minimumCacheDurationMs);
  const currentTimestamp = Date.now();
  const expirationTimestamp = insertionTimestamp + cacheDurationMs;
  return currentTimestamp >= expirationTimestamp;
}
var noop4 = () => {
};
var _subscribers, _preloadedRequests, _shortestCacheDurations, _cachedAt, _ongoingFetches, _staleQueriesInterval;
var _FetchClient = class _FetchClient {
  constructor() {
    // A map of FetchResult values for each URL
    __publicField(this, "responseValues", /* @__PURE__ */ new Map());
    // A map of URLs to their subscribers
    __privateAdd(this, _subscribers, /* @__PURE__ */ new Map());
    // A set of requests that have been preloaded by a loading variant
    __privateAdd(this, _preloadedRequests, /* @__PURE__ */ new Set());
    // Map for how long to cache the response for (in seconds)
    __privateAdd(this, _shortestCacheDurations, /* @__PURE__ */ new Map());
    // Map containing a timestamp when a URL was inserted into the cache
    __privateAdd(this, _cachedAt, /* @__PURE__ */ new Map());
    // Map of promises for requests that are currently in flight
    __privateAdd(this, _ongoingFetches, /* @__PURE__ */ new Map());
    // An ID for an interval that checks for stale queries and refetches
    __privateAdd(this, _staleQueriesInterval, /* @__PURE__ */ new Map());
    __publicField(this, "persistCache", debounce2(() => {
      const data2 = {};
      for (const [url, responseValue] of this.responseValues) {
        if (!responseValue) continue;
        if (responseValue.status !== "success") continue;
        const cacheConfig = __privateGet(this, _shortestCacheDurations).get(url);
        if (!cacheConfig || cacheConfig === 0) continue;
        const storedAt = __privateGet(this, _cachedAt).get(url);
        if (!storedAt) continue;
        if (storedAt && isCacheExpired(storedAt, cacheConfig)) {
          continue;
        }
        data2[url] = [storedAt, cacheConfig, responseValue.data];
      }
      try {
        localStorage.setItem(_FetchClient.cacheKey, JSON.stringify(data2));
      } catch {
      }
    }, 500));
  }
  unmount() {
    for (const [key7, interval] of __privateGet(this, _staleQueriesInterval)) {
      clearInterval(interval);
      __privateGet(this, _staleQueriesInterval).delete(key7);
    }
  }
  stopQueryRefetching(request) {
    const cacheKey = getRequestCacheKey(request);
    const interval = __privateGet(this, _staleQueriesInterval).get(cacheKey);
    if (interval) {
      clearInterval(interval);
      __privateGet(this, _staleQueriesInterval).delete(cacheKey);
    }
  }
  /**
   * Start an interval for the given request to refresh the value
   * depending on the shortest configured cache duration for that request.
   */
  startQueryRefetching(request) {
    const cacheKey = getRequestCacheKey(request);
    const currentIntervalForRequest = __privateGet(this, _staleQueriesInterval).get(cacheKey);
    const shortestCacheDuration = __privateGet(this, _shortestCacheDurations).get(cacheKey);
    if (currentIntervalForRequest) return;
    if (!shortestCacheDuration) return;
    const interval = safeWindow.setInterval(() => {
      if (document.visibilityState === "hidden") return;
      const cachedAt = __privateGet(this, _cachedAt).get(cacheKey);
      if (!shortestCacheDuration || !cachedAt) return;
      void this.fetchWithCache({
        ...request,
        cacheDuration: shortestCacheDuration
      });
    }, shortestCacheDuration);
    __privateGet(this, _staleQueriesInterval).set(cacheKey, interval);
  }
  hydrateCache() {
    try {
      const rawData = localStorage.getItem(_FetchClient.cacheKey);
      if (!rawData) return;
      const data2 = JSON.parse(rawData);
      if (typeof data2 !== "object") throw new Error("Invalid cache data");
      for (const cacheKey in data2) {
        const cached = data2[cacheKey];
        if (!Array.isArray(cached) || cached.length !== 3) throw new Error("Invalid cache data");
        const [storedAt, cacheDuration, cachedData] = cached;
        if (isCacheExpired(storedAt, cacheDuration)) continue;
        __privateGet(this, _cachedAt).set(cacheKey, storedAt);
        __privateGet(this, _shortestCacheDurations).set(cacheKey, cacheDuration);
        this.responseValues.set(cacheKey, { status: "success", data: cachedData });
      }
    } catch (error) {
      try {
        localStorage.removeItem(_FetchClient.cacheKey);
      } catch {
      }
    }
  }
  setResponseValue(cacheKey, value) {
    this.responseValues.set(cacheKey, value);
    this.persistCache();
    const subscribers = __privateGet(this, _subscribers).get(cacheKey);
    if (!subscribers) return;
    for (const subscriber of subscribers) {
      subscriber();
    }
  }
  async prefetch(request) {
    if (!isBrowser2()) return;
    if (!isValidURL(request.url, false)) return;
    const cacheKey = getRequestCacheKey(request);
    __privateGet(this, _preloadedRequests).add(cacheKey);
    await this.fetchWithCache(request);
    const result = this.getValue(cacheKey);
    if (!result || result.status === "loading") {
      throw new Error("Unexpected result status for prefetch");
    }
    const subscribers = __privateGet(this, _subscribers).get(cacheKey);
    for (const subscriber of subscribers ?? []) {
      subscriber();
    }
    const resolvedValue = resolveFetchDataValue(result, request);
    if (request.resultOutputType === "image" /* Image */ && isString(resolvedValue)) {
      await preloadImage(resolvedValue).catch(noop4);
    }
    return resolvedValue;
  }
  async fetchWithCache(request) {
    if (!isBrowser2()) return;
    const cacheKey = getRequestCacheKey(request);
    const ongoingFetch = __privateGet(this, _ongoingFetches).get(cacheKey);
    if (ongoingFetch) return ongoingFetch;
    const cachedAt = __privateGet(this, _cachedAt).get(cacheKey);
    const hasExpiredCache = cachedAt && isCacheExpired(cachedAt, request.cacheDuration);
    if (this.responseValues.has(cacheKey) && !hasExpiredCache) {
      return;
    }
    const currentValue = this.responseValues.get(cacheKey);
    if (!currentValue) {
      this.setResponseValue(cacheKey, loadingFetchResult);
    }
    const doFetch = async () => {
      try {
        const response = await fetch(request.url, {
          method: "GET",
          credentials: request.credentials
        });
        if (!response.ok) {
          this.setResponseValue(cacheKey, {
            status: "error",
            error: new Error("Invalid Response Status"),
            data: void 0
          });
          return;
        }
        const value = await response.json();
        this.setResponseValue(cacheKey, { status: "success", data: value });
        __privateGet(this, _cachedAt).set(cacheKey, Date.now());
      } catch (error) {
        this.setResponseValue(cacheKey, { status: "error", error, data: void 0 });
      }
    };
    const promise = doFetch();
    __privateGet(this, _ongoingFetches).set(cacheKey, promise);
    void promise.finally(() => {
      __privateGet(this, _ongoingFetches).delete(cacheKey);
    });
    return promise;
  }
  getValue(cacheKey, onlyIfPrefetched = false) {
    if (onlyIfPrefetched && !__privateGet(this, _preloadedRequests).has(cacheKey)) return void 0;
    return this.responseValues.get(cacheKey);
  }
  subscribe(request, callback, skipFetchRequest = false) {
    const { url, cacheDuration } = request;
    if (!isValidURL(url, false)) return noop4;
    const cacheKey = getRequestCacheKey(request);
    const cacheDurationForUrl = __privateGet(this, _shortestCacheDurations).get(cacheKey);
    if (!cacheDurationForUrl || cacheDuration < cacheDurationForUrl) {
      __privateGet(this, _shortestCacheDurations).set(cacheKey, cacheDuration);
    }
    if (!skipFetchRequest) {
      this.startQueryRefetching(request);
      void this.fetchWithCache(request);
    }
    const subscribers = __privateGet(this, _subscribers).get(cacheKey) ?? /* @__PURE__ */ new Set();
    subscribers.add(callback);
    __privateGet(this, _subscribers).set(cacheKey, subscribers);
    return () => {
      const nextSubscribers = __privateGet(this, _subscribers).get(cacheKey);
      if (!nextSubscribers) return;
      nextSubscribers.delete(callback);
      if (nextSubscribers.size === 0) {
        __privateGet(this, _subscribers).delete(cacheKey);
      }
      if (__privateGet(this, _subscribers).size === 0) {
        this.stopQueryRefetching(request);
      }
    };
  }
};
_subscribers = new WeakMap();
_preloadedRequests = new WeakMap();
_shortestCacheDurations = new WeakMap();
_cachedAt = new WeakMap();
_ongoingFetches = new WeakMap();
_staleQueriesInterval = new WeakMap();
__publicField(_FetchClient, "cacheKey", "framer-fetch-client-cache");
var FetchClient = _FetchClient;
var FetchClientContext = /* @__PURE__ */ React69.createContext(void 0);
var IsRestoringCacheContext = /* @__PURE__ */ React69.createContext(true);
var FetchClientProvider = ({
  children,
  client: initialClient
}) => {
  const [client] = React69.useState(() => initialClient ?? new FetchClient());
  const [isRestoring, setIsRestoring] = React69.useState(true);
  React69.useEffect(() => {
    client.hydrateCache();
    React69.startTransition(() => {
      setIsRestoring(false);
    });
    return () => client.unmount();
  }, [client]);
  return /* @__PURE__ */ jsx67(IsRestoringCacheContext.Provider, { value: isRestoring, children: /* @__PURE__ */ jsx67(FetchClientContext.Provider, { value: client, children }) });
};
var _subscriptions, _subscribers2, _results, _SSRResults, _onlyPrefetched;
var RequestsObserver = class {
  constructor(client, requests) {
    this.client = client;
    this.requests = requests;
    // a map of subscriptions on the FetchClient
    __privateAdd(this, _subscriptions, /* @__PURE__ */ new Map());
    // A set of subscribers to requests of the observer
    __privateAdd(this, _subscribers2, /* @__PURE__ */ new Set());
    // The results of the susbcribed requests
    __privateAdd(this, _results);
    // getServerSnapshot is also called on the Client while the tree is hydrating.
    // It is important to always return the same value or hydration warnings will occur.
    __privateAdd(this, _SSRResults);
    // When the RequestsObserver mounts we allow reading prefetched values.
    // This is to support Text FX on mount for requests that were prefetched.
    __privateAdd(this, _onlyPrefetched, true);
    __publicField(this, "updateResults", () => {
      const data2 = [];
      const statuses = /* @__PURE__ */ new Set();
      const errors = [];
      for (const request of this.requests) {
        const cachekey = getRequestCacheKey(request);
        const value = this.client.getValue(cachekey, __privateGet(this, _onlyPrefetched));
        if (!value) {
          statuses.add("loading");
          data2.push(request.fallbackValue);
          continue;
        }
        statuses.add(value.status);
        try {
          const resolvedValue = resolveFetchDataValue(value, request);
          data2.push(resolvedValue);
        } catch (error) {
          data2.push(!isUndefined(request.errorFallbackValue) ? request.errorFallbackValue : request.fallbackValue);
          errors.push(error);
        }
      }
      const status = statuses.has("error") ? "error" : statuses.has("loading") ? "loading" : "success";
      const result = { status, data: data2 };
      if (!isEqual(result, __privateGet(this, _results))) {
        __privateSet(this, _results, result);
        if (errors.length > 0 && !statuses.has("loading") && __privateGet(this, _subscribers2).size > 0) {
          console.error("Fetch failed: " + errors.join("\n"));
        }
      }
      for (const subscriber of __privateGet(this, _subscribers2)) {
        subscriber();
      }
    });
    __publicField(this, "subscribe", (callback) => {
      __privateGet(this, _subscribers2).add(callback);
      this.updateResults();
      return () => {
        __privateGet(this, _subscribers2).delete(callback);
      };
    });
    __publicField(this, "getServerResults", () => {
      return __privateGet(this, _SSRResults);
    });
    __publicField(this, "getResults", () => {
      return __privateGet(this, _results);
    });
    this.setRequests(requests, { onlyPrefetched: true });
    __privateSet(this, _SSRResults, { status: "loading", data: requests.map((request) => request.fallbackValue) });
    __privateSet(this, _results, __privateGet(this, _SSRResults));
  }
  setRequests(requests, { onlyPrefetched = false }) {
    const lastRequests = this.requests;
    this.requests = requests;
    const requestsByCacheKey = new Map(requests.map((request) => [getRequestCacheKey(request), request]));
    const nextSubscribedKeys = Array.from(requestsByCacheKey.keys());
    const hasOnlyPrefetchedChange = __privateGet(this, _onlyPrefetched) !== onlyPrefetched;
    if (!onlyPrefetched) __privateSet(this, _onlyPrefetched, false);
    const hasSubscriptionChange = nextSubscribedKeys.length !== __privateGet(this, _subscriptions).size || nextSubscribedKeys.some((url) => !__privateGet(this, _subscriptions).has(url));
    if (!hasSubscriptionChange && !hasOnlyPrefetchedChange) {
      if (!isEqual(lastRequests, requests)) {
        this.updateResults();
      }
      return;
    }
    for (const url of __privateGet(this, _subscriptions).keys()) {
      __privateGet(this, _subscriptions).get(url)?.();
      __privateGet(this, _subscriptions).delete(url);
    }
    for (const cacheKey of nextSubscribedKeys) {
      const requestConfig = requestsByCacheKey.get(cacheKey);
      if (!requestConfig) continue;
      const unsubscribe = this.client.subscribe(requestConfig, this.updateResults, onlyPrefetched);
      __privateGet(this, _subscriptions).set(cacheKey, unsubscribe);
    }
    if (__privateGet(this, _subscribers2).size === 0) return;
    this.updateResults();
  }
  unmount() {
    for (const unsubscribe of __privateGet(this, _subscribers2)) {
      unsubscribe();
    }
    for (const unsubscribe of __privateGet(this, _subscriptions).values()) {
      unsubscribe();
    }
  }
};
_subscriptions = new WeakMap();
_subscribers2 = new WeakMap();
_results = new WeakMap();
_SSRResults = new WeakMap();
_onlyPrefetched = new WeakMap();
function useFetchRequestsForChildren(requests, disabled, children) {
  const fetchClient = React69.useContext(FetchClientContext);
  if (!fetchClient) {
    throw new Error("useFetchRequest must be used within a FetchClientProvider");
  }
  const isRestoringCache = React69.useContext(IsRestoringCacheContext);
  const [observer] = React69.useState(() => new RequestsObserver(fetchClient, requests));
  React69.useLayoutEffect(() => {
    if (disabled) return;
    observer.setRequests(requests, { onlyPrefetched: false });
  }, [requests, observer, disabled]);
  React69.useEffect(() => {
    return () => observer.unmount();
  }, [observer]);
  const subscribe = React69.useCallback(
    (onChange) => {
      if (isRestoringCache || disabled) return noop4;
      return observer.subscribe(onChange);
    },
    [disabled, observer, isRestoringCache]
  );
  const synchronousData = React69.useSyncExternalStore(subscribe, observer.getResults, observer.getServerResults);
  const deferredData = React69.useDeferredValue(synchronousData);
  return useMemoOne(() => children(deferredData.data, deferredData.status), [deferredData, children]);
}
function usePrefetch() {
  const fetchClient = React69.useContext(FetchClientContext);
  if (!fetchClient) {
    throw new Error("useFetchRequest must be used within a FetchClientProvider");
  }
  return React69.useCallback((request) => fetchClient.prefetch(request), [fetchClient]);
}

// ../../library/src/modules/PageRoot.tsx
import { jsx as jsx68 } from "react/jsx-runtime";
MotionGlobalConfig.WillChange = WillChangeMotionValue;
function PageRoot({
  RootComponent,
  isWebsite,
  routeId,
  framerSiteId,
  pathVariables,
  routes,
  collectionUtils,
  notFoundPage,
  isReducedMotion = false,
  includeDataObserver = false,
  localeId,
  locales,
  preserveQueryParams,
  EditorBar,
  defaultPageStyle,
  disableHistory,
  LayoutTemplate,
  siteCanonicalURL,
  adaptLayoutToTextDirection,
  loadSnippetsModule
}) {
  React70.useEffect(() => {
    if (isWebsite) return;
    MainLoop.start();
  }, []);
  if (isWebsite) {
    return /* @__PURE__ */ jsx68(MotionConfig, { reducedMotion: isReducedMotion ? "user" : "never", children: /* @__PURE__ */ jsx68(CollectionUtilsCacheProvider, { collectionUtils, children: /* @__PURE__ */ jsx68(FetchClientProvider, { children: /* @__PURE__ */ jsx68(CustomCursorHost, { children: /* @__PURE__ */ jsx68(FormContext.Provider, { value: framerSiteId, children: /* @__PURE__ */ jsx68(SnippetsProvider, { loadSnippetsModule, children: /* @__PURE__ */ jsx68(
      Router,
      {
        initialRoute: routeId,
        initialPathVariables: pathVariables,
        initialLocaleId: localeId,
        routes,
        collectionUtils,
        notFoundPage,
        locales,
        defaultPageStyle: defaultPageStyle ?? { minHeight: "100vh", width: "auto" },
        preserveQueryParams,
        EditorBar,
        disableHistory,
        LayoutTemplate,
        siteCanonicalURL,
        adaptLayoutToTextDirection
      }
    ) }) }) }) }) }) });
  } else {
    const Wrapper = includeDataObserver ? DataObserver : React70.Fragment;
    return /* @__PURE__ */ jsx68(Wrapper, { children: /* @__PURE__ */ jsx68(RoutesProvider, { routes, children: /* @__PURE__ */ jsx68(NavigationWrapper, { children: React70.isValidElement(RootComponent) ? RootComponent : React70.createElement(
      // @ts-expect-error to figure out how to type this properly, as tests are using different
      // $$typeof symbol and isValidElement fails
      RootComponent,
      { key: routeId }
    ) }) }) });
  }
}

// ../../library/src/modules/ResolveLinks.tsx
import { forwardRef as forwardRef6 } from "react";
var ResolveLinks = /* @__PURE__ */ withChildrenCanSuspend(
  /* @__PURE__ */ forwardRef6(function ResolveLinksInner({ links, children, ...rest }, ref) {
    const router = useRouter();
    const { activeLocale } = useLocaleInfo();
    const cloneWithPropsAndRef = useCloneChildrenWithPropsAndRef(ref);
    const resolveSlugsWithSuspense2 = useResolveSlugsWithSuspense();
    const promises = [];
    const resolvedLinks = links.map((link) => {
      if (!link) return void 0;
      if (isString(link)) return resolveLinkInternal(link, router, void 0, void 0, activeLocale);
      return resolveLinkInternal(
        link.href,
        router,
        link.implicitPathVariables,
        link.refKey,
        activeLocale,
        (unresolvedPathSlugs, unresolvedHashSlugs) => {
          return resolveSlugsWithSuspense2(unresolvedPathSlugs, unresolvedHashSlugs, activeLocale, promises);
        }
      );
    });
    if (promises.length > 0) {
      throw Promise.allSettled(promises);
    }
    const childrenWithLinks = children(resolvedLinks);
    return cloneWithPropsAndRef(childrenWithLinks, rest);
  })
);

// ../../library/src/modules/Fetcher.tsx
import * as React71 from "react";
var Fetcher = /* @__PURE__ */ React71.forwardRef(function Fetcher2({ requests, disabled, children, ...rest }, ref) {
  const cloneWithPropsAndRef = useCloneChildrenWithPropsAndRef(ref);
  const childrenWithValues = useFetchRequestsForChildren(requests, disabled, children);
  return cloneWithPropsAndRef(childrenWithValues, rest);
});

// ../../library/src/modules/callEach.ts
var callEach = (...fns) => fns.forEach((fn) => fn && fn());

// ../../library/src/utils/getLogger.ts
function getLogger2(name) {
  return {
    trace(...args) {
      return runtime.getLogger(name)?.trace(...args);
    },
    debug(...args) {
      return runtime.getLogger(name)?.debug(...args);
    },
    info(...args) {
      return runtime.getLogger(name)?.info(...args);
    },
    warn(...args) {
      return runtime.getLogger(name)?.warn(...args);
    },
    error(...args) {
      return runtime.getLogger(name)?.error(...args);
    },
    get enabled() {
      return runtime.getLogger(name) !== void 0;
    }
  };
}

// ../../library/src/modules/cms/optimizer/Evaluate.ts
function evaluateSync(generator) {
  const state = generator.next();
  assert(state.done, "Generator must not yield");
  return state.value;
}
async function evaluateAsync(generator, state = generator.next()) {
  while (!state.done) {
    const value = await state.value;
    state = generator.next(value);
  }
  return state.value;
}
function evaluateMaybeAsync(generator) {
  const state = generator.next();
  if (state.done) return state.value;
  return evaluateAsync(generator, state);
}
function* evaluateObject(values) {
  const result = {};
  const keys3 = Object.keys(values);
  const promises = [];
  for (const key7 of keys3) {
    const generator = values[key7];
    if (isGenerator2(generator)) {
      const state = generator.next();
      if (state.done) {
        result[key7] = state.value;
      } else {
        promises.push(
          evaluateAsync(generator, state).then((value) => {
            result[key7] = value;
          })
        );
      }
    } else {
      result[key7] = generator;
    }
  }
  if (promises.length > 0) {
    yield Promise.all(promises);
  }
  return result;
}
function* evaluateArray(values) {
  const result = [];
  const keys3 = values.keys();
  const promises = [];
  for (const key7 of keys3) {
    const generator = values[key7];
    if (isGenerator2(generator)) {
      const state = generator.next();
      if (state.done) {
        result[key7] = state.value;
      } else {
        promises.push(
          evaluateAsync(generator, state).then((value) => {
            result[key7] = value;
          })
        );
      }
    } else {
      result[key7] = generator;
    }
  }
  if (promises.length > 0) {
    yield Promise.all(promises);
  }
  return result;
}

// ../../library/src/modules/cms/types.ts
function isAnyCollection(value) {
  return isAnyLegacyCollection(value) || isAnyDatabaseCollection(value);
}
function isLegacyCollection(value) {
  return isArray(value) && value.every(isObject2);
}
function isLegacyLocalizedCollection(value) {
  return isObject2(value) && isFunction(value.read) && isFunction(value.preload);
}
function isAnyLegacyCollection(value) {
  return isLegacyCollection(value) || isLegacyLocalizedCollection(value);
}
function isDatabaseCollection(value) {
  return isObject2(value) && isObject2(value.schema);
}
function isLocalizedDatabaseCollection(value) {
  return isObject2(value) && isObject2(value.collectionByLocaleId);
}
function isAnyDatabaseCollection(value) {
  return isDatabaseCollection(value) || isLocalizedDatabaseCollection(value);
}

// ../../library/src/modules/cms/DatabaseValue.ts
function compareArray(left, right, collation11) {
  const leftLength = left.value.length;
  const rightLength = right.value.length;
  if (leftLength < rightLength) return -1;
  if (leftLength > rightLength) return 1;
  for (let i = 0; i < leftLength; i++) {
    const leftItem = left.value[i];
    const rightItem = right.value[i];
    const result = compare(leftItem, rightItem, collation11);
    if (result !== 0) return result;
  }
  return 0;
}
function castArray(value, definition) {
  switch (value?.type) {
    case "array" /* Array */: {
      const result = value.value.map((item) => {
        return DatabaseValue.cast(item, definition.definition);
      });
      return {
        type: "array" /* Array */,
        value: result
      };
    }
  }
  return null;
}
function compareBoolean(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function castBoolean(value) {
  switch (value?.type) {
    case "boolean" /* Boolean */: {
      return value;
    }
    case "number" /* Number */:
    case "string" /* String */: {
      return {
        type: "boolean" /* Boolean */,
        value: Boolean(value.value)
      };
    }
  }
  return null;
}
function valueToBoolean(value) {
  const cast = castBoolean(value);
  return cast?.value ?? false;
}
function compareColor(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function castColor(value) {
  switch (value?.type) {
    case "color" /* Color */: {
      return value;
    }
  }
  return null;
}
function compareDate(left, right) {
  const leftDate = new Date(left.value);
  const rightDate = new Date(right.value);
  if (leftDate < rightDate) return -1;
  if (leftDate > rightDate) return 1;
  return 0;
}
function castDate(value) {
  switch (value?.type) {
    case "date" /* Date */: {
      return value;
    }
    case "number" /* Number */:
    case "string" /* String */: {
      const date = new Date(value.value);
      if (isValidDate(date)) {
        return {
          type: "date" /* Date */,
          value: date.toISOString()
        };
      }
      return null;
    }
  }
  return null;
}
function compareEnum(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function castEnum(value) {
  switch (value?.type) {
    case "enum" /* Enum */: {
      return value;
    }
    case "string" /* String */: {
      return {
        type: "enum" /* Enum */,
        value: value.value
      };
    }
  }
  return null;
}
function compareFile(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function castFile(value) {
  switch (value?.type) {
    case "file" /* File */: {
      return value;
    }
  }
  return null;
}
function compareLink(left, right) {
  const leftEncoded = JSON.stringify(left.value);
  const rightEncoded = JSON.stringify(right.value);
  if (leftEncoded < rightEncoded) return -1;
  if (leftEncoded > rightEncoded) return 1;
  return 0;
}
function castLink(value) {
  switch (value?.type) {
    case "link" /* Link */: {
      return value;
    }
    case "string" /* String */: {
      try {
        const { protocol } = new URL(value.value);
        if (protocol === "http:" || protocol === "https:") {
          return {
            type: "link" /* Link */,
            value: value.value
          };
        }
        return null;
      } catch {
        return null;
      }
    }
  }
  return null;
}
function compareNumber(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function castNumber(value) {
  switch (value?.type) {
    case "number" /* Number */:
    case "string" /* String */: {
      const number2 = Number(value.value);
      if (Number.isFinite(number2)) {
        return {
          type: "number" /* Number */,
          value: number2
        };
      }
      return null;
    }
  }
  return null;
}
function valueToNumber(value) {
  const cast = castNumber(value);
  return cast?.value ?? null;
}
function compareObject(left, right, collation11) {
  const leftKeys = Object.keys(left.value).sort();
  const rightKeys = Object.keys(right.value).sort();
  if (leftKeys.length < rightKeys.length) return -1;
  if (leftKeys.length > rightKeys.length) return 1;
  for (let i = 0; i < leftKeys.length; i++) {
    const leftKey = leftKeys[i];
    const rightKey = rightKeys[i];
    if (leftKey < rightKey) return -1;
    if (leftKey > rightKey) return 1;
    const leftValue = left.value[leftKey] ?? null;
    const rightValue = right.value[rightKey] ?? null;
    const result = compare(leftValue, rightValue, collation11);
    if (result !== 0) return result;
  }
  return 0;
}
function castObject(value, definition) {
  switch (value?.type) {
    case "object" /* Object */: {
      const result = {};
      const definitionEntries = Object.entries(definition.definitions);
      for (const [key7, itemDefinition] of definitionEntries) {
        const item = value.value[key7] ?? null;
        result[key7] = DatabaseValue.cast(item, itemDefinition);
      }
      return {
        type: "object" /* Object */,
        value: result
      };
    }
  }
  return null;
}
function compareResponsiveImage(left, right) {
  const leftEncoded = JSON.stringify(left.value);
  const rightEncoded = JSON.stringify(right.value);
  if (leftEncoded < rightEncoded) return -1;
  if (leftEncoded > rightEncoded) return 1;
  return 0;
}
function castResponsiveImage(value) {
  switch (value?.type) {
    case "responsiveimage" /* ResponsiveImage */: {
      return value;
    }
  }
  return null;
}
function compareRichText(left, right) {
  const leftValue = left.value;
  const rightValue = right.value;
  if (leftValue < rightValue) return -1;
  if (leftValue > rightValue) return 1;
  return 0;
}
function castRichText(value) {
  switch (value?.type) {
    case "richtext" /* RichText */: {
      return value;
    }
  }
  return null;
}
function compareVectorSetItem(left, right) {
  const leftValue = left.value;
  const rightValue = right.value;
  if (leftValue < rightValue) return -1;
  if (leftValue > rightValue) return 1;
  return 0;
}
function castVectorSetItem(value) {
  switch (value?.type) {
    case "vectorsetitem" /* VectorSetItem */: {
      return value;
    }
  }
  return null;
}
function compareString(left, right, collation11) {
  let leftValue = left.value;
  let rightValue = right.value;
  if (collation11.type === 0 /* CaseInsensitive */) {
    leftValue = left.value.toLowerCase();
    rightValue = right.value.toLowerCase();
  }
  if (leftValue < rightValue) return -1;
  if (leftValue > rightValue) return 1;
  return 0;
}
function castString(value) {
  switch (value?.type) {
    case "string" /* String */: {
      return value;
    }
    case "number" /* Number */: {
      return {
        type: "string" /* String */,
        value: String(value.value)
      };
    }
  }
  return null;
}
function valueToString(value) {
  const cast = castString(value);
  return cast?.value ?? null;
}
var DatabaseValue = {
  /**
   * Casts a value to a different type.
   */
  cast(value, definition) {
    switch (definition.type) {
      case "array" /* Array */:
        return castArray(value, definition);
      case "boolean" /* Boolean */:
        return castBoolean(value);
      case "color" /* Color */:
        return castColor(value);
      case "date" /* Date */:
        return castDate(value);
      case "enum" /* Enum */:
        return castEnum(value);
      case "file" /* File */:
        return castFile(value);
      case "link" /* Link */:
        return castLink(value);
      case "number" /* Number */:
        return castNumber(value);
      case "object" /* Object */:
        return castObject(value, definition);
      case "responsiveimage" /* ResponsiveImage */:
        return castResponsiveImage(value);
      case "richtext" /* RichText */:
        return castRichText(value);
      case "string" /* String */:
        return castString(value);
      case "vectorsetitem" /* VectorSetItem */:
        return castVectorSetItem(value);
      case "unknown":
        return value;
      default:
        assertNever(definition, "Unsupported cast");
    }
  },
  /**
   * Parses a JavaScript variable into a DatabaseValue.
   */
  parse(value) {
    if (isBoolean(value)) {
      return {
        type: "boolean" /* Boolean */,
        value
      };
    }
    if (isValidDate(value)) {
      return {
        type: "date" /* Date */,
        value: value.toISOString()
      };
    }
    if (isNumber(value)) {
      return {
        type: "number" /* Number */,
        value
      };
    }
    if (isString(value)) {
      return {
        type: "string" /* String */,
        value
      };
    }
    if (isArray(value)) {
      return {
        type: "array" /* Array */,
        value: value.map(DatabaseValue.parse)
      };
    }
    return null;
  },
  /**
   * Checks if the left value is equal to the right value. Returns false if
   * the values are not of the same type.
   */
  equal(left, right, collation11) {
    if (left?.type !== right?.type) {
      return false;
    }
    return compare(left, right, collation11) === 0;
  },
  /**
   * Checks if the left value is less than the right value. Returns false if
   * the values are not of the same type.
   */
  lessThan(left, right, collation11) {
    if (left?.type !== right?.type) {
      return false;
    }
    return compare(left, right, collation11) < 0;
  },
  /**
   * Checks if the left value is less than or equal to the right value.
   * Returns false if the values are not of the same type.
   */
  lessThanOrEqual(left, right, collation11) {
    if (left?.type !== right?.type) {
      return false;
    }
    return compare(left, right, collation11) <= 0;
  },
  /**
   * Checks if the left value is greater than the right value. Returns false
   * if the values are not of the same type.
   */
  greaterThan(left, right, collation11) {
    if (left?.type !== right?.type) {
      return false;
    }
    return compare(left, right, collation11) > 0;
  },
  /**
   * Checks if the left value is greater than or equal to the right value.
   * Returns false if the values are not of the same type.
   */
  greaterThanOrEqual(left, right, collation11) {
    if (left?.type !== right?.type) {
      return false;
    }
    return compare(left, right, collation11) >= 0;
  },
  /**
   * Checks if the left value is in the right value. Returns false if the
   * right value is not an array.
   */
  in(left, right, collation11) {
    if (right?.type !== "array" /* Array */) return false;
    return right.value.some((item) => {
      return DatabaseValue.equal(item, left, collation11);
    });
  },
  /**
   * Get the index of the first occurrence of `target` in `source`.
   *
   * If source has duplicates, the index of the first occurrence is always returned.
   */
  indexOf(source, target, collation11) {
    if (source?.type !== "array" /* Array */) return -1;
    return source.value.findIndex((item) => {
      return DatabaseValue.equal(item, target, collation11);
    });
  },
  contains(source, target, collation11) {
    let sourceValue = valueToString(source);
    let targetValue = valueToString(target);
    if (isNull(sourceValue)) return false;
    if (isNull(targetValue)) return false;
    if (collation11.type === 0 /* CaseInsensitive */) {
      sourceValue = sourceValue.toLowerCase();
      targetValue = targetValue.toLowerCase();
    }
    return sourceValue.includes(targetValue);
  },
  startsWith(source, target, collation11) {
    let sourceValue = valueToString(source);
    let targetValue = valueToString(target);
    if (isNull(sourceValue)) return false;
    if (isNull(targetValue)) return false;
    if (collation11.type === 0 /* CaseInsensitive */) {
      sourceValue = sourceValue.toLowerCase();
      targetValue = targetValue.toLowerCase();
    }
    return sourceValue.startsWith(targetValue);
  },
  endsWith(source, target, collation11) {
    let sourceValue = valueToString(source);
    let targetValue = valueToString(target);
    if (isNull(sourceValue)) return false;
    if (isNull(targetValue)) return false;
    if (collation11.type === 0 /* CaseInsensitive */) {
      sourceValue = sourceValue.toLowerCase();
      targetValue = targetValue.toLowerCase();
    }
    return sourceValue.endsWith(targetValue);
  },
  length(value) {
    switch (value?.type) {
      case "array" /* Array */:
        return value.value.length;
    }
    return 0;
  },
  stringify(value) {
    if (value === null) {
      return "null";
    }
    switch (value.type) {
      case "array" /* Array */:
        return `[${value.value.map(DatabaseValue.stringify).join(", ")}]`;
      case "boolean" /* Boolean */:
      case "number" /* Number */:
        return String(value.value);
      case "string" /* String */:
        return `'${value.value}'`;
      case "enum" /* Enum */:
        return `'${value.value}' /* Enum */`;
      case "color" /* Color */:
        return `'${value.value}' /* Color */`;
      case "date" /* Date */:
        return `'${value.value}' /* Date */`;
      case "richtext" /* RichText */:
        return "RichText";
      case "vectorsetitem" /* VectorSetItem */:
        return "VectorSetItem";
      case "responsiveimage" /* ResponsiveImage */:
        return "ResponsiveImage";
      case "file" /* File */:
        return "File";
      case "link" /* Link */:
        return isString(value.value) ? `'${value.value}' /* Link */` : "Link";
      case "object" /* Object */:
        return "Object";
      default:
        assertNever(value);
    }
  }
};
function compare(left, right, collation11) {
  if (isNull(left) || isNull(right)) {
    assert(left === right);
    return 0;
  }
  switch (left.type) {
    case "array" /* Array */: {
      assert(left.type === right.type);
      return compareArray(left, right, collation11);
    }
    case "boolean" /* Boolean */: {
      assert(left.type === right.type);
      return compareBoolean(left, right);
    }
    case "color" /* Color */: {
      assert(left.type === right.type);
      return compareColor(left, right);
    }
    case "date" /* Date */: {
      assert(left.type === right.type);
      return compareDate(left, right);
    }
    case "enum" /* Enum */: {
      assert(left.type === right.type);
      return compareEnum(left, right);
    }
    case "file" /* File */: {
      assert(left.type === right.type);
      return compareFile(left, right);
    }
    case "link" /* Link */: {
      assert(left.type === right.type);
      return compareLink(left, right);
    }
    case "number" /* Number */: {
      assert(left.type === right.type);
      return compareNumber(left, right);
    }
    case "object" /* Object */: {
      assert(left.type === right.type);
      return compareObject(left, right, collation11);
    }
    case "responsiveimage" /* ResponsiveImage */: {
      assert(left.type === right.type);
      return compareResponsiveImage(left, right);
    }
    case "richtext" /* RichText */: {
      assert(left.type === right.type);
      return compareRichText(left, right);
    }
    case "vectorsetitem" /* VectorSetItem */: {
      assert(left.type === right.type);
      return compareVectorSetItem(left, right);
    }
    case "string" /* String */: {
      assert(left.type === right.type);
      return compareString(left, right, collation11);
    }
    default: {
      assertNever(left);
    }
  }
}

// ../../library/src/modules/cms/DatabaseValueDefinition.ts
var unknownDefinition = {
  type: "unknown",
  isNullable: true
};

// ../../library/src/modules/cms/CompatibilityDatabaseCollection.ts
async function getCollectionItems(collection, locale) {
  if (isLegacyLocalizedCollection(collection)) {
    await collection.preload(locale);
    return collection.read(locale);
  }
  return collection;
}
var CompatibilityDatabaseCollection = class {
  constructor(collection, locale) {
    this.collection = collection;
    this.locale = locale;
    __publicField(this, "schema");
    __publicField(this, "indexes", []);
    const propertyControls = getPropertyControls(collection);
    assert(propertyControls, "Collection does not have properties");
    const schema = {
      id: {
        type: "string" /* String */,
        isNullable: false
      }
    };
    const controlEntries = Object.entries(propertyControls);
    for (const [key7, controlDescription] of controlEntries) {
      if (!controlDescription) continue;
      const type = controlDescription.type;
      assert(type !== "array" /* Array */, "Array properties are not supported");
      assert(type !== "object" /* Object */, "Object properties are not supported");
      schema[key7] = {
        type,
        isNullable: true
      };
    }
    this.schema = schema;
  }
  getDatabaseItem(item, pointer) {
    const data2 = {};
    const itemIndex = Number(pointer);
    for (const key7 in this.schema) {
      const value = item[key7];
      if (isNullish(value)) continue;
      const definition = this.schema[key7];
      if (isUndefined(definition)) continue;
      assert(definition.type !== "unknown", "Invalid definition type");
      if (definition.type === "richtext" /* RichText */) {
        data2[key7] = {
          type: definition.type,
          value: { itemIndex, key: key7 }
        };
        continue;
      }
      data2[key7] = {
        type: definition.type,
        // biome-ignore lint/suspicious/noExplicitAny: Existing.
        value
      };
    }
    return { pointer, data: data2 };
  }
  async resolveRichText(pointer) {
    const { itemIndex, key: key7 } = pointer;
    const items = await getCollectionItems(this.collection, this.locale);
    const richText = items[itemIndex]?.[key7];
    if (LazyValue.is(richText)) {
      return richText.readMaybeAsync();
    }
    return richText;
  }
  async scanItems() {
    const items = await getCollectionItems(this.collection, this.locale);
    return items.map((item, index) => {
      const pointer = String(index);
      return this.getDatabaseItem(item, pointer);
    });
  }
  async resolveItems(pointers) {
    const items = await getCollectionItems(this.collection, this.locale);
    return pointers.map((pointer) => {
      const index = Number(pointer);
      const item = items[index];
      assert(item, "Can't find collection item");
      return this.getDatabaseItem(item, pointer);
    });
  }
  compareItems(left, right) {
    return Number(left.pointer) - Number(right.pointer);
  }
};

// ../../library/src/modules/cms/getCollectionId.ts
var collectionIds = /* @__PURE__ */ new WeakMap();
var prefix2 = "$r_";
function hasRandomCollectionId(id) {
  return id.includes(prefix2);
}
function getCollectionId(collection) {
  if (isAnyDatabaseCollection(collection) && collection.id) {
    return collection.id;
  }
  const existing = collectionIds.get(collection);
  if (existing) return existing;
  const id = `${prefix2}${Math.random().toString(16).slice(2)}`;
  collectionIds.set(collection, id);
  return id;
}

// ../../library/src/modules/cms/getCollectionForLocale.ts
var compatibilityCache = /* @__PURE__ */ new Map();
function getCollectionForLocale(data2, locale) {
  if (isAnyLegacyCollection(data2)) {
    const collectionId = getCollectionId(data2);
    const localeId = locale?.id ?? defaultLocaleId;
    const cacheKey = collectionId + localeId;
    const cached = compatibilityCache.get(cacheKey);
    if (cached) return cached;
    const collection = new CompatibilityDatabaseCollection(data2, locale);
    compatibilityCache.set(cacheKey, collection);
    return collection;
  }
  if (isDatabaseCollection(data2)) {
    return data2;
  }
  if (isLocalizedDatabaseCollection(data2)) {
    while (locale) {
      const collection = data2.collectionByLocaleId[locale.id];
      if (collection) return collection;
      locale = locale.fallback;
    }
    return data2.collectionByLocaleId.default;
  }
  assertNever(data2, "Unsupported collection type");
}

// ../../library/src/modules/cms/optimizer/Cost.ts
function getNetworkLatency() {
  return 25;
}
function getNetworkSpeed() {
  return 100 * 125;
}
var KB = 1e3;
var Cost = class _Cost {
  constructor(network) {
    this.network = network;
  }
  static estimate(totalRequests, transferredBytes) {
    const latency = getNetworkLatency();
    const speed = getNetworkSpeed();
    const network = totalRequests * latency + transferredBytes / speed;
    return new _Cost(network);
  }
  static max(left, right) {
    const network = Math.max(left.network, right.network);
    return new _Cost(network);
  }
  static compare(left, right) {
    if (left.network < right.network) return -1;
    if (left.network > right.network) return 1;
    return 0;
  }
  add(cost) {
    this.network += cost.network;
    return this;
  }
  toString() {
    return `${this.network}ms`;
  }
};

// ../../library/src/modules/cms/optimizer/Group.ts
function GroupId(id) {
  return id;
}
var Group = class {
  constructor(id, relational) {
    this.id = id;
    this.relational = relational;
    /**
     * A list of all nodes in the group. All nodes must have compatible
     * relational props.
     */
    __publicField(this, "nodes", []);
    /**
     * A map of all winners in the group by their hash.
     */
    __publicField(this, "winners", /* @__PURE__ */ new Map());
  }
  /**
   * Adds a node to the group. Throws an error if the node is already in a
   * group.
   */
  addNode(node) {
    this.nodes.push(node);
    node.setGroup(this);
  }
  /**
   * Returns the winner for the given required physical props. The winner
   * stores the best node and its cost. This is used to find the best node in
   * the group.
   */
  getWinner(required) {
    const hash2 = required.getHash();
    const existing = this.winners.get(hash2);
    if (existing) return existing;
    const winner = new Winner();
    this.winners.set(hash2, winner);
    return winner;
  }
  /**
   * Returns the optimized version of the node. The optimized version is the
   * node with the lowest cost with all children replaced with their optimized
   * versions. This is used to create the final optimized query plan.
   */
  getOptimized(required) {
    const winner = this.getWinner(required);
    assert(winner.node, "Group not optimized");
    const optimizer = winner.node.getOptimized(required);
    optimizer.setGroup(this);
    return optimizer;
  }
};
var Winner = class {
  constructor() {
    __publicField(this, "node");
    __publicField(this, "cost", new Cost(Infinity));
    __publicField(this, "nodes", []);
  }
  update(node, cost) {
    this.nodes.push(node);
    if (Cost.compare(cost, this.cost) < 0) {
      this.node = node;
      this.cost = cost;
    }
  }
};

// ../../library/src/modules/cms/optimizer/nodes/AbstractNode.ts
var AbstractNode = class {
  constructor(isSynchronous) {
    this.isSynchronous = isSynchronous;
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalNode.ts
var RelationalNode = class extends AbstractNode {
  constructor() {
    super(...arguments);
    __publicField(this, "group");
  }
  /**
   * Returns the group that the node belongs to. Throws an error if the node
   * is not in a group. This should only happen in the constructor because
   * every node is added to a group right after creation.
   */
  getGroup() {
    assert(this.group, "Node must be in a group");
    return this.group;
  }
  /**
   * Adds the node to the given group. Throws an error if the node is already
   * in a group.
   */
  setGroup(group) {
    assert(!this.group, "Node is already in a group");
    this.group = group;
  }
  /**
   * Evaluates the node and all children synchronously. Throws an error if the
   * node is not synchronous.
   */
  evaluateSync() {
    const generator = this.evaluate(void 0);
    return evaluateSync(generator);
  }
  /**
   * Evaluates the node and all children asynchronously.
   */
  evaluateAsync() {
    const generator = this.evaluate(void 0);
    return evaluateAsync(generator);
  }
};

// ../../library/src/modules/cms/optimizer/Hashable.ts
function Hash(value) {
  return value;
}
function isHashable(value) {
  return isObject2(value) && isFunction(value.getHash);
}
function calculateHash(name, ...values) {
  const hashes = values.map((value) => {
    const isCollectionMetadata = value instanceof CollectionMetadata;
    assert(!isCollectionMetadata, "Pass CollectionMetadata.id instead");
    const isFieldMetadata = value instanceof FieldMetadata;
    assert(!isFieldMetadata, "Pass FieldMetadata.id instead");
    const isIndexMetadata = value instanceof IndexMetadata;
    assert(!isIndexMetadata, "Pass IndexMetadata.id instead");
    const isRelationalNode = value instanceof RelationalNode;
    assert(!isRelationalNode, "Pass RelationalNode.group.id instead");
    const isGroup = value instanceof Group;
    assert(!isGroup, "Pass Group.id instead");
    if (isHashable(value)) {
      return value.getHash();
    }
    return JSON.stringify(value);
  });
  return Hash(`${name}(${hashes.join(", ")})`);
}

// ../../library/src/modules/cms/optimizer/Resolver.ts
function wrapRichTextPointer(collection, pointer) {
  return {
    collectionId: getCollectionId(collection),
    pointer
  };
}
function isWrappedRichTextPointer(value) {
  return isObject2(value) && isString(value.collectionId);
}
function wrapVectorSetItemPointer(collection, pointer) {
  return {
    collectionId: getCollectionId(collection),
    pointer
  };
}
function isWrappedVectorSetItemPointer(value) {
  return isObject2(value) && isString(value.collectionId);
}
var Resolver = class {
  constructor(query, locale) {
    __publicField(this, "collections");
    __publicField(this, "richTextCache", /* @__PURE__ */ new WeakMap());
    __publicField(this, "vectorSetItemCache", /* @__PURE__ */ new WeakMap());
    this.collections = getCollectionsFromQuery(query, locale);
  }
  *resolveArrayValue(value) {
    return yield* evaluateArray(
      value.value.map((item) => {
        return this.resolveValue(item);
      })
    );
  }
  *resolveObjectValue(value) {
    const result = {};
    for (const key7 in value.value) {
      const item = value.value[key7];
      result[key7] = this.resolveValue(item);
    }
    return yield* evaluateObject(result);
  }
  loadRichTextValue(value) {
    const wrapped = value.value;
    assert(isWrappedRichTextPointer(wrapped), "Rich text pointer must be wrapped");
    const collection = this.collections.get(wrapped.collectionId);
    assert(collection, "Can't find collection for rich text pointer");
    const cache2 = this.richTextCache.get(collection) ?? /* @__PURE__ */ new Map();
    this.richTextCache.set(collection, cache2);
    const cached = cache2.get(wrapped.pointer);
    if (cached) return cached;
    const result = collection.resolveRichText(wrapped.pointer);
    cache2.set(wrapped.pointer, result);
    return result;
  }
  preloadRichTextValue(value) {
    void this.loadRichTextValue(value);
  }
  *resolveRichTextValue(value) {
    const result = this.loadRichTextValue(value);
    if (isPromiseLike(result)) return yield result;
    return result;
  }
  loadVectorSetItemValue(value) {
    const wrapped = value.value;
    assert(isWrappedVectorSetItemPointer(wrapped), "Vector set item pointer must be wrapped");
    const collection = this.collections.get(wrapped.collectionId);
    assert(collection, "Can't find collection for vector set item pointer");
    assert(collection.resolveVectorSetItem, "Can't resolve vector set item pointer");
    const cache2 = this.vectorSetItemCache.get(collection) ?? /* @__PURE__ */ new Map();
    this.vectorSetItemCache.set(collection, cache2);
    const cached = cache2.get(wrapped.pointer);
    if (cached) return cached;
    const result = collection.resolveVectorSetItem(wrapped.pointer);
    cache2.set(wrapped.pointer, result);
    return result;
  }
  preloadVectorSetItemValue(value) {
    void this.loadVectorSetItemValue(value);
  }
  *resolveVectorSetItemValue(value) {
    const result = this.loadVectorSetItemValue(value);
    if (isPromiseLike(result)) return yield result;
    return result;
  }
  *resolveValue(value) {
    switch (value?.type) {
      case "array" /* Array */:
        return yield* this.resolveArrayValue(value);
      case "object" /* Object */:
        return yield* this.resolveObjectValue(value);
      case "richtext" /* RichText */:
        return yield* this.resolveRichTextValue(value);
      case "vectorsetitem" /* VectorSetItem */:
        return yield* this.resolveVectorSetItemValue(value);
    }
    return value?.value ?? null;
  }
};
function getCollectionsFromQuery(query, locale) {
  const collections = /* @__PURE__ */ new Map();
  function collect(value) {
    if (isObject2(value)) {
      if (value.type === "Collection" && isAnyCollection(value.data)) {
        const collection = getCollectionForLocale(value.data, locale);
        const collectionId = getCollectionId(collection);
        collections.set(collectionId, collection);
      } else {
        for (const key7 in value) {
          const property = value[key7];
          collect(property);
        }
      }
    } else if (isArray(value)) {
      for (const item of value) {
        collect(item);
      }
    }
  }
  collect(query);
  return collections;
}

// ../../library/src/modules/cms/optimizer/Metadata.ts
var VIRTUAL_INDEX_FIELD = "index";
var Metadata = class extends Set {
  merge(other) {
    for (const item of other) {
      this.add(item);
    }
  }
  equals(other) {
    if (this === other) return true;
    if (this.size !== other.size) return false;
    for (const item of this) {
      if (!other.has(item)) return false;
    }
    return true;
  }
  subsetOf(other) {
    if (this === other) return true;
    if (this.size > other.size) return false;
    for (const item of this) {
      if (!other.has(item)) return false;
    }
    return true;
  }
  getHash() {
    const ids = [];
    for (const item of this) {
      ids.push(item.id);
    }
    ids.sort((a, b) => a - b);
    return calculateHash(this.name, ...ids);
  }
};
function CollectionId(id) {
  return id;
}
var CollectionMetadata = class {
  constructor(id, name, data2) {
    this.id = id;
    this.name = name;
    this.data = data2;
    __publicField(this, "indexes", new Indexes());
    __publicField(this, "fields", new Fields());
  }
};
function IndexId(id) {
  return id;
}
var IndexMetadata = class {
  constructor(id, data2, collection, lookupNodes, constraint, ordering) {
    this.id = id;
    this.data = data2;
    this.collection = collection;
    this.lookupNodes = lookupNodes;
    this.constraint = constraint;
    this.ordering = ordering;
    __publicField(this, "resolvedFields", new Fields());
    for (const fieldName in data2.schema) {
      for (const field of collection.fields) {
        if (field.name === fieldName) {
          this.resolvedFields.add(field);
        }
      }
    }
  }
};
var Indexes = class extends Metadata {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "Indexes");
  }
};
function FieldId(id) {
  return id;
}
var FieldMetadata = class {
  constructor(id, name, definition, collection) {
    this.id = id;
    this.name = name;
    this.definition = definition;
    this.collection = collection;
  }
  getValue(item) {
    assert(this.name, "Can only get value of field with a name");
    const value = item.data[this.name];
    switch (value?.type) {
      case "richtext" /* RichText */: {
        assert(this.collection, "Rich text field must have a collection");
        return {
          type: "richtext" /* RichText */,
          value: wrapRichTextPointer(this.collection.data, value.value)
        };
      }
      case "vectorsetitem" /* VectorSetItem */: {
        assert(this.collection, "Vector set item field must have a collection");
        return {
          type: "vectorsetitem" /* VectorSetItem */,
          value: wrapVectorSetItemPointer(this.collection.data, value.value)
        };
      }
    }
    return value ?? null;
  }
};
var Fields = class extends Metadata {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "Fields");
  }
};

// ../../library/src/modules/cms/optimizer/Ordering.ts
var OrderingField = class {
  constructor(field, direction = "asc" /* Ascending */) {
    this.field = field;
    this.direction = direction;
  }
  getHash() {
    return calculateHash("OrderingField", this.field.id, this.direction);
  }
};
var Ordering = class {
  constructor(ordering) {
    __publicField(this, "fields", []);
    if (ordering) {
      this.merge(ordering);
    }
  }
  get length() {
    return this.fields.length;
  }
  getHash() {
    return calculateHash("Ordering", ...this.fields);
  }
  push(field) {
    this.fields.push(field);
  }
  merge(ordering) {
    this.fields.push(...ordering.fields);
  }
  equals(other) {
    if (this === other) return true;
    if (this.length !== other.length) return false;
    return this.getHash() === other.getHash();
  }
  providedByFields(fields) {
    for (const { field } of this.fields) {
      if (fields.has(field)) continue;
      if (field.name === VIRTUAL_INDEX_FIELD) continue;
      return false;
    }
    return true;
  }
};

// ../../library/src/modules/cms/optimizer/PhysicalProps.ts
var RequiredProps = class {
  constructor(ordering, resolvedFields) {
    this.ordering = ordering;
    this.resolvedFields = resolvedFields;
  }
  getHash() {
    return calculateHash("RequiredProps", this.ordering, this.resolvedFields);
  }
  /**
   * Required props with no ordering and no resolved fields are considered
   * minimal. Every node can provide them.
   */
  get isMinimal() {
    return this.ordering.length === 0 && this.resolvedFields.size === 0;
  }
  /**
   * Checks if the node can provide the required props. If it can't, we need
   * to add enforcers that provides them.
   *
   * Some nodes don't provide the required props directly, but can pass them
   * through to their children. E.g. a `RelationalFilter` returns the relation
   * in the same order and with the same resolved fields as its input. These
   * nodes should return `true` and pass the required props to their children.
   */
  canProvide(node) {
    return this.canProvideOrdering(node) && this.canProvideResolvedFields(node);
  }
  /**
   * Checks if the given node can provide the required ordering. If it can't,
   * we need to add an `EnforcerSort` node that provides it.
   */
  canProvideOrdering(node) {
    if (this.ordering.length === 0) return true;
    return node.canProvideOrdering(this.ordering);
  }
  /**
   * Checks if the given node can provide the required resolved fields. If it
   * can't, we need to add an `EnforcerResolve` node that provides it.
   */
  canProvideResolvedFields(node) {
    if (this.resolvedFields.size === 0) return true;
    return node.canProvideResolvedFields(this.resolvedFields);
  }
};

// ../../library/src/modules/cms/optimizer/Scope.ts
var Scope = class _Scope {
  constructor(parent) {
    this.parent = parent;
    /**
     * The last node built in the scope.
     */
    __publicField(this, "node");
    /**
     * The required ordering of the scope.
     */
    __publicField(this, "ordering");
    /**
     * A list of all fields available in the scope.
     */
    __publicField(this, "fields", []);
  }
  /**
   * Returns the last node built in the scope and removes it from the scope.
   * Throws an error if no node was built in the scope yet.
   */
  takeNode() {
    const node = this.node;
    assert(node, "Node is missing");
    this.node = void 0;
    return node;
  }
  /**
   * Sets the last node built in the scope. Throws an error if there is
   * already a node in the scope.
   */
  setNode(node) {
    assert(!this.node, "Node already set");
    this.node = node;
  }
  setOrdering(ordering) {
    this.ordering = ordering;
  }
  /**
   * Create a new scope with the this scope as its parent.
   */
  push() {
    return new _Scope(this);
  }
  /**
   * Creates a new scope with the parent of the this scope as its parent.
   */
  replace() {
    return new _Scope(this.parent);
  }
  /**
   * Adds a field to this scope. Any fields that are added will be available
   * in the this scope and all of its children.
   */
  addField(scopeField) {
    this.fields.push(scopeField);
  }
  /**
   * Merges all fields from the given scope into the this scope.
   */
  addFieldsFromScope(scope) {
    for (const scopeField of scope.fields) {
      this.addField(scopeField);
    }
  }
  /**
   * Resolves a field from this scope. If the field is not found, the parent
   * scope is checked. If the name of a field is ambiguous, an error is
   * thrown.
   */
  resolveField(name, collection) {
    const candidates = [];
    for (const field of this.fields) {
      if (field.name !== name) continue;
      if (collection && field.collectionName !== collection) continue;
      candidates.push(field);
    }
    if (candidates.length === 1) {
      return candidates[0];
    }
    if (candidates.length > 1) {
      throw new Error("Ambiguous fields");
    }
    return this.parent?.resolveField(name, collection);
  }
  /**
   * Checks if the scope or any parent scope has the given scope field.
   */
  has(scopeField) {
    if (this.fields.includes(scopeField)) {
      return true;
    }
    return this.parent?.has(scopeField) ?? false;
  }
  /**
   * Returns the required ordering for the scope.
   */
  getRequiredOrdering() {
    return this.ordering ?? new Ordering();
  }
  /**
   * Returns the required resolved fields for the scope.
   */
  getRequiredResolvedFields() {
    const resolvedFields = new Fields();
    for (const { field } of this.fields) {
      if (field.collection) {
        resolvedFields.add(field);
      }
    }
    return resolvedFields;
  }
  /**
   * Returns the set of required physical props for this scope. This is used
   * to create the required props for the root node in the optimizer.
   */
  getRequiredProps() {
    const ordering = this.getRequiredOrdering();
    const resolvedFields = this.getRequiredResolvedFields();
    return new RequiredProps(ordering, resolvedFields);
  }
  /**
   * Returns a map of the fields in this scope, with their scope names as
   * keys. This is used to create the final `QueryResult` with the correct
   * field names.
   */
  getNamedFields() {
    const namedFields = {};
    for (const { name, field } of this.fields) {
      namedFields[name] = field;
    }
    return namedFields;
  }
  /**
   * Returns the single field from this scope if it only contains one field.
   * Throws an error if there are more than one fields.
   */
  getSingleField() {
    assert(this.fields.length === 1, "Scope must contain exactly one field");
    const scopeField = this.fields[0];
    assert(scopeField, "Field must exist");
    return scopeField.field;
  }
};

// ../../library/src/modules/cms/optimizer/Relation.ts
var Tuple = class {
  constructor() {
    __publicField(this, "pointers", /* @__PURE__ */ new Map());
    __publicField(this, "values", /* @__PURE__ */ new Map());
  }
  getKey() {
    const result = [];
    for (const [collection, pointer] of this.pointers) {
      result.push(`${collection.id}-${pointer}`);
    }
    return result.sort().join("-");
  }
  addValue(field, value) {
    this.values.set(field, value);
  }
  getValue(field) {
    return this.values.get(field) ?? null;
  }
  mergeValues(tuple) {
    for (const [field, value] of tuple.values) {
      this.addValue(field, value);
    }
  }
  addPointer(collection, pointer) {
    this.pointers.set(collection, pointer);
  }
  getPointer(collection) {
    return this.pointers.get(collection);
  }
  mergePointers(tuple) {
    for (const [collection, pointer] of tuple.pointers) {
      this.addPointer(collection, pointer);
    }
  }
  merge(tuple) {
    this.mergeValues(tuple);
    this.mergePointers(tuple);
  }
};
var Relation = class _Relation {
  constructor(fields, tuples = []) {
    this.fields = fields;
    this.tuples = tuples;
  }
  push(tuple) {
    this.tuples.push(tuple);
  }
  filter(predicate) {
    const tuples = this.tuples.filter(predicate);
    return new _Relation(this.fields, tuples);
  }
  map(fields, callback) {
    const tuples = this.tuples.map(callback);
    return new _Relation(fields, tuples);
  }
  sort(callback) {
    const tuples = Array.from(this.tuples).sort(callback);
    return new _Relation(this.fields, tuples);
  }
  slice(start, end) {
    const tuples = this.tuples.slice(start, end);
    return new _Relation(this.fields, tuples);
  }
  union(other) {
    const fields = new Fields();
    for (const field of this.fields) {
      if (other.fields.has(field)) {
        fields.add(field);
      }
    }
    const keys3 = /* @__PURE__ */ new Set();
    const result = new _Relation(fields);
    for (const tuple of this.tuples) {
      const key7 = tuple.getKey();
      keys3.add(key7);
      result.push(tuple);
    }
    for (const tuple of other.tuples) {
      const key7 = tuple.getKey();
      if (keys3.has(key7)) continue;
      result.push(tuple);
    }
    return result;
  }
  intersection(other) {
    const fields = new Fields();
    for (const field of this.fields) {
      if (other.fields.has(field)) {
        fields.add(field);
      }
    }
    const keys3 = /* @__PURE__ */ new Set();
    const result = new _Relation(fields);
    for (const tuple of this.tuples) {
      const key7 = tuple.getKey();
      keys3.add(key7);
    }
    for (const tuple of other.tuples) {
      const key7 = tuple.getKey();
      if (!keys3.has(key7)) continue;
      result.push(tuple);
    }
    return result;
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalProject.ts
var ProjectionField = class {
  constructor(input, field) {
    this.input = input;
    this.field = field;
  }
  getHash() {
    return calculateHash("ProjectionField", this.input, this.field.id);
  }
};
var RelationalProject = class _RelationalProject extends RelationalNode {
  constructor(input, projections, passthrough) {
    let isSynchronous = input.isSynchronous;
    for (const projection of projections) {
      isSynchronous &&= projection.input.isSynchronous;
    }
    super(isSynchronous);
    this.input = input;
    this.projections = projections;
    this.passthrough = passthrough;
    __publicField(this, "inputGroup");
    this.inputGroup = input.getGroup();
  }
  getHash() {
    return calculateHash("RelationalProject", this.inputGroup.id, ...this.projections, this.passthrough);
  }
  getOutputFields() {
    const fields = new Fields();
    fields.merge(this.passthrough);
    for (const projection of this.projections) {
      fields.add(projection.field);
    }
    return fields;
  }
  canProvideOrdering(ordering) {
    const projectionFields = new Fields();
    for (const projection of this.projections) {
      projectionFields.add(projection.field);
    }
    for (const { field } of ordering.fields) {
      if (projectionFields.has(field)) {
        return false;
      }
    }
    return true;
  }
  canProvideResolvedFields() {
    return true;
  }
  getInputRequiredProps(required) {
    const resolvedFields = new Fields(required.resolvedFields);
    for (const projection of this.projections) {
      resolvedFields.merge(projection.input.referencedFields);
      resolvedFields.delete(projection.field);
    }
    return new RequiredProps(required.ordering, resolvedFields);
  }
  optimize(optimizer, required) {
    const inputRequired = this.getInputRequiredProps(required);
    const inputCost = optimizer.optimizeGroup(this.inputGroup, inputRequired);
    let projectionsCost = new Cost(0);
    for (const projection of this.projections) {
      const projectionCost = projection.input.optimize(optimizer);
      projectionsCost = Cost.max(projectionsCost, projectionCost);
    }
    return new Cost(0).add(Cost.max(inputCost, projectionsCost));
  }
  getOptimized(required) {
    const inputRequired = this.getInputRequiredProps(required);
    const input = this.inputGroup.getOptimized(inputRequired);
    const projections = this.projections.map((projection) => {
      const projectionInput = projection.input.getOptimized();
      return new ProjectionField(projectionInput, projection.field);
    });
    return new _RelationalProject(input, projections, this.passthrough);
  }
  *evaluate(context) {
    const outputFields = this.getOutputFields();
    const input = yield* this.input.evaluate(context);
    const projectedValues = yield* evaluateArray(
      input.tuples.map(
        (tuple) => evaluateArray(
          this.projections.map(
            (projection) => evaluateObject({
              field: projection.field,
              value: projection.input.evaluate(context, tuple)
            })
          )
        )
      )
    );
    return input.map(outputFields, (tuple, index) => {
      const result = new Tuple();
      result.mergePointers(tuple);
      for (const field of this.passthrough) {
        const value = tuple.getValue(field);
        result.addValue(field, value);
      }
      const projections = projectedValues[index];
      assert(projections, "Projections must exist");
      for (const { field, value } of projections) {
        result.addValue(field, value);
      }
      return result;
    });
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarNode.ts
var collation = {
  type: 0 /* CaseInsensitive */
};
var ScalarNode = class extends AbstractNode {
  constructor(referencedFields, referencedOuterFields, isSynchronous) {
    super(isSynchronous);
    this.referencedFields = referencedFields;
    this.referencedOuterFields = referencedOuterFields;
    this.isSynchronous = isSynchronous;
  }
  /**
   * Evaluates the node and all children synchronously. Throws an error if the
   * node is not synchronous.
   */
  evaluateSync() {
    const generator = this.evaluate(void 0, void 0);
    return evaluateSync(generator);
  }
  /**
   * Evaluates the node and all children asynchronously.
   */
  evaluateAsync() {
    const generator = this.evaluate(void 0, void 0);
    return evaluateAsync(generator);
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarCase.ts
var collation2 = {
  type: 0 /* CaseInsensitive */
};
var CaseCondition = class {
  constructor(when, then) {
    this.when = when;
    this.then = then;
  }
  getHash() {
    return calculateHash("CaseCondition", this.when, this.then);
  }
};
var ScalarCase = class _ScalarCase extends ScalarNode {
  constructor(input, conditions, otherwise) {
    const referencedFields = new Fields();
    const referencedOuterFields = new Fields();
    let isSynchronous = true;
    if (input) {
      referencedFields.merge(input.referencedFields);
      referencedOuterFields.merge(input.referencedOuterFields);
      isSynchronous &&= input.isSynchronous;
    }
    for (const { when, then } of conditions) {
      referencedFields.merge(when.referencedFields);
      referencedOuterFields.merge(when.referencedOuterFields);
      isSynchronous &&= when.isSynchronous;
      referencedFields.merge(then.referencedFields);
      referencedOuterFields.merge(then.referencedOuterFields);
      isSynchronous &&= then.isSynchronous;
    }
    if (otherwise) {
      referencedFields.merge(otherwise.referencedFields);
      referencedOuterFields.merge(otherwise.referencedOuterFields);
      isSynchronous &&= otherwise.isSynchronous;
    }
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.input = input;
    this.conditions = conditions;
    this.otherwise = otherwise;
    __publicField(this, "definition", {
      type: "unknown",
      isNullable: true
    });
  }
  getHash() {
    return calculateHash("ScalarCase", this.input, ...this.conditions, this.otherwise);
  }
  optimize(optimizer) {
    this.input?.optimize(optimizer);
    for (const condition of this.conditions) {
      condition.when.optimize(optimizer);
      condition.then.optimize(optimizer);
    }
    this.otherwise?.optimize(optimizer);
    return new Cost(0);
  }
  getOptimized() {
    const input = this.input?.getOptimized();
    const conditions = this.conditions.map((condition) => {
      const when = condition.when.getOptimized();
      const then = condition.then.getOptimized();
      return new CaseCondition(when, then);
    });
    const otherwise = this.otherwise?.getOptimized();
    return new _ScalarCase(input, conditions, otherwise);
  }
  *evaluate(context, tuple) {
    const { input, conditions, otherwise } = yield* evaluateObject({
      input: this.input?.evaluate(context, tuple) ?? null,
      conditions: evaluateArray(
        this.conditions.map(
          (condition) => evaluateObject({
            when: condition.when.evaluate(context, tuple),
            // biome-ignore lint/suspicious/noThenProperty: Existing name.
            then: condition.then.evaluate(context, tuple)
          })
        )
      ),
      otherwise: this.otherwise?.evaluate(context, tuple) ?? null
    });
    if (this.input) {
      for (const { when, then } of conditions) {
        if (DatabaseValue.equal(input, when, collation2)) {
          return then;
        }
      }
    } else {
      for (const { when, then } of conditions) {
        if (valueToBoolean(when)) {
          return then;
        }
      }
    }
    return otherwise;
  }
};

// ../../library/src/modules/cms/optimizer/Builder.ts
var Builder = class {
  constructor(normalizer, query, locale) {
    this.normalizer = normalizer;
    this.query = query;
    this.locale = locale;
    __publicField(this, "collectionId", 0);
    __publicField(this, "indexId", 0);
    __publicField(this, "fieldId", 0);
    /**
     * A stack of the subqueries that are currently being built. We use this to
     * calculate fields that come from the enclosing scope or from inside the
     * subquery.
     */
    __publicField(this, "subqueries", []);
  }
  build() {
    const inScope = new Scope();
    return this.buildQuery(inScope, this.query);
  }
  buildQuery(inScope, query) {
    const select = { type: "Select", ...query };
    return this.buildSelect(inScope, select);
  }
  buildSelect(inScope, select) {
    const fromScope = this.buildFrom(inScope, select.from);
    const defaultOrdering = fromScope.getRequiredOrdering();
    if (select.where) {
      const input = fromScope.takeNode();
      const predicate = this.buildExpression(fromScope, select.where);
      const node = this.normalizer.newRelationalFilter(input, predicate);
      fromScope.setNode(node);
    }
    const orderProjections = [];
    const orderFields = new Fields();
    let ordering;
    if (select.orderBy) {
      ordering = new Ordering();
      for (const order of select.orderBy) {
        if (order.type === "Identifier") {
          const scopeField = fromScope.resolveField(order.name, order.collection);
          if (isUndefined(scopeField)) continue;
          orderFields.add(scopeField.field);
          const orderingField = new OrderingField(scopeField.field, order.direction);
          ordering.push(orderingField);
        } else {
          const expression = this.buildExpression(fromScope, order);
          const fieldId = FieldId(this.fieldId++);
          const field = new FieldMetadata(fieldId, void 0, expression.definition, void 0);
          const projection = new ProjectionField(expression, field);
          orderProjections.push(projection);
          const orderingField = new OrderingField(field, order.direction);
          ordering.push(orderingField);
        }
      }
      ordering.merge(defaultOrdering);
    } else {
      ordering = defaultOrdering;
    }
    const projectionScope = this.buildSelectList(fromScope, select.select, orderFields, orderProjections);
    projectionScope.setOrdering(ordering);
    if (select.offset) {
      const input = projectionScope.takeNode();
      const offset = this.buildExpression(inScope, select.offset);
      const node = this.normalizer.newRelationalOffset(input, offset, ordering);
      projectionScope.setNode(node);
    }
    if (select.limit) {
      const input = projectionScope.takeNode();
      const limit = this.buildExpression(inScope, select.limit);
      const node = this.normalizer.newRelationalLimit(input, limit, ordering);
      projectionScope.setNode(node);
    }
    return projectionScope;
  }
  buildSelectList(inScope, selects, orderFields, orderProjections) {
    const outScope = inScope.push();
    const passthrough = new Fields(orderFields);
    const projections = [...orderProjections];
    for (const select of selects) {
      if (select.type === "Identifier") {
        const scopeField = inScope.resolveField(select.name, select.collection);
        if (isUndefined(scopeField)) continue;
        passthrough.add(scopeField.field);
        outScope.addField({ ...scopeField, name: select.alias ?? scopeField.name });
      } else {
        const expression = this.buildExpression(inScope, select);
        assert(select.alias, "Subqueries should have an alias");
        const fieldId = FieldId(this.fieldId++);
        const fieldName = select.alias;
        const field = new FieldMetadata(fieldId, fieldName, expression.definition, void 0);
        const projection = new ProjectionField(expression, field);
        projections.push(projection);
        outScope.addField({
          field,
          name: fieldName
        });
      }
    }
    const input = inScope.takeNode();
    const node = this.normalizer.newRelationalProject(input, projections, passthrough);
    outScope.setNode(node);
    return outScope;
  }
  buildFrom(inScope, from) {
    switch (from.type) {
      case "Collection":
        return this.buildCollection(inScope, from);
      case "LeftJoin":
        return this.buildJoin(inScope, from);
      default:
        assertNever(from, "Unsupported from type");
    }
  }
  buildCollection(inScope, from) {
    const outScope = inScope.push();
    const collectionData = getCollectionForLocale(from.data, this.locale);
    const collectionName = from.alias;
    const collectionId = CollectionId(this.collectionId++);
    const collection = new CollectionMetadata(collectionId, collectionName, collectionData);
    for (const [fieldName, definition] of Object.entries(collectionData.schema)) {
      const fieldId = FieldId(this.fieldId++);
      const field = new FieldMetadata(fieldId, fieldName, definition, collection);
      outScope.addField({
        field,
        name: fieldName,
        collectionName
      });
      collection.fields.add(field);
    }
    {
      const definition = { type: "number" /* Number */, isNullable: false };
      const fieldId = FieldId(this.fieldId++);
      const field = new FieldMetadata(fieldId, VIRTUAL_INDEX_FIELD, definition, collection);
      outScope.addField({
        field,
        name: VIRTUAL_INDEX_FIELD,
        collectionName
      });
      const ordering = new Ordering();
      const orderingField = new OrderingField(field);
      ordering.push(orderingField);
      outScope.setOrdering(ordering);
    }
    for (const indexData of collectionData.indexes) {
      const lookupNodes = [];
      for (const expression of indexData.fields) {
        const node2 = this.buildExpression(outScope, expression);
        lookupNodes.push(node2);
      }
      let constraint;
      if (indexData.where) {
        constraint = this.buildExpression(outScope, indexData.where);
      }
      const ordering = new Ordering();
      const indexId = IndexId(this.indexId++);
      const index = new IndexMetadata(indexId, indexData, collection, lookupNodes, constraint, ordering);
      collection.indexes.add(index);
    }
    const node = this.normalizer.newRelationalScan(collection);
    outScope.setNode(node);
    return outScope;
  }
  buildJoin(inScope, from) {
    const leftScope = this.buildFrom(inScope, from.left);
    const rightScope = this.buildFrom(inScope, from.right);
    const ordering = new Ordering();
    const leftOrdering = leftScope.getRequiredOrdering();
    ordering.merge(leftOrdering);
    const rightOrdering = rightScope.getRequiredOrdering();
    ordering.merge(rightOrdering);
    const outScope = inScope.push();
    outScope.addFieldsFromScope(leftScope);
    outScope.addFieldsFromScope(rightScope);
    outScope.setOrdering(ordering);
    const constraint = this.buildExpression(outScope, from.constraint);
    const left = leftScope.takeNode();
    const right = rightScope.takeNode();
    let node;
    switch (from.type) {
      case "LeftJoin":
        node = this.normalizer.newRelationalLeftJoin(left, right, constraint);
        break;
      default:
        assertNever(from.type, "Unsupported join type");
    }
    outScope.setNode(node);
    return outScope;
  }
  buildExpression(inScope, expression) {
    switch (expression.type) {
      case "Identifier":
        return this.buildIdentifier(inScope, expression);
      case "LiteralValue":
        return this.buildLiteralValue(expression);
      case "FunctionCall":
        return this.buildFunctionCall(inScope, expression);
      case "Case":
        return this.buildCase(inScope, expression);
      case "UnaryOperation":
        return this.buildUnaryOperation(inScope, expression);
      case "BinaryOperation":
        return this.buildBinaryOperation(inScope, expression);
      case "TypeCast":
        return this.buildTypeCast(inScope, expression);
      case "Select":
        throw new Error("Subqueries are only supported inside subquery function calls");
      default:
        assertNever(expression, "Unsupported expression");
    }
  }
  buildIdentifier(inScope, expression) {
    const scopeField = inScope.resolveField(expression.name, expression.collection);
    if (scopeField) {
      let isOuterField = false;
      for (const subquery of this.subqueries) {
        if (isOuterField) {
          subquery.referencedOuterFields.add(scopeField.field);
        } else {
          isOuterField = subquery.inScope.has(scopeField);
          if (isOuterField) {
            subquery.referencedFields.add(scopeField.field);
          }
        }
      }
      return this.normalizer.newScalarVariable(scopeField.field, isOuterField);
    }
    return this.normalizer.newScalarConstant(unknownDefinition, null);
  }
  buildLiteralValue(expression) {
    const value = DatabaseValue.parse(expression.value);
    return this.normalizer.newScalarConstant(unknownDefinition, value);
  }
  buildFunctionCall(inScope, expression) {
    const getArgument = (index) => {
      const argument = expression.arguments[index];
      assert(argument, "Missing argument");
      return this.buildExpression(inScope, argument);
    };
    const functionName = expression.functionName;
    switch (functionName) {
      case "CONTAINS" /* Contains */: {
        const source = getArgument(0);
        const target = getArgument(1);
        return this.normalizer.newScalarContains(source, target);
      }
      case "STARTS_WITH" /* StartsWith */: {
        const source = getArgument(0);
        const target = getArgument(1);
        return this.normalizer.newScalarStartsWith(source, target);
      }
      case "ENDS_WITH" /* EndsWith */: {
        const source = getArgument(0);
        const target = getArgument(1);
        return this.normalizer.newScalarEndsWith(source, target);
      }
      case "LENGTH" /* Length */: {
        const array = getArgument(0);
        return this.normalizer.newScalarLength(array);
      }
      case "INDEX_OF" /* IndexOf */: {
        const source = getArgument(0);
        const target = getArgument(1);
        return this.normalizer.newScalarIndexOf(source, target);
      }
      case "ARRAY" /* Array */: {
        const subquery = expression.arguments[0];
        assert(subquery, "Missing argument");
        assert(subquery.type === "Select", "Subqueries require a select expression");
        return this.buildSubqueryArray(inScope, subquery);
      }
      case "FLAT_ARRAY" /* FlatArray */: {
        const subquery = expression.arguments[0];
        assert(subquery, "Missing argument");
        assert(subquery.type === "Select", "Subqueries require a select expression");
        return this.buildSubqueryFlatArray(inScope, subquery);
      }
      case "INTERSECT" /* Intersect */: {
        const source = getArgument(0);
        const target = getArgument(1);
        return this.normalizer.newScalarIntersection(source, target);
      }
      default:
        assertNever(functionName, "Unsupported function name");
    }
  }
  buildSubqueryArray(inScope, expression) {
    try {
      const subquery = new Subquery(inScope);
      this.subqueries.push(subquery);
      const outScope = this.buildSelect(inScope, expression);
      const input = outScope.takeNode();
      const namedFields = outScope.getNamedFields();
      const ordering = outScope.getRequiredOrdering();
      const referencedFields = subquery.referencedFields;
      const referencedOuterFields = subquery.referencedOuterFields;
      return this.normalizer.newScalarArray(input, namedFields, ordering, referencedFields, referencedOuterFields);
    } finally {
      this.subqueries.pop();
    }
  }
  buildSubqueryFlatArray(inScope, expression) {
    try {
      const subquery = new Subquery(inScope);
      this.subqueries.push(subquery);
      const outScope = this.buildSelect(inScope, expression);
      const input = outScope.takeNode();
      const field = outScope.getSingleField();
      const ordering = outScope.getRequiredOrdering();
      const referencedFields = subquery.referencedFields;
      const referencedOuterFields = subquery.referencedOuterFields;
      return this.normalizer.newScalarFlatArray(input, field, ordering, referencedFields, referencedOuterFields);
    } finally {
      this.subqueries.pop();
    }
  }
  buildCase(inScope, expression) {
    let input;
    if (expression.value) {
      input = this.buildExpression(inScope, expression.value);
    }
    const conditions = expression.conditions.map((condition) => {
      const when = this.buildExpression(inScope, condition.when);
      const then = this.buildExpression(inScope, condition.then);
      return new CaseCondition(when, then);
    });
    let otherwise;
    if (expression.else) {
      otherwise = this.buildExpression(inScope, expression.else);
    }
    return this.normalizer.newScalarCase(input, conditions, otherwise);
  }
  buildUnaryOperation(inScope, expression) {
    const input = this.buildExpression(inScope, expression.value);
    switch (expression.operator) {
      case "not" /* Not */:
        return this.normalizer.newScalarNot(input);
      default:
        assertNever(expression.operator, "Unsupported unary operator");
    }
  }
  buildBinaryOperation(inScope, expression) {
    const left = this.buildExpression(inScope, expression.left);
    const right = this.buildExpression(inScope, expression.right);
    switch (expression.operator) {
      case "and" /* And */:
        return this.normalizer.newScalarAnd(left, right);
      case "or" /* Or */:
        return this.normalizer.newScalarOr(left, right);
      case "==" /* Equals */:
        return this.normalizer.newScalarEquals(left, right);
      case "!=" /* NotEquals */:
        return this.normalizer.newScalarNotEquals(left, right);
      case "<" /* LessThan */:
        return this.normalizer.newScalarLessThan(left, right);
      case "<=" /* LessThanOrEqual */:
        return this.normalizer.newScalarLessThanOrEqual(left, right);
      case ">" /* GreaterThan */:
        return this.normalizer.newScalarGreaterThan(left, right);
      case ">=" /* GreaterThanOrEqual */:
        return this.normalizer.newScalarGreaterThanOrEqual(left, right);
      case "in" /* In */:
        return this.normalizer.newScalarIn(left, right);
      default:
        assertNever(expression.operator, "Unsupported binary operator");
    }
  }
  buildTypeCast(inScope, expression) {
    const input = this.buildExpression(inScope, expression.value);
    switch (expression.dataType) {
      case "BOOLEAN" /* Boolean */: {
        const definition = { type: "boolean" /* Boolean */, isNullable: true };
        return this.normalizer.newScalarCast(input, definition);
      }
      case "DATE" /* Date */: {
        const definition = { type: "date" /* Date */, isNullable: true };
        return this.normalizer.newScalarCast(input, definition);
      }
      case "NUMBER" /* Number */: {
        const definition = { type: "number" /* Number */, isNullable: true };
        return this.normalizer.newScalarCast(input, definition);
      }
      case "STRING" /* String */: {
        const definition = { type: "string" /* String */, isNullable: true };
        return this.normalizer.newScalarCast(input, definition);
      }
      default:
        throw new Error("Unsupported data type");
    }
  }
};
var Subquery = class {
  constructor(inScope) {
    this.inScope = inScope;
    /**
     * A list of fields that are referenced from `inScope` of the subquery.
     *
     * To evaluate a subquery, we need to know which fields are coming from
     * outside the subquery and which fields are coming from inside the
     * subquery. For example, in the following query:
     *
     * ```
     * SELECT title, (
     *     SELECT name FROM articles
     *     WHERE id = author_id
     * ) AS author FROM articles
     * ```
     *
     * The `name` and `id` fields are coming from the inside the subquery, but
     * the `author_id` field is coming from the parent scope. We need to resolve
     * `author_id` before we can evaluate the subquery.
     */
    __publicField(this, "referencedFields", new Fields());
    /**
     * A list of fields that are referenced from the `inScope` of the parent
     * subquery.
     */
    __publicField(this, "referencedOuterFields", new Fields());
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalFilter.ts
var RelationalFilter = class _RelationalFilter extends RelationalNode {
  constructor(input, predicate) {
    super(input.isSynchronous && predicate.isSynchronous);
    this.input = input;
    this.predicate = predicate;
    __publicField(this, "inputGroup");
    this.inputGroup = input.getGroup();
  }
  getHash() {
    return calculateHash("RelationalFilter", this.inputGroup.id, this.predicate);
  }
  getOutputFields() {
    return this.inputGroup.relational.outputFields;
  }
  canProvideOrdering() {
    return true;
  }
  canProvideResolvedFields() {
    return true;
  }
  getInputRequiredProps(required) {
    const resolvedFields = new Fields(required.resolvedFields);
    resolvedFields.merge(this.predicate.referencedFields);
    return new RequiredProps(required.ordering, resolvedFields);
  }
  optimize(optimizer, required) {
    const inputRequired = this.getInputRequiredProps(required);
    const inputCost = optimizer.optimizeGroup(this.inputGroup, inputRequired);
    const predicateCost = this.predicate.optimize(optimizer);
    return new Cost(0).add(Cost.max(inputCost, predicateCost));
  }
  getOptimized(required) {
    const inputRequired = this.getInputRequiredProps(required);
    const input = this.inputGroup.getOptimized(inputRequired);
    const predicate = this.predicate.getOptimized();
    return new _RelationalFilter(input, predicate);
  }
  *evaluate(context) {
    const input = yield* this.input.evaluate(context);
    const predicates = yield* evaluateArray(
      input.tuples.map((tuple) => {
        return this.predicate.evaluate(context, tuple);
      })
    );
    return input.filter((_, index) => {
      const predicate = predicates[index] ?? null;
      return valueToBoolean(predicate);
    });
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalIndexLookup.ts
var RelationalIndexLookup = class _RelationalIndexLookup extends RelationalNode {
  constructor(index, query) {
    super(false);
    this.index = index;
    this.query = query;
  }
  getHash() {
    return calculateHash("RelationalIndexLookup", this.index.id, ...this.query);
  }
  getOutputFields() {
    return this.index.collection.fields;
  }
  canProvideOrdering(ordering) {
    return ordering.equals(this.index.ordering);
  }
  canProvideResolvedFields(resolvedFields) {
    return resolvedFields.subsetOf(this.index.resolvedFields);
  }
  optimize() {
    const isFullScan = this.query.every((lookup) => lookup.type === "All" /* All */);
    return Cost.estimate(1, isFullScan ? 100 * KB : 50 * KB);
  }
  getOptimized() {
    return new _RelationalIndexLookup(this.index, this.query);
  }
  *evaluate() {
    const index = this.index;
    const collection = index.collection;
    const outputFields = this.getOutputFields();
    const items = yield index.data.lookupItems(this.query);
    const tuples = items.map((item) => {
      const tuple = new Tuple();
      for (const field of index.resolvedFields) {
        const value = field.getValue(item);
        tuple.addPointer(collection, item.pointer);
        tuple.addValue(field, value);
      }
      return tuple;
    });
    return new Relation(outputFields, tuples);
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalIntersection.ts
var RelationalIntersection = class _RelationalIntersection extends RelationalNode {
  constructor(left, right) {
    super(left.isSynchronous && right.isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "leftGroup");
    __publicField(this, "rightGroup");
    this.leftGroup = left.getGroup();
    this.rightGroup = right.getGroup();
  }
  getHash() {
    return calculateHash("RelationalIntersection", this.leftGroup.id, this.rightGroup.id);
  }
  getOutputFields() {
    const outputFields = new Fields();
    const leftOutputFields = this.leftGroup.relational.outputFields;
    const rightOutputFields = this.rightGroup.relational.outputFields;
    for (const field of leftOutputFields) {
      if (rightOutputFields.has(field)) {
        outputFields.add(field);
      }
    }
    return outputFields;
  }
  canProvideOrdering() {
    return false;
  }
  canProvideResolvedFields() {
    return true;
  }
  getChildRequiredProps(required) {
    const ordering = new Ordering();
    return new RequiredProps(ordering, required.resolvedFields);
  }
  optimize(optimizer, required) {
    const leftRequired = this.getChildRequiredProps(required);
    const leftCost = optimizer.optimizeGroup(this.leftGroup, leftRequired);
    const rightRequired = this.getChildRequiredProps(required);
    const rightCost = optimizer.optimizeGroup(this.rightGroup, rightRequired);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized(required) {
    const leftRequired = this.getChildRequiredProps(required);
    const left = this.leftGroup.getOptimized(leftRequired);
    const rightRequired = this.getChildRequiredProps(required);
    const right = this.rightGroup.getOptimized(rightRequired);
    return new _RelationalIntersection(left, right);
  }
  *evaluate(context) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context),
      right: this.right.evaluate(context)
    });
    return left.intersection(right);
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarEquals.ts
var ScalarEquals = class _ScalarEquals extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarEquals", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarEquals(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: DatabaseValue.equal(left, right, collation)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalLeftJoin.ts
var RelationalLeftJoin = class _RelationalLeftJoin extends RelationalNode {
  constructor(left, right, constraint) {
    super(left.isSynchronous && right.isSynchronous && constraint.isSynchronous);
    this.left = left;
    this.right = right;
    this.constraint = constraint;
    __publicField(this, "leftGroup");
    __publicField(this, "rightGroup");
    this.leftGroup = left.getGroup();
    this.rightGroup = right.getGroup();
  }
  getHash() {
    return calculateHash("RelationalLeftJoin", this.leftGroup.id, this.rightGroup.id, this.constraint);
  }
  getOutputFields() {
    const outputFields = new Fields();
    outputFields.merge(this.leftGroup.relational.outputFields);
    outputFields.merge(this.rightGroup.relational.outputFields);
    return outputFields;
  }
  canProvideOrdering() {
    return false;
  }
  canProvideResolvedFields() {
    return true;
  }
  getChildRequiredProps(group, required) {
    const resolvedFields = new Fields();
    const outputFields = group.relational.outputFields;
    for (const field of required.resolvedFields) {
      if (outputFields.has(field)) {
        resolvedFields.add(field);
      }
    }
    for (const field of this.constraint.referencedFields) {
      if (outputFields.has(field)) {
        resolvedFields.add(field);
      }
    }
    const ordering = new Ordering();
    return new RequiredProps(ordering, resolvedFields);
  }
  optimize(optimizer, required) {
    const leftRequired = this.getChildRequiredProps(this.leftGroup, required);
    const leftCost = optimizer.optimizeGroup(this.leftGroup, leftRequired);
    const rightRequired = this.getChildRequiredProps(this.rightGroup, required);
    const rightCost = optimizer.optimizeGroup(this.rightGroup, rightRequired);
    const constraintCost = this.constraint.optimize(optimizer);
    return Cost.max(Cost.max(leftCost, rightCost), constraintCost);
  }
  getOptimized(required) {
    const leftRequired = this.getChildRequiredProps(this.leftGroup, required);
    const left = this.leftGroup.getOptimized(leftRequired);
    const rightRequired = this.getChildRequiredProps(this.rightGroup, required);
    const right = this.rightGroup.getOptimized(rightRequired);
    const constraint = this.constraint.getOptimized();
    return new _RelationalLeftJoin(left, right, constraint);
  }
  /** Optimized path for equality constraints that runs in O(n + m) time. */
  *evaluateScalarEquals(left, right, leftConstraint, rightConstraint, context) {
    const joinKeyMap = /* @__PURE__ */ new Map();
    for (const rightTuple of right.tuples) {
      const rightValue = yield* rightConstraint.evaluate(context, rightTuple);
      const key7 = JSON.stringify(rightValue?.value ?? null);
      const tuplesForKey = joinKeyMap.get(key7) ?? [];
      tuplesForKey.push(rightTuple);
      joinKeyMap.set(key7, tuplesForKey);
    }
    const outputFields = this.getOutputFields();
    const result = new Relation(outputFields);
    for (const leftTuple of left.tuples) {
      const leftValue = yield* leftConstraint.evaluate(context, leftTuple);
      const key7 = JSON.stringify(leftValue?.value ?? null);
      const matches = joinKeyMap.get(key7) ?? [];
      if (matches.length === 0) {
        result.push(leftTuple);
      } else {
        for (const rightTuple of matches) {
          const joinedTuple = new Tuple();
          joinedTuple.merge(leftTuple);
          joinedTuple.merge(rightTuple);
          result.push(joinedTuple);
        }
      }
    }
    return result;
  }
  *evaluate(context) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context),
      right: this.right.evaluate(context)
    });
    if (this.constraint instanceof ScalarEquals) {
      if (this.constraint.left.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.right.referencedFields.subsetOf(this.rightGroup.relational.outputFields)) {
        return yield* this.evaluateScalarEquals(
          left,
          right,
          this.constraint.left,
          this.constraint.right,
          context
        );
      }
      if (this.constraint.right.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.left.referencedFields.subsetOf(this.rightGroup.relational.outputFields)) {
        return yield* this.evaluateScalarEquals(
          left,
          right,
          this.constraint.right,
          this.constraint.left,
          context
        );
      }
    }
    const outputFields = this.getOutputFields();
    const result = new Relation(outputFields);
    for (const leftTuple of left.tuples) {
      let hasMatch = false;
      for (const rightTuple of right.tuples) {
        const tuple = new Tuple();
        tuple.merge(leftTuple);
        tuple.merge(rightTuple);
        const value = yield* this.constraint.evaluate(context, tuple);
        if (valueToBoolean(value)) {
          result.push(tuple);
          hasMatch = true;
        }
      }
      if (!hasMatch) {
        result.push(leftTuple);
      }
    }
    return result;
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalRightJoin.ts
var RelationalRightJoin = class _RelationalRightJoin extends RelationalNode {
  constructor(left, right, constraint) {
    super(left.isSynchronous && right.isSynchronous && constraint.isSynchronous);
    this.left = left;
    this.right = right;
    this.constraint = constraint;
    __publicField(this, "leftGroup");
    __publicField(this, "rightGroup");
    this.leftGroup = left.getGroup();
    this.rightGroup = right.getGroup();
  }
  getHash() {
    return calculateHash("RelationalRightJoin", this.leftGroup.id, this.rightGroup.id, this.constraint);
  }
  getOutputFields() {
    const outputFields = new Fields();
    outputFields.merge(this.leftGroup.relational.outputFields);
    outputFields.merge(this.rightGroup.relational.outputFields);
    return outputFields;
  }
  canProvideOrdering() {
    return false;
  }
  canProvideResolvedFields() {
    return true;
  }
  getChildRequiredProps(group, required) {
    const resolvedFields = new Fields();
    const outputFields = group.relational.outputFields;
    for (const field of required.resolvedFields) {
      if (outputFields.has(field)) {
        resolvedFields.add(field);
      }
    }
    for (const field of this.constraint.referencedFields) {
      if (outputFields.has(field)) {
        resolvedFields.add(field);
      }
    }
    const ordering = new Ordering();
    return new RequiredProps(ordering, resolvedFields);
  }
  optimize(optimizer, required) {
    const leftRequired = this.getChildRequiredProps(this.leftGroup, required);
    const leftCost = optimizer.optimizeGroup(this.leftGroup, leftRequired);
    const rightRequired = this.getChildRequiredProps(this.rightGroup, required);
    const rightCost = optimizer.optimizeGroup(this.rightGroup, rightRequired);
    const constraintCost = this.constraint.optimize(optimizer);
    return Cost.max(Cost.max(leftCost, rightCost), constraintCost);
  }
  getOptimized(required) {
    const leftRequired = this.getChildRequiredProps(this.leftGroup, required);
    const left = this.leftGroup.getOptimized(leftRequired);
    const rightRequired = this.getChildRequiredProps(this.rightGroup, required);
    const right = this.rightGroup.getOptimized(rightRequired);
    const constraint = this.constraint.getOptimized();
    return new _RelationalRightJoin(left, right, constraint);
  }
  /** Optimized path for equality constraints that runs in O(n + m) time. */
  *evaluateScalarEquals(left, right, leftConstraint, rightConstraint, context) {
    const joinKeyMap = /* @__PURE__ */ new Map();
    for (const leftTuple of left.tuples) {
      const leftValue = yield* leftConstraint.evaluate(context, leftTuple);
      const key7 = JSON.stringify(leftValue?.value ?? null);
      const tuplesForKey = joinKeyMap.get(key7) ?? [];
      tuplesForKey.push(leftTuple);
      joinKeyMap.set(key7, tuplesForKey);
    }
    const outputFields = this.getOutputFields();
    const result = new Relation(outputFields);
    for (const rightTuple of right.tuples) {
      const rightValue = yield* rightConstraint.evaluate(context, rightTuple);
      const key7 = JSON.stringify(rightValue?.value ?? null);
      const matches = joinKeyMap.get(key7) ?? [];
      if (matches.length === 0) {
        result.push(rightTuple);
      } else {
        for (const leftTuple of matches) {
          const joinedTuple = new Tuple();
          joinedTuple.merge(rightTuple);
          joinedTuple.merge(leftTuple);
          result.push(joinedTuple);
        }
      }
    }
    return result;
  }
  *evaluate(context) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context),
      right: this.right.evaluate(context)
    });
    if (this.constraint instanceof ScalarEquals) {
      if (this.constraint.left.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.right.referencedFields.subsetOf(this.rightGroup.relational.outputFields)) {
        return yield* this.evaluateScalarEquals(
          left,
          right,
          this.constraint.left,
          this.constraint.right,
          context
        );
      }
      if (this.constraint.right.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.left.referencedFields.subsetOf(this.rightGroup.relational.outputFields)) {
        return yield* this.evaluateScalarEquals(
          left,
          right,
          this.constraint.right,
          this.constraint.left,
          context
        );
      }
    }
    const outputFields = this.getOutputFields();
    const result = new Relation(outputFields);
    for (const rightTuple of right.tuples) {
      let hasMatch = false;
      for (const leftTuple of left.tuples) {
        const tuple = new Tuple();
        tuple.merge(rightTuple);
        tuple.merge(leftTuple);
        const value = yield* this.constraint.evaluate(context, tuple);
        if (valueToBoolean(value)) {
          result.push(tuple);
          hasMatch = true;
        }
      }
      if (!hasMatch) {
        result.push(rightTuple);
      }
    }
    return result;
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalScan.ts
var RelationalScan = class _RelationalScan extends RelationalNode {
  constructor(collection) {
    super(false);
    this.collection = collection;
  }
  getHash() {
    return calculateHash("RelationalScan", this.collection.id);
  }
  getOutputFields() {
    return this.collection.fields;
  }
  canProvideOrdering() {
    return false;
  }
  canProvideResolvedFields(resolvedFields) {
    return resolvedFields.subsetOf(this.collection.fields);
  }
  optimize() {
    return Cost.estimate(1, 200 * KB);
  }
  getOptimized() {
    return new _RelationalScan(this.collection);
  }
  *evaluate() {
    const collection = this.collection;
    const outputFields = this.getOutputFields();
    const items = yield collection.data.scanItems();
    const tuples = items.map((item) => {
      const tuple = new Tuple();
      for (const field of outputFields) {
        const value = field.getValue(item);
        tuple.addPointer(collection, item.pointer);
        tuple.addValue(field, value);
      }
      return tuple;
    });
    return new Relation(outputFields, tuples);
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalUnion.ts
var RelationalUnion = class _RelationalUnion extends RelationalNode {
  constructor(left, right) {
    super(left.isSynchronous && right.isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "leftGroup");
    __publicField(this, "rightGroup");
    this.leftGroup = left.getGroup();
    this.rightGroup = right.getGroup();
  }
  getHash() {
    return calculateHash("RelationalUnion", this.leftGroup.id, this.rightGroup.id);
  }
  getOutputFields() {
    const outputFields = new Fields();
    const leftOutputFields = this.leftGroup.relational.outputFields;
    const rightOutputFields = this.rightGroup.relational.outputFields;
    for (const field of leftOutputFields) {
      if (rightOutputFields.has(field)) {
        outputFields.add(field);
      }
    }
    return outputFields;
  }
  canProvideOrdering() {
    return false;
  }
  canProvideResolvedFields() {
    return true;
  }
  getChildRequiredProps(required) {
    const ordering = new Ordering();
    return new RequiredProps(ordering, required.resolvedFields);
  }
  optimize(optimizer, required) {
    const leftRequired = this.getChildRequiredProps(required);
    const leftCost = optimizer.optimizeGroup(this.leftGroup, leftRequired);
    const rightRequired = this.getChildRequiredProps(required);
    const rightCost = optimizer.optimizeGroup(this.rightGroup, rightRequired);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized(required) {
    const leftRequired = this.getChildRequiredProps(required);
    const left = this.leftGroup.getOptimized(leftRequired);
    const rightRequired = this.getChildRequiredProps(required);
    const right = this.rightGroup.getOptimized(rightRequired);
    return new _RelationalUnion(left, right);
  }
  *evaluate(context) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context),
      right: this.right.evaluate(context)
    });
    return left.union(right);
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarAnd.ts
var ScalarAnd = class _ScalarAnd extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarAnd", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarAnd(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: valueToBoolean(left) && valueToBoolean(right)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarConstant.ts
var ScalarConstant = class extends ScalarNode {
  constructor(definition, value) {
    const referencedFields = new Fields();
    const referencedOuterFields = new Fields();
    super(referencedFields, referencedOuterFields, true);
    this.definition = definition;
    this.value = value;
  }
  getHash() {
    return calculateHash("ScalarConstant", this.definition, this.value);
  }
  optimize() {
    return new Cost(0);
  }
  getOptimized() {
    return this;
  }
  // biome-ignore lint/correctness/useYield: Required by the super class.
  *evaluate() {
    return this.value;
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarContains.ts
var collation3 = {
  type: 0 /* CaseInsensitive */
};
var ScalarContains = class _ScalarContains extends ScalarNode {
  constructor(source, target) {
    const referencedFields = new Fields();
    referencedFields.merge(source.referencedFields);
    referencedFields.merge(target.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(source.referencedOuterFields);
    referencedOuterFields.merge(target.referencedOuterFields);
    const isSynchronous = source.isSynchronous && target.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.source = source;
    this.target = target;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarContains", this.source, this.target);
  }
  optimize(optimizer) {
    const sourceCost = this.source.optimize(optimizer);
    const targetCost = this.target.optimize(optimizer);
    return Cost.max(sourceCost, targetCost);
  }
  getOptimized() {
    const source = this.source.getOptimized();
    const target = this.target.getOptimized();
    return new _ScalarContains(source, target);
  }
  *evaluate(context, tuple) {
    const { source, target } = yield* evaluateObject({
      source: this.source.evaluate(context, tuple),
      target: this.target.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: DatabaseValue.contains(source, target, collation3)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarEndsWith.ts
var collation4 = {
  type: 0 /* CaseInsensitive */
};
var ScalarEndsWith = class _ScalarEndsWith extends ScalarNode {
  constructor(source, target) {
    const referencedFields = new Fields();
    referencedFields.merge(source.referencedFields);
    referencedFields.merge(target.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(source.referencedOuterFields);
    referencedOuterFields.merge(target.referencedOuterFields);
    const isSynchronous = source.isSynchronous && target.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.source = source;
    this.target = target;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarEndsWith", this.source, this.target);
  }
  optimize(optimizer) {
    const sourceCost = this.source.optimize(optimizer);
    const targetCost = this.target.optimize(optimizer);
    return Cost.max(sourceCost, targetCost);
  }
  getOptimized() {
    const source = this.source.getOptimized();
    const target = this.target.getOptimized();
    return new _ScalarEndsWith(source, target);
  }
  *evaluate(context, tuple) {
    const { source, target } = yield* evaluateObject({
      source: this.source.evaluate(context, tuple),
      target: this.target.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: DatabaseValue.endsWith(source, target, collation4)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarGreaterThan.ts
var ScalarGreaterThan = class _ScalarGreaterThan extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarGreaterThan", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarGreaterThan(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: DatabaseValue.greaterThan(left, right, collation)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarGreaterThanOrEqual.ts
var ScalarGreaterThanOrEqual = class _ScalarGreaterThanOrEqual extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarGreaterThanOrEqual", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarGreaterThanOrEqual(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: DatabaseValue.greaterThanOrEqual(left, right, collation)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarLessThan.ts
var ScalarLessThan = class _ScalarLessThan extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarLessThan", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarLessThan(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: DatabaseValue.lessThan(left, right, collation)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarLessThanOrEqual.ts
var ScalarLessThanOrEqual = class _ScalarLessThanOrEqual extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarLessThanOrEqual", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarLessThanOrEqual(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: DatabaseValue.lessThanOrEqual(left, right, collation)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarNotEquals.ts
var ScalarNotEquals = class _ScalarNotEquals extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarNotEquals", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarNotEquals(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: !DatabaseValue.equal(left, right, collation)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarOr.ts
var ScalarOr = class _ScalarOr extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarOr", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarOr(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: valueToBoolean(left) || valueToBoolean(right)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarStartsWith.ts
var collation5 = {
  type: 0 /* CaseInsensitive */
};
var ScalarStartsWith = class _ScalarStartsWith extends ScalarNode {
  constructor(source, target) {
    const referencedFields = new Fields();
    referencedFields.merge(source.referencedFields);
    referencedFields.merge(target.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(source.referencedOuterFields);
    referencedOuterFields.merge(target.referencedOuterFields);
    const isSynchronous = source.isSynchronous && target.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.source = source;
    this.target = target;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarStartsWith", this.source, this.target);
  }
  optimize(optimizer) {
    const sourceCost = this.source.optimize(optimizer);
    const targetCost = this.target.optimize(optimizer);
    return Cost.max(sourceCost, targetCost);
  }
  getOptimized() {
    const source = this.source.getOptimized();
    const target = this.target.getOptimized();
    return new _ScalarStartsWith(source, target);
  }
  *evaluate(context, tuple) {
    const { source, target } = yield* evaluateObject({
      source: this.source.evaluate(context, tuple),
      target: this.target.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: DatabaseValue.startsWith(source, target, collation5)
    };
  }
};

// ../../library/src/modules/cms/optimizer/Explorer.ts
var Explorer = class {
  constructor(normalizer) {
    this.normalizer = normalizer;
    __publicField(this, "memo");
    this.memo = normalizer.memo;
  }
  explore(before) {
    const group = before.getGroup();
    if (before instanceof RelationalLeftJoin) {
      const after = new RelationalRightJoin(before.right, before.left, before.constraint);
      this.memo.addRelational(after, group);
    }
    if (before instanceof RelationalFilter) {
      if (before.predicate instanceof ScalarAnd) {
        const left = this.normalizer.newRelationalFilter(before.input, before.predicate.left);
        const right = this.normalizer.newRelationalFilter(before.input, before.predicate.right);
        const after = new RelationalIntersection(left, right);
        this.memo.addRelational(after, group);
      }
      if (before.predicate instanceof ScalarOr) {
        const left = this.normalizer.newRelationalFilter(before.input, before.predicate.left);
        const right = this.normalizer.newRelationalFilter(before.input, before.predicate.right);
        const after = new RelationalUnion(left, right);
        this.memo.addRelational(after, group);
      }
    }
    if (before instanceof RelationalScan) {
      for (const index of before.collection.indexes) {
        if (index.constraint) continue;
        const query = createIndexQueryAll(index.lookupNodes.length);
        const after = new RelationalIndexLookup(index, query);
        this.memo.addRelational(after, group);
      }
    }
    if (before instanceof RelationalFilter) {
      for (const input of before.inputGroup.nodes) {
        if (input instanceof RelationalScan) {
          for (const index of input.collection.indexes) {
            if (before.predicate instanceof ScalarEquals && before.predicate.left === index.lookupNodes[0] && before.predicate.right instanceof ScalarConstant && index.data.supportedLookupTypes.includes("Equals" /* Equals */)) {
              const query = createIndexQueryAll(index.lookupNodes.length);
              query[0] = {
                type: "Equals" /* Equals */,
                value: before.predicate.right.value
              };
              const after = new RelationalIndexLookup(index, query);
              this.memo.addRelational(after, group);
            }
            if (before.predicate instanceof ScalarNotEquals && before.predicate.left === index.lookupNodes[0] && before.predicate.right instanceof ScalarConstant && index.data.supportedLookupTypes.includes("NotEquals" /* NotEquals */)) {
              const query = createIndexQueryAll(index.lookupNodes.length);
              query[0] = {
                type: "NotEquals" /* NotEquals */,
                value: before.predicate.right.value
              };
              const after = new RelationalIndexLookup(index, query);
              this.memo.addRelational(after, group);
            }
            if (before.predicate instanceof ScalarLessThan && before.predicate.left === index.lookupNodes[0] && before.predicate.right instanceof ScalarConstant && index.data.supportedLookupTypes.includes("LessThan" /* LessThan */)) {
              const query = createIndexQueryAll(index.lookupNodes.length);
              query[0] = {
                type: "LessThan" /* LessThan */,
                value: before.predicate.right.value,
                inclusive: false
              };
              const after = new RelationalIndexLookup(index, query);
              this.memo.addRelational(after, group);
            }
            if (before.predicate instanceof ScalarLessThanOrEqual && before.predicate.left === index.lookupNodes[0] && before.predicate.right instanceof ScalarConstant && index.data.supportedLookupTypes.includes("LessThan" /* LessThan */)) {
              const query = createIndexQueryAll(index.lookupNodes.length);
              query[0] = {
                type: "LessThan" /* LessThan */,
                value: before.predicate.right.value,
                inclusive: true
              };
              const after = new RelationalIndexLookup(index, query);
              this.memo.addRelational(after, group);
            }
            if (before.predicate instanceof ScalarGreaterThan && before.predicate.left === index.lookupNodes[0] && before.predicate.right instanceof ScalarConstant && index.data.supportedLookupTypes.includes("GreaterThan" /* GreaterThan */)) {
              const query = createIndexQueryAll(index.lookupNodes.length);
              query[0] = {
                type: "GreaterThan" /* GreaterThan */,
                value: before.predicate.right.value,
                inclusive: false
              };
              const after = new RelationalIndexLookup(index, query);
              this.memo.addRelational(after, group);
            }
            if (before.predicate instanceof ScalarGreaterThanOrEqual && before.predicate.left === index.lookupNodes[0] && before.predicate.right instanceof ScalarConstant && index.data.supportedLookupTypes.includes("GreaterThan" /* GreaterThan */)) {
              const query = createIndexQueryAll(index.lookupNodes.length);
              query[0] = {
                type: "GreaterThan" /* GreaterThan */,
                value: before.predicate.right.value,
                inclusive: true
              };
              const after = new RelationalIndexLookup(index, query);
              this.memo.addRelational(after, group);
            }
            if (before.predicate instanceof ScalarContains && before.predicate.source === index.lookupNodes[0] && before.predicate.target instanceof ScalarConstant && index.data.supportedLookupTypes.includes("Contains" /* Contains */)) {
              const query = createIndexQueryAll(index.lookupNodes.length);
              query[0] = {
                type: "Contains" /* Contains */,
                value: before.predicate.target.value
              };
              const after = new RelationalIndexLookup(index, query);
              this.memo.addRelational(after, group);
            }
            if (before.predicate instanceof ScalarStartsWith && before.predicate.source === index.lookupNodes[0] && before.predicate.target instanceof ScalarConstant && index.data.supportedLookupTypes.includes("StartsWith" /* StartsWith */)) {
              const query = createIndexQueryAll(index.lookupNodes.length);
              query[0] = {
                type: "StartsWith" /* StartsWith */,
                value: before.predicate.target.value
              };
              const after = new RelationalIndexLookup(index, query);
              this.memo.addRelational(after, group);
            }
            if (before.predicate instanceof ScalarEndsWith && before.predicate.source === index.lookupNodes[0] && before.predicate.target instanceof ScalarConstant && index.data.supportedLookupTypes.includes("EndsWith" /* EndsWith */)) {
              const query = createIndexQueryAll(index.lookupNodes.length);
              query[0] = {
                type: "EndsWith" /* EndsWith */,
                value: before.predicate.target.value
              };
              const after = new RelationalIndexLookup(index, query);
              this.memo.addRelational(after, group);
            }
          }
        }
      }
    }
  }
};
function createIndexQueryAll(length) {
  const lookup = { type: "All" /* All */ };
  return new Array(length).fill(lookup);
}

// ../../library/src/modules/cms/optimizer/LogicalProps.ts
var RelationalProps = class {
  constructor(outputFields) {
    this.outputFields = outputFields;
  }
  /**
   * Checks if the given relational properties are compatible with this.
   */
  isCompatible(other) {
    return this.outputFields.equals(other.outputFields);
  }
};

// ../../library/src/modules/cms/optimizer/Memo.ts
var Memo = class {
  constructor() {
    /**
     * A map of all nodes in the memo by their hash. This allows to easily find
     * duplicated nodes and their groups.
     */
    __publicField(this, "nodes", /* @__PURE__ */ new Map());
    /**
     * A list of all groups in the memo. The id of a group is the index of the
     * group in this list.
     */
    __publicField(this, "groups", []);
  }
  /**
   * Adds a new group with the given relational props to the memo. All nodes
   * in the group must have the same props. It's expected that the normalized
   * node is immediately added to the group after creating it.
   */
  addGroup(relationalProps) {
    const id = GroupId(this.groups.length);
    const group = new Group(id, relationalProps);
    this.groups.push(group);
    return group;
  }
  /**
   * Adds a relational node to the memo and the group. If the node is already
   * in the memo, it returns the existing node. If no group is given, it
   * creates a new group with the given relational props of the node.
   */
  addRelational(node, group) {
    const hash2 = node.getHash();
    const existing = this.nodes.get(hash2);
    if (existing) return existing;
    this.nodes.set(hash2, node);
    const outputFields = node.getOutputFields();
    const relational = new RelationalProps(outputFields);
    group ??= this.addGroup(relational);
    group.addNode(node);
    assert(relational.isCompatible(group.relational), "Group has inconsistent relational props");
    return node;
  }
  /**
   * Adds a scalar node to the memo. If the node is already in the memo, it
   * returns the existing node.
   */
  addScalar(node) {
    const hash2 = node.getHash();
    const existing = this.nodes.get(hash2);
    if (existing) return existing;
    this.nodes.set(hash2, node);
    return node;
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalLimit.ts
var RelationalLimit = class _RelationalLimit extends RelationalNode {
  constructor(input, limit, ordering) {
    super(input.isSynchronous && limit.isSynchronous);
    this.input = input;
    this.limit = limit;
    this.ordering = ordering;
    __publicField(this, "inputGroup");
    this.inputGroup = input.getGroup();
  }
  getHash() {
    return calculateHash("RelationalLimit", this.inputGroup.id, this.limit);
  }
  getOutputFields() {
    return this.inputGroup.relational.outputFields;
  }
  canProvideOrdering(ordering) {
    return ordering.equals(this.ordering);
  }
  canProvideResolvedFields() {
    return true;
  }
  getInputRequiredProps(required) {
    const resolvedFields = new Fields(required.resolvedFields);
    resolvedFields.merge(this.limit.referencedFields);
    return new RequiredProps(this.ordering, resolvedFields);
  }
  optimize(optimizer, required) {
    const inputRequired = this.getInputRequiredProps(required);
    const inputCost = optimizer.optimizeGroup(this.inputGroup, inputRequired);
    const limitCost = this.limit.optimize(optimizer);
    return new Cost(0).add(Cost.max(inputCost, limitCost));
  }
  getOptimized(required) {
    const inputRequired = this.getInputRequiredProps(required);
    const input = this.inputGroup.getOptimized(inputRequired);
    const limit = this.limit.getOptimized();
    return new _RelationalLimit(input, limit, this.ordering);
  }
  *evaluate(context) {
    const { input, limit } = yield* evaluateObject({
      input: this.input.evaluate(context),
      limit: this.limit.evaluate(context, void 0)
    });
    const value = valueToNumber(limit) ?? Infinity;
    if (value === Infinity) return input;
    return input.slice(0, value);
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalOffset.ts
var RelationalOffset = class _RelationalOffset extends RelationalNode {
  constructor(input, offset, ordering) {
    super(input.isSynchronous && offset.isSynchronous);
    this.input = input;
    this.offset = offset;
    this.ordering = ordering;
    __publicField(this, "inputGroup");
    this.inputGroup = input.getGroup();
  }
  getHash() {
    return calculateHash("RelationalOffset", this.inputGroup.id, this.offset);
  }
  getOutputFields() {
    return this.inputGroup.relational.outputFields;
  }
  canProvideOrdering(ordering) {
    return ordering.equals(this.ordering);
  }
  canProvideResolvedFields() {
    return true;
  }
  getInputRequiredProps(required) {
    const resolvedFields = new Fields(required.resolvedFields);
    resolvedFields.merge(this.offset.referencedFields);
    return new RequiredProps(this.ordering, resolvedFields);
  }
  optimize(optimizer, required) {
    const inputRequired = this.getInputRequiredProps(required);
    const inputCost = optimizer.optimizeGroup(this.inputGroup, inputRequired);
    const offsetCost = this.offset.optimize(optimizer);
    return new Cost(0).add(Cost.max(inputCost, offsetCost));
  }
  getOptimized(required) {
    const inputRequired = this.getInputRequiredProps(required);
    const input = this.inputGroup.getOptimized(inputRequired);
    const offset = this.offset.getOptimized();
    return new _RelationalOffset(input, offset, this.ordering);
  }
  *evaluate(context) {
    const { input, offset } = yield* evaluateObject({
      input: this.input.evaluate(context),
      offset: this.offset.evaluate(context, void 0)
    });
    const value = valueToNumber(offset) ?? 0;
    if (value === 0) return input;
    return input.slice(value);
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarArray.ts
var ScalarArray = class _ScalarArray extends ScalarNode {
  constructor(input, namedFields, ordering, referencedFields, referencedOuterFields) {
    super(referencedFields, referencedOuterFields, input.isSynchronous);
    this.input = input;
    this.namedFields = namedFields;
    this.ordering = ordering;
    this.referencedFields = referencedFields;
    this.referencedOuterFields = referencedOuterFields;
    __publicField(this, "inputGroup");
    __publicField(this, "definition");
    this.inputGroup = input.getGroup();
    const itemDefinitions = {};
    const namedFieldEntries = Object.entries(namedFields);
    for (const [name, field] of namedFieldEntries) {
      itemDefinitions[name] = field.definition;
    }
    this.definition = {
      type: "array" /* Array */,
      isNullable: false,
      definition: {
        type: "object" /* Object */,
        isNullable: false,
        definitions: itemDefinitions
      }
    };
  }
  getHash() {
    const namedFieldIds = {};
    const namedFieldEntries = Object.entries(this.namedFields);
    for (const [name, field] of namedFieldEntries) {
      namedFieldIds[name] = field.id;
    }
    return calculateHash(
      "ScalarArray",
      this.inputGroup.id,
      namedFieldIds,
      this.ordering,
      this.referencedFields,
      this.referencedOuterFields
    );
  }
  getInputRequiredProps() {
    const resolvedFields = new Fields();
    const fields = Object.values(this.namedFields);
    for (const field of fields) {
      if (isUndefined(field.collection)) continue;
      resolvedFields.add(field);
    }
    return new RequiredProps(this.ordering, resolvedFields);
  }
  optimize(optimizer) {
    const inputRequired = this.getInputRequiredProps();
    const inputCost = optimizer.optimizeGroup(this.inputGroup, inputRequired);
    return new Cost(0).add(inputCost);
  }
  getOptimized() {
    const inputRequired = this.getInputRequiredProps();
    const input = this.inputGroup.getOptimized(inputRequired);
    return new _ScalarArray(
      input,
      this.namedFields,
      this.ordering,
      this.referencedFields,
      this.referencedOuterFields
    );
  }
  *evaluate(context, tuple) {
    const inputContext = new Tuple();
    if (context) inputContext.merge(context);
    if (tuple) inputContext.merge(tuple);
    const relation = yield* this.input.evaluate(inputContext);
    const namedFieldEntries = Object.entries(this.namedFields);
    return {
      type: "array" /* Array */,
      value: relation.tuples.map((relationTuple) => {
        const value = {};
        for (const [name, field] of namedFieldEntries) {
          value[name] = relationTuple.getValue(field);
        }
        return {
          type: "object" /* Object */,
          value
        };
      })
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarCast.ts
var ScalarCast = class _ScalarCast extends ScalarNode {
  constructor(input, definition) {
    super(input.referencedFields, input.referencedOuterFields, input.isSynchronous);
    this.input = input;
    this.definition = definition;
    assert(definition.isNullable, "Unsupported non-nullable cast");
  }
  getHash() {
    return calculateHash("ScalarCast", this.input, this.definition);
  }
  optimize(optimizer) {
    return this.input.optimize(optimizer);
  }
  getOptimized() {
    const input = this.input.getOptimized();
    return new _ScalarCast(input, this.definition);
  }
  *evaluate(context, tuple) {
    const input = yield* this.input.evaluate(context, tuple);
    return DatabaseValue.cast(input, this.definition);
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarFlatArray.ts
var ScalarFlatArray = class _ScalarFlatArray extends ScalarNode {
  constructor(input, field, ordering, referencedFields, referencedOuterFields) {
    super(referencedFields, referencedOuterFields, input.isSynchronous);
    this.input = input;
    this.field = field;
    this.ordering = ordering;
    this.referencedFields = referencedFields;
    this.referencedOuterFields = referencedOuterFields;
    __publicField(this, "inputGroup");
    __publicField(this, "definition");
    this.inputGroup = input.getGroup();
    this.definition = {
      type: "array" /* Array */,
      isNullable: false,
      definition: field.definition
    };
  }
  getHash() {
    return calculateHash(
      "ScalarFlatArray",
      this.inputGroup.id,
      this.field.id,
      this.ordering,
      this.referencedFields,
      this.referencedOuterFields
    );
  }
  getInputRequiredProps() {
    const resolvedFields = new Fields();
    if (!isUndefined(this.field.collection)) {
      resolvedFields.add(this.field);
    }
    return new RequiredProps(this.ordering, resolvedFields);
  }
  optimize(optimizer) {
    const inputRequired = this.getInputRequiredProps();
    const inputCost = optimizer.optimizeGroup(this.inputGroup, inputRequired);
    return new Cost(0).add(inputCost);
  }
  getOptimized() {
    const inputRequired = this.getInputRequiredProps();
    const input = this.inputGroup.getOptimized(inputRequired);
    return new _ScalarFlatArray(input, this.field, this.ordering, this.referencedFields, this.referencedOuterFields);
  }
  *evaluate(context, tuple) {
    const inputContext = new Tuple();
    if (context) inputContext.merge(context);
    if (tuple) inputContext.merge(tuple);
    const relation = yield* this.input.evaluate(inputContext);
    return {
      type: "array" /* Array */,
      value: relation.tuples.map((relationTuple) => {
        return relationTuple.getValue(this.field);
      })
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarIn.ts
var collation6 = {
  type: 0 /* CaseInsensitive */
};
var ScalarIn = class _ScalarIn extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarIn", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarIn(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: DatabaseValue.in(left, right, collation6)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarIndexOf.ts
var collation7 = {
  type: 1 /* CaseSensitive */
};
var ScalarIndexOf = class _ScalarIndexOf extends ScalarNode {
  constructor(source, target) {
    const referencedFields = new Fields();
    referencedFields.merge(source.referencedFields);
    referencedFields.merge(target.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(source.referencedOuterFields);
    referencedOuterFields.merge(target.referencedOuterFields);
    const isSynchronous = source.isSynchronous && target.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.source = source;
    this.target = target;
    __publicField(this, "definition", {
      type: "number" /* Number */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarIndexOf", this.source, this.target);
  }
  optimize(optimizer) {
    const sourceCost = this.source.optimize(optimizer);
    const targetCost = this.target.optimize(optimizer);
    return Cost.max(sourceCost, targetCost);
  }
  getOptimized() {
    const source = this.source.getOptimized();
    const target = this.target.getOptimized();
    return new _ScalarIndexOf(source, target);
  }
  *evaluate(context, tuple) {
    const { source, target } = yield* evaluateObject({
      source: this.source.evaluate(context, tuple),
      target: this.target.evaluate(context, tuple)
    });
    return {
      type: "number" /* Number */,
      value: DatabaseValue.indexOf(source, target, collation7)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarIntersection.ts
var ScalarIntersection = class _ScalarIntersection extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "array" /* Array */,
      definition: {
        type: "string" /* String */,
        isNullable: false
      },
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarIntersection", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarIntersection(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    const leftSet = databaseValueToSet(left);
    const rightSet = databaseValueToSet(right);
    const intersection2 = [];
    const shortestSet = leftSet.size < rightSet.size ? leftSet : rightSet;
    const longestSet = shortestSet === leftSet ? rightSet : leftSet;
    for (const item of shortestSet) {
      if (longestSet.has(item)) {
        intersection2.push({
          type: "string" /* String */,
          value: item
        });
      }
    }
    return {
      type: "array" /* Array */,
      value: intersection2
    };
  }
};
function databaseValueToSet(value) {
  const set = /* @__PURE__ */ new Set();
  if (!value) return set;
  assert2(value.type === "array" /* Array */, "ScalarIntersection expects an array, got:", value.type);
  for (const item of value.value) {
    if (!item) continue;
    assert2(
      item.type === "string" /* String */,
      "ScalarIntersection expects an array of strings, got an array with:",
      item.type
    );
    set.add(item.value);
  }
  return set;
}

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarLength.ts
var ScalarLength = class _ScalarLength extends ScalarNode {
  constructor(input) {
    super(input.referencedFields, input.referencedOuterFields, input.isSynchronous);
    this.input = input;
    __publicField(this, "definition", {
      type: "number" /* Number */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarLength", this.input);
  }
  optimize(optimizer) {
    return this.input.optimize(optimizer);
  }
  getOptimized() {
    const input = this.input.getOptimized();
    return new _ScalarLength(input);
  }
  *evaluate(context, tuple) {
    const input = yield* this.input.evaluate(context, tuple);
    return {
      type: "number" /* Number */,
      value: DatabaseValue.length(input)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarNot.ts
var ScalarNot = class _ScalarNot extends ScalarNode {
  constructor(input) {
    super(input.referencedFields, input.referencedOuterFields, input.isSynchronous);
    this.input = input;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarNot", this.input);
  }
  optimize(optimizer) {
    return this.input.optimize(optimizer);
  }
  getOptimized() {
    const input = this.input.getOptimized();
    return new _ScalarNot(input);
  }
  *evaluate(context, tuple) {
    const input = yield* this.input.evaluate(context, tuple);
    return {
      type: "boolean" /* Boolean */,
      value: !valueToBoolean(input)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarNotIn.ts
var collation8 = {
  type: 0 /* CaseInsensitive */
};
var ScalarNotIn = class _ScalarNotIn extends ScalarNode {
  constructor(left, right) {
    const referencedFields = new Fields();
    referencedFields.merge(left.referencedFields);
    referencedFields.merge(right.referencedFields);
    const referencedOuterFields = new Fields();
    referencedOuterFields.merge(left.referencedOuterFields);
    referencedOuterFields.merge(right.referencedOuterFields);
    const isSynchronous = left.isSynchronous && right.isSynchronous;
    super(referencedFields, referencedOuterFields, isSynchronous);
    this.left = left;
    this.right = right;
    __publicField(this, "definition", {
      type: "boolean" /* Boolean */,
      isNullable: false
    });
  }
  getHash() {
    return calculateHash("ScalarNotIn", this.left, this.right);
  }
  optimize(optimizer) {
    const leftCost = this.left.optimize(optimizer);
    const rightCost = this.right.optimize(optimizer);
    return Cost.max(leftCost, rightCost);
  }
  getOptimized() {
    const left = this.left.getOptimized();
    const right = this.right.getOptimized();
    return new _ScalarNotIn(left, right);
  }
  *evaluate(context, tuple) {
    const { left, right } = yield* evaluateObject({
      left: this.left.evaluate(context, tuple),
      right: this.right.evaluate(context, tuple)
    });
    return {
      type: "boolean" /* Boolean */,
      value: !DatabaseValue.in(left, right, collation8)
    };
  }
};

// ../../library/src/modules/cms/optimizer/nodes/scalar/ScalarVariable.ts
var ScalarVariable = class extends ScalarNode {
  constructor(field, isOuterField) {
    assert(field.name !== VIRTUAL_INDEX_FIELD, "Invalid field name");
    const referencedFields = new Fields();
    const referencedOuterFields = new Fields();
    if (isOuterField) {
      referencedOuterFields.add(field);
    } else {
      referencedFields.add(field);
    }
    super(referencedFields, referencedOuterFields, true);
    this.field = field;
    this.isOuterField = isOuterField;
    __publicField(this, "definition");
    this.definition = field.definition;
  }
  getHash() {
    return calculateHash("ScalarVariable", this.field.id, this.isOuterField);
  }
  optimize() {
    return new Cost(0);
  }
  getOptimized() {
    return this;
  }
  // biome-ignore lint/correctness/useYield: Required by the super class.
  *evaluate(context, tuple) {
    if (this.isOuterField) {
      assert(context, "Context must exist");
      return context.getValue(this.field);
    }
    assert(tuple, "Tuple must exist");
    return tuple.getValue(this.field);
  }
};

// ../../library/src/modules/cms/optimizer/Normalizer.ts
var Normalizer = class {
  constructor(memo4) {
    this.memo = memo4;
  }
  finishRelational(node) {
    return this.memo.addRelational(node);
  }
  newRelationalScan(collection) {
    const node = new RelationalScan(collection);
    return this.finishRelational(node);
  }
  newRelationalIndexLookup(index, query) {
    const node = new RelationalIndexLookup(index, query);
    return this.finishRelational(node);
  }
  newRelationalLeftJoin(left, right, constraint) {
    const node = new RelationalLeftJoin(left, right, constraint);
    return this.finishRelational(node);
  }
  newRelationalRightJoin(left, right, constraint) {
    return this.newRelationalLeftJoin(right, left, constraint);
  }
  newRelationalFilter(input, predicate) {
    if (input instanceof RelationalLeftJoin && // Check that the predicate doesn't depend on any joined field.
    predicate.referencedFields.subsetOf(input.leftGroup.relational.outputFields)) {
      const pushedFilter = this.newRelationalFilter(input.left, predicate);
      return this.newRelationalLeftJoin(pushedFilter, input.right, input.constraint);
    }
    if (input instanceof RelationalRightJoin && // Check that the predicate doesn't depend on any joined field.
    predicate.referencedFields.subsetOf(input.rightGroup.relational.outputFields)) {
      const pushedFilter = this.newRelationalFilter(input.right, predicate);
      return this.newRelationalLeftJoin(input.left, pushedFilter, input.constraint);
    }
    const node = new RelationalFilter(input, predicate);
    return this.finishRelational(node);
  }
  newRelationalProject(input, projections, passthrough) {
    const node = new RelationalProject(input, projections, passthrough);
    return this.finishRelational(node);
  }
  newRelationalLimit(input, limit, ordering) {
    if (input instanceof RelationalProject && // Check that the limit doesn't depend on any projected field.
    limit.referencedFields.subsetOf(input.inputGroup.relational.outputFields) && // Check that the ordering doesn't depend on any projected field.
    ordering.providedByFields(input.inputGroup.relational.outputFields)) {
      const pushedLimit = this.newRelationalLimit(input.input, limit, ordering);
      return this.newRelationalProject(pushedLimit, input.projections, input.passthrough);
    }
    const node = new RelationalLimit(input, limit, ordering);
    return this.finishRelational(node);
  }
  newRelationalOffset(input, offset, ordering) {
    const node = new RelationalOffset(input, offset, ordering);
    return this.finishRelational(node);
  }
  finishScalar(node) {
    const isConstant = node instanceof ScalarConstant;
    if (!isConstant && node.isSynchronous && node.referencedFields.size === 0 && node.referencedOuterFields.size === 0) {
      const value = node.evaluateSync();
      return this.newScalarConstant(node.definition, value);
    }
    return this.memo.addScalar(node);
  }
  /**
   * When we create `ScalarConstant` nodes, we always give them an unknown
   * type definition. Before we compare them to other nodes, we need to cast
   * them to a specific type.
   *
   * For example, in the following query:
   * ```
   * SELECT id FROM cars WHERE type = "coupe"
   * ```
   *
   * If the `type` field is an enum, and we parse the `"coupe"` constant as a
   * string, the where clause will always be false because an enum can't be
   * equal to a string. But if we cast the string to an enum type first, the
   * where clause will work as expected.
   */
  removeUnknown(node, definition) {
    if (node.definition.type !== "unknown") return node;
    if (definition.type === "unknown") return node;
    const nullableDefinition = { ...definition, isNullable: true };
    return this.newScalarCast(node, nullableDefinition);
  }
  newScalarVariable(field, isOuterField) {
    const node = new ScalarVariable(field, isOuterField);
    return this.finishScalar(node);
  }
  newScalarConstant(definition, value) {
    const node = new ScalarConstant(definition, value);
    return this.finishScalar(node);
  }
  newScalarNot(input) {
    if (input instanceof ScalarNot) {
      if (input.input.definition.type === "boolean" /* Boolean */) {
        return input.input;
      }
      const definition = { type: "boolean" /* Boolean */, isNullable: true };
      return this.newScalarCast(input.input, definition);
    }
    if (input instanceof ScalarEquals) {
      return this.newScalarNotEquals(input.left, input.right);
    }
    if (input instanceof ScalarNotEquals) {
      return this.newScalarEquals(input.left, input.right);
    }
    if (input instanceof ScalarLessThan) {
      return this.newScalarGreaterThanOrEqual(input.left, input.right);
    }
    if (input instanceof ScalarLessThanOrEqual) {
      return this.newScalarGreaterThan(input.left, input.right);
    }
    if (input instanceof ScalarGreaterThan) {
      return this.newScalarLessThanOrEqual(input.left, input.right);
    }
    if (input instanceof ScalarGreaterThanOrEqual) {
      return this.newScalarLessThan(input.left, input.right);
    }
    if (input instanceof ScalarAnd) {
      const left = this.newScalarNot(input.left);
      const right = this.newScalarNot(input.right);
      return this.newScalarOr(left, right);
    }
    if (input instanceof ScalarOr) {
      const left = this.newScalarNot(input.left);
      const right = this.newScalarNot(input.right);
      return this.newScalarAnd(left, right);
    }
    const node = new ScalarNot(input);
    return this.finishScalar(node);
  }
  // TODO: Normalize `$1 AND true` to `$1`
  // TODO: Normalize `true AND $1` to `$1`
  // TODO: Normalize `$1 AND false` to `false`
  // TODO: Normalize `false AND $1` to `false`
  // TODO: Normalize `$1 AND ($2 AND $c)` to `($1 AND $2) AND $c`
  newScalarAnd(left, right) {
    const node = new ScalarAnd(left, right);
    return this.finishScalar(node);
  }
  // TODO: Normalize `$1 OR true` to `$1`
  // TODO: Normalize `true OR $1` to `$1`
  // TODO: Normalize `$1 OR false` to `$1`
  // TODO: Normalize `false OR $1` to `false`
  // TODO: Normalize `$1 OR ($2 OR $c)` to `($1 OR $2) OR $c`
  newScalarOr(left, right) {
    const node = new ScalarOr(left, right);
    return this.finishScalar(node);
  }
  newScalarEquals(left, right) {
    const isLeftVariable = left instanceof ScalarVariable;
    const isRightVariable = right instanceof ScalarVariable;
    if (isRightVariable && !isLeftVariable) {
      return this.newScalarEquals(right, left);
    }
    left = this.removeUnknown(left, right.definition);
    right = this.removeUnknown(right, left.definition);
    const node = new ScalarEquals(left, right);
    return this.finishScalar(node);
  }
  newScalarNotEquals(left, right) {
    const isLeftVariable = left instanceof ScalarVariable;
    const isRightVariable = right instanceof ScalarVariable;
    if (isRightVariable && !isLeftVariable) {
      return this.newScalarNotEquals(right, left);
    }
    left = this.removeUnknown(left, right.definition);
    right = this.removeUnknown(right, left.definition);
    const node = new ScalarNotEquals(left, right);
    return this.finishScalar(node);
  }
  newScalarLessThan(left, right) {
    const isLeftVariable = left instanceof ScalarVariable;
    const isRightVariable = right instanceof ScalarVariable;
    if (isRightVariable && !isLeftVariable) {
      return this.newScalarGreaterThan(right, left);
    }
    left = this.removeUnknown(left, right.definition);
    right = this.removeUnknown(right, left.definition);
    const node = new ScalarLessThan(left, right);
    return this.finishScalar(node);
  }
  newScalarLessThanOrEqual(left, right) {
    const isLeftVariable = left instanceof ScalarVariable;
    const isRightVariable = right instanceof ScalarVariable;
    if (isRightVariable && !isLeftVariable) {
      return this.newScalarGreaterThanOrEqual(right, left);
    }
    left = this.removeUnknown(left, right.definition);
    right = this.removeUnknown(right, left.definition);
    const node = new ScalarLessThanOrEqual(left, right);
    return this.finishScalar(node);
  }
  newScalarGreaterThan(left, right) {
    const isLeftVariable = left instanceof ScalarVariable;
    const isRightVariable = right instanceof ScalarVariable;
    if (isRightVariable && !isLeftVariable) {
      return this.newScalarLessThan(right, left);
    }
    left = this.removeUnknown(left, right.definition);
    right = this.removeUnknown(right, left.definition);
    const node = new ScalarGreaterThan(left, right);
    return this.finishScalar(node);
  }
  newScalarGreaterThanOrEqual(left, right) {
    const isLeftVariable = left instanceof ScalarVariable;
    const isRightVariable = right instanceof ScalarVariable;
    if (isRightVariable && !isLeftVariable) {
      return this.newScalarLessThanOrEqual(right, left);
    }
    left = this.removeUnknown(left, right.definition);
    right = this.removeUnknown(right, left.definition);
    const node = new ScalarGreaterThanOrEqual(left, right);
    return this.finishScalar(node);
  }
  newScalarIn(left, right) {
    if (right.definition.type === "array" /* Array */) {
      left = this.removeUnknown(left, right.definition.definition);
    }
    const arrayDefinition = {
      type: "array" /* Array */,
      isNullable: true,
      definition: left.definition
    };
    right = this.removeUnknown(right, arrayDefinition);
    const node = new ScalarIn(left, right);
    return this.finishScalar(node);
  }
  newScalarNotIn(left, right) {
    if (right.definition.type === "array" /* Array */) {
      left = this.removeUnknown(left, right.definition.definition);
    }
    const arrayDefinition = {
      type: "array" /* Array */,
      isNullable: true,
      definition: left.definition
    };
    right = this.removeUnknown(right, arrayDefinition);
    const node = new ScalarNotIn(left, right);
    return this.finishScalar(node);
  }
  newScalarCase(input, conditions, otherwise) {
    if (input) {
      const castConditions = [];
      for (const { when, then } of conditions) {
        const castWhen = this.removeUnknown(when, input.definition);
        const castCondition = new CaseCondition(castWhen, then);
        castConditions.push(castCondition);
      }
      conditions = castConditions;
    }
    const node = new ScalarCase(input, conditions, otherwise);
    return this.finishScalar(node);
  }
  newScalarContains(source, target) {
    const node = new ScalarContains(source, target);
    return this.finishScalar(node);
  }
  newScalarStartsWith(source, target) {
    const node = new ScalarStartsWith(source, target);
    return this.finishScalar(node);
  }
  newScalarEndsWith(source, target) {
    const node = new ScalarEndsWith(source, target);
    return this.finishScalar(node);
  }
  newScalarLength(array) {
    const node = new ScalarLength(array);
    return this.finishScalar(node);
  }
  newScalarIndexOf(source, target) {
    const node = new ScalarIndexOf(source, target);
    return this.finishScalar(node);
  }
  newScalarArray(input, namedFields, ordering, referencedFields, referencedOuterFields) {
    const node = new ScalarArray(input, namedFields, ordering, referencedFields, referencedOuterFields);
    return this.finishScalar(node);
  }
  newScalarFlatArray(input, field, ordering, referencedFields, referencedOuterFields) {
    const node = new ScalarFlatArray(input, field, ordering, referencedFields, referencedOuterFields);
    return this.finishScalar(node);
  }
  newScalarIntersection(left, right) {
    const node = new ScalarIntersection(left, right);
    return this.finishScalar(node);
  }
  newScalarCast(input, definition) {
    if (input.definition.type === definition.type) {
      return input;
    }
    const node = new ScalarCast(input, definition);
    return this.finishScalar(node);
  }
};

// ../../library/src/modules/cms/optimizer/nodes/enforcer/EnforcerNode.ts
var EnforcerNode = class extends RelationalNode {
};

// ../../library/src/modules/cms/optimizer/nodes/enforcer/EnforcerResolve.ts
var EnforcerResolve = class _EnforcerResolve extends EnforcerNode {
  constructor(input, fields, resolver) {
    super(false);
    this.input = input;
    this.fields = fields;
    this.resolver = resolver;
    __publicField(this, "inputGroup");
    this.inputGroup = input.getGroup();
  }
  getHash() {
    return calculateHash("EnforcerResolve", this.inputGroup.id, this.fields);
  }
  getOutputFields() {
    return this.inputGroup.relational.outputFields;
  }
  canProvideOrdering() {
    return true;
  }
  canProvideResolvedFields(resolvedFields) {
    return resolvedFields.subsetOf(this.fields);
  }
  getInputRequiredProps(required) {
    const resolvedFields = new Fields();
    return new RequiredProps(required.ordering, resolvedFields);
  }
  optimize(optimizer, required) {
    const inputRequired = this.getInputRequiredProps(required);
    const inputCost = optimizer.optimizeGroup(this.inputGroup, inputRequired);
    return Cost.estimate(0, 100 * KB).add(inputCost);
  }
  getOptimized(required) {
    const inputRequired = this.getInputRequiredProps(required);
    const input = this.inputGroup.getOptimized(inputRequired);
    return new _EnforcerResolve(input, this.fields, this.resolver);
  }
  *evaluate(context) {
    const input = yield* this.input.evaluate(context);
    assert(this.fields.subsetOf(input.fields), "Fields can't be resolved");
    const collections = /* @__PURE__ */ new Set();
    for (const field of this.fields) {
      assert(field.collection, "Collection required to resolve field");
      collections.add(field.collection);
    }
    for (const tuple of input.tuples) {
      for (const field of this.fields) {
        const value = tuple.getValue(field);
        if (value?.type === "richtext" /* RichText */) {
          this.resolver.preloadRichTextValue(value);
        } else if (value?.type === "vectorsetitem" /* VectorSetItem */) {
          this.resolver.preloadVectorSetItemValue(value);
        }
      }
    }
    const collectionItems = yield Promise.all(
      Array.from(collections).map(async (collection) => {
        const pointers = [];
        for (const tuple of input.tuples) {
          const pointer = tuple.getPointer(collection);
          if (pointer) pointers.push(pointer);
        }
        const items = await collection.data.resolveItems(pointers);
        assert(items.length === pointers.length, "Invalid number of items");
        return [collection, items];
      })
    );
    return input.map(input.fields, (tuple) => {
      const result = new Tuple();
      result.merge(tuple);
      for (const [collection, items] of collectionItems) {
        const pointer = tuple.getPointer(collection);
        if (!pointer) continue;
        const item = items.shift();
        assert(item, "Item not found");
        assert(item.pointer === pointer, "Pointer mismatch");
        for (const field of collection.fields) {
          const value = field.getValue(item);
          result.addValue(field, value);
        }
      }
      return result;
    });
  }
};

// ../../library/src/modules/cms/optimizer/nodes/enforcer/EnforcerSort.ts
var collation9 = {
  type: 0 /* CaseInsensitive */
};
var EnforcerSort = class _EnforcerSort extends EnforcerNode {
  constructor(input, ordering) {
    super(input.isSynchronous);
    this.input = input;
    this.ordering = ordering;
    __publicField(this, "inputGroup");
    this.inputGroup = input.getGroup();
  }
  getHash() {
    return calculateHash("EnforcerSort", this.inputGroup.id, this.ordering);
  }
  getOutputFields() {
    return this.inputGroup.relational.outputFields;
  }
  canProvideOrdering(ordering) {
    return ordering.equals(this.ordering);
  }
  canProvideResolvedFields() {
    return true;
  }
  getInputRequiredProps(required) {
    const resolvedFields = new Fields(required.resolvedFields);
    for (const { field } of this.ordering.fields) {
      if (field.name === VIRTUAL_INDEX_FIELD) continue;
      if (isUndefined(field.collection)) continue;
      resolvedFields.add(field);
    }
    const ordering = new Ordering();
    return new RequiredProps(ordering, resolvedFields);
  }
  optimize(optimizer, required) {
    const inputRequired = this.getInputRequiredProps(required);
    const inputCost = optimizer.optimizeGroup(this.inputGroup, inputRequired);
    return new Cost(0).add(inputCost);
  }
  getOptimized(required) {
    const inputRequired = this.getInputRequiredProps(required);
    const input = this.inputGroup.getOptimized(inputRequired);
    return new _EnforcerSort(input, this.ordering);
  }
  *evaluate(context) {
    const input = yield* this.input.evaluate(context);
    return input.sort((leftTuple, rightTuple) => {
      for (const { field, direction } of this.ordering.fields) {
        const isAscending = direction === "asc" /* Ascending */;
        if (field.name === VIRTUAL_INDEX_FIELD) {
          const collection = field.collection;
          assert(collection, "Collection required for sorting");
          const leftPointer = leftTuple.getPointer(collection);
          assert(leftPointer, "Pointer required for sorting");
          const leftItem = { pointer: leftPointer, data: {} };
          const rightPointer = rightTuple.getPointer(collection);
          assert(rightPointer, "Pointer required for sorting");
          const rightItem = { pointer: rightPointer, data: {} };
          const order = collection.data.compareItems(leftItem, rightItem);
          return isAscending ? order : -order;
        }
        const leftValue = leftTuple.getValue(field);
        const rightValue = rightTuple.getValue(field);
        if (DatabaseValue.equal(leftValue, rightValue, collation9)) {
          continue;
        }
        if (isNull(leftValue) || DatabaseValue.lessThan(leftValue, rightValue, collation9)) {
          return isAscending ? -1 : 1;
        }
        if (isNull(rightValue) || DatabaseValue.greaterThan(leftValue, rightValue, collation9)) {
          return isAscending ? 1 : -1;
        }
        throw new Error("Invalid comparison");
      }
      return 0;
    });
  }
};

// ../../library/src/modules/cms/optimizer/nodes/relational/RelationalAssert.ts
var collation10 = {
  type: 1 /* CaseSensitive */
};

// ../../library/src/modules/cms/optimizer/Optimizer.ts
var Optimizer = class {
  constructor(query, locale, resolver) {
    this.query = query;
    this.locale = locale;
    this.resolver = resolver;
    __publicField(this, "memo", new Memo());
    __publicField(this, "normalizer", new Normalizer(this.memo));
    __publicField(this, "explorer", new Explorer(this.normalizer));
  }
  optimize() {
    const builder = new Builder(this.normalizer, this.query, this.locale);
    const outScope = builder.build();
    const root = outScope.takeNode();
    const group = root.getGroup();
    const required = outScope.getRequiredProps();
    this.optimizeGroup(group, required);
    const optimized = group.getOptimized(required);
    const namedFields = outScope.getNamedFields();
    return [optimized, namedFields];
  }
  optimizeGroup(group, required) {
    const winner = group.getWinner(required);
    if (winner.node) return winner.cost;
    const normalized = group.nodes[0];
    assert(normalized, "Normalized node not found");
    this.createEnforcer(winner, normalized, required);
    for (const node of group.nodes) {
      if (required.canProvide(node)) {
        const cost = node.optimize(this, required);
        winner.update(node, cost);
      }
      if (required.isMinimal) {
        this.explorer.explore(node);
      }
    }
    if (false) {
      assert(winner.node, "Group not optimized");
      const cache2 = /* @__PURE__ */ new Map();
      winner.node = new RelationalAssert(winner.node, required, cache2);
    }
    return winner.cost;
  }
  createEnforcer(winner, node, required) {
    if (required.resolvedFields.size > 0) {
      const enforcer = new EnforcerResolve(node, required.resolvedFields, this.resolver);
      const cost = enforcer.optimize(this, required);
      winner.update(enforcer, cost);
    }
    if (required.ordering.length > 0) {
      const enforcer = new EnforcerSort(node, required.ordering);
      const cost = enforcer.optimize(this, required);
      winner.update(enforcer, cost);
    }
  }
};

// ../../library/src/modules/cms/stringifyQuery.ts
function stringifyIdentifier(expression) {
  if (expression.collection) {
    return `"${expression.collection}"."${expression.name}"`;
  }
  return `"${expression.name}"`;
}
function stringifyLiteralValue(expression) {
  if (typeof expression.value === "string") {
    return `'${expression.value}'`;
  }
  return expression.value;
}
function stringifyFunctionCall(expression) {
  return `${expression.functionName}(${expression.arguments.map((argument) => stringifyExpression(argument)).join(", ")})`;
}
function stringifyCaseExpression(expression) {
  let caseString = "CASE";
  if (expression.value) {
    caseString += ` ${stringifyExpression(expression.value)}`;
  }
  for (const condition of expression.conditions) {
    caseString += ` WHEN ${stringifyExpression(condition.when)} THEN ${stringifyExpression(condition.then)}`;
  }
  if (expression.else) {
    caseString += ` ELSE ${stringifyExpression(expression.else)}`;
  }
  caseString += " END";
  return caseString;
}
function stringifyUnaryOperation(expression) {
  const value = stringifyExpression(expression.value);
  const operator = expression.operator.toUpperCase();
  return `${operator} ${value}`;
}
function stringifyBinaryOperation(expression) {
  const left = stringifyExpression(expression.left);
  const right = stringifyExpression(expression.right);
  const operator = expression.operator.toUpperCase();
  return `${left} ${operator} ${right}`;
}
function stringifyTypeCast(expression) {
  return `CAST(${stringifyExpression(expression.value)} as ${expression.dataType})`;
}
function stringifyExpression(expression) {
  switch (expression.type) {
    case "Identifier":
      return stringifyIdentifier(expression);
    case "LiteralValue":
      return stringifyLiteralValue(expression);
    case "FunctionCall":
      return stringifyFunctionCall(expression);
    case "Case":
      return stringifyCaseExpression(expression);
    case "UnaryOperation":
      return stringifyUnaryOperation(expression);
    case "BinaryOperation":
      return stringifyBinaryOperation(expression);
    case "TypeCast":
      return stringifyTypeCast(expression);
    case "Select":
      return `${stringifyQuery(expression)}`;
    default: {
      assertNever(expression);
    }
  }
}
function stringifyCollection(collection) {
  if (isDatabaseCollection(collection.data)) {
    return "Collection";
  }
  if (collection.alias) {
    return `"${collection.data.displayName}" AS "${collection.alias}"`;
  }
  return `"${collection.data.displayName}"`;
}
function stringifyJoin(join) {
  let result = `${stringifyFrom(join.left)} LEFT JOIN ${stringifyFrom(join.right)}`;
  if (join.constraint) {
    result += ` ON ${stringifyExpression(join.constraint)}`;
  }
  return result;
}
function stringifyFrom(from) {
  switch (from.type) {
    case "Collection":
      return stringifyCollection(from);
    case "LeftJoin":
      return stringifyJoin(from);
    default:
      assertNever(from);
  }
}
function autoIndentSql(sql) {
  let formattedSql = "";
  const tokens = sql.split(/\s+/u);
  tokens.forEach((token) => {
    if (token === "") return;
    if (["SELECT", "FROM", "WHERE", "ORDER", "LIMIT", "OFFSET"].includes(token)) {
      formattedSql += `
${token}`;
    } else if (["AND", "OR"].includes(token)) {
      formattedSql += `
	${token}`;
    } else {
      formattedSql += ` ${token}`;
    }
  });
  return formattedSql.trim();
}
function stringifyQuery(query) {
  let queryString = "";
  queryString += `SELECT ${query.select.map((selectExpression) => {
    const expressionString = stringifyExpression(selectExpression);
    if (selectExpression.alias) {
      return `${expressionString} AS "${selectExpression.alias}"`;
    }
    return expressionString;
  }).join(", ")}`;
  queryString += ` FROM ${stringifyFrom(query.from)}`;
  if (query.where) {
    queryString += ` WHERE ${stringifyExpression(query.where)}`;
  }
  if (query.orderBy) {
    queryString += ` ORDER BY ${query.orderBy.map((orderExpression) => {
      return `${stringifyExpression(orderExpression)} ${orderExpression.direction ?? "asc" /* Ascending */}`;
    }).join(", ")}`;
  }
  if (query.limit) {
    queryString += ` LIMIT ${stringifyExpression(query.limit)}`;
  }
  if (query.offset) {
    queryString += ` OFFSET ${stringifyExpression(query.offset)}`;
  }
  return autoIndentSql(queryString);
}

// ../../library/src/modules/cms/QueryEngine.ts
var log2 = /* @__PURE__ */ getLogger2("query-engine");
var QueryEngine = class {
  async evalQuery(query, locale, includeRaw) {
    if (log2.enabled) {
      log2.debug(`Query:
${stringifyQuery(query)}`);
    }
    const resolver = new Resolver(query, locale);
    const optimizer = new Optimizer(query, locale, resolver);
    const [root, namedFields] = optimizer.optimize();
    const relation = await root.evaluateAsync();
    const namedFieldEntries = Object.entries(namedFields);
    const rawResults = [];
    const maybeEvaluatedPromise = evaluateMaybeAsync(
      evaluateArray(
        relation.tuples.map((tuple) => {
          const object = {};
          const rawObject = {};
          for (const [fieldName, field] of namedFieldEntries) {
            const value = tuple.getValue(field);
            object[fieldName] = resolver.resolveValue(value);
            if (includeRaw) {
              rawObject[fieldName] = value;
            }
          }
          if (includeRaw) {
            rawResults.push(rawObject);
          }
          return evaluateObject(object);
        })
      )
    );
    if (includeRaw) {
      return [isPromise(maybeEvaluatedPromise) ? await maybeEvaluatedPromise : maybeEvaluatedPromise, rawResults];
    }
    return maybeEvaluatedPromise;
  }
  async serializeableQuery(query, locale) {
    return this.evalQuery(query, locale, true);
  }
  async query(query, locale) {
    return this.evalQuery(query, locale, false);
  }
  resolveSerializableQueryResult(raw, query, locale) {
    const resolver = new Resolver(query, locale);
    return evaluateMaybeAsync(
      evaluateArray(
        raw.map((item) => {
          const object = {};
          let key7;
          for (key7 in item) {
            const value = item[key7];
            object[key7] = resolver.resolveValue(value);
          }
          return evaluateObject(object);
        })
      )
    );
  }
};

// ../../library/src/modules/cms/QueryCache.ts
var handoverDataType2 = /* @__PURE__ */ (() => HandoverDataType.QueryCache)();
function isCollection(value) {
  return isObject2(value) && value.type === "Collection";
}
var QueryCache = class {
  constructor(queryEngine2, maxSize = Infinity) {
    this.queryEngine = queryEngine2;
    this.maxSize = maxSize;
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    /** Server-only cache for serialized results to avoid re-serializing on cache hits */
    __publicField(this, "serializedCache", handoverCollector !== void 0 ? /* @__PURE__ */ new Map() : void 0);
  }
  prune() {
    if (this.cache.size <= this.maxSize) return;
    for (const [key7, value] of this.cache) {
      if (this.cache.size <= this.maxSize) break;
      if (value.state === "pending") continue;
      this.cache.delete(key7);
      this.serializedCache?.delete(key7);
    }
  }
  get(query, locale) {
    const key7 = getCacheKey(query, locale);
    const existing = this.cache.get(key7);
    if (existing) {
      this.cache.delete(key7);
      this.cache.set(key7, existing);
      if (handoverCollector !== void 0 && this.serializedCache !== void 0 && !hasRandomCollectionId(key7) && existing.state === "fulfilled") {
        const cachedSerialized = this.serializedCache.get(key7);
        if (cachedSerialized !== void 0) {
          handoverCollector.set(handoverDataType2, key7, cachedSerialized);
        }
      }
      return existing;
    }
    const resolver = () => {
      const containsRandomCollectionId = hasRandomCollectionId(key7);
      const handoverResult = containsRandomCollectionId ? void 0 : getHandoverData(handoverDataType2, key7);
      if (handoverResult) {
        try {
          return this.queryEngine.resolveSerializableQueryResult(handoverResult, query, locale);
        } catch (error) {
          handleHydrationError(error, key7);
        }
      }
      if (handoverCollector !== void 0 && !containsRandomCollectionId) {
        return this.queryEngine.serializeableQuery(query, locale).then(([queryResult, serializableResult]) => {
          this.serializedCache?.set(key7, serializableResult);
          handoverCollector.set(handoverDataType2, key7, serializableResult);
          return queryResult;
        });
      }
      return this.queryEngine.query(query, locale);
    };
    const value = new LazyValue(resolver);
    this.cache.set(key7, value);
    this.prune();
    return value;
  }
};
function replaceCollection(_, value) {
  if (isCollection(value) && isAnyCollection(value.data)) return getCollectionId(value.data);
  return value;
}
function getCacheKey(query, locale) {
  const localeId = locale?.id ?? "default";
  return JSON.stringify(query, replaceCollection) + localeId;
}

// ../../library/src/modules/useActiveVariantCallback.ts
import { useEffect as useEffect21, useRef as useRef21 } from "react";
function rejectPending(pendingTimers, pendingPromises) {
  pendingTimers.forEach((t) => clearTimeout(t));
  pendingTimers.clear();
  pendingPromises.forEach((reject) => reject?.("Callback cancelled by variant change"));
  pendingPromises.clear();
}
function createSet() {
  return /* @__PURE__ */ new Set();
}
function useActiveVariantCallback(baseVariant) {
  const pendingPromises = useConstant(createSet);
  const pendingTimers = useConstant(createSet);
  useOnCurrentTargetChange(() => {
    return () => rejectPending(pendingTimers, pendingPromises);
  });
  useEffect21(() => {
    return () => rejectPending(pendingTimers, pendingPromises);
  }, []);
  useEffect21(() => {
    rejectPending(pendingTimers, pendingPromises);
  }, [baseVariant]);
  return useRef21({
    /**
     * Create a callback that can be cancelled if the base variant changes.
     */
    activeVariantCallback: (callback) => async (...args) => {
      return new Promise((resolve, reject) => {
        pendingPromises.add(reject);
        void callback(...args).then(resolve);
      }).catch(() => {
      });
    },
    /**
     * Execute a callback after a defined period of time. The callback will not
     * be called if pending events are cancelled because the timeout will be
     * cancelled.
     */
    delay: async (callback, msDelay) => {
      await new Promise((resolve) => {
        pendingTimers.add(globalThis.setTimeout(() => resolve(true), msDelay));
      });
      callback();
    }
  }).current;
}
function useActiveTargetCallback() {
  const value = useActiveVariantCallback(void 0);
  return useRef21({
    activeTargetCallback: value.activeVariantCallback,
    delay: value.delay
  }).current;
}

// ../../library/src/modules/useAddVariantProps.ts
import React72 from "react";
function useAddVariantProps(baseVariant, gestureVariant, variantProps) {
  return React72.useCallback(
    (id) => {
      if (!variantProps) return {};
      if (!baseVariant) return {};
      if (gestureVariant) {
        return Object.assign({}, variantProps[baseVariant]?.[id], variantProps[gestureVariant]?.[id]);
      }
      return variantProps[baseVariant]?.[id] || {};
    },
    [baseVariant, gestureVariant, variantProps]
  );
}

// ../../library/src/modules/useBreakpointVariants.ts
import { startTransition as startTransition7, useCallback as useCallback19, useContext as useContext28, useEffect as useEffect22, useRef as useRef22 } from "react";
function createMediaQueriesFromBreakpoints(breakpoints) {
  const mediaQueries = {};
  for (const [variant, query] of Object.entries(breakpoints)) {
    const { min = 0, max } = query;
    const mediaQuery = [];
    if (min) mediaQuery.push(`(min-width: ${min}px)`);
    if (max) mediaQuery.push(`(max-width: ${max}px)`);
    if (mediaQuery.length) mediaQueries[variant] = mediaQuery.join(" and ");
  }
  return mediaQueries;
}
function activeMediaQueryFromWindow(mediaQueries) {
  for (const [variant, query] of Object.entries(mediaQueries)) {
    const mql = safeWindow.matchMedia(query);
    if (mql.matches) return variant;
  }
}
function activeBreakpointHashesFromWindow(breakpoints) {
  const matches = [];
  for (const { hash: hash2, mediaQuery } of breakpoints) {
    if (!mediaQuery) continue;
    const mql = safeWindow.matchMedia(mediaQuery);
    if (mql.matches) matches.push(hash2);
  }
  if (matches.length > 0) return matches;
  const defaultHash = breakpoints[0]?.hash;
  if (!defaultHash) return void 0;
  return [defaultHash];
}
function useHydratedBreakpointVariants(initial, mediaQueries, hydratedWithInitial = true) {
  const isInitialNavigation = useContext28(IsInitialNavigationContext);
  const isStaticRenderer2 = useIsStaticRenderer();
  const usesMediaQueries = !isStaticRenderer2 && isBrowser2();
  const baseVariant = useRef22(usesMediaQueries ? activeMediaQueryFromWindow(mediaQueries) ?? initial : initial);
  const basePropsVariant = useRef22(hydratedWithInitial && isInitialNavigation ? initial : baseVariant.current);
  const forceUpdate = useForceUpdate2();
  const instantTransition = useInstantTransition();
  const setActiveVariantInstant = useCallback19(
    (variant) => {
      if (variant !== baseVariant.current || variant !== basePropsVariant.current) {
        let updateStateAndRerender2 = function() {
          baseVariant.current = basePropsVariant.current = variant;
          startTransition7(() => {
            forceUpdate();
          });
        };
        var updateStateAndRerender = updateStateAndRerender2;
        if (isStaticRenderer2) {
          updateStateAndRerender2();
        } else {
          instantTransition(() => {
            updateStateAndRerender2();
          });
        }
      }
    },
    [instantTransition, forceUpdate, isStaticRenderer2]
  );
  useIsomorphicLayoutEffect2(() => {
    if (!isStaticRenderer2) return;
    setActiveVariantInstant(initial);
  }, [initial, isStaticRenderer2, setActiveVariantInstant]);
  useIsomorphicLayoutEffect2(() => {
    if (!hydratedWithInitial || isInitialNavigation !== true) return;
    setActiveVariantInstant(baseVariant.current);
  }, []);
  useEffect22(() => {
    const callbacks = [];
    for (const [variant, query] of Object.entries(mediaQueries)) {
      const mql = safeWindow.matchMedia(query);
      const callback = (event) => {
        if (event.matches) setActiveVariantInstant(variant);
      };
      addMQLCallback(mql, callback);
      callbacks.push([mql, callback]);
    }
    return () => callbacks.forEach(([mql, callback]) => removeMQLCallback(mql, callback));
  }, [mediaQueries, setActiveVariantInstant]);
  return [baseVariant.current, basePropsVariant.current];
}
function addMQLCallback(mql, callback) {
  if (mql.addEventListener) {
    mql.addEventListener("change", callback);
  } else {
    mql.addListener(callback);
  }
}
function removeMQLCallback(mql, callback) {
  if (mql.removeEventListener) {
    mql.removeEventListener("change", callback);
  } else {
    mql.removeListener(callback);
  }
}
function useBreakpointVariants(initial, _width, breakpoints) {
  const mediaQueries = useConstant(() => createMediaQueriesFromBreakpoints(breakpoints));
  const [initialVariant] = useHydratedBreakpointVariants(initial, mediaQueries, true);
  return initialVariant;
}
function removeHiddenBreakpointLayers(_initial, _mediaQueries, _variantClassNames) {
}
var framerBreakpointCSSSelector = "style[data-framer-breakpoint-css]";
function requestIdleCallbackFallback(callback) {
  setTimeout(callback, 1);
}
function removeHiddenBreakpointLayersV2(breakpoints) {
  const suspenseBoundaries = /* @__PURE__ */ new Set();
  const activeBreakpointHashes = activeBreakpointHashesFromWindow(breakpoints);
  if (activeBreakpointHashes) {
    for (const hash2 of activeBreakpointHashes) {
      for (const hiddenLayer of document.querySelectorAll(".hidden-" + hash2)) {
        if (isSuspenseBoundaryStart(hiddenLayer.previousSibling)) {
          suspenseBoundaries.add(hiddenLayer.previousSibling);
        }
        hiddenLayer.parentNode?.removeChild(hiddenLayer);
      }
    }
  }
  const requestIdleCallback2 = supportsRequestIdleCallback ? safeWindow.requestIdleCallback : requestIdleCallbackFallback;
  requestIdleCallback2(() => {
    document.querySelector(framerBreakpointCSSSelector)?.remove();
  });
  for (const ssrVariant of document.querySelectorAll(".ssr-variant:empty")) {
    if (isSuspenseBoundaryStart(ssrVariant.previousSibling)) {
      suspenseBoundaries.add(ssrVariant.previousSibling);
    }
    ssrVariant.parentNode?.removeChild(ssrVariant);
  }
  for (const suspenseBoundary of suspenseBoundaries) {
    if (isSuspenseBoundaryEnd(suspenseBoundary.nextSibling)) {
      suspenseBoundary.parentNode?.removeChild(suspenseBoundary.nextSibling);
      suspenseBoundary.parentNode?.removeChild(suspenseBoundary);
    }
  }
}
function isSuspenseBoundaryStart(node) {
  return node?.nodeType === Node.COMMENT_NODE && node.textContent === "$";
}
function isSuspenseBoundaryEnd(node) {
  return node?.nodeType === Node.COMMENT_NODE && node.textContent === "/$";
}

// ../../library/src/modules/useDataRecord.ts
import { useMemo as useMemo17 } from "react";
function useDataRecord(collection, variables) {
  return useMemo17(() => {
    if (!Array.isArray(collection)) {
      return null;
    }
    if (!variables) {
      return null;
    }
    const pageRecord = collection.find((record) => {
      return Object.entries(variables).every(([key7, value]) => {
        const recordValue = record[key7];
        if (value === void 0 || recordValue === void 0 || isObject2(value) || isObject2(recordValue)) {
          return false;
        }
        return String(value) === String(recordValue);
      });
    });
    return pageRecord ?? null;
  }, [collection, variables]);
}

// ../../library/src/modules/useDynamicRefs.ts
import React73, { createRef, useMemo as useMemo18 } from "react";
function useDynamicRefs() {
  const map2 = useConstant(() => /* @__PURE__ */ new Map());
  return React73.useCallback((key7) => {
    const existing = map2.get(key7);
    if (existing) return existing;
    const ref = createRef();
    map2.set(key7, ref);
    return ref;
  }, []);
}
var map = /* @__PURE__ */ new Map();
function useSiteRefs() {
  const route = useCurrentRoute();
  const { activeLocale } = useLocaleInfo();
  const path = useMemo18(() => {
    return getPathForRoute(route, {
      currentRoutePath: route?.path,
      currentRoutePathLocalized: route?.pathLocalized,
      currentPathVariables: route?.pathVariables,
      preserveQueryParams: false,
      relative: false,
      siteCanonicalURL: void 0,
      localeId: activeLocale?.id
    });
  }, [route, activeLocale?.id]);
  return React73.useCallback(
    (key7) => {
      if (!key7) return;
      const computedKey = `${path}-${key7}`;
      const existing = map.get(computedKey);
      if (existing) return existing;
      const ref = createRef();
      map.set(computedKey, ref);
      return ref;
    },
    [path]
  );
}

// ../../library/src/modules/useGamepad.ts
import React74 from "react";
function isFramerGamepadKeydownData(value) {
  return isObject2(value) && value.mapping !== void 0;
}
function gamepadInputsHaveChanged(previous, current) {
  if (previous.length !== current.length) return true;
  if (!previous.every((item, i) => current[i] === item)) return true;
  return false;
}
function createGamepadPoller() {
  const handlers = /* @__PURE__ */ new Set();
  let isConnected = false;
  let isPolling = null;
  let lastKeys = [];
  const startPolling = () => {
    const input = getGamepadInputs();
    if (!input) return;
    const { gamepad, inputs } = input;
    const { mapping, id } = gamepad;
    if (gamepadInputsHaveChanged(lastKeys, inputs)) handlers.forEach((handler) => handler({ inputs, mapping, id }));
    lastKeys = inputs;
    isPolling = safeWindow.requestAnimationFrame(startPolling);
  };
  const handleConnection = () => {
    if (isConnected || isPolling) return;
    startPolling();
    isConnected = true;
  };
  const stopPolling = () => {
    if (!isPolling) return;
    safeWindow.cancelAnimationFrame(isPolling);
    isPolling = null;
  };
  const handleDisconnection = () => {
    if (!isConnected) return;
    stopPolling();
    isConnected = false;
  };
  const setupAndStartPolling = () => {
    if (isPolling) return;
    const gamepad = getGamepadInputs();
    if (!gamepad) {
      safeWindow.addEventListener("gamepadconnected", handleConnection);
      return;
    }
    safeWindow.addEventListener("gamepaddisconnected", handleDisconnection);
    isConnected = true;
    startPolling();
  };
  const cleanupAndStopPolling = () => {
    if (!isPolling) return;
    safeWindow.removeEventListener("gamepadconnected", handleConnection);
    safeWindow.removeEventListener("gamepaddisconnected", handleDisconnection);
    stopPolling();
  };
  return {
    register(callback) {
      if (handlers.size === 0) setupAndStartPolling();
      handlers.add(callback);
    },
    unregister(callback) {
      handlers.delete(callback);
      if (handlers.size === 0) cleanupAndStopPolling();
    }
  };
}
var gamepadPoller = /* @__PURE__ */ createGamepadPoller();
var GamepadContext = /* @__PURE__ */ React74.createContext(gamepadPoller);
function getGamepadInputs() {
  let firstConnectedGamepad = null;
  const gamepads = navigator.getGamepads();
  for (const gamepad of gamepads) {
    if (!gamepad) continue;
    if (!firstConnectedGamepad) firstConnectedGamepad = gamepad;
    const inputs = [...scanPressedAxis(gamepad), ...scanPressedButtons(gamepad)];
    if (inputs.length > 0) return { gamepad, inputs };
  }
  if (firstConnectedGamepad) return { gamepad: firstConnectedGamepad, inputs: [] };
  return null;
}
function scanPressedAxis(gamepad) {
  const axes = [];
  for (const [idx, axis] of gamepad.axes.entries()) {
    if (idx > 3) continue;
    if (axis <= -0.5) axes.push(`Axis ${idx}-`);
    if (axis > 0.5) axes.push(`Axis ${idx}+`);
  }
  return axes;
}
function scanPressedButtons(gamepad) {
  const buttons = [];
  for (const [idx, button] of gamepad.buttons.entries()) {
    if (isButtonPressed(button)) buttons.push(`Button ${idx}`);
  }
  return buttons;
}
function isButtonPressed(button) {
  return button.pressed === true || button.value > 0;
}
function useGamepad(input, callback, { mapping, on } = {}) {
  const context = React74.useContext(GamepadContext);
  const settings = useConstant(() => ({
    mapping: mapping ?? "standard",
    on: on ?? "keydown"
  }));
  const stateRef = React74.useRef({
    pressed: false,
    handler: callback
  });
  const cb = React74.useCallback(
    (gamepad) => {
      const { pressed, handler } = stateRef.current;
      if (gamepad.inputs.includes(input) && settings.mapping === gamepad.mapping) {
        settings.on === "keydown" && handler();
        stateRef.current.pressed = true;
      } else if (pressed) {
        settings.on === "keyup" && handler();
        stateRef.current.pressed = false;
      }
    },
    [input, settings]
  );
  useOnCurrentTargetChange((isInTarget, isOverlayed) => {
    const isActive = isInTarget && !isOverlayed;
    if (isActive) {
      context.register(cb);
    } else {
      context.unregister(cb);
    }
    return () => context.unregister(cb);
  }, []);
  React74.useEffect(() => {
    return () => context.unregister(cb);
  }, [cb, context]);
  React74.useEffect(() => {
    stateRef.current.handler = callback;
  }, [callback]);
}

// ../../library/src/modules/useHotkey.ts
import React75 from "react";
var modifierDefaults = {
  altKey: false,
  ctrlKey: false,
  metaKey: false,
  shiftKey: false
};
function createShortcutDefinition(shortcut) {
  const keys3 = shortcut.split("+");
  const key7 = keys3.pop();
  if (!key7) return void 0;
  const modifiers = {};
  for (const modifier of keys3) {
    modifiers[`${modifier}Key`] = true;
  }
  return {
    ...modifierDefaults,
    ...modifiers,
    key: key7
  };
}
function useHotkey(shortcut, callback) {
  const inTarget = React75.useRef(true);
  const shortcutDefinition = useConstant(() => createShortcutDefinition(shortcut));
  useOnCurrentTargetChange((isCurrentTarget, isOverlayed) => {
    inTarget.current = isCurrentTarget && !isOverlayed;
    return () => inTarget.current = false;
  });
  const eventHandler = React75.useCallback(
    (event) => {
      if (!shortcutDefinition) return;
      if (!inTarget.current) return;
      if (!Object.keys(shortcutDefinition).every((key7) => shortcutDefinition[key7] === asRecord(event)[key7])) return;
      event.preventDefault();
      callback();
    },
    [shortcutDefinition, callback]
  );
  React75.useEffect(() => {
    document.addEventListener("keydown", eventHandler);
    return () => document.removeEventListener("keydown", eventHandler);
  }, [eventHandler]);
}

// ../../library/src/modules/useNavigate.tsx
function useNavigate() {
  const { navigate } = useRouter();
  const onCanvas = useIsOnFramerCanvas();
  if (!navigate) return () => {
  };
  return (target) => {
    if (onCanvas) return;
    navigate(target);
    return false;
  };
}

// ../../library/src/modules/useOnVariantChange.ts
import React76 from "react";
function callbackForVariant(map2, variant) {
  if (map2[variant]) return map2[variant];
  if (variant in map2) return void 0;
  return map2.default;
}
function useOnVariantChange(variant, callbackMap) {
  const isRenderingStaticContent = isStaticRenderer();
  if (isRenderingStaticContent) return;
  const isActiveScreenRef = React76.useRef(true);
  const callbackMapRef = React76.useRef(callbackMap);
  useOnCurrentTargetChange((isCurrent, isOverlayed) => {
    const isActiveScreen = isCurrent && !isOverlayed;
    if (!isActiveScreenRef.current && isActiveScreen) {
      const callback = callbackForVariant(callbackMapRef.current, variant);
      if (callback) callback();
    }
    isActiveScreenRef.current = isActiveScreen;
  }, []);
  React76.useEffect(() => {
    if (isActiveScreenRef.current) {
      const callback = callbackForVariant(callbackMapRef.current, variant);
      if (callback) callback();
    }
  }, [variant]);
}
function useOnAppear(callback) {
  useOnVariantChange("default", { default: callback });
}

// ../../library/src/modules/useOverlayState.tsx
import React77, { startTransition as startTransition8 } from "react";
function setOverflow(blockDocumentScrolling, show) {
  if (blockDocumentScrolling === false) return;
  frame.render(() => {
    const htmlStyle = document.documentElement.style;
    if (show) {
      htmlStyle.setProperty("overflow", "hidden");
    } else {
      htmlStyle.removeProperty("overflow");
    }
  });
}
function useOverlayState({
  blockDocumentScrolling = true,
  dismissWithEsc = false
} = {}) {
  const [showOverlay, setShowOverlay] = React77.useState(false);
  const callback = React77.useCallback(
    async (show) => {
      await yieldToMain({ priority: "user-blocking", continueAfter: "paint" });
      startTransition8(() => setShowOverlay(show));
      setOverflow(blockDocumentScrolling, show);
    },
    [blockDocumentScrolling]
  );
  React77.useEffect(
    () => () => {
      void yieldToMain({ priority: "user-blocking", continueAfter: "paint" }).then(() => {
        setOverflow(blockDocumentScrolling, false);
      });
    },
    [blockDocumentScrolling]
  );
  React77.useEffect(() => {
    if (!dismissWithEsc) return;
    const handleEscapeKeyDown = (event) => {
      if (event.key !== "Escape") return;
      event.preventDefault();
      event.stopPropagation();
      void callback(false);
    };
    safeWindow.addEventListener("keydown", handleEscapeKeyDown);
    return () => safeWindow.removeEventListener("keydown", handleEscapeKeyDown);
  }, [dismissWithEsc, callback]);
  return [showOverlay, callback];
}

// ../../library/src/modules/usePrototypeNavigate.tsx
import React78 from "react";

// ../../library/src/router/isRoute.ts
var key4 = "page";
function isRoute(route) {
  return isObject2(route) && key4 in route && route.page !== void 0;
}

// ../../library/src/modules/usePrototypeNavigate.tsx
async function componentForRoute(route) {
  if (!isRoute(route)) return;
  const { page: routeComponent } = route;
  if (!routeComponent) return;
  if (React78.isValidElement(routeComponent)) return routeComponent;
  if (withPreload(routeComponent)) await routeComponent.preload();
  return React78.createElement(routeComponent, { key: route.path });
}
var preloadKey2 = "preload";
function withPreload(component) {
  return !!component && isObject2(component) && preloadKey2 in component;
}
function usePrototypeNavigate({ preload } = {}) {
  const navigation = useNavigation();
  const { getRoute } = useRouter();
  const onCanvas = useIsOnFramerCanvas();
  React78.useEffect(() => {
    if (!navigation || onCanvas) return;
    preload?.forEach((componentOrRoute) => {
      let component;
      if (isString(componentOrRoute)) {
        const route = getRoute?.(componentOrRoute);
        if (isRoute(route)) {
          component = route.page;
        }
      } else {
        component = componentOrRoute;
      }
      if (component && withPreload(component)) void component.preload();
    });
  }, []);
  if (!navigation) return () => {
  };
  return async (target, options = {}) => {
    if (onCanvas) return;
    if (target === "previous") {
      navigation.goBack();
      return false;
    }
    const Component18 = typeof target === "string" ? await componentForRoute(getRoute?.(target)).catch(() => {
    }) : React78.isValidElement(target) ? target : null;
    if (!Component18) return;
    const { appearsFrom, backdropColor, animation } = options;
    const transitionType = options.transition || "instant";
    switch (transitionType) {
      case "instant":
        navigation.instant(Component18);
        break;
      case "fade":
        navigation.fade(Component18, { animation });
        break;
      case "push":
        navigation.push(Component18, { appearsFrom, animation });
        break;
      case "flip":
        navigation.flip(Component18, { appearsFrom, animation });
        break;
      case "magicMotion":
        navigation.magicMotion(Component18, { animation });
        break;
      // Overlay stack navigation doesn't support updating the browser's
      // path.
      case "modal":
        navigation.modal(Component18, { backdropColor, animation });
        break;
      case "overlay":
        navigation.overlay(Component18, { appearsFrom, backdropColor, animation });
        break;
    }
    return false;
  };
}

// ../../library/src/modules/useQueryData.ts
import { useCallback as useCallback20 } from "react";
var queryEngine = /* @__PURE__ */ new QueryEngine();
var queryCache = /* @__PURE__ */ new QueryCache(queryEngine);
function useQueryData(query) {
  const { activeLocale } = useLocaleInfo();
  const cached = queryCache.get(query, activeLocale);
  return cached.use();
}
function useQueryCount(query) {
  const countQuery = { ...query, select: [] };
  const collection = useQueryData(countQuery);
  return collection.length;
}
function usePreloadQuery() {
  const { activeLocale } = useLocaleInfo();
  return useCallback20(
    (query) => {
      return queryCache.get(query, activeLocale).readMaybeAsync();
    },
    [activeLocale]
  );
}
function getWhereExpressionFromPathVariables(pathVariables, collection) {
  const entries = Object.entries(pathVariables ?? {}).filter(([, value]) => {
    if (isUndefined(value)) return false;
    if (isObject2(value)) return false;
    return true;
  });
  const expressions = entries.map(
    ([name, value]) => ({
      type: "BinaryOperation",
      operator: "==" /* Equals */,
      left: {
        type: "TypeCast",
        value: {
          type: "Identifier",
          name,
          collection
        },
        dataType: "STRING" /* String */
      },
      right: {
        type: "LiteralValue",
        value: String(value)
      }
    })
  );
  if (expressions.length === 0) {
    return {
      type: "LiteralValue",
      value: false
    };
  }
  return expressions.reduce(
    (result, expression) => ({
      type: "BinaryOperation",
      operator: "and" /* And */,
      left: result,
      right: expression
    })
  );
}

// ../../library/src/components/utils/useLoadMorePaginatedQuery.tsx
import { useMemo as useMemo20 } from "react";

// ../../library/src/components/utils/useLoadMorePagination.tsx
import { startTransition as startTransition9, useCallback as useCallback21, useEffect as useEffect23, useMemo as useMemo19, useRef as useRef23, useState as useState7, useTransition } from "react";
function useLoadMorePagination(totalSize, pageSize, hash2, paginateWithSuspendedLoadingState = false) {
  const [isPending, startLoadingTransition] = useTransition();
  const totalPages = Math.ceil(totalSize / pageSize);
  const [currentPage, setCurrentPage] = useState7(
    globalThis?.history?.state?.paginationInfo?.[hash2]?.currentPage ?? 1
  );
  const currentPageRef = useRef23(currentPage);
  const paginationInfo = useMemo19(() => {
    return {
      currentPage,
      totalPages,
      isLoading: isPending
    };
  }, [currentPage, totalPages, isPending]);
  useEffect23(() => {
    pushLoadMoreHistory(hash2, paginationInfo);
  }, [hash2, paginationInfo]);
  const onCanvas = useIsOnFramerCanvas();
  const loadMore = useCallback21(async () => {
    if (onCanvas) return;
    if (currentPageRef.current >= totalPages) return;
    await yieldToMain({ priority: "user-blocking", continueAfter: "paint" });
    if (currentPageRef.current >= totalPages) return;
    const renderNextPage = (startTransition16) => {
      startTransition16(() => {
        setCurrentPage((_currentPage) => {
          const nextPage = Math.min(_currentPage + 1, totalPages);
          currentPageRef.current = nextPage;
          return nextPage;
        });
      });
    };
    if (!paginateWithSuspendedLoadingState) return renderNextPage(startTransition9);
    return renderNextPage(startLoadingTransition);
  }, [totalPages, paginateWithSuspendedLoadingState]);
  return { paginationInfo, loadMore };
}

// ../../library/src/components/utils/useLoadMorePaginatedQuery.tsx
function useLoadMorePaginatedQuery(query, pageSize, hash2) {
  const count = useQueryCount(query);
  const { paginationInfo, loadMore } = useLoadMorePagination(count, pageSize, hash2, true);
  const paginatedQuery = useMemo20(() => {
    let limit = pageSize * paginationInfo.currentPage;
    if (query.limit) {
      if (query.limit.type !== "LiteralValue" || typeof query.limit.value !== "number") {
        throw new Error("Unexpected type for query limit");
      }
      limit = Math.min(limit, query.limit.value);
    }
    return { ...query, limit: { type: "LiteralValue", value: limit } };
  }, [query, pageSize, paginationInfo]);
  return { paginatedQuery, paginationInfo, loadMore };
}

// ../../library/src/modules/useVariantState.ts
import { startTransition as startTransition10, useCallback as useCallback22, useContext as useContext29, useEffect as useEffect24, useMemo as useMemo21, useRef as useRef24 } from "react";
function createGestureVariant(variant, type) {
  return `${variant}-${type}`;
}
function nextVariant(allVariants, currentVariant) {
  const index = allVariants.indexOf(currentVariant);
  let nextIndex = index + 1;
  if (nextIndex >= allVariants.length) {
    nextIndex = 0;
  }
  const nextVariant2 = allVariants[nextIndex];
  assert(nextVariant2 !== void 0, "nextVariant should be defined");
  return nextVariant2;
}
function activeTransition(transitions, variant) {
  if (!transitions) return void 0;
  if (variant) {
    const variantTransition = transitions[variant];
    if (variantTransition) return variantTransition;
  }
  return transitions.default;
}
var VariantSelector = /* @__PURE__ */ ((VariantSelector2) => {
  VariantSelector2["Variant"] = "v";
  return VariantSelector2;
})(VariantSelector || {});
function getGesture(enabledGestures, isHovered, isPressed, isLoading, isError) {
  const { hover: hover2, pressed, loading, error } = enabledGestures || {};
  if (error && isError) return "error";
  if (loading && isLoading) return "loading";
  if (pressed && isPressed) return "pressed";
  if (hover2 && isHovered) return "hover";
}
function createVariantClassName(baseVariant, variantClassNames) {
  const mappedClassName = variantClassNames[baseVariant];
  if (mappedClassName) return mappedClassName;
  return `framer-${"v" /* Variant */}-${baseVariant}`;
}
function safeBaseVariant(targetVariant, fallbackVariant, validBaseVariants) {
  if (!targetVariant) return fallbackVariant;
  if (validBaseVariants.has(targetVariant)) return targetVariant;
  return fallbackVariant;
}
var CycleVariantState = /* @__PURE__ */ Symbol("cycle");
function useRunCallbackIfPageIsVisible() {
  const listenerRef = useRef24();
  const callbackRef = useRef24();
  const clean = useCallback22(() => {
    if (!listenerRef.current) return;
    document.removeEventListener("visibilitychange", listenerRef.current);
    listenerRef.current = void 0;
    callbackRef.current = void 0;
  }, []);
  useEffect24(() => {
    return () => {
      clean();
    };
  }, [clean]);
  return useCallback22(
    (callback) => {
      if (!document.hidden) {
        callback();
        clean();
        return;
      }
      callbackRef.current = callback;
      if (listenerRef.current) return;
      const listenerFn = () => {
        if (document.hidden) return;
        callbackRef.current?.();
        clean();
      };
      listenerRef.current = listenerFn;
      document.addEventListener("visibilitychange", listenerFn);
    },
    [clean]
  );
}
function useRunCallbackIfElementIsInView() {
  const observerRefCleanup = useRef24();
  const isInViewRef = useRef24(false);
  const callbackRef = useRef24();
  const observers = useContext29(SharedIntersectionObserverContext);
  useEffect24(() => {
    return () => {
      observerRefCleanup.current?.();
      callbackRef.current = void 0;
      observerRefCleanup.current = void 0;
    };
  }, []);
  return useCallback22(
    (callback, ref) => {
      if (!ref?.current || isInViewRef.current) {
        callback();
        return;
      }
      callbackRef.current = callback;
      if (observerRefCleanup.current) return;
      let queuedMicrotask = false;
      const observerCallback = (entry) => {
        isInViewRef.current = entry.isIntersecting;
        if (queuedMicrotask) return;
        queuedMicrotask = true;
        queueMicrotask(() => {
          queuedMicrotask = false;
          if (!isInViewRef.current) return;
          callbackRef.current?.();
        });
      };
      observerRefCleanup.current = observeElement(observers, "undefined", ref.current, null, observerCallback);
    },
    [observers]
  );
}
function useUpdateIfVisible(ref) {
  const runUpdateIfPageIsVisible = useRunCallbackIfPageIsVisible();
  const runUpdateIfElementIsInView = useRunCallbackIfElementIsInView();
  return useCallback22(
    (callback, checkViewport = false) => {
      if (isBot) {
        callback();
        return;
      }
      const runUpdate = checkViewport && ref ? () => runUpdateIfElementIsInView(callback, ref) : callback;
      runUpdateIfPageIsVisible(runUpdate);
    },
    [runUpdateIfPageIsVisible, runUpdateIfElementIsInView, ref]
  );
}
var globalWaitingForClickPromise;
var globalWaitingForClickResolve;
async function getPromiseWithFallback() {
  return new Promise((resolve) => {
    let resolveFn = resolve;
    setTimeout(() => {
      if (!resolveFn) return;
      performance.mark("wait-for-click-fallback");
      resolveFn();
    }, 150);
    globalWaitingForClickResolve = () => {
      resolve();
      resolveFn = void 0;
    };
  });
}
function globalWaitForClickListener(event) {
  if (event.button === 0) {
    performance.mark("pointerdown-listener");
    globalWaitingForClickPromise = getPromiseWithFallback();
  }
}
function globalClickReceivedListener() {
  performance.mark("click-received-listener");
  globalWaitingForClickPromise = void 0;
  globalWaitingForClickResolve?.();
  globalWaitingForClickResolve = void 0;
}
function useWaitForGlobalClick(enabled = false) {
  useEffect24(() => {
    if (!enabled) return;
    document.addEventListener("pointerup", globalWaitForClickListener, true);
    document.__proto__.addEventListener.call(document, "click", globalClickReceivedListener, true);
  }, [enabled]);
}
function useVariantState({
  variant,
  defaultVariant: externalDefaultVariant,
  transitions: externalTransitions,
  enabledGestures: externalEnabledGestures,
  cycleOrder: externalCycleOrder = [],
  variantProps = {},
  variantClassNames = {},
  ref
}) {
  const forceUpdate = useForceUpdate2();
  const isCanvas = useIsOnFramerCanvas();
  const validBaseVariants = useConstant(() => new Set(externalCycleOrder));
  const { yieldOnTap: yieldOnTapFeatureOn } = useLibraryFeatures();
  useWaitForGlobalClick(yieldOnTapFeatureOn);
  const runUpdateIfVisible = useUpdateIfVisible(ref);
  const internalState = useRef24({
    isHovered: false,
    isHoveredHasUpdated: false,
    isPressed: false,
    isPressedHasUpdated: false,
    isError: false,
    hasPressedVariants: true,
    baseVariant: safeBaseVariant(variant, externalDefaultVariant, validBaseVariants),
    lastVariant: variant,
    gestureVariant: void 0,
    loadedBaseVariant: {},
    // When used in generated components, these are static values defined
    // outside of the component function that also need to not result in
    // memorized values being recalculated, so we dump them into the ref.
    defaultVariant: externalDefaultVariant,
    enabledGestures: externalEnabledGestures,
    cycleOrder: externalCycleOrder,
    transitions: externalTransitions
  });
  const resolveNextVariant = useCallback22((targetBaseVariant) => {
    const { isHovered: isHovered2, isPressed: isPressed2, isError: isError2, enabledGestures: enabledGestures2, defaultVariant: defaultVariant2 } = internalState.current;
    const nextBaseVariant = safeBaseVariant(targetBaseVariant, defaultVariant2, validBaseVariants);
    const gesture = getGesture(enabledGestures2?.[nextBaseVariant], isHovered2, isPressed2, false, isError2);
    const nextGestureVariant = gesture ? createGestureVariant(nextBaseVariant, gesture) : void 0;
    return [nextBaseVariant, nextGestureVariant];
  }, []);
  const updateIfNeeded = useCallback22(
    async (baseVariant2, gestureVariant2, defaultVariant2, nextBaseVariant, checkViewport = false, clearError = false) => {
      const [nextBase, nextGesture] = resolveNextVariant(nextBaseVariant);
      if (nextBase === baseVariant2 && nextGesture === gestureVariant2) return;
      if (clearError) internalState.current.isError = false;
      internalState.current.baseVariant = nextBase || defaultVariant2;
      internalState.current.gestureVariant = nextGesture;
      const yieldOnTap = yieldOnTapFeatureOn && internalState.current.isPressedHasUpdated;
      if (yieldOnTap && globalWaitingForClickPromise) {
        performance.mark("wait-for-tap-start");
        await globalWaitingForClickPromise;
        performance.measure("wait-for-tap", "wait-for-tap-start");
      }
      if (yieldOnTap) {
        performance.mark("yield-on-tap-start");
        await yieldToMain({ priority: "user-blocking", continueAfter: "paint" });
        performance.measure("yield-on-tap", "yield-on-tap-start");
      }
      const { isHovered: isHovered2, isPressed: isPressed2, isHoveredHasUpdated, isPressedHasUpdated } = internalState.current;
      if (isHovered2 || isHoveredHasUpdated || isPressed2 || isPressedHasUpdated) {
        startTransition10(forceUpdate);
        return;
      }
      runUpdateIfVisible(() => startTransition10(forceUpdate), checkViewport);
    },
    [resolveNextVariant, forceUpdate, runUpdateIfVisible, yieldOnTapFeatureOn]
  );
  const setGestureState = useCallback22(
    ({ isHovered: isHovered2, isPressed: isPressed2, isError: isError2 }) => {
      const isPressedHasUpdated = isPressed2 !== internalState.current.isPressed;
      const isHoveredHasUpdated = isHovered2 !== internalState.current.isHovered;
      if (isHovered2 !== void 0) internalState.current.isHovered = isHovered2;
      if (isPressed2 !== void 0) internalState.current.isPressed = isPressed2;
      if (isError2 !== void 0) internalState.current.isError = isError2;
      const { baseVariant: baseVariant2, gestureVariant: gestureVariant2, defaultVariant: defaultVariant2 } = internalState.current;
      internalState.current.isPressedHasUpdated = isPressedHasUpdated;
      internalState.current.isHoveredHasUpdated = isHoveredHasUpdated;
      void updateIfNeeded(baseVariant2, gestureVariant2, defaultVariant2, baseVariant2, false);
    },
    [updateIfNeeded]
  );
  const setVariant = useCallback22(
    (proposedVariant, pauseOffscreen = false) => {
      const { defaultVariant: defaultVariant2, cycleOrder, baseVariant: baseVariant2, gestureVariant: gestureVariant2 } = internalState.current;
      const nextBaseVariant = proposedVariant === CycleVariantState ? nextVariant(cycleOrder || [], baseVariant2 || defaultVariant2) : proposedVariant;
      void updateIfNeeded(baseVariant2, gestureVariant2, defaultVariant2, nextBaseVariant, pauseOffscreen, true);
    },
    [updateIfNeeded]
  );
  const clearLoadingGesture = useCallback22(() => {
    const { baseVariant: baseVariant2 } = internalState.current;
    internalState.current.loadedBaseVariant[baseVariant2] = true;
    runUpdateIfVisible(() => startTransition10(forceUpdate), true);
  }, [forceUpdate, runUpdateIfVisible]);
  if (variant !== internalState.current.lastVariant) {
    const [nextBase, nextGesture] = resolveNextVariant(variant);
    internalState.current.lastVariant = nextBase;
    if (nextBase !== internalState.current.baseVariant || nextGesture !== internalState.current.gestureVariant) {
      internalState.current.baseVariant = nextBase;
      internalState.current.gestureVariant = nextGesture;
    }
  }
  const {
    baseVariant,
    gestureVariant,
    defaultVariant,
    enabledGestures,
    isHovered,
    isPressed,
    isError,
    loadedBaseVariant
  } = internalState.current;
  const addVariantProps = useAddVariantProps(
    internalState.current.baseVariant,
    internalState.current.gestureVariant,
    variantProps
  );
  return useMemo21(() => {
    const variants = [];
    if (baseVariant !== defaultVariant) variants.push(baseVariant);
    const hasLoadingVariant = enabledGestures?.[baseVariant]?.loading;
    const isLoading = !isError && !isCanvas && !!hasLoadingVariant && !loadedBaseVariant[baseVariant];
    const gesture = isLoading ? createGestureVariant(baseVariant, "loading") : gestureVariant;
    if (gesture) variants.push(gesture);
    const gestures = enabledGestures?.[baseVariant];
    const gestureHandlers = {
      onMouseEnter: () => setGestureState({ isHovered: true }),
      onMouseLeave: () => setGestureState({ isHovered: false })
    };
    if (gestures?.pressed) {
      Object.assign(gestureHandlers, {
        onTapStart: () => setGestureState({ isPressed: true }),
        onTapCancel: () => setGestureState({ isPressed: false }),
        onTap: () => setGestureState({ isPressed: false })
      });
    }
    return {
      variants,
      baseVariant,
      gestureVariant: gesture,
      isLoading,
      transition: activeTransition(internalState.current.transitions, baseVariant),
      setVariant,
      setGestureState,
      clearLoadingGesture,
      addVariantProps,
      gestureHandlers,
      classNames: cx(
        createVariantClassName(baseVariant, variantClassNames),
        getGesture(gestures, isHovered, isPressed, isLoading, isError)
      )
    };
  }, [
    baseVariant,
    gestureVariant,
    isHovered,
    isPressed,
    loadedBaseVariant,
    addVariantProps,
    setVariant,
    defaultVariant,
    enabledGestures,
    setGestureState,
    clearLoadingGesture,
    variantClassNames
  ]);
}

// ../../library/src/modules/safeCSSValue.ts
var reUnsafeCharacters = /[}{<>&;]/u;
function safeCSSValue(value) {
  if (!isString(value)) return "none";
  if (reUnsafeCharacters.test(value)) return "none";
  return value;
}

// ../../library/src/modules/code-boundary/withCodeBoundaryForOverrides.tsx
import React79 from "react";
import { jsx as jsx69 } from "react/jsx-runtime";
function withCodeBoundaryForOverrides(Component18, { scopeId, nodeId, override, inComponentSlot }) {
  if (!shouldEnableCodeBoundaries()) {
    return override(Component18);
  }
  const appliedOverride = tryToApplyOverride(Component18, override);
  let hasErrorBeenLogged = false;
  function CodeBoundaryForOverrides(props, ref) {
    const nearestExternalComponent = useNearestExternalComponent();
    const shouldWrapWithBoundary = shouldWrapOverrideWithBoundary(
      scopeId,
      nearestExternalComponent?.scopeId,
      nearestExternalComponent?.level,
      inComponentSlot ?? false
    );
    if (shouldWrapWithBoundary) {
      if (appliedOverride.status === "success") {
        return /* @__PURE__ */ jsx69(NodeIdContext.Provider, { value: nodeId, children: /* @__PURE__ */ jsx69(
          CodeComponentBoundary,
          {
            getErrorMessage: getErrorMessageForOverride.bind(null, scopeId, nodeId),
            fallback: /* @__PURE__ */ jsx69(Component18, { ...props, ref }),
            children: /* @__PURE__ */ jsx69(appliedOverride.Component, { ...props, ref })
          }
        ) });
      } else {
        if (!hasErrorBeenLogged) {
          logError(appliedOverride.error);
          logError(getErrorMessageForOverride(scopeId, nodeId));
          collectErrorToAnalytics(appliedOverride.error);
          hasErrorBeenLogged = true;
        }
        return /* @__PURE__ */ jsx69(Component18, { ...props, ref });
      }
    } else {
      if (appliedOverride.status === "success") {
        return /* @__PURE__ */ jsx69(NodeIdContext.Provider, { value: nodeId, children: /* @__PURE__ */ jsx69(appliedOverride.Component, { ...props, ref }) });
      } else {
        throw appliedOverride.error;
      }
    }
  }
  return React79.forwardRef(CodeBoundaryForOverrides);
}
function tryToApplyOverride(Component18, override) {
  try {
    const ComponentWithOverrides = override(Component18);
    return { status: "success", Component: ComponentWithOverrides };
  } catch (error) {
    return { status: "error", error };
  }
}

// ../../library/src/modules/withStrokeFX.tsx
import { forwardRef as forwardRef8, useEffect as useEffect25 } from "react";
import { jsx as jsx70 } from "react/jsx-runtime";
function valueWithMirroring(value, mirror) {
  return mirror ? wrap(0, 2, value) : value;
}
function singleFrame() {
  return new Promise((resolve) => {
    frame.postRender(() => resolve());
  });
}
var withV1StrokeFX = (Component18) => forwardRef8((props, forwardedRef) => {
  const {
    strokeEffectLength,
    strokeEffectGap,
    strokeEffectOffset,
    strokeEffectLoop,
    strokeEffectTotalLength,
    strokeEffectLoopType,
    pathLengthTransition,
    ...restProps
  } = props;
  const isCanvas = isStaticRenderer();
  const offset = useMotionValue(0);
  const { length, gap } = useConstant(() => ({
    length: strokeEffectTotalLength * strokeEffectLength,
    gap: strokeEffectTotalLength * strokeEffectGap
  }));
  useEffect25(() => {
    if (isCanvas) return;
    const signal = new AbortController();
    async function loop() {
      let index = 0;
      while (true) {
        if (signal.signal.aborted) break;
        const mirror = strokeEffectLoop && strokeEffectLoopType === "mirror";
        const from = valueWithMirroring(index, mirror);
        const to = valueWithMirroring(index + 1, mirror);
        await Promise.all([animate(offset, [from, to], pathLengthTransition), singleFrame()]);
        if (!strokeEffectLoop) break;
        if (strokeEffectLoop && strokeEffectLoopType === "repeat") continue;
        index++;
      }
    }
    void loop();
    return () => {
      signal.abort();
    };
  }, []);
  const value = useTransform(offset, (v) => {
    return strokeEffectOffset * strokeEffectTotalLength + (strokeEffectTotalLength - Math.max(v, 1e-3) * strokeEffectTotalLength);
  });
  const effect = !isCanvas ? {
    // These are static values, but they are set via js so that they are ignored
    // unless in the preview/published site.
    strokeDasharray: `${length} ${gap}`,
    strokeDashoffset: value
  } : void 0;
  return /* @__PURE__ */ jsx70(Component18, { ...restProps, ...effect, ref: forwardedRef });
});

// ../../library/src/render/presentation/Ticker.tsx
import { forwardRef as forwardRef12, useState as useState9 } from "react";

// ../../library/src/render/utils/tickerUtils.ts
import { Children as Children4, Fragment as Fragment11, isValidElement as isValidElement6 } from "react";
function flattenChildrenToTickerItems(children) {
  const result = [];
  Children4.forEach(children, (child) => {
    if (isValidElement6(child) && child.type === Fragment11) {
      result.push(...flattenChildrenToTickerItems(child.props.children));
    } else {
      result.push(child);
    }
  });
  return result;
}

// ../../library/src/render/presentation/BasicTicker.tsx
import { forwardRef as forwardRef10 } from "react";

// ../../library/src/render/presentation/motionplus/Ticker.tsx
import { createContext as createContext13, useContext as useContext30, useRef as useRef25, useEffect as useEffect26, forwardRef as forwardRef9, useState as useState8, useMemo as useMemo22, useCallback as useCallback23 } from "react";
import { Fragment as Fragment12, jsx as jsx71, jsxs as jsxs16 } from "react/jsx-runtime";
function findCurrentIndexFromInset(currentInset, itemPositions, wrapInset) {
  const iteration = Math.floor(currentInset / wrapInset);
  const transform2 = iteration * wrapInset;
  let itemIndex = 0;
  for (let i = 0; i < itemPositions.length; i++) {
    const { end } = itemPositions[i];
    itemIndex = i;
    if (end + transform2 > currentInset) {
      break;
    }
  }
  return itemIndex + iteration * itemPositions.length;
}
function findNextItemInset(currentInset, itemPositions, gap, targetInset) {
  if (itemPositions.length === 0)
    return 0;
  const totalItemLength = itemPositions[itemPositions.length - 1].end;
  const wrapInset = totalItemLength + gap;
  const idealInset = targetInset ?? currentInset + (itemPositions[0]?.end ?? 0);
  const currentItemIndex = findCurrentIndexFromInset(currentInset, itemPositions, wrapInset);
  let index = currentItemIndex + 1;
  let nextItemInset = 0;
  let hasFoundNextInset = false;
  while (!hasFoundNextInset) {
    const { start, end } = itemPositions[wrap(0, itemPositions.length, index)];
    const iteration = Math.floor(index / itemPositions.length);
    const transformInset = iteration * wrapInset;
    const transformedStart = start + transformInset;
    nextItemInset = transformedStart;
    if (end + transformInset > idealInset) {
      hasFoundNextInset = true;
    } else {
      index++;
    }
  }
  return nextItemInset;
}
function findPrevItemInset(currentInset, itemPositions, gap, targetInset, containerLength) {
  if (itemPositions.length === 0)
    return 0;
  const totalItemLength = itemPositions[itemPositions.length - 1].end;
  const wrapInset = totalItemLength + gap;
  const idealInset = targetInset ?? currentInset - (containerLength ?? 0);
  const currentItemIndex = findCurrentIndexFromInset(currentInset, itemPositions, wrapInset);
  let index = currentItemIndex;
  let prevItemInset = currentInset;
  let hasFoundPrevInset = false;
  while (!hasFoundPrevInset) {
    const { start, end } = itemPositions[wrap(0, itemPositions.length, index)];
    const itemSize = end - start;
    const iteration = Math.floor(index / itemPositions.length);
    const transformInset = iteration * wrapInset;
    const transformedStart = start + transformInset;
    if (idealInset <= transformedStart + gap || transformedStart >= currentInset) {
      prevItemInset = transformedStart;
      index--;
    } else if (idealInset <= transformedStart) {
      prevItemInset = transformedStart;
      hasFoundPrevInset = true;
    } else {
      if (containerLength && itemSize > containerLength || prevItemInset === currentInset && idealInset >= transformedStart) {
        prevItemInset = transformedStart;
      }
      hasFoundPrevInset = true;
    }
  }
  return prevItemInset;
}
var TickerContext = /* @__PURE__ */ (() => {
  const Context2 = createContext13(null);
  Context2.displayName = "TickerContext";
  return Context2;
})();
function useTicker() {
  const context = useContext30(TickerContext);
  invariant(Boolean(context), "useTicker must be used within a Ticker component");
  return context;
}
var TickerItemContext = /* @__PURE__ */ (() => {
  const Context2 = createContext13(void 0);
  Context2.displayName = "TickerItemContext";
  return Context2;
})();
function useTickerItem() {
  const itemContext = useContext30(TickerItemContext);
  invariant(Boolean(itemContext), "useTickerItem must be used within a TickerItem");
  return itemContext;
}
var ltrStrategy = (insetProp, lengthProp, viewportLengthProp, paddingStartProp, direction) => {
  return {
    sign: 1,
    direction,
    lengthProp,
    viewportLengthProp,
    paddingStartProp,
    measureItem: (item) => {
      return {
        start: item[insetProp],
        end: item[insetProp] + item[lengthProp]
      };
    },
    getCumulativeInset: (element) => {
      let offset = 0;
      let el = element;
      while (el) {
        offset += el[insetProp];
        el = el.offsetParent;
      }
      return offset;
    }
  };
};
var xStrategy = /* @__PURE__ */ (() => ltrStrategy("offsetLeft", "offsetWidth", "innerWidth", "paddingLeft", "right"))();
var yStrategy = /* @__PURE__ */ (() => ltrStrategy("offsetTop", "offsetHeight", "innerHeight", "paddingTop", "bottom"))();
function offsetRight(element, container) {
  const containerWidth = container?.offsetWidth ?? window.innerWidth;
  return containerWidth - (element.offsetLeft + element.offsetWidth);
}
var xRtlStrategy = /* @__PURE__ */ (() => ({
  ...xStrategy,
  sign: -1,
  direction: "left",
  paddingStartProp: "paddingRight",
  measureItem: (item, container) => {
    const length = item.offsetWidth;
    const start = offsetRight(item, container);
    return { start, end: start + length };
  },
  getCumulativeInset: (element) => {
    let offset = 0;
    let el = element;
    while (el) {
      offset += offsetRight(el, el.offsetParent);
      el = el.offsetParent;
    }
    return offset;
  }
}))();
function getLayoutStrategy(axis, direction) {
  return axis === "y" ? yStrategy : direction === "ltr" ? xStrategy : xRtlStrategy;
}
function TickerItemWrapper({ children, offset, axis, listSize = 0, numItems = 0, itemIndex, cloneIndex, bounds, alignItems, reproject = true, size = "auto", safeMargin }) {
  const { start, end } = bounds;
  const { visibleLength, direction, inset: inset2 } = useTicker();
  const { sign } = getLayoutStrategy(axis, direction);
  const projection = useTransform(() => {
    if (!reproject)
      return 0;
    const currentOffset = offset.get();
    if (!start && !end || !listSize)
      return 0;
    if (currentOffset * sign + bounds.end <= -inset2 - safeMargin) {
      return listSize * sign;
    }
    if (safeMargin > 0) {
      const rightBoundary = visibleLength - inset2 + safeMargin;
      if (currentOffset * sign + bounds.start >= rightBoundary) {
        return -listSize * sign;
      }
    }
    return 0;
  });
  const itemOffset = useTransform(() => {
    const currentOffset = offset.get();
    const currentTransform = projection.get();
    if (!start && !end || !listSize)
      return 0;
    return currentOffset * sign + start + currentTransform * sign;
  });
  const offAxisSize = alignItems === "stretch" ? "100%" : "fit-content";
  const ariaProps = cloneIndex === void 0 ? {
    ["aria-hidden"]: false,
    ["aria-posinset"]: itemIndex + 1,
    ["aria-setsize"]: numItems
  } : {
    ["aria-hidden"]: true
  };
  const props = {
    className: cloneIndex === void 0 ? "ticker-item" : "clone-item",
    style: {
      flexGrow: 0,
      flexShrink: 0,
      position: "relative",
      flexBasis: size === "fill" ? "100%" : void 0,
      display: size === "fill" ? "flex" : void 0,
      height: axis === "x" ? offAxisSize : void 0,
      width: axis === "y" ? offAxisSize : void 0,
      x: axis === "x" ? projection : 0,
      y: axis === "y" ? projection : 0
    },
    ...ariaProps
  };
  return /* @__PURE__ */ jsx71(TickerItemContext.Provider, { value: {
    start,
    end,
    offset: itemOffset,
    projection,
    itemIndex,
    cloneIndex,
    props
  }, children: size === "manual" ? children : /* @__PURE__ */ jsx71(DefaultTickerItem, { children }) });
}
function DefaultTickerItem({ children }) {
  const { props } = useTickerItem();
  return /* @__PURE__ */ jsx71(motion.li, { ...props, children });
}
function useFocusNavigation(containerRef, axis, focusOffset, offset, setHasFocus) {
  const isFocusTrapped = useRef25(false);
  useEffect26(() => {
    const container = containerRef.current;
    if (!container)
      return;
    let detectionEnabled = false;
    const abortController = new AbortController();
    const eventOptions = {
      signal: abortController.signal
    };
    const eventOptionsWithCapture = {
      ...eventOptions,
      capture: true
    };
    const scrollProp = axis === "x" ? "scrollLeft" : "scrollTop";
    const offsetProp = axis === "x" ? "offsetLeft" : "offsetTop";
    const leftKey = axis === "x" ? "ArrowLeft" : "ArrowUp";
    const rightKey = axis === "x" ? "ArrowRight" : "ArrowDown";
    let focusableElements = [];
    let focusIndex = 0;
    const applyFocusOffset = () => {
      const nextFocusableElement = focusableElements[focusIndex];
      if (!nextFocusableElement)
        return;
      nextFocusableElement.focus();
      focusOffset.set(-nextFocusableElement[offsetProp]);
      container[scrollProp] = 0;
      frame.render(() => {
        container[scrollProp] = 0;
      });
    };
    const handleFocusNavigation = (event) => {
      if (event.key === "Tab") {
        event.preventDefault();
        endFocusTrap();
        const allFocusableElements = Array.from(document.querySelectorAll('a, button, input, textarea, select, [tabindex]:not([tabindex="-1"]), [contenteditable="true"]')).filter(isHTMLElement);
        allFocusableElements.sort(compareTabIndexes);
        const lastFocusableElement = allFocusableElements[event.shiftKey ? 0 : allFocusableElements.length - 1];
        const initialIndex = event.shiftKey ? allFocusableElements.length - 1 : 0;
        if (container.contains(lastFocusableElement)) {
          allFocusableElements[initialIndex].focus();
          return;
        } else {
          const indexOfCurrentElement = allFocusableElements.indexOf(focusableElements[focusIndex]);
          const delta = event.shiftKey ? -1 : 1;
          for (let i = indexOfCurrentElement; i < allFocusableElements.length && i >= 0; i += delta) {
            const element = allFocusableElements[i];
            if (!container.contains(element)) {
              element.focus();
              return;
            }
          }
        }
        return;
      } else if (event.key === leftKey) {
        focusIndex--;
      } else if (event.key === rightKey) {
        focusIndex++;
      }
      focusIndex = wrap(0, focusableElements.length, focusIndex);
      applyFocusOffset();
    };
    const startFocusTrap = () => {
      if (isFocusTrapped.current)
        return;
      focusableElements = Array.from(container.querySelectorAll('.ticker-item a, .ticker-item button, .ticker-item input, .ticker-item textarea, .ticker-item select, .ticker-item [tabindex]:not([tabindex="-1"]), .ticker-item [contenteditable="true"]')).filter(isHTMLElement);
      focusIndex = 0;
      if (!focusableElements.length)
        return;
      setHasFocus(true);
      isFocusTrapped.current = true;
      applyFocusOffset();
      window.addEventListener("focus", detectTrapEnd, eventOptionsWithCapture);
      window.addEventListener("blur", detectTrapEnd, eventOptionsWithCapture);
      container.addEventListener("keydown", handleFocusNavigation, eventOptions);
    };
    const detectTrapEnd = (event) => {
      if (!event.target || !(event.target instanceof HTMLElement) || !container.contains(event.target)) {
        endFocusTrap();
      }
    };
    const endFocusTrap = () => {
      if (!isFocusTrapped.current)
        return;
      isFocusTrapped.current = false;
      setHasFocus(false);
      offset.set(focusOffset.get());
      window.removeEventListener("focus", detectTrapEnd);
      window.removeEventListener("blur", detectTrapEnd);
      container.removeEventListener("keydown", handleFocusNavigation);
    };
    const handleFocus = (event) => {
      const { target } = event;
      if (!isHTMLElement(target))
        return;
      if (!isFocusTrapped.current) {
        startFocusTrap();
      }
    };
    const detectFocusTrapEnable = () => {
      if (detectionEnabled)
        return;
      detectionEnabled = true;
      container.addEventListener("focus", handleFocus, eventOptionsWithCapture);
      window.addEventListener("pointermove", handlePointerMove, eventOptions);
    };
    const handlePointerMove = () => {
      if (!detectionEnabled)
        return;
      detectionEnabled = false;
      container.removeEventListener("focus", handleFocus, true);
      window.removeEventListener("pointermove", handlePointerMove, eventOptions);
    };
    const handleAriaHiddenClicks = (event) => {
      const target = event.target;
      let ariaHiddenAncestor = target.closest('[aria-hidden="true"]');
      if (ariaHiddenAncestor) {
        ariaHiddenAncestor.removeAttribute("aria-hidden");
      }
    };
    window.addEventListener("keydown", detectFocusTrapEnable, eventOptions);
    container.addEventListener("pointerdown", handleAriaHiddenClicks, eventOptions);
    return () => {
      abortController.abort();
      endFocusTrap();
    };
  }, []);
}
function compareTabIndexes(a, b) {
  if (a.tabIndex >= 1 && b.tabIndex >= 1) {
    return a.tabIndex - b.tabIndex;
  }
  if (a.tabIndex >= 1 && b.tabIndex <= 0) {
    return -1;
  }
  if (b.tabIndex >= 1 && a.tabIndex <= 0) {
    return 1;
  }
  return 0;
}
function calcItemLength(itemPosition) {
  return itemPosition.end - itemPosition.start;
}
function calcTotalItemLength(itemPositions) {
  return itemPositions[itemPositions.length - 1].end - itemPositions[0].start;
}
function calcNumClones(visibleLength, itemPositions, gap) {
  const totalItemLength = calcTotalItemLength(itemPositions);
  const maxItemLength = Math.max(...itemPositions.map(calcItemLength));
  let count = 0;
  let safeFillLength = 0;
  while (safeFillLength < visibleLength) {
    safeFillLength = (totalItemLength + gap) * (count + 1) - maxItemLength;
    count++;
  }
  return Math.max(count - 1, 0);
}
var alignAlias = {
  start: "flex-start",
  end: "flex-end"
};
function TickerComponent({ items, velocity = 50, hoverFactor = 1, gap = 10, axis = "x", align = "center", offset, isStatic = false, itemSize = "auto", overflow = false, loop = true, children, as = "div", snap, safeMargin = 0, fade = 0, ...props }, ref) {
  const internalContainerRef = useRef25(null);
  const containerRef = useComposedRefs(ref, internalContainerRef);
  const listRef = useRef25(null);
  const [state, setState] = useState8({
    direction: "ltr",
    visibleLength: 0,
    inset: 0,
    totalItemLength: 0,
    containerLength: 0,
    itemPositions: [],
    isMeasured: false,
    maxInset: null
  });
  const alignItems = alignAlias[align] || align;
  if (isStatic) {
    const renderedOffset2 = useMotionValue(0);
    return /* @__PURE__ */ jsx71(TickerContext.Provider, { value: { ...state, gap, clampOffset: noop, renderedOffset: renderedOffset2 }, children: /* @__PURE__ */ jsx71(ListView, { containerProps: props, containerRef, children, gap, axis, alignItems, offset: renderedOffset2, renderedOffset: renderedOffset2, items, itemSize, state, overflow, safeMargin, isStatic: true, as, fade }) });
  }
  const [hasFocus, setHasFocus] = useState8(false);
  const velocityFactor = useMotionValue(1);
  const defaultOffset2 = useMotionValue(0);
  offset ?? (offset = defaultOffset2);
  const wrappedOffset = useTransform(() => {
    if (state.direction === "rtl") {
      return wrap(state.totalItemLength + gap + state.inset, state.inset, offset.get());
    }
    return wrap(-state.totalItemLength - gap - state.inset, -state.inset, offset.get());
  });
  const focusOffset = useMotionValue(0);
  const renderedOffset = hasFocus ? focusOffset : loop ? wrappedOffset : offset;
  const isInViewport = useInView(internalContainerRef, { margin: "100px" });
  const isPageInView = usePageInView();
  const isInView = isInViewport && isPageInView;
  const isReducedMotion = useReducedMotion();
  const updateMeasurements = () => {
    if (!internalContainerRef.current || !listRef.current)
      return;
    const direction = window.getComputedStyle(internalContainerRef.current).direction;
    const { measureItem, lengthProp, viewportLengthProp, getCumulativeInset } = getLayoutStrategy(axis, direction);
    const paddingStartProp = axis === "x" ? "paddingLeft" : "paddingTop";
    const paddingEndProp = axis === "x" ? "paddingRight" : "paddingBottom";
    const container = internalContainerRef.current;
    const list = listRef.current;
    const allItems = list.querySelectorAll(".ticker-item");
    if (!allItems.length)
      return;
    let hasItemSizeChanged = false;
    const itemPositions = [];
    for (let i = 0; i < allItems.length; i++) {
      const size = measureItem(allItems[i], container);
      itemPositions.push(size);
      const prevSize = state.itemPositions[i];
      if (!prevSize || size.start !== prevSize.start || size.end !== prevSize.end) {
        hasItemSizeChanged = true;
      }
    }
    const containerLength = Math.min(container[lengthProp], window[viewportLengthProp]);
    let visibleLength = overflow ? window[viewportLengthProp] : containerLength;
    if (safeMargin > 0) {
      visibleLength += safeMargin * 2;
    }
    const totalItemLength = calcTotalItemLength(itemPositions);
    const computedContainerStyle = window.getComputedStyle(container);
    const containerPaddingStart = parseInt(computedContainerStyle[paddingStartProp] ?? 0);
    const containerPaddingEnd = parseInt(computedContainerStyle[paddingEndProp] ?? 0);
    const inset2 = overflow ? getCumulativeInset(allItems[0]) : containerPaddingStart;
    const maxInset = loop === false ? Math.max(0, totalItemLength - containerLength + containerPaddingStart + containerPaddingEnd) : null;
    if (visibleLength !== state.visibleLength || totalItemLength !== state.totalItemLength || inset2 !== state.inset || state.itemPositions.length !== itemPositions.length || hasItemSizeChanged) {
      setState({
        direction,
        visibleLength,
        itemPositions,
        totalItemLength,
        inset: inset2,
        containerLength,
        maxInset,
        isMeasured: true
      });
    }
  };
  useIsomorphicLayoutEffect(() => {
    if (!isInView || !internalContainerRef.current)
      return;
    updateMeasurements();
    const trackViewport = overflow ? resize(updateMeasurements) : void 0;
    const trackContainer = resize(internalContainerRef.current, updateMeasurements);
    return () => {
      trackViewport?.();
      trackContainer();
    };
  }, [items, isInView, overflow]);
  const isMeasured = state.totalItemLength > 0;
  const { sign } = getLayoutStrategy(axis, state.direction);
  useAnimationFrame(isMeasured && isInView && offset === defaultOffset2 && !isReducedMotion ? (_, delta) => {
    const frameOffset = delta / 1e3 * (velocity * sign * velocityFactor.get());
    offset.set(offset.get() - frameOffset);
  } : noop);
  const cloneCount = useMemo22(() => {
    if (!isMeasured || !state.visibleLength)
      return 0;
    return calcNumClones(state.visibleLength, state.itemPositions, gap);
  }, [isMeasured, state]);
  const totalListSize = state.totalItemLength === 0 ? 0 : (state.totalItemLength + gap) * (cloneCount + 1);
  const clonedItemGroups = [];
  if (loop) {
    for (let i = 0; i < cloneCount; i++) {
      const clonedItems = [];
      items.forEach((item, itemIndex) => {
        const originalBounds = state.itemPositions[itemIndex];
        const cloneOffset = (state.totalItemLength + gap) * (i + 1);
        const cloneBounds = originalBounds ? {
          start: originalBounds.start + cloneOffset,
          end: originalBounds.end + cloneOffset
        } : defaultBounds;
        clonedItems.push(/* @__PURE__ */ jsx71(TickerItemWrapper, { offset: renderedOffset, axis, listSize: totalListSize, itemIndex, cloneIndex: itemIndex, bounds: cloneBounds, alignItems, size: itemSize, safeMargin, numItems: items.length, children: item }, `clone-${i}-${itemIndex}`));
      });
      const id = `ticker-group-${i}`;
      clonedItemGroups.push(/* @__PURE__ */ jsx71(LayoutGroup, { id, children: clonedItems }, id));
    }
  }
  useFocusNavigation(internalContainerRef, axis, focusOffset, offset, setHasFocus);
  const clampOffset = useCallback23((newOffset) => state.maxInset !== null ? clamp(-state.maxInset, 0, newOffset) : newOffset, [state.maxInset]);
  return /* @__PURE__ */ jsx71(TickerContext.Provider, { value: { ...state, gap, clampOffset, renderedOffset }, children: /* @__PURE__ */ jsx71(ListView, { containerProps: props, children, containerRef, listRef, gap, axis, alignItems, isMeasured, isInView, offset, renderedOffset, items, itemSize, clonedItems: clonedItemGroups, clampOffset, snap, safeMargin, onPointerEnter: () => {
    animate(velocityFactor, hoverFactor);
  }, onPointerLeave: () => {
    animate(velocityFactor, 1);
  }, totalListSize, state, overflow, loop, as, fade }) });
}
var Ticker = /* @__PURE__ */ forwardRef9(TickerComponent);
function ListView({ children, containerProps, containerRef, listRef, gap, axis, alignItems, isMeasured, isInView, isStatic, items, offset, clonedItems, clampOffset, renderedOffset, onPointerEnter, onPointerLeave, totalListSize, itemSize, overflow, state, safeMargin, snap, loop, as, fade }) {
  const MotionComponent = useMemo22(() => motion.create(as), [as]);
  let dragConstraints = {};
  const { maxInset } = state;
  if (maxInset !== null) {
    if (axis === "x") {
      dragConstraints = { left: maxInset * -1, right: 0 };
    } else {
      dragConstraints = { top: maxInset * -1, bottom: 0 };
    }
  }
  let { drag, _dragX, _dragY, dragMomentum = false, onDragStart, onDragEnd, onPointerDown, ...remainingProps } = containerProps;
  const dragMotionValue = axis === "x" ? _dragX : _dragY;
  const dragMomentumAnimation = useRef25(null);
  const stopDragMomentumAnimation = () => {
    if (!dragMomentumAnimation.current)
      return;
    dragMomentumAnimation.current.stop();
    dragMomentumAnimation.current = null;
  };
  if (!onDragEnd && drag && dragMotionValue) {
    onPointerDown = () => {
      dragMotionValue.jump(offset.get());
      stopDragMomentumAnimation();
    };
    onDragEnd = (_e, { velocity }) => {
      const current = offset.get();
      stopDragMomentumAnimation();
      frame.postRender(() => {
        let target = current + velocity[axis] * (snap ? 0.3 : 0.8);
        if (snap) {
          if (velocity[axis] < 0) {
            target = -findNextItemInset(-current, state.itemPositions, gap, -target);
          } else if (velocity[axis] > 0) {
            target = -findPrevItemInset(-current, state.itemPositions, gap, -target, state.containerLength);
          } else {
            const closestNext = -findNextItemInset(-current, state.itemPositions, gap, -current);
            const closestPrev = -findPrevItemInset(-current, state.itemPositions, gap, -current, state.containerLength);
            target = Math.abs(current - closestNext) < Math.abs(current - closestPrev) ? closestNext : closestPrev;
          }
        }
        const constraints = loop ? {} : {
          max: 0,
          min: dragConstraints[axis === "x" ? "left" : "top"]
        };
        dragMomentumAnimation.current = animate(dragMotionValue, clampOffset?.(target), snap ? pageTransition : {
          type: "inertia",
          velocity: velocity[axis],
          modifyTarget: () => target,
          bounceDamping: 40,
          bounceStiffness: 400,
          ...constraints
        });
      });
    };
  }
  const fadeStartOpacity = useMotionValue(loop ? 0 : 1);
  const fadeEndOpacity = useMotionValue(0);
  const strategy = getLayoutStrategy(axis, state.direction);
  const unit = typeof fade === "number" ? "px" : "";
  const maskImage = useTransform(() => {
    return `linear-gradient(to ${strategy.direction}, rgba(0,0,0,${fadeStartOpacity.get()}) 0px, black ${fade}${unit}, black calc(100% - ${fade}${unit}), rgba(0,0,0,${fadeEndOpacity.get()}) 100%)`;
  });
  const fadeStyles = fade ? { maskImage, WebkitMaskImage: maskImage } : {};
  const isAtLimits = useRef25({ start: true, end: false });
  useMotionValueEvent(renderedOffset, "change", (value) => {
    if (maxInset === null)
      return;
    if (value <= maxInset) {
      if (!isAtLimits.current.start) {
        animate(fadeStartOpacity, 1, fadeTransition);
        isAtLimits.current.start = true;
      }
    } else {
      if (isAtLimits.current.start) {
        animate(fadeStartOpacity, 0, fadeTransition);
        isAtLimits.current.start = false;
      }
    }
    if (value >= 0) {
      if (!isAtLimits.current.end) {
        animate(fadeEndOpacity, 1, fadeTransition);
        isAtLimits.current.end = true;
      }
    } else {
      if (isAtLimits.current.end) {
        animate(fadeEndOpacity, 0, fadeTransition);
        isAtLimits.current.end = false;
      }
    }
  });
  return /* @__PURE__ */ jsxs16(Fragment12, { children: [
    /* @__PURE__ */ jsx71(MotionComponent, { ...remainingProps, ref: containerRef, style: {
      overflowX: !overflow && axis === "x" ? "clip" : void 0,
      overflowY: !overflow && axis === "y" ? "clip" : void 0,
      ...containerStyle,
      ...containerProps.style,
      ...fadeStyles
    }, onPointerEnter, onPointerLeave, children: /* @__PURE__ */ jsxs16(motion.ul, { ref: listRef, role: "group", style: {
      ...listStyle,
      flexDirection: axis === "x" ? "row" : "column",
      gap: `${gap}px`,
      x: axis === "x" ? renderedOffset : 0,
      y: axis === "y" ? renderedOffset : 0,
      opacity: isMeasured || isStatic ? 1 : 0,
      alignItems,
      willChange: isMeasured && isInView ? "transform" : void 0,
      width: "100%",
      height: "100%",
      maxHeight: "100%",
      maxWidth: "100%"
    }, drag, _dragX, _dragY, dragConstraints, dragMomentum, onPointerDown, onDragStart, onDragEnd, children: [
      items.map((item, index) => /* @__PURE__ */ jsx71(TickerItemWrapper, { axis, offset: renderedOffset, listSize: totalListSize, itemIndex: index, bounds: state.itemPositions[index] ?? defaultBounds, alignItems, size: itemSize, reproject: loop, safeMargin, numItems: items.length, children: item }, "original-" + index)),
      clonedItems || null
    ] }) }),
    " ",
    children
  ] });
}
var defaultBounds = { start: 0, end: 0 };
var containerStyle = {
  display: "flex",
  position: "relative"
};
var listStyle = {
  display: "flex",
  position: "relative",
  willChange: "transform",
  listStyleType: "none",
  padding: 0,
  margin: 0,
  justifyContent: "flex-start"
};
var pageTransition = {
  type: "spring",
  stiffness: 400,
  damping: 40
};
var fadeTransition = {
  duration: 0.2,
  ease: "linear"
};

// ../../library/src/render/presentation/BasicTicker.tsx
import { jsx as jsx72 } from "react/jsx-runtime";
var BasicTicker = /* @__PURE__ */ forwardRef10(function BasicTicker2(props, ref) {
  const {
    children,
    as: asProp,
    tickerEffectVelocity,
    tickerEffectAlign,
    axis,
    directionModifier,
    hoverModifier,
    gap,
    overflow,
    playState,
    ...rest
  } = props;
  const Component18 = asProp ?? motion.div;
  const isStatic = useIsStaticRenderer();
  const baseVelocity = playState === "paused" ? 0 : tickerEffectVelocity ?? 100;
  const velocity = baseVelocity * directionModifier;
  return /* @__PURE__ */ jsx72(
    Ticker,
    {
      ref,
      as: Component18,
      ...rest,
      gap,
      axis,
      align: tickerEffectAlign ?? "center",
      isStatic,
      velocity,
      hoverFactor: hoverModifier,
      itemSize: "manual",
      overflow
    }
  );
});

// ../../library/src/render/presentation/DraggableTicker.tsx
import { forwardRef as forwardRef11, useEffect as useEffect27, useRef as useRef26 } from "react";
import { jsx as jsx73 } from "react/jsx-runtime";
var DraggableTicker = /* @__PURE__ */ forwardRef11(function DraggableTicker2(props, ref) {
  const {
    children,
    as: asProp,
    tickerEffectVelocity,
    tickerEffectAlign,
    axis,
    directionModifier,
    hoverModifier,
    gap,
    overflow,
    playState,
    ...rest
  } = props;
  const Component18 = asProp ?? motion.div;
  const layoutDirection = useLayoutDirection();
  const layoutDirectionModifier = layoutDirection === "rtl" && axis === "x" ? -1 : 1;
  const baseVelocity = playState === "paused" ? 0 : tickerEffectVelocity ?? 100;
  const targetVelocity = baseVelocity * directionModifier * layoutDirectionModifier;
  const offsetMotionValue = useMotionValue(0);
  const lastDrag = useRef26(0);
  const dragMomentum = useRef26(false);
  const isHovering = useRef26(false);
  const isDragging2 = useRef26(false);
  const handleClickCapture = (event) => {
    if (!isDragging2.current) return;
    if (event.target && event.target !== event.currentTarget) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  useAnimationFrame((_, delta) => {
    const velocity = Math.abs(offsetMotionValue.getVelocity());
    const currentTargetVelocity = isHovering.current ? targetVelocity * hoverModifier : targetVelocity;
    if (performance.now() > lastDrag.current && (!dragMomentum.current || velocity < Math.abs(currentTargetVelocity))) {
      const frameOffset = delta / 1e3 * currentTargetVelocity;
      const updated = offsetMotionValue.get() - frameOffset;
      if (dragMomentum.current) {
        offsetMotionValue.stop();
        dragMomentum.current = false;
      }
      offsetMotionValue.set(updated);
    }
  });
  useEffect27(() => {
    if (playState === "paused") {
      offsetMotionValue.stop();
    }
  }, [playState, offsetMotionValue]);
  return /* @__PURE__ */ jsx73(
    Ticker,
    {
      ref,
      as: Component18,
      ...rest,
      gap,
      axis,
      align: tickerEffectAlign ?? "center",
      itemSize: "manual",
      overflow,
      _dragX: axis === "x" ? offsetMotionValue : void 0,
      _dragY: axis === "y" ? offsetMotionValue : void 0,
      offset: offsetMotionValue,
      drag: axis,
      dragMomentum: true,
      onClickCapture: handleClickCapture,
      onDragStart: () => {
        isDragging2.current = true;
      },
      onDragEnd: () => {
        lastDrag.current = performance.now();
        dragMomentum.current = true;
        setTimeout(() => {
          isDragging2.current = false;
        }, 5);
      },
      onMouseEnter: () => {
        isHovering.current = true;
      },
      onMouseLeave: () => {
        isHovering.current = false;
      }
    }
  );
});

// ../../library/src/render/presentation/TickerContext.tsx
import { createContext as createContext14, startTransition as startTransition11, useMemo as useMemo23 } from "react";
import { jsx as jsx74 } from "react/jsx-runtime";
var TickerContext2 = /* @__PURE__ */ (() => {
  const Context2 = createContext14(void 0);
  Context2.displayName = "TickerContext";
  return Context2;
})();
var TickerContextProvider = ({
  onPlayStateChange,
  children
}) => {
  const value = useMemo23(
    () => ({
      start: () => startTransition11(() => onPlayStateChange("running")),
      stop: () => startTransition11(() => onPlayStateChange("paused"))
    }),
    [onPlayStateChange]
  );
  return /* @__PURE__ */ jsx74(TickerContext2.Provider, { value, children });
};

// ../../library/src/render/presentation/Ticker.tsx
import { jsx as jsx75 } from "react/jsx-runtime";
var Ticker2 = /* @__PURE__ */ forwardRef12(function Ticker3(props, ref) {
  const {
    children,
    tickerEffectDraggable,
    tickerEffectStackDirection,
    tickerEffectXOverflow,
    tickerEffectYOverflow,
    tickerEffectOverflow,
    tickerEffectGap,
    tickerEffectDirectionModifier,
    tickerEffectHoverModifier,
    tickerEffectPosition,
    tickerEffectIsDataRepeater,
    style: styleProps,
    ...rest
  } = props;
  const isStatic = useIsStaticRenderer();
  const [playState, setPlayState] = useState9("running");
  const axis = tickerEffectStackDirection?.startsWith("column") ? "y" : "x";
  const directionModifier = tickerEffectDirectionModifier === "reverse" ? -1 : 1;
  const hoverModifier = isFiniteNumber(tickerEffectHoverModifier) ? tickerEffectHoverModifier / 100 : 1;
  const xOverflowWithFallback = tickerEffectXOverflow ?? tickerEffectOverflow ?? "visible";
  const yOverflowWithFallback = tickerEffectYOverflow ?? tickerEffectOverflow ?? "visible";
  const overflow = (axis === "x" ? xOverflowWithFallback : yOverflowWithFallback) === "visible";
  const gap = getGap(tickerEffectGap, axis);
  const items = flattenChildrenToTickerItems(children);
  const tickerStyle = {
    ...styleProps,
    // Enable fractional unit fallback for dynamic numbers of CMS items
    "--ticker-cms-total-children": tickerEffectIsDataRepeater ? items.length : void 0,
    // collected position is not present on canvas and would be overridden when codegenned into a class
    // so we have to add it here to avoid it being set to relative by the underlying ticker component
    position: tickerEffectPosition
  };
  if (isStatic || !tickerEffectDraggable) {
    return /* @__PURE__ */ jsx75(TickerContextProvider, { onPlayStateChange: setPlayState, children: /* @__PURE__ */ jsx75(
      BasicTicker,
      {
        ...rest,
        style: tickerStyle,
        ref,
        axis,
        gap,
        overflow,
        directionModifier,
        hoverModifier,
        items,
        playState
      }
    ) });
  }
  return /* @__PURE__ */ jsx75(TickerContextProvider, { onPlayStateChange: setPlayState, children: /* @__PURE__ */ jsx75(
    DraggableTicker,
    {
      ...rest,
      style: tickerStyle,
      ref,
      axis,
      gap,
      overflow,
      directionModifier,
      hoverModifier,
      items,
      playState
    }
  ) });
});
function getGap(gap, axis) {
  if (isFiniteNumber(gap)) return gap;
  if (!isString(gap)) return void 0;
  const gaps = gap.split(" ");
  const rowGap = gaps[0];
  const columnGap = gaps[1] ?? gaps[0];
  if (axis === "x" && columnGap) return naNToUndefined(parseInt(columnGap));
  if (axis === "y" && rowGap) return naNToUndefined(parseInt(rowGap));
  return void 0;
}
function naNToUndefined(value) {
  return Number.isNaN(value) ? void 0 : value;
}

// ../../library/src/modules/withTickerFX.tsx
import { jsx as jsx76 } from "react/jsx-runtime";
var withTickerFX = (Component18) => {
  return (props) => {
    if (props.tickerEffectEnabled) {
      return /* @__PURE__ */ jsx76(Ticker2, { ...props, as: Component18 });
    }
    return /* @__PURE__ */ jsx76(Component18, { ...props });
  };
};

// ../../library/src/modules/withMappedReactProps.tsx
import { jsx as jsx77 } from "react/jsx-runtime";
function extractMappingFromInfo(info) {
  const json = info.__FramerMetadata__.exports.default.annotations?.framerVariables;
  if (!json) return void 0;
  try {
    return JSON.parse(json);
  } catch {
    return void 0;
  }
}
function withMappedReactProps(Component18, info) {
  return (rawProps) => {
    const props = {};
    const mapping = extractMappingFromInfo(info);
    for (const key7 in rawProps) {
      asRecord(props)[mapping?.[key7] ?? key7] = rawProps[key7];
    }
    return /* @__PURE__ */ jsx77(Component18, { ...props });
  };
}

// ../../library/src/modules/withVariantAppearEffect.tsx
import React80, { startTransition as startTransition12 } from "react";
import { jsx as jsx78 } from "react/jsx-runtime";
var keys = /* @__PURE__ */ new Set([
  "visibleVariantId",
  "obscuredVariantId",
  "threshold",
  "animateOnce",
  "variantAppearEffectEnabled",
  "targets",
  "exitTarget",
  "scrollDirection"
]);
var defaultRanges3 = { inputRange: [], outputRange: [] };
function createInputOutputRanges2(transformTargets, threshold, exitTarget) {
  const outputRange = [];
  const inputRange = createTransformInputRange(
    transformTargets,
    threshold,
    (index) => outputRange.unshift(index, index)
  );
  if (exitTarget) {
    const lastInputRange = inputRange[inputRange.length - 1];
    if (!isNumber(lastInputRange)) return defaultRanges3;
    inputRange.push(lastInputRange + 1);
    outputRange.push(-1);
  }
  const firstItem = inputRange[0];
  if (!isNumber(firstItem)) return defaultRanges3;
  if (firstItem <= 1) return { inputRange, outputRange };
  return { inputRange: [0, Math.max(firstItem - 1, 0), ...inputRange], outputRange: [-1, -1, ...outputRange] };
}
var withVariantAppearEffect = (Component18) => React80.forwardRef(
  (props, forwardedRef) => {
    if (RenderTarget.current() === RenderTarget.canvas) return /* @__PURE__ */ jsx78(Component18, { ...props, ref: forwardedRef });
    const [options, rest] = extractPrefixedProps(props, keys);
    const {
      visibleVariantId,
      obscuredVariantId,
      animateOnce,
      threshold,
      variantAppearEffectEnabled,
      targets,
      exitTarget,
      scrollDirection
    } = options;
    const [activeVariant, setVariant] = React80.useState(obscuredVariantId);
    const animateState = React80.useRef(false);
    const observerRef = useObserverRef(forwardedRef);
    useAppearEffect(
      observerRef,
      (appears) => {
        if (options.targets) return;
        if (options.scrollDirection) return;
        if (animateOnce && animateState.current === true) return;
        if (animateState.current === appears) return;
        animateState.current = appears;
        React80.startTransition(() => {
          setVariant(appears ? visibleVariantId : obscuredVariantId);
        });
      },
      {
        enabled: variantAppearEffectEnabled,
        animateOnce,
        threshold: {
          y: threshold
        }
      }
    );
    React80.useEffect(() => {
      if (scrollDirection) return;
      if (!targets) return;
      const playedState = {};
      let currentVariant = void 0;
      return scroll((_, { y: scrollY }) => {
        if (!targets[0] || targets[0].ref && !targets[0].ref.current) return;
        const { inputRange, outputRange } = createInputOutputRanges2(
          targets,
          (threshold ?? 0) * scrollY.containerLength,
          exitTarget
        );
        if (inputRange.length === 0 || inputRange.length !== outputRange.length) return;
        const index = Math.floor(transform(scrollY.current, inputRange, outputRange));
        if (animateOnce && playedState[index]) return;
        playedState[index] = true;
        const variant = targets[index]?.target ?? void 0;
        if (variant === currentVariant) return;
        currentVariant = variant;
        React80.startTransition(() => {
          setVariant(variant);
        });
      });
    }, [animateOnce, threshold, targets, props.variant, scrollDirection, exitTarget]);
    useScrollDirectionChange(scrollDirection, (variant) => React80.startTransition(() => setVariant(variant)), {
      enabled: variantAppearEffectEnabled,
      repeat: !animateOnce
    });
    useOnRouteChange(() => {
      if (!variantAppearEffectEnabled) return;
      const useObscuredVariant = !options.targets && !options.scrollDirection;
      const target = useObscuredVariant ? options.obscuredVariantId : void 0;
      startTransition12(() => setVariant(target));
    });
    if (!("variantAppearEffectEnabled" in options) || variantAppearEffectEnabled === true) {
      return /* @__PURE__ */ jsx78(Component18, { ...rest, variant: activeVariant ?? props.variant, ref: observerRef });
    } else {
      return /* @__PURE__ */ jsx78(Component18, { ...rest });
    }
  }
);

// ../../library/src/modules/withVariantFX.tsx
import React81 from "react";
import { jsx as jsx79 } from "react/jsx-runtime";
var withVariantFX = (Component18) => React81.forwardRef(
  ({ initial, animate: animate3, exit, ...props }, forwardedRef) => {
    const observerRef = useObserverRef(forwardedRef);
    const effect = usePresenceAnimation(
      {
        initial,
        animate: animate3,
        exit
      },
      observerRef,
      true
    );
    return /* @__PURE__ */ jsx79(Component18, { ...props, style: { ...props?.style, ...effect.values }, ref: observerRef });
  }
);

// ../../library/src/render/WindowContext.ts
import React82 from "react";
var WindowContext = /* @__PURE__ */ React82.createContext(
  void 0
);
var useProvidedWindow = () => React82.useContext(WindowContext);

// ../../library/src/render/fonts/fonts.ts
var safeFonts = {
  Arial: {
    Regular: { selector: "Arial", weight: void 0 },
    Black: { selector: "Arial-Black", weight: void 0 },
    Narrow: { selector: "Arial Narrow", weight: void 0 },
    "Rounded Bold": { selector: "Arial Rounded MT Bold", weight: void 0 }
  },
  Avenir: {
    Book: { selector: "Avenir", weight: void 0 },
    Light: { selector: "Avenir-Light", weight: void 0 },
    Medium: { selector: "Avenir-Medium", weight: void 0 },
    Heavy: { selector: "Avenir-Heavy", weight: void 0 },
    Black: { selector: "Avenir-Black", weight: void 0 }
  },
  "Avenir Next": {
    Regular: { selector: "Avenir Next", weight: void 0 },
    "Ultra Light": { selector: "AvenirNext-UltraLight", weight: void 0 },
    Medium: { selector: "AvenirNext-Medium", weight: void 0 },
    "Demi Bold": { selector: "AvenirNext-DemiBold", weight: void 0 },
    Heavy: { selector: "AvenirNext-Heavy", weight: void 0 }
  },
  "Avenir Next Condensed": {
    Regular: { selector: "Avenir Next Condensed", weight: void 0 },
    "Ultra Light": { selector: "AvenirNextCondensed-UltraLight", weight: void 0 },
    Medium: { selector: "AvenirNextCondensed-Medium", weight: void 0 },
    "Demi Bold": { selector: "AvenirNextCondensed-DemiBold", weight: void 0 },
    Heavy: { selector: "AvenirNextCondensed-Heavy", weight: void 0 }
  },
  Baskerville: {
    Regular: { selector: "Baskerville", weight: void 0 },
    "Semi Bold": { selector: "Baskerville-SemiBold", weight: void 0 }
  },
  "Bodoni 72": {
    Book: { selector: "Bodoni 72", weight: void 0 },
    Oldstyle: { selector: "Bodoni 72 Oldstyle", weight: void 0 },
    Smallcaps: { selector: "Bodoni 72 Smallcaps", weight: void 0 }
  },
  Courier: { Regular: { selector: "Courier", weight: void 0 } },
  "Courier New": { Regular: { selector: "Courier New", weight: void 0 } },
  Futura: {
    Medium: { selector: "Futura", weight: void 0 },
    Condensed: { selector: "Futura-CondensedMedium", weight: void 0 },
    "Condensed ExtraBold": { selector: "Futura-CondensedExtraBold", weight: void 0 }
  },
  Georgia: { Regular: { selector: "Georgia", weight: void 0 } },
  "Gill Sans": {
    Regular: { selector: "Gill Sans", weight: void 0 },
    Light: { selector: "GillSans-Light", weight: void 0 },
    SemiBold: { selector: "GillSans-SemiBold", weight: void 0 },
    UltraBold: { selector: "GillSans-UltraBold", weight: void 0 }
  },
  Helvetica: {
    Regular: { selector: "Helvetica", weight: void 0 },
    Light: { selector: "Helvetica-Light", weight: void 0 },
    Bold: { selector: "Helvetica-Bold", weight: void 0 },
    Oblique: { selector: "Helvetica-Oblique", weight: void 0 },
    "Light Oblique": { selector: "Helvetica-LightOblique", weight: void 0 },
    "Bold Oblique": { selector: "Helvetica-BoldOblique", weight: void 0 }
  },
  "Helvetica Neue": {
    Regular: { selector: "Helvetica Neue", weight: void 0 },
    UltraLight: { selector: "HelveticaNeue-UltraLight", weight: void 0 },
    Thin: { selector: "HelveticaNeue-Thin", weight: void 0 },
    Light: { selector: "HelveticaNeue-Light", weight: void 0 },
    Medium: { selector: "HelveticaNeue-Medium", weight: void 0 },
    Bold: { selector: "HelveticaNeue-Bold", weight: void 0 },
    Italic: { selector: "HelveticaNeue-Italic", weight: void 0 },
    "UltraLight Italic": { selector: "HelveticaNeue-UltraLightItalic", weight: void 0 },
    "Thin Italic": { selector: "HelveticaNeue-ThinItalic", weight: void 0 },
    "Light Italic": { selector: "HelveticaNeue-LightItalic", weight: void 0 },
    "Medium Italic": { selector: "HelveticaNeue-MediumItalic", weight: void 0 },
    "Bold Italic": { selector: "HelveticaNeue-BoldItalic", weight: void 0 },
    "Condensed Bold": { selector: "HelveticaNeue-CondensedBold", weight: void 0 },
    "Condensed Black": { selector: "HelveticaNeue-CondensedBlack", weight: void 0 }
  },
  "Hoefler Text": { Regular: { selector: "Hoefler Text", weight: void 0 } },
  Impact: { Regular: { selector: "Impact", weight: void 0 } },
  "Lucida Grande": { Regular: { selector: "Lucida Grande", weight: void 0 } },
  Menlo: { Regular: { selector: "Menlo", weight: void 0 } },
  Monaco: { Regular: { selector: "Monaco", weight: void 0 } },
  Optima: {
    Regular: { selector: "Optima", weight: void 0 },
    ExtraBlack: { selector: "Optima-ExtraBlack", weight: void 0 }
  },
  Palatino: { Regular: { selector: "Palatino", weight: void 0 } },
  "SF Pro Display": {
    Regular: { selector: "__SF-UI-Display-Regular__", weight: 400 },
    Ultralight: { selector: "__SF-UI-Display-Ultralight__", weight: 100 },
    Thin: { selector: "__SF-UI-Display-Thin__", weight: 200 },
    Light: { selector: "__SF-UI-Display-Light__", weight: 300 },
    Medium: { selector: "__SF-UI-Display-Medium__", weight: 500 },
    Semibold: { selector: "__SF-UI-Display-Semibold__", weight: 600 },
    Bold: { selector: "__SF-UI-Display-Bold__", weight: 700 },
    Heavy: { selector: "__SF-UI-Display-Heavy__", weight: 800 },
    Black: { selector: "__SF-UI-Display-Black__", weight: 900 },
    Italic: { selector: "__SF-UI-Display-Italic__", weight: 400 },
    "Ultralight Italic": { selector: "__SF-UI-Display-Ultralight-Italic__", weight: 100 },
    "Thin Italic": { selector: "__SF-UI-Display-Thin-Italic__", weight: 200 },
    "Light Italic": { selector: "__SF-UI-Display-Light-Italic__", weight: 300 },
    "Medium Italic": { selector: "__SF-UI-Display-Medium-Italic__", weight: 500 },
    "Semibold Italic": { selector: "__SF-UI-Display-Semibold-Italic__", weight: 600 },
    "Bold Italic": { selector: "__SF-UI-Display-Bold-Italic__", weight: 700 },
    "Heavy Italic": { selector: "__SF-UI-Display-Heavy-Italic__", weight: 800 },
    "Black Italic": { selector: "__SF-UI-Display-Black-Italic__", weight: 900 }
  },
  "SF Pro Display Condensed": {
    Regular: { selector: "__SF-UI-Display-Condensed-Regular__", weight: 400 },
    Ultralight: { selector: "__SF-UI-Display-Condensed-Ultralight__", weight: 100 },
    Thin: { selector: "__SF-UI-Display-Condensed-Thin__", weight: 200 },
    Light: { selector: "__SF-UI-Display-Condensed-Light__", weight: 300 },
    Medium: { selector: "__SF-UI-Display-Condensed-Medium__", weight: 500 },
    Semibold: { selector: "__SF-UI-Display-Condensed-Semibold__", weight: 600 },
    Bold: { selector: "__SF-UI-Display-Condensed-Bold__", weight: 700 },
    Heavy: { selector: "__SF-UI-Display-Condensed-Heavy__", weight: 800 },
    Black: { selector: "__SF-UI-Display-Condensed-Black__", weight: 900 }
  },
  "SF Pro Text": {
    Regular: { selector: "__SF-UI-Text-Regular__", weight: 400 },
    Light: { selector: "__SF-UI-Text-Light__", weight: 200 },
    Medium: { selector: "__SF-UI-Text-Medium__", weight: 500 },
    Semibold: { selector: "__SF-UI-Text-Semibold__", weight: 600 },
    Bold: { selector: "__SF-UI-Text-Bold__", weight: 700 },
    Heavy: { selector: "__SF-UI-Text-Heavy__", weight: 800 },
    Italic: { selector: "__SF-UI-Text-Italic__", weight: 400 },
    "Light Italic": { selector: "__SF-UI-Text-Light-Italic__", weight: 200 },
    "Medium Italic": { selector: "__SF-UI-Text-Medium-Italic__", weight: 500 },
    "Semibold Italic": { selector: "__SF-UI-Text-Semibold-Italic__", weight: 600 },
    "Bold Italic": { selector: "__SF-UI-Text-Bold-Italic__", weight: 700 },
    "Heavy Italic": { selector: "__SF-UI-Text-Heavy-Italic__", weight: 800 }
  },
  "SF Pro Text Condensed": {
    Regular: { selector: "__SF-UI-Text-Condensed-Regular__", weight: 400 },
    Light: { selector: "__SF-UI-Text-Condensed-Light__", weight: 200 },
    Medium: { selector: "__SF-UI-Text-Condensed-Medium__", weight: 500 },
    Semibold: { selector: "__SF-UI-Text-Condensed-Semibold__", weight: 600 },
    Bold: { selector: "__SF-UI-Text-Condensed-Bold__", weight: 700 },
    Heavy: { selector: "__SF-UI-Text-Condensed-Heavy__", weight: 800 }
  },
  Tahoma: { Regular: { selector: "Tahoma", weight: void 0 } },
  Times: { Regular: { selector: "Times", weight: void 0 } },
  "Times New Roman": { Regular: { selector: "Times New Roman", weight: void 0 } },
  Trebuchet: { Regular: { selector: "Trebuchet MS", weight: void 0 } },
  Verdana: { Regular: { selector: "Verdana", weight: void 0 } }
};
var fontAliases = {
  "__SF-Compact-Display-Regular__": "SFCompactDisplay-Regular|.SFCompactDisplay-Regular",
  "__SF-Compact-Display-Ultralight__": "SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight",
  "__SF-Compact-Display-Thin__": "SFCompactDisplay-Thin|.SFCompactDisplay-Thin",
  "__SF-Compact-Display-Light__": "SFCompactDisplay-Light|.SFCompactDisplay-Light",
  "__SF-Compact-Display-Medium__": "SFCompactDisplay-Medium|.SFCompactDisplay-Medium",
  "__SF-Compact-Display-Semibold__": "SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold",
  "__SF-Compact-Display-Heavy__": "SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy",
  "__SF-Compact-Display-Black__": "SFCompactDisplay-Black|.SFCompactDisplay-Black",
  "__SF-Compact-Display-Bold__": "SFCompactDisplay-Bold|.SFCompactDisplay-Bold",
  "__SF-UI-Text-Regular__": ".SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText",
  "__SF-UI-Text-Light__": ".SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light",
  "__SF-UI-Text-Medium__": ".SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium",
  "__SF-UI-Text-Semibold__": ".SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold",
  "__SF-UI-Text-Bold__": ".SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold",
  "__SF-UI-Text-Heavy__": ".SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy",
  "__SF-UI-Text-Italic__": ".SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic",
  "__SF-UI-Text-Light-Italic__": ".SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic",
  "__SF-UI-Text-Medium-Italic__": ".SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic",
  "__SF-UI-Text-Semibold-Italic__": ".SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic",
  "__SF-UI-Text-Bold-Italic__": ".SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic",
  "__SF-UI-Text-Heavy-Italic__": ".SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic",
  "__SF-Compact-Text-Regular__": "SFCompactText-Regular|.SFCompactText-Regular",
  "__SF-Compact-Text-Light__": "SFCompactText-Light|.SFCompactText-Light",
  "__SF-Compact-Text-Medium__": "SFCompactText-Medium|.SFCompactText-Medium",
  "__SF-Compact-Text-Semibold__": "SFCompactText-Semibold|.SFCompactText-Semibold",
  "__SF-Compact-Text-Bold__": "SFCompactText-Bold|.SFCompactText-Bold",
  "__SF-Compact-Text-Heavy__": "SFCompactText-Heavy|.SFCompactText-Heavy",
  "__SF-Compact-Text-Italic__": "SFCompactText-Italic|.SFCompactText-Italic",
  "__SF-Compact-Text-Light-Italic__": "SFCompactText-LightItalic|.SFCompactText-LightItalic",
  "__SF-Compact-Text-Medium-Italic__": "SFCompactText-MediumItalic|.SFCompactText-MediumItalic",
  "__SF-Compact-Text-Semibold-Italic__": "SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic",
  "__SF-Compact-Text-Bold-Italic__": "SFCompactText-BoldItalic|.SFCompactText-BoldItalic",
  "__SF-Compact-Text-Heavy-Italic__": "SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic",
  "__SF-UI-Display-Condensed-Regular__": ".SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular",
  "__SF-UI-Display-Condensed-Ultralight__": ".SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight",
  "__SF-UI-Display-Condensed-Thin__": ".SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin",
  "__SF-UI-Display-Condensed-Light__": ".SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light",
  "__SF-UI-Display-Condensed-Medium__": ".SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium",
  "__SF-UI-Display-Condensed-Semibold__": ".SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold",
  "__SF-UI-Display-Condensed-Bold__": ".SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold",
  "__SF-UI-Display-Condensed-Heavy__": ".SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy",
  "__SF-UI-Display-Condensed-Black__": ".SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black",
  "__SF-UI-Display-Regular__": ".SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay",
  "__SF-UI-Display-Ultralight__": ".SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight",
  "__SF-UI-Display-Thin__": ".SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin",
  "__SF-UI-Display-Light__": ".SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light",
  "__SF-UI-Display-Medium__": ".SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium",
  "__SF-UI-Display-Semibold__": ".SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold",
  "__SF-UI-Display-Bold__": ".SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold",
  "__SF-UI-Display-Heavy__": ".SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy",
  "__SF-UI-Display-Black__": ".SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black",
  "__SF-UI-Display-Italic__": ".SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic",
  "__SF-UI-Display-Ultralight-Italic__": ".SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic",
  "__SF-UI-Display-Thin-Italic__": ".SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic",
  "__SF-UI-Display-Light-Italic__": ".SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic",
  "__SF-UI-Display-Medium-Italic__": ".SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic",
  "__SF-UI-Display-Semibold-Italic__": ".SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic",
  "__SF-UI-Display-Bold-Italic__": ".SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic",
  "__SF-UI-Display-Heavy-Italic__": ".SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic",
  "__SF-UI-Display-Black-Italic__": ".SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic",
  "__SF-UI-Text-Condensed-Regular__": ".SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular",
  "__SF-UI-Text-Condensed-Light__": ".SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light",
  "__SF-UI-Text-Condensed-Medium__": ".SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium",
  "__SF-UI-Text-Condensed-Semibold__": ".SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold",
  "__SF-UI-Text-Condensed-Bold__": ".SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold",
  "__SF-UI-Text-Condensed-Heavy__": ".SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy",
  "__SF-Compact-Rounded-Regular__": "SFCompactRounded-Regular|.SFCompactRounded-Regular",
  "__SF-Compact-Rounded-Ultralight__": "SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight",
  "__SF-Compact-Rounded-Thin__": "SFCompactRounded-Thin|.SFCompactRounded-Thin",
  "__SF-Compact-Rounded-Light__": "SFCompactRounded-Light|.SFCompactRounded-Light",
  "__SF-Compact-Rounded-Medium__": "SFCompactRounded-Medium|.SFCompactRounded-Medium",
  "__SF-Compact-Rounded-Semibold__": "SFCompactRounded-Semibold|.SFCompactRounded-Semibold",
  "__SF-Compact-Rounded-Bold__": "SFCompactRounded-Bold|.SFCompactRounded-Bold",
  "__SF-Compact-Rounded-Heavy__": "SFCompactRounded-Heavy|.SFCompactRounded-Heavy",
  "__SF-Compact-Rounded-Black__": "SFCompactRounded-Black|.SFCompactRounded-Black"
};
var fontFamilies = safeFonts;

// ../../library/src/render/fonts/types.ts
var FontSourceNames = /* @__PURE__ */ ((FontSourceNames2) => {
  FontSourceNames2["Google"] = "google";
  FontSourceNames2["Fontshare"] = "fontshare";
  FontSourceNames2["Framer"] = "framer";
  FontSourceNames2["Local"] = "local";
  FontSourceNames2["Custom"] = "custom";
  FontSourceNames2["BuiltIn"] = "builtIn";
  return FontSourceNames2;
})(FontSourceNames || {});
function isSuccessfullyParsedFontVariant(variant) {
  return variant.weight !== void 0 && variant.style !== void 0;
}

// ../../library/src/render/fonts/LocalFontSource.ts
var systemFontFamilyName = "System Default";
var LocalFontSource = class {
  constructor() {
    __publicField(this, "name", "local" /* Local */);
    __publicField(this, "fontFamilies", []);
    __publicField(this, "byFamilyName", /* @__PURE__ */ new Map());
    __publicField(this, "fontAliasBySelector", /* @__PURE__ */ new Map());
    __publicField(this, "fontAliases", /* @__PURE__ */ new Map());
  }
  getFontFamilyByName(family) {
    return this.byFamilyName.get(family) ?? null;
  }
  // TODO: these are duplicated across implementations of FontSource
  // When adding a third source, we should abstract them
  createFontFamily(family) {
    const fontFamily = { name: family, fonts: [], source: this.name };
    this.addFontFamily(fontFamily);
    return fontFamily;
  }
  addFontFamily(fontFamily) {
    this.fontFamilies.push(fontFamily);
    this.byFamilyName.set(fontFamily.name, fontFamily);
  }
  // end of duplication
  importFonts() {
    const fonts = [];
    for (const family of Object.keys(fontFamilies)) {
      const members = fontFamilies[family];
      if (!members) continue;
      const fontFamily = this.createFontFamily(family);
      for (const variant of Object.keys(members)) {
        const member = members[variant];
        if (!member) continue;
        const { selector, weight } = member;
        const font = {
          variant,
          selector,
          weight,
          family: fontFamily,
          cssFamilyName: fontFamily.name
        };
        fontFamily.fonts.push(font);
      }
      fonts.push(...fontFamily.fonts);
    }
    for (const [key7, value] of Object.entries(fontAliases)) {
      this.addFontAlias(key7, value);
    }
    const { fontFamily: systemFontFamily, aliases } = this.getSystemFontFamily();
    this.addFontFamily(systemFontFamily);
    for (const [key7, value] of aliases) {
      this.addFontAlias(key7, value);
    }
    fonts.push(...systemFontFamily.fonts);
    return fonts;
  }
  addFontAlias(key7, value) {
    this.fontAliases.set(key7, value);
    this.fontAliasBySelector.set(value, key7);
  }
  getSystemFontFamily() {
    const fontFamilies2 = (
      // System fonts - Taken from https://furbo.org/stuff/systemfonts-new.html - "All Platforms" section
      "system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif"
    );
    const fontFamily = { name: systemFontFamilyName, fonts: [], source: this.name };
    const aliases = /* @__PURE__ */ new Map();
    const weights = [400, 100, 200, 300, 500, 600, 700, 800, 900];
    const styles4 = ["normal", "italic"];
    for (const style of styles4) {
      for (const weight of weights) {
        const variant = createVariantName(weight, style);
        const alias = `__SystemDefault-${weight}-${style}__`;
        const font = {
          variant,
          selector: alias,
          style,
          weight,
          family: fontFamily,
          cssFamilyName: fontFamily.name
        };
        fontFamily.fonts.push(font);
        aliases.set(alias, fontFamilies2);
      }
    }
    return { fontFamily, aliases };
  }
  getFontAliasBySelector(selector) {
    return this.fontAliasBySelector.get(selector) || null;
  }
  getFontSelectorByAlias(alias) {
    return this.fontAliases.get(alias) || null;
  }
  /** Font family aliases are in the format of `__Alias-Name__` */
  isFontFamilyAlias(value) {
    if (value && /^__.*__$/u.exec(value)) return true;
    return false;
  }
};
var fontWeightNames = {
  "100": "Thin",
  "200": "Extra Light",
  "300": "Light",
  "400": "Normal",
  "500": "Medium",
  "600": "Semi Bold",
  "700": "Bold",
  "800": "Extra Bold",
  "900": "Black"
};
function createVariantName(weight, style) {
  const friendlyStyle = style === "normal" ? "Regular" : "Italic";
  if (weight === 400) {
    return friendlyStyle;
  }
  if (style !== "normal") {
    return `${fontWeightNames[weight]} ${friendlyStyle}`;
  }
  return `${fontWeightNames[weight]}`;
}

// ../../library/src/utils/MapWithHash.ts
var MapWithHash = class extends Map {
  constructor() {
    super(...arguments);
    __publicField(this, "_hash", 0);
  }
  get hash() {
    return this._hash;
  }
  set(key7, value) {
    this._hash++;
    return super.set(key7, value);
  }
  delete(key7) {
    this._hash++;
    return super.delete(key7);
  }
  clear() {
    this._hash++;
    return super.clear();
  }
};

// ../../library/src/render/fonts/css.ts
var FRAMER_VARIABLE_FONT_SUFFIX = "Variable";
function createCSSFamilyName(fontFamilyName, isVariable) {
  return isVariable ? `${fontFamilyName} ${FRAMER_VARIABLE_FONT_SUFFIX}` : fontFamilyName;
}
function createCSSFontFamilyFromWebFontLocator(locator, fontSource) {
  switch (fontSource) {
    case "custom" /* Custom */:
      throw new Error("Custom fonts are not supported");
    default:
      return createCSSFamilyName(locator.name, locator.isVariable);
  }
}

// ../../library/src/render/fonts/fontUtils.ts
function supportsOpenType(openTypeData) {
  return Boolean(openTypeData && Array.isArray(openTypeData));
}
function validateVariationAxes(variationAxesData) {
  if (!variationAxesData) return;
  if (!Array.isArray(variationAxesData)) return;
  const variationAxes = [];
  for (const axis of variationAxesData) {
    if (!isVariationAxis(axis)) continue;
    variationAxes.push({
      tag: axis.tag,
      name: axis.name,
      minValue: axis.minValue,
      maxValue: axis.maxValue,
      defaultValue: axis.defaultValue
    });
  }
  return variationAxes;
}
function isOpenTypeFeature(feature) {
  if (typeof feature !== "object" || feature === null) return false;
  if (!("tag" in feature) || typeof feature.tag !== "string") return false;
  if ("coverage" in feature && typeof feature.coverage !== "undefined" && !Array.isArray(feature.coverage)) {
    return false;
  }
  return true;
}
function isVariationAxis(axis) {
  if (typeof axis !== "object" || axis === null) return false;
  if (!("tag" in axis) || typeof axis.tag !== "string") return false;
  if ("name" in axis && typeof axis.name !== "string") return false;
  if (!("minValue" in axis) || typeof axis.minValue !== "number") return false;
  if (!("maxValue" in axis) || typeof axis.maxValue !== "number") return false;
  if (!("defaultValue" in axis) || typeof axis.defaultValue !== "number") {
    return false;
  }
  return true;
}

// ../../library/src/render/fonts/BuiltInFontSource.ts
var builtInFontSelectorPrefix = "BI;";
var BuiltInFontSource = class {
  constructor() {
    __publicField(this, "name", "builtIn" /* BuiltIn */);
    __publicField(this, "fontFamilies", []);
    __publicField(this, "byFamilyName", /* @__PURE__ */ new Map());
    __publicField(this, "assetByKey", /* @__PURE__ */ new Map());
  }
  importFonts(assets) {
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    this.assetByKey.clear();
    const fonts = [];
    for (const asset of assets) {
      if (!this.isValidBuiltInFont(asset)) continue;
      const { properties } = asset;
      const fontName = properties.font.fontFamily;
      const fontFamily = this.createFontFamily(
        fontName,
        properties.font.foundryName,
        properties.font.fontVersion
      );
      const openTypeData = properties.font.openTypeData;
      const variationAxesData = properties.font.variationAxes;
      const isVariableFont2 = Array.isArray(variationAxesData);
      const variant = isVariableFont2 ? "variable" : properties.font.fontSubFamily || "regular";
      const url = createAbsoluteAssetURLFromAsset(asset);
      const font = {
        assetKey: asset.key,
        family: fontFamily,
        selector: this.createSelector(fontName, variant, properties.font.fontVersion),
        variant,
        file: url,
        hasOpenTypeFeatures: supportsOpenType(openTypeData),
        variationAxes: validateVariationAxes(variationAxesData),
        category: properties.font.fontCategory,
        weight: variantNameToWeight(variant),
        style: getFontStyle(variant),
        cssFamilyName: createCSSFamilyName(fontName, isVariableFont2)
      };
      fontFamily.fonts.push(font);
      this.assetByKey.set(asset.key, asset);
      fonts.push(font);
    }
    for (const fontFamily of this.fontFamilies) {
      fontFamily.fonts.sort((a, b) => {
        const weightA = variantNameToWeight(a.variant);
        const weightB = variantNameToWeight(b.variant);
        if (!weightA || !weightB) return 1;
        return weightA - weightB;
      });
    }
    return fonts;
  }
  static parseVariant(variant) {
    const kebabCaseVariant = variantToKebabCase(variant);
    const weight = variantsNameToWeight[kebabCaseVariant];
    const style = getFontStyle(variant);
    return { weight, style };
  }
  getFontBySelector(selector) {
    const locator = this.parseSelector(selector);
    if (!locator) return;
    const fontFamily = this.getFontFamilyByName(locator.name);
    if (!fontFamily) return;
    return fontFamily.fonts.find((f) => f.selector === selector);
  }
  getFontFamilyByName(family) {
    return this.byFamilyName.get(family) ?? null;
  }
  createFontFamily(family, foundryName, version2) {
    const existingFontFamily = this.byFamilyName.get(family);
    if (existingFontFamily && existingFontFamily.version === version2) return existingFontFamily;
    const fontFamily = {
      source: this.name,
      name: family,
      fonts: [],
      foundryName,
      version: version2
    };
    this.addFontFamily(fontFamily);
    return fontFamily;
  }
  getOpenTypeFeatures(font) {
    assert(font.assetKey, "Font must have an asset key");
    const asset = this.assetByKey.get(font.assetKey);
    const openTypeData = asset?.properties?.font?.openTypeData;
    if (!supportsOpenType(openTypeData)) return [];
    return openTypeData?.map((feature) => {
      if (!isOpenTypeFeature(feature)) return;
      return { tag: feature.tag, coverage: feature.coverage };
    });
  }
  isValidBuiltInFont(asset) {
    if (!asset.mimeType.startsWith("font/")) return false;
    if (asset.properties?.kind !== "font") return false;
    if (!asset.properties.font) return false;
    if (!asset.properties.font.fontVersion) return false;
    if (!asset.properties.font.fontFamily) return false;
    return "fontFamily" in asset.properties.font;
  }
  createSelector(family, variant, version2) {
    return `${builtInFontSelectorPrefix}${family}/${variant}/${version2}`;
  }
  parseSelector(selector) {
    if (!selector.startsWith(builtInFontSelectorPrefix)) return null;
    const [_, selectorWithoutPrefix] = selector.split(builtInFontSelectorPrefix);
    if (selectorWithoutPrefix === void 0) return null;
    const [name, variant, version2] = selectorWithoutPrefix.split("/");
    if (!name || !variant || !version2) return null;
    return {
      name,
      variant,
      source: this.name,
      isVariable: variant.toLowerCase().includes("variable")
    };
  }
  addFontFamily(fontFamily) {
    this.fontFamilies.push(fontFamily);
    this.byFamilyName.set(fontFamily.name, fontFamily);
  }
};
var variantsNameToWeight = {
  ultralight: 100,
  "ultralight-italic": 100,
  thin: 200,
  "thin-italic": 200,
  demi: 200,
  light: 300,
  "light-italic": 300,
  normal: 350,
  base: 400,
  regular: 400,
  classic: 400,
  "regular-slanted": 400,
  italic: 400,
  oblique: 400,
  dense: 400,
  brukt: 300,
  book: 400,
  "book-italic": 400,
  text: 400,
  "text-italic": 400,
  medium: 500,
  solid: 500,
  "medium-oblique": 500,
  "medium-italic": 500,
  mittel: 500,
  semibold: 600,
  "semibold-italic": 600,
  bold: 700,
  "bold-italic": 700,
  "bold-oblique": 700,
  fett: 700,
  ultrabold: 800,
  "ultrabold-italic": 800,
  extrabold: 800,
  "extrabold-italic": 800,
  black: 900,
  extralight: 100,
  "extralight-italic": 100,
  "black-italic": 900,
  "extra-italic": 900,
  "extra-italic-bold": 900,
  satt: 900,
  heavy: 900,
  "heavy-italic": 900,
  // The following variants are only used in the FT88 font. These are not really weights, but more font styles (gothique, cursive, etc.).
  // We assign them different (fake) weights to ensure that the changes are picked up when switching between variants.
  serif: 100,
  school: 200,
  expanded: 300,
  gothique: 500,
  // The following variants are only used in the ARK_ES font.
  // We assign them different (fake) weights to ensure that the changes are picked up when switching between variants.
  // The order is important because we want to group all the light together and solid together.
  "dense-light": 200,
  "dense-regular": 300,
  "dense-medium": 400,
  "dense-bold": 500,
  "solid-light": 600,
  "solid-regular": 700,
  "solid-medium": 800,
  "solid-bold": 900,
  // The following variants are only used in the Tecnica font.
  // We assign them different (fake) weights to ensure that the changes are picked up when switching between variants.
  "53": 400,
  "55": 600,
  // The following variants are only used in the Rag font.
  // We assign them different (fake) weights to ensure that the changes are picked up when switching between variants.
  "narrow-regular": 350,
  "narrow-black": 850,
  // we want to put variable fonts last
  variable: 1e3,
  "variable-italic": 1e3
};
function variantNameToWeight(variant) {
  const kebabCaseVariant = variantToKebabCase(variant);
  return variantsNameToWeight[kebabCaseVariant];
}
function variantToKebabCase(variant) {
  return variant.toLowerCase().replace(/\s+/gu, "-");
}
function getFontStyle(variant) {
  variant = variant.toLowerCase();
  if (variant.includes("italic") || variant.includes("oblique") || variant.includes("slanted")) return "italic";
  return "normal";
}

// ../../library/src/render/fonts/getRelatedFontVariants.ts
function getRelatedFontVariants(currentVariant, availableVariants) {
  return {
    ...pickBoldItalicVariants(currentVariant, availableVariants),
    ...pickVariableVariants(currentVariant, availableVariants)
  };
}
function pickBoldItalicVariants(currentVariant, availableVariants) {
  if (availableVariants.length === 0) {
    return {
      variantBold: void 0,
      variantBoldItalic: void 0,
      variantItalic: void 0
    };
  }
  const { weight: currentWeight, style: currentStyle } = currentVariant;
  const variantByWeightAndStyle = /* @__PURE__ */ new Map();
  const boldVariantByStyle = /* @__PURE__ */ new Map();
  for (const variant of availableVariants) {
    if (variant.isVariable !== currentVariant.isVariable) continue;
    variantByWeightAndStyle.set(`${variant.weight}-${variant.style}`, variant);
    if (variant.weight <= currentWeight) continue;
    if (!boldVariantByStyle.has(variant.style)) {
      boldVariantByStyle.set(variant.style, variant);
    }
  }
  let variantBold = boldVariantByStyle.get(currentStyle);
  let variantBoldItalic = boldVariantByStyle.get("italic");
  const currentVariantWeight = currentVariant.weight;
  if (currentVariantWeight <= 300) {
    variantBold = variantByWeightAndStyle.get(`400-${currentStyle}`) ?? variantBold;
    variantBoldItalic = variantByWeightAndStyle.get("400-italic") ?? variantBoldItalic;
  } else if (currentVariantWeight <= 500) {
    variantBold = variantByWeightAndStyle.get(`700-${currentStyle}`) ?? variantBold;
    variantBoldItalic = variantByWeightAndStyle.get("700-italic") ?? variantBoldItalic;
  } else {
    variantBold = variantByWeightAndStyle.get(`900-${currentStyle}`) ?? variantBold;
    variantBoldItalic = variantByWeightAndStyle.get("900-italic") ?? variantBoldItalic;
  }
  const variantItalic = variantByWeightAndStyle.get(`${currentWeight}-italic`);
  return { variantBold, variantItalic, variantBoldItalic };
}
function pickVariableVariants(currentVariant, availableVariants) {
  if (availableVariants.length === 0) return { variantVariable: void 0, variantVariableItalic: void 0 };
  const variantByWeightAndStyle = /* @__PURE__ */ new Map();
  let variantVariable;
  let variantVariableItalic;
  let fallbackVariant;
  let fallbackItalicVariant;
  for (const variant of availableVariants) {
    if (!variant.isVariable) continue;
    const isSameWeight = variant.weight === currentVariant.weight;
    const isDefaultWeight = variant.weight === 400;
    if (variant.style === "normal") {
      if (isSameWeight) {
        variantVariable = variant;
      } else if (isDefaultWeight) {
        fallbackVariant = variant;
      } else if (!fallbackVariant) {
        fallbackVariant = variant;
      }
    } else if (variant.style === "italic") {
      if (isSameWeight) {
        variantVariableItalic = variant;
      } else if (isDefaultWeight) {
        fallbackItalicVariant = variant;
      } else if (!fallbackItalicVariant) {
        fallbackItalicVariant = variant;
      }
    }
  }
  return {
    variantVariable: variantVariable ?? fallbackVariant,
    variantVariableItalic: variantVariableItalic ?? fallbackItalicVariant
  };
}

// ../../library/src/render/fonts/variableFont.ts
function isVariableFont(font) {
  return Boolean(font.variationAxes);
}

// ../../library/src/render/fonts/CustomFontSource.ts
var log3 = getLogger2("custom-font-source");
var customFontSelectorLegacyPrefix = "CUSTOM;";
var customFontSelectorPrefixV2 = "CUSTOMV2;";
function isCustomFontSelector(selector) {
  return isCustomFontSelectorV2(selector) || isCustomFontSelectorLegacy(selector);
}
function isCustomFontSelectorV2(selector) {
  return selector.startsWith(customFontSelectorPrefixV2);
}
function isCustomFontSelectorLegacy(selector) {
  return selector.startsWith(customFontSelectorLegacyPrefix);
}
function findDuplicateFont(existingFonts, newFont) {
  for (let i = 0; i < existingFonts.length; i++) {
    const existingFont = existingFonts[i];
    if (!existingFont) continue;
    if (existingFont.owner !== newFont.owner && existingFont.file === newFont.file) {
      return { existingFont, index: i, projectDuplicate: true };
    }
    if (existingFont && // TODO: When fonts have a duplicate selector, we assume it's the same font, but it can
    // be a different file. Currently there is no way to resolve these conflicts in the UI.
    // This problem exsits already for files with the same metadata.
    existingFont.selector === newFont.selector) {
      return { existingFont, index: i, projectDuplicate: false };
    }
  }
  return void 0;
}
function getLegacyFontFamilyName(properties) {
  const { font } = properties;
  const fontFamily = font.fontFamily;
  const isAssetVariableFont = Array.isArray(font.variationAxes);
  if (isAssetVariableFont && fontFamily.toLowerCase().includes("variable")) return fontFamily;
  const variant = isAssetVariableFont ? FRAMER_VARIABLE_FONT_SUFFIX : font.fontSubFamily.trim();
  if (variant === "") return fontFamily;
  return `${fontFamily} ${variant}`;
}
function getCustomFontInfo({ fontFamily, fontSubFamily, variationAxes, faceDescriptors }) {
  const rawVariant = fontSubFamily.trim() || "Regular";
  const containsVariant = rawVariant.toLocaleLowerCase().includes("variable");
  const variant = validateVariationAxes(variationAxes) && !containsVariant ? `Variable ${rawVariant}` : rawVariant;
  let style = "normal";
  let weight = 400;
  if (faceDescriptors) {
    weight = faceDescriptors.weight;
    style = faceDescriptors.italic || faceDescriptors.oblique ? "italic" : "normal";
  }
  return { family: fontFamily, variant, weight, style };
}
var CustomFontSource = class _CustomFontSource {
  constructor() {
    __publicField(this, "name", "custom" /* Custom */);
    __publicField(this, "fontFamilies", []);
    __publicField(this, "byFamilyName", /* @__PURE__ */ new Map());
    __publicField(this, "assetsByKey", /* @__PURE__ */ new Map());
  }
  deprecatedImportFonts(assets) {
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    this.assetsByKey.clear();
    const fonts = [];
    for (const asset of assets) {
      if (!this.isValidCustomFontAsset(asset)) {
        continue;
      }
      const variationAxesData = asset.properties?.font.variationAxes;
      const assetIsVariableFont = Array.isArray(variationAxesData);
      const fontName = getLegacyFontFamilyName(asset.properties);
      const fontFamily = this.createFontFamily(fontName);
      const openTypeData = asset.properties?.font.openTypeData;
      const variant = assetIsVariableFont ? "variable" : this.inferVariantName(fontName);
      const url = createAbsoluteAssetURLFromAsset(asset);
      const selector = _CustomFontSource.createLegacySelector(fontName);
      const { family, variant: v2Variant } = getCustomFontInfo(asset.properties.font);
      const v2Selector = _CustomFontSource.createSelector(family, v2Variant);
      const font = {
        assetKey: asset.key,
        family: fontFamily,
        selector,
        variant,
        file: url,
        hasOpenTypeFeatures: supportsOpenType(openTypeData),
        variationAxes: validateVariationAxes(variationAxesData),
        owner: getAssetOwnerType(asset),
        cssFamilyName: _CustomFontSource.cssFontFamilyFromSelector(selector),
        alternativeSelectors: {
          [v2Selector]: {
            variant: v2Variant,
            cssFamilyName: _CustomFontSource.cssFontFamilyFromSelector(v2Selector)
          }
        }
      };
      fontFamily.fonts.push(font);
      this.assetsByKey.set(asset.key, asset);
      fonts.push(...fontFamily.fonts);
    }
    return fonts;
  }
  importFonts(assets, enableFontImprovements) {
    if (!enableFontImprovements) {
      return this.deprecatedImportFonts(assets);
    }
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    this.assetsByKey.clear();
    const fonts = {};
    for (const asset of assets) {
      if (!this.isValidCustomFontAsset(asset)) {
        continue;
      }
      const { family, variant, weight, style } = getCustomFontInfo(asset.properties.font);
      const variationAxesData = asset.properties.font.variationAxes;
      const assetIsVariableFont = Array.isArray(variationAxesData);
      const openTypeData = asset.properties.font.openTypeData;
      const url = createAbsoluteAssetURLFromAsset(asset);
      const ownerType = getAssetOwnerType(asset);
      const legacyFontFamilyName = getLegacyFontFamilyName(asset.properties);
      const legacySelector = _CustomFontSource.createLegacySelector(legacyFontFamilyName);
      const fontFamily = this.createFontFamily(family);
      const selector = _CustomFontSource.createSelector(fontFamily.name, variant);
      const font = {
        assetKey: asset.key,
        family: fontFamily,
        selector,
        variant,
        weight,
        style,
        file: url,
        hasOpenTypeFeatures: supportsOpenType(openTypeData),
        variationAxes: validateVariationAxes(variationAxesData),
        owner: ownerType,
        alternativeSelectors: {
          [legacySelector]: {
            variant: assetIsVariableFont ? "variable" : this.inferVariantName(legacyFontFamilyName),
            cssFamilyName: _CustomFontSource.cssFontFamilyFromSelector(legacySelector)
          }
        },
        cssFamilyName: _CustomFontSource.cssFontFamilyFromSelector(selector)
      };
      const duplicateInfo = findDuplicateFont(fontFamily.fonts, font);
      if (duplicateInfo?.projectDuplicate) {
        if (font.owner === "project") {
          fontFamily.fonts[duplicateInfo.index] = font;
          fonts[selector] = font;
        }
      } else if (duplicateInfo) {
        log3.warn("Duplicate font found for:", font, "with existing font:", duplicateInfo.existingFont);
        const existingFont = duplicateInfo.existingFont;
        const newIsWoff2 = font.file?.endsWith(".woff2") ?? false;
        const existingIsWoff2 = existingFont.file?.endsWith(".woff2") ?? false;
        if (newIsWoff2 && !existingIsWoff2) {
          fontFamily.fonts[duplicateInfo.index] = font;
          fonts[selector] = font;
        }
      } else {
        fontFamily.fonts.push(font);
        fonts[selector] = font;
      }
      this.assetsByKey.set(asset.key, asset);
    }
    for (const fontFamily of this.fontFamilies) {
      if (fontFamily.fonts.length > 0) {
        updateFontRelationships(fontFamily);
      }
    }
    return Object.values(fonts);
  }
  static createSelector(family, variant) {
    return `${customFontSelectorPrefixV2}${family}${variant ? ` ${variant}` : ""}`;
  }
  static createLegacySelector(fontName) {
    return `${customFontSelectorLegacyPrefix}${fontName}`;
  }
  static cssFontFamilyFromSelector(selector) {
    assert(isCustomFontSelector(selector), "Selector must be a custom font selector");
    if (isCustomFontSelectorLegacy(selector)) {
      return selector.slice(customFontSelectorLegacyPrefix.length);
    }
    return selector.slice(customFontSelectorPrefixV2.length);
  }
  isValidCustomFontAsset(asset) {
    if (!asset.mimeType.startsWith("font/")) return false;
    if (asset.properties?.kind !== "font") return false;
    if (!asset.properties.font) return false;
    return "fontFamily" in asset.properties.font;
  }
  getOpenTypeFeatures(font) {
    assert(font.assetKey, "Font must have an asset key");
    const asset = this.assetsByKey.get(font.assetKey);
    const openTypeData = asset?.properties?.font?.openTypeData;
    if (!supportsOpenType(openTypeData)) return [];
    return openTypeData?.map((feature) => {
      if (!isOpenTypeFeature(feature)) return;
      return { tag: feature.tag, coverage: feature.coverage };
    });
  }
  inferVariantName(family) {
    const possibleValues = [
      "thin",
      "ultra light",
      "extra light",
      "light",
      "normal",
      "medium",
      "semi bold",
      "bold",
      "extra bold",
      "black"
    ];
    const possibleValuesWithItalics = [...possibleValues.map((value) => `${value} italic`), ...possibleValues];
    const lowerCaseFamily = family.toLowerCase();
    const tokens = [...lowerCaseFamily.split(" "), ...lowerCaseFamily.split("-"), ...lowerCaseFamily.split("_")];
    const foundToken = possibleValuesWithItalics.find(
      (value) => tokens.includes(value) || tokens.includes(value.replace(/\s+/gu, ""))
    );
    if (foundToken) return foundToken.replace(/^\w|\s\w/gu, (char) => char.toUpperCase());
    return "Regular";
  }
  createFontFamily(family) {
    const existingFontFamily = this.byFamilyName.get(family);
    if (existingFontFamily) return existingFontFamily;
    const fontFamily = {
      source: this.name,
      name: family,
      fonts: []
    };
    this.addFontFamily(fontFamily);
    return fontFamily;
  }
  addFontFamily(fontFamily) {
    this.fontFamilies.push(fontFamily);
    this.byFamilyName.set(fontFamily.name, fontFamily);
  }
  getFontFamilyByName(family) {
    const foundFontFamily = this.byFamilyName.get(family);
    if (!foundFontFamily) return null;
    return foundFontFamily;
  }
};
function fontToVariantWithMetadata(font) {
  if (!font.weight || !font.style) return void 0;
  return {
    weight: font.weight,
    style: font.style,
    isVariable: isVariableFont(font),
    selector: font.selector
  };
}
function updateFontRelationships(fontFamily) {
  const availableVariants = fontFamily.fonts.map((font) => fontToVariantWithMetadata(font)).filter((font) => font !== void 0);
  for (const font of fontFamily.fonts) {
    const variant = fontToVariantWithMetadata(font);
    if (!variant) continue;
    const relatedVariants = getRelatedFontVariants(variant, availableVariants);
    font.selectorVariable = relatedVariants.variantVariable?.selector;
    font.selectorVariableItalic = relatedVariants.variantVariableItalic?.selector;
    font.selectorBold = relatedVariants.variantBold?.selector;
    font.selectorBoldItalic = relatedVariants.variantBoldItalic?.selector;
    font.selectorItalic = relatedVariants.variantItalic?.selector;
  }
}
function getAssetOwnerType(asset) {
  return asset.ownerTypes.includes("team") ? "team" : "project";
}

// ../../library/src/render/fonts/loadOpenType.ts
async function loadFontsWithOpenType(source) {
  switch (source) {
    case "google": {
      const supportedFonts = await import("./google-4VARBVAS.mjs");
      return supportedFonts?.default;
    }
    case "fontshare": {
      const supportedFonts = await import("./fontshare-LTYJMI6Q.mjs");
      return supportedFonts?.default;
    }
    default:
      throw new Error(`Unknown font source: ${source}`);
  }
}
async function loadFontToOpenTypeFeatures(source) {
  switch (source) {
    case "google": {
      const features = await import("./google-IHP45ZLM.mjs");
      return features?.default;
    }
    case "fontshare": {
      const features = await import("./fontshare-XMKN2FOD.mjs");
      return features?.default;
    }
    case "framer": {
      const features = await import("./framer-font-D6RMCRV4.mjs");
      return features?.default;
    }
    default:
      throw new Error(`Unknown font source: ${source}`);
  }
}

// ../../library/src/render/fonts/parseFontshareCategories.ts
var knownFontshareCategories = ["display", "sans", "serif", "slab", "handwritten", "script"];
function parseFontshareCategories(categoriesField) {
  return categoriesField.split(",").map((category) => category.trim().toLowerCase()).filter(isKnownFontshareCategory);
}
function isKnownFontshareCategory(category) {
  return knownFontshareCategories.includes(category);
}

// ../../library/src/render/fonts/FontshareSource.ts
var fontsharePrefix = "FS;";
var weightNameToNumber = {
  thin: 100,
  hairline: 100,
  // Alternative name for "thin".
  extralight: 200,
  light: 300,
  regular: 400,
  medium: 500,
  semibold: 600,
  bold: 700,
  extrabold: 800,
  ultra: 800,
  // Alternative name for "extrabold".
  black: 900,
  heavy: 900
  // Alternative name for "black".
};
var weightNames = /* @__PURE__ */ Object.keys(weightNameToNumber);
var allowedVariantsRegex = /* @__PURE__ */ (() => new RegExp(`^(?:${[...weightNames, "italic", "variable"].join("|")})`, "u"))();
var FontshareSource = class _FontshareSource {
  constructor() {
    __publicField(this, "name", "fontshare" /* Fontshare */);
    __publicField(this, "fontFamilies", []);
    __publicField(this, "byFamilyName", /* @__PURE__ */ new Map());
  }
  getFontFamilyByName(family) {
    return this.byFamilyName.get(family) ?? null;
  }
  /**
   * Parses variant a string into a weight number and style, defaulting to a
   * weight of `400` and/or a style of `"normal"` depending on what isn't
   * present in the variant string.
   *
   * E.g:
   *   - `"Bold"` becomes `{ weight: 700, style: "normal" }`
   *   - `"Bold Italic"` becomes `{ weight: 700, style: "italic" }`
   *   - `"Italic"` becomes `{ weight: 400, style: "italic" }`
   *   - `"Variable Italic"` becomes `{ weight: 400, style: "italic" }`
   */
  static parseVariant(variant) {
    const variantSplit = variant.toLowerCase().split(" ");
    const weightName = weightNames.find((weightName2) => {
      return variantSplit.includes(weightName2);
    });
    const styleName = variant.toLowerCase().includes("italic") ? "italic" : "normal";
    const weight = weightName && weightNameToNumber[weightName] || 400;
    const style = styleName === "italic" ? styleName : "normal";
    return { weight, style };
  }
  parseSelector(selector) {
    if (!selector.startsWith(fontsharePrefix)) return null;
    const tokens = selector.split("-");
    if (tokens.length !== 2) return null;
    const [family, variant] = tokens;
    if (!family || !variant) return null;
    return {
      name: family.replace(fontsharePrefix, ""),
      variant,
      source: this.name,
      isVariable: variant.toLowerCase().includes("variable")
    };
  }
  static createSelector(family, variant) {
    return `${fontsharePrefix}${family}-${variant.toLowerCase()}`;
  }
  /**
   * We are using this selector to get Open Type features and variable fonts variation axes.
   * CAUTION: This method has to be exactly the same as the one in font-metadata-extractor tool.
   * https://github.com/framer/FramerStudio/blob/master/tools/font-metadata-extractor/src/utils/fontShare.ts
   */
  static createMetadataSelector(family) {
    return `${fontsharePrefix}${family}`;
  }
  addFontFamily(fontFamily) {
    this.fontFamilies.push(fontFamily);
    this.byFamilyName.set(fontFamily.name, fontFamily);
  }
  async importFonts(fontshareFonts, variationAxesData) {
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    const fontsWithOpenType = await loadFontsWithOpenType("fontshare" /* Fontshare */);
    const fonts = [];
    for (const fontshareFont of fontshareFonts) {
      const fontStyles = fontshareFont.font_styles.filter((fontStyle) => {
        const variant = fontStyle.name.toLowerCase();
        const allowedVariantMatch = allowedVariantsRegex.exec(variant);
        if (!allowedVariantMatch || variant.split(" ").includes("wide")) {
          return false;
        }
        return true;
      });
      const fontVariants = fontStyles.map((fontStyle) => {
        const variantInfo = _FontshareSource.parseVariant(fontStyle.name);
        return {
          ...variantInfo,
          selector: _FontshareSource.createSelector(fontshareFont.name, fontStyle.name),
          isVariable: fontStyle.is_variable,
          fontshareVariantName: fontStyle.name,
          file: fontStyle.file
        };
      });
      const key7 = _FontshareSource.createMetadataSelector(fontshareFont.name);
      const variationAxes = variationAxesData?.[key7];
      const familyName = fontshareFont.name;
      let fontFamily = this.getFontFamilyByName(familyName);
      if (!fontFamily) {
        fontFamily = { name: familyName, fonts: [], source: this.name };
        this.addFontFamily(fontFamily);
      }
      const fontMetadataSelector = _FontshareSource.createMetadataSelector(fontshareFont.name);
      const hasOpenTypeFeatures = fontsWithOpenType[fontMetadataSelector];
      for (const fontVariant of fontVariants) {
        const { variantBold, variantBoldItalic, variantItalic, variantVariable, variantVariableItalic } = getRelatedFontVariants(fontVariant, fontVariants);
        const font = {
          family: fontFamily,
          variant: fontVariant.fontshareVariantName.toLowerCase(),
          selector: fontVariant.selector,
          selectorBold: variantBold?.selector,
          selectorBoldItalic: variantBoldItalic?.selector,
          selectorItalic: variantItalic?.selector,
          selectorVariable: variantVariable?.selector,
          selectorVariableItalic: variantVariableItalic?.selector,
          weight: fontVariant.weight,
          style: fontVariant.style,
          file: fontVariant.file,
          category: mapToKnownCategory(fontshareFont.category),
          hasOpenTypeFeatures,
          variationAxes: fontVariant.isVariable ? variationAxes : void 0,
          cssFamilyName: createCSSFamilyName(fontFamily.name, fontVariant.isVariable)
        };
        fontFamily.fonts.push(font);
        fonts.push(font);
      }
    }
    return fonts;
  }
  async getOpenTypeFeatures(font) {
    const fontToOpenTypeFeatures = await loadFontToOpenTypeFeatures("fontshare" /* Fontshare */);
    const metadataSelector = _FontshareSource.createMetadataSelector(font.family.name);
    return fontToOpenTypeFeatures[metadataSelector];
  }
};
function mapToKnownCategory(categoryString) {
  const categoryMapping = {
    serif: "serif",
    sans: "sans-serif",
    slab: "slab",
    display: "display",
    // As of Nov 2023, these two look similar enough  so we can map them into the same category.
    handwritten: "handwriting",
    script: "handwriting"
  };
  const category = parseFontshareCategories(categoryString)[0];
  return category && categoryMapping[category];
}

// ../../library/src/render/fonts/FramerFontSource.ts
var framerInterFontPrefix = "Inter";
var framerFontPrefix = "FR;";
var weightNameToNumber2 = {
  Thin: 100,
  ExtraLight: 200,
  Light: 300,
  "": 400,
  // Regular weights have a selector like "Inter" or "Inter-Italic", with no mention of weight.
  Medium: 500,
  SemiBold: 600,
  Bold: 700,
  ExtraBold: 800,
  Black: 900
};
var FramerFontSource = class _FramerFontSource {
  constructor() {
    __publicField(this, "name", "framer" /* Framer */);
    __publicField(this, "fontFamilies", []);
    __publicField(this, "byFamilyName", /* @__PURE__ */ new Map());
  }
  getFontFamilyByName(family) {
    return this.byFamilyName.get(family) ?? null;
  }
  addFontFamily(familyName) {
    const fontFamily = { name: familyName, fonts: [], source: this.name };
    this.fontFamilies.push(fontFamily);
    this.byFamilyName.set(fontFamily.name, fontFamily);
    return fontFamily;
  }
  static getDraftFontPropertiesBySelector(selector) {
    if (!selector.startsWith(framerFontPrefix) && !selector.startsWith(framerInterFontPrefix)) return null;
    const tokens = selector.split("-");
    const [family, weightAndStyleInfo = ""] = tokens;
    if (!family) return null;
    const style = weightAndStyleInfo.includes("Italic") ? "italic" : "normal";
    const weightName = weightAndStyleInfo.replace("Italic", "");
    const weight = weightName && weightNameToNumber2[weightName] || 400;
    return {
      cssFamilyName: family,
      style,
      weight,
      source: "framer" /* Framer */,
      variant: void 0,
      category: "sans-serif"
    };
  }
  static createMetadataSelector(family) {
    return `${framerFontPrefix}${family}`;
  }
  importFonts(framerFonts, variationAxesData) {
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    const fonts = [];
    framerFonts.forEach((framerFont) => {
      const { uiFamilyName: familyName, ...rest } = framerFont;
      const key7 = _FramerFontSource.createMetadataSelector(framerFont.uiFamilyName);
      const variationAxes = variationAxesData?.[key7];
      let fontFamily = this.getFontFamilyByName(familyName);
      if (!fontFamily) {
        fontFamily = this.addFontFamily(familyName);
      }
      const isVariable = framerFont.selector === framerFont.selectorVariable || framerFont.selector === framerFont.selectorVariableItalic;
      const font = {
        ...rest,
        family: fontFamily,
        variationAxes: isVariable ? variationAxes : void 0
      };
      fontFamily.fonts.push(font);
      fonts.push(font);
    });
    return fonts;
  }
  async getOpenTypeFeatures(font) {
    const fontToOpenTypeFeatures = await loadFontToOpenTypeFeatures("framer" /* Framer */);
    const metadataSelector = _FramerFontSource.createMetadataSelector(font.family.name);
    return fontToOpenTypeFeatures[metadataSelector];
  }
};

// ../../library/src/render/fonts/GoogleFontSource.ts
var googleFontSelectorPrefix = "GF;";
var GoogleFontSource = class _GoogleFontSource {
  constructor() {
    __publicField(this, "name", "google" /* Google */);
    __publicField(this, "fontFamilies", []);
    __publicField(this, "byFamilyName", /* @__PURE__ */ new Map());
  }
  getFontFamilyByName(family) {
    return this.byFamilyName.get(family) ?? null;
  }
  static parseVariant(variant) {
    if (variant === "regular") return { style: "normal", weight: 400 };
    const match = /(\d*)(normal|italic)?/u.exec(variant);
    if (!match) return {};
    const weight = parseInt(match[1] || "400");
    const style = match[2] === "italic" ? "italic" : "normal";
    return { weight, style };
  }
  parseSelector(selector) {
    if (!selector.startsWith(googleFontSelectorPrefix)) return null;
    const isVariable = selector.includes("-variable-");
    const tokens = isVariable ? selector.split("-variable-") : selector.split("-");
    if (tokens.length !== 2) return null;
    const [family, variant] = tokens;
    if (!family || !variant) return null;
    return { name: family.replace(googleFontSelectorPrefix, ""), variant, source: this.name, isVariable };
  }
  static createSelector(family, variant, isVariableFont2) {
    return `${googleFontSelectorPrefix}${family}-${isVariableFont2 ? "variable-" : ""}${variant}`;
  }
  /**
   * We are using this selector to get Open Type features and variable fonts variation axes.
   * CAUTION: This method has to be exactly the same as the one in font-metadata-extractor tool.
   * https://github.com/framer/FramerStudio/blob/master/tools/font-metadata-extractor/src/utils/googleFonts.ts
   */
  static createMetadataSelector(family) {
    return `${googleFontSelectorPrefix}${family}`;
  }
  addFontFamily(family) {
    const fontFamily = { name: family, fonts: [], source: this.name };
    this.fontFamilies.push(fontFamily);
    this.byFamilyName.set(fontFamily.name, fontFamily);
    return fontFamily;
  }
  async importFonts(webFonts, webFontsWithAxes, fontsToVariationAxes) {
    this.fontFamilies.length = 0;
    this.byFamilyName.clear();
    const fontsWithOpenType = await loadFontsWithOpenType("google" /* Google */);
    const fonts = [];
    const webFontsMap = mapBy(webFonts, (webFont) => webFont.family);
    const webFontsWithAxesMap = mapBy(webFontsWithAxes, (webFont) => webFont.family);
    for (const webFontName in webFontsMap) {
      const webFont = webFontsMap[webFontName];
      if (!webFont) continue;
      let fontFamily = this.getFontFamilyByName(webFont.family);
      if (!fontFamily) {
        fontFamily = this.addFontFamily(webFont.family);
      }
      const rawStaticVariants = webFont.variants;
      const staticVariants = rawStaticVariants.map((variantName) => {
        const parsedVariant = _GoogleFontSource.parseVariant(variantName);
        return {
          ...parsedVariant,
          googleFontsVariantName: variantName,
          selector: _GoogleFontSource.createSelector(webFontName, variantName, false),
          isVariable: false,
          file: webFont.files[variantName]
        };
      });
      const variableFont = webFontsWithAxesMap[webFontName];
      const variableVariants = variableFont?.axes ? variableFont.variants.map((variantName) => {
        const parsedVariant = _GoogleFontSource.parseVariant(variantName);
        return {
          ...parsedVariant,
          googleFontsVariantName: variantName,
          selector: _GoogleFontSource.createSelector(webFontName, variantName, true),
          isVariable: true,
          file: variableFont.files[variantName]
        };
      }) : [];
      const key7 = _GoogleFontSource.createMetadataSelector(webFont.family);
      const variationAxes = fontsToVariationAxes?.[key7];
      const allVariants = [...staticVariants, ...variableVariants];
      const allSuccessfullyParsedVariants = allVariants.filter(isSuccessfullyParsedFontVariant);
      const fontMetadataSelector = _GoogleFontSource.createMetadataSelector(webFontName);
      const hasOpenTypeFeatures = fontsWithOpenType[fontMetadataSelector];
      for (const variant of allVariants) {
        const { weight, style, selector, googleFontsVariantName } = variant;
        const linkedVariants = isSuccessfullyParsedFontVariant(variant) ? getRelatedFontVariants(variant, allSuccessfullyParsedVariants) : void 0;
        const { variantBold, variantItalic, variantBoldItalic, variantVariable, variantVariableItalic } = linkedVariants ?? {};
        const font = {
          family: fontFamily,
          variant: googleFontsVariantName,
          selector,
          selectorBold: variantBold?.selector,
          selectorBoldItalic: variantBoldItalic?.selector,
          selectorItalic: variantItalic?.selector,
          selectorVariable: variantVariable?.selector,
          selectorVariableItalic: variantVariableItalic?.selector,
          weight,
          style,
          category: mapToKnownCategory2(webFont.category),
          file: variant.file?.replace("http://", "https://"),
          variationAxes: variant.isVariable ? variationAxes : void 0,
          hasOpenTypeFeatures,
          cssFamilyName: createCSSFamilyName(fontFamily.name, variant.isVariable)
        };
        fontFamily.fonts.push(font);
        fonts.push(font);
      }
    }
    return fonts;
  }
  async getOpenTypeFeatures(font) {
    const fontToOpenTypeFeatures = await loadFontToOpenTypeFeatures("google" /* Google */);
    const metadataSelector = _GoogleFontSource.createMetadataSelector(font.family.name);
    return fontToOpenTypeFeatures[metadataSelector];
  }
};
function mapToKnownCategory2(category) {
  const categoryMapping = {
    serif: "serif",
    "sans-serif": "sans-serif",
    display: "display",
    handwriting: "handwriting",
    monospace: "monospace"
  };
  if (!category) return void 0;
  return categoryMapping[category];
}
function mapBy(array, keyFn) {
  return array.reduce(
    (acc, item) => {
      acc[keyFn(item)] = item;
      return acc;
    },
    {}
  );
}

// ../../library/src/render/fonts/loadFont.ts
var import_fontfaceobserver = __toESM(require_fontfaceobserver_standalone(), 1);
var FONT_LOADING_TIMEOUT = 5e3;
var MAX_RETRIES = 3;
var FontLoadingError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "FontLoadingError";
  }
};
var fontRequests = /* @__PURE__ */ new Map();
var fontReadyPromises = /* @__PURE__ */ new Map();
var loadFont = (data2, doc) => loadFontWithRetries(data2, doc);
async function loadFontWithRetries(data2, doc, attempt = 0) {
  const { family, url, stretch, unicodeRange } = data2;
  const weight = data2.weight;
  const style = data2.style || "normal";
  const requestId = `${family}-${style}-${weight}-${url}`;
  if (!fontRequests.has(requestId) || attempt > 0) {
    const fontFace = new FontFace(family, `url(${url})`, {
      weight: isString(weight) ? weight : weight?.toString(),
      style,
      stretch,
      unicodeRange
    });
    const readyPromise = fontFace.load().then(() => {
      doc.fonts.add(fontFace);
      return isFontReady(family, style, weight);
    }).catch((e) => {
      if (e.name !== "NetworkError") {
        throw e;
      }
      if (attempt < MAX_RETRIES) {
        return loadFontWithRetries(data2, doc, attempt + 1);
      }
      throw new FontLoadingError(
        `Font loading failed after ${attempt} retries due to network error: ${JSON.stringify({
          family,
          style,
          weight,
          url,
          stretch,
          unicodeRange
        })}`
      );
    });
    fontRequests.set(requestId, readyPromise);
  }
  await fontRequests.get(requestId);
}
async function isFontReady(family, style, weight) {
  const readyPromiseId = `${family}-${style}-${weight}`;
  if (!fontReadyPromises.has(readyPromiseId)) {
    const observer = new import_fontfaceobserver.default(family, {
      style,
      weight
    });
    const readyPromise = observer.load(null, FONT_LOADING_TIMEOUT);
    fontReadyPromises.set(readyPromiseId, readyPromise);
  }
  try {
    await fontReadyPromises.get(readyPromiseId);
  } catch (e) {
    throw new FontLoadingError(
      `Failed to check if font is ready (${FONT_LOADING_TIMEOUT}ms timeout exceeded): ${JSON.stringify({
        family,
        style,
        weight
      })}`
    );
  }
}

// ../../library/src/render/fonts/static/variable-fonts/framer.json
var framer_default = { "FR;Inter": [{ tag: "opsz", minValue: 14, maxValue: 32, defaultValue: 14, name: "Optical size" }, { tag: "wght", minValue: 100, maxValue: 900, defaultValue: 400, name: "Weight" }] };

// ../../library/src/render/fonts/loadVariationAxes.ts
function loadVariationAxes(source) {
  try {
    if (source === "framer" /* Framer */) {
      if (!isValidVariationAxesData(framer_default)) return void 0;
      return framer_default;
    } else {
      const axes = (async () => {
        switch (source) {
          case "google" /* Google */: {
            return (await import("./google-LWW6GXZ4.mjs")).default;
          }
          case "fontshare" /* Fontshare */: {
            return (await import("./fontshare-X63NXWGB.mjs")).default;
          }
          default:
            assertNever(source);
        }
      })();
      if (!isValidVariationAxesData(axes)) return void 0;
      return axes;
    }
  } catch (error) {
    console.error(error);
    return void 0;
  }
}
function isValidVariationAxesData(data2) {
  return isObject2(data2) && Object.values(data2).every(isValidVariationAxes);
}
function isVariationAxis2(data2) {
  return isObject2(data2) && isString(data2.tag);
}
function isValidVariationAxes(data2) {
  return Array.isArray(data2) && data2.every(isVariationAxis2);
}

// ../../library/src/render/fonts/fontStore.ts
var FontStore = class {
  constructor() {
    /**
     * Enabling the `FontStore` will make Text components automatically load
     * their fonts on render. Otherwise font loading is the responsibility of
     * the environment.
     */
    __publicField(this, "enabled", false);
    __publicField(this, "bySelector", new MapWithHash());
    __publicField(this, "loadedSelectors", /* @__PURE__ */ new Set());
    __publicField(this, "getGoogleFontsListPromise");
    __publicField(this, "getFontshareFontsListPromise");
    __publicField(this, "getBuiltInFontsListPromise");
    __publicField(this, "customFontsImportPromise", new Promise((resolve) => {
      this.resolveCustomFontsImportPromise = resolve;
    }));
    __publicField(this, "local");
    __publicField(this, "google");
    __publicField(this, "fontshare");
    __publicField(this, "builtIn");
    __publicField(this, "framer");
    __publicField(this, "custom");
    __publicField(this, "bySelectorValuesCache");
    __publicField(this, "testing", {
      addFont: this.addFont.bind(this)
    });
    this.local = new LocalFontSource();
    this.google = new GoogleFontSource();
    this.fontshare = new FontshareSource();
    this.framer = new FramerFontSource();
    this.custom = new CustomFontSource();
    this.builtIn = new BuiltInFontSource();
    this.importLocalFonts();
  }
  get hash() {
    return this.bySelector.hash;
  }
  addFont(font) {
    this.bySelector.set(font.selector, font);
    if (font.alternativeSelectors) {
      for (const altSelector of Object.keys(font.alternativeSelectors)) {
        this.bySelector.set(altSelector, font);
      }
    }
  }
  getAvailableFonts() {
    if (!this.bySelectorValuesCache || this.bySelectorValuesCache.hash !== this.bySelector.hash) {
      const uniqueFonts = /* @__PURE__ */ new Map();
      for (const font of this.bySelector.values()) {
        uniqueFonts.set(font, true);
      }
      this.bySelectorValuesCache = {
        result: Array.from(uniqueFonts.keys()),
        hash: this.bySelector.hash
      };
    }
    return this.bySelectorValuesCache.result;
  }
  importLocalFonts() {
    for (const font of this.local.importFonts()) {
      this.addFont(font);
      void this.loadFont(font.selector);
    }
  }
  async importGoogleFonts() {
    if (!this.getGoogleFontsListPromise) {
      this.getGoogleFontsListPromise = Promise.resolve().then(async () => {
        const { staticFonts, variableFonts } = await runtime.fetchGoogleFontsList();
        const axesData = await loadVariationAxes("google" /* Google */);
        for (const font of await this.google.importFonts(staticFonts, variableFonts, axesData)) {
          this.addFont(font);
        }
        return { staticFonts, variableFonts };
      });
    }
    return this.getGoogleFontsListPromise;
  }
  async importFontshareFonts() {
    if (!this.getFontshareFontsListPromise) {
      this.getFontshareFontsListPromise = runtime.fetchFontshareFontsList();
      const fontshareFonts = await this.getFontshareFontsListPromise;
      const axesData = await loadVariationAxes("fontshare" /* Fontshare */);
      for (const font of await this.fontshare.importFonts(fontshareFonts, axesData)) {
        this.addFont(font);
      }
    }
    return this.getFontshareFontsListPromise;
  }
  async importBuiltInFonts() {
    if (!this.getBuiltInFontsListPromise) {
      this.getBuiltInFontsListPromise = runtime.fetchBuiltInFontsList();
      const builtInFonts = await this.getBuiltInFontsListPromise;
      for (const font of await this.builtIn.importFonts(builtInFonts)) {
        this.addFont(font);
      }
    }
    return this.getBuiltInFontsListPromise;
  }
  importFramerFonts(fonts) {
    const axesData = loadVariationAxes("framer" /* Framer */);
    this.framer.importFonts(fonts, axesData).forEach((font) => {
      this.addFont(font);
    });
  }
  importCustomFonts(assets, enableFontImprovements) {
    this.bySelector.forEach((_, key7) => {
      if (isCustomFontSelector(key7)) {
        this.bySelector.delete(key7);
      }
    });
    const importedFonts = this.custom.importFonts(assets, enableFontImprovements);
    for (const font of importedFonts) {
      this.addFont(font);
    }
    this.resolveCustomFontsImportPromise();
  }
  /**
   * Returns a promise that resolves when custom fonts have been imported
   * @internal
   */
  getCustomFontsImportPromise() {
    return this.customFontsImportPromise;
  }
  getFontFamily(info) {
    const fontFamily = this[info.source].getFontFamilyByName(info.name);
    return fontFamily;
  }
  getFontBySelector(selector) {
    if (!selector) return void 0;
    let font;
    font = this.bySelector.get(selector);
    if (!font) return void 0;
    if (font.alternativeSelectors && selector in font.alternativeSelectors) {
      return { ...font, ...font.alternativeSelectors[selector] };
    }
    return font;
  }
  // Function called by draft to get font properties for a selector, before the (google) font is available in the store
  // It replaces a previous function that created Font instances and added them to the store
  // on the fly while rendering drafts, which caused issues (overriding real google font info with fake instances with partial data).
  // Ideally this should not happen, but that's a fix for another day
  getDraftPropertiesBySelector(selector) {
    const font = this.getFontBySelector(selector);
    if (font) {
      return {
        style: font.style,
        weight: font.weight,
        variant: font.variant,
        cssFamilyName: font.cssFamilyName,
        source: font.family.source,
        category: font.category
      };
    }
    const googleLocator = this.google.parseSelector(selector);
    if (googleLocator) {
      const fontVariant = GoogleFontSource.parseVariant(googleLocator.variant);
      if (isSuccessfullyParsedFontVariant(fontVariant)) {
        return {
          style: fontVariant.style,
          weight: fontVariant.weight,
          variant: googleLocator.variant,
          cssFamilyName: createCSSFontFamilyFromWebFontLocator(googleLocator, "google" /* Google */),
          source: "google" /* Google */,
          category: void 0
        };
      }
    }
    const fontshareLocator = this.fontshare.parseSelector(selector);
    if (fontshareLocator) {
      const fontVariant = FontshareSource.parseVariant(fontshareLocator.variant);
      if (isSuccessfullyParsedFontVariant(fontVariant)) {
        return {
          style: fontVariant.style,
          weight: fontVariant.weight,
          variant: fontshareLocator.variant,
          cssFamilyName: createCSSFontFamilyFromWebFontLocator(fontshareLocator, "fontshare" /* Fontshare */),
          source: "fontshare" /* Fontshare */,
          category: void 0
        };
      }
    }
    const builtInFontLocator = this.builtIn.parseSelector(selector);
    if (builtInFontLocator) {
      const fontVariant = BuiltInFontSource.parseVariant(builtInFontLocator.variant);
      if (isSuccessfullyParsedFontVariant(fontVariant)) {
        return {
          style: fontVariant.style,
          weight: fontVariant.weight,
          variant: builtInFontLocator.variant,
          cssFamilyName: createCSSFontFamilyFromWebFontLocator(builtInFontLocator, "builtIn" /* BuiltIn */),
          source: "builtIn" /* BuiltIn */,
          category: void 0
        };
      }
    }
    const framerFontDraftProperties = FramerFontSource.getDraftFontPropertiesBySelector(selector);
    if (framerFontDraftProperties) {
      return framerFontDraftProperties;
    }
    return null;
  }
  isSelectorLoaded(selector) {
    return this.loadedSelectors.has(selector);
  }
  /**
   * Load a single font
   * */
  async loadFont(selector) {
    const font = this.getFontBySelector(selector);
    if (!font) {
      return 2 /* NotFound */;
    }
    if (this.loadedSelectors.has(selector)) {
      return 0 /* AlreadyLoaded */;
    }
    const family = font.cssFamilyName;
    const source = font.family.source;
    const fontIsVariable = isVariableFont(font);
    switch (source) {
      case "local" /* Local */:
        this.loadedSelectors.add(selector);
        return 1 /* Loaded */;
      case "framer" /* Framer */:
        if (!isTest()) {
          await isFontReady(font.family.name, font.style, font.weight);
        }
        if (fontIsVariable) {
          if (!font.file) {
            return Promise.reject(`Unable to load font: ${selector}`);
          }
          await loadFont(
            {
              family,
              url: font.file,
              weight: font.weight,
              style: font.style
            },
            document
          );
        }
        this.loadedSelectors.add(selector);
        return 1 /* Loaded */;
      case "google" /* Google */:
      case "fontshare" /* Fontshare */:
      case "builtIn" /* BuiltIn */:
      case "custom" /* Custom */:
        if (!font.file) {
          return Promise.reject(`Unable to load font: ${selector}`);
        }
        await loadFont(
          {
            family,
            url: font.file,
            weight: font.weight,
            style: font.style
          },
          document
        );
        this.loadedSelectors.add(selector);
        return 1 /* Loaded */;
      default:
        assertNever(source);
    }
  }
  async loadFontsFromSelectors(selectors) {
    if (!this.enabled) return [];
    const importPromises = [];
    const shouldImportFontshareFonts = selectors.some((selector) => selector.startsWith(fontsharePrefix));
    if (shouldImportFontshareFonts) {
      importPromises.push(
        this.importFontshareFonts().catch((error) => {
          warnOnce2("Failed to load Fontshare fonts:", error);
        })
      );
    }
    const shouldImportGoogleFonts = selectors.some((selector) => selector.startsWith(googleFontSelectorPrefix));
    if (shouldImportGoogleFonts) {
      importPromises.push(
        this.importGoogleFonts().catch((error) => {
          warnOnce2("Failed to load Google fonts:", error);
        })
      );
    }
    const shouldImportBuiltInFonts = selectors.some((selector) => selector.startsWith(builtInFontSelectorPrefix));
    if (shouldImportBuiltInFonts) {
      importPromises.push(
        this.importBuiltInFonts().catch((error) => {
          warnOnce2("Failed to load built-in fonts:", error);
        })
      );
    }
    const shouldImportCustomFonts = selectors.some(isCustomFontSelector);
    if (shouldImportCustomFonts) {
      importPromises.push(
        this.customFontsImportPromise.catch((error) => {
          warnOnce2("Failed to load custom fonts:", error);
        })
      );
    }
    if (importPromises.length > 0) {
      await Promise.all(importPromises);
    }
    const loadingPromises = [];
    for (const selector of selectors) {
      loadingPromises.push(this.loadFont(selector));
    }
    return Promise.allSettled(loadingPromises);
  }
  async loadFonts(fontSelectors) {
    const results = await this.loadFontsFromSelectors(fontSelectors);
    const newlyLoadedFontCount = results.filter(
      (result) => result.status === "fulfilled" && result.value === 1 /* Loaded */
    ).length;
    return { newlyLoadedFontCount };
  }
  // Deprecated methods that are kept for backwards compatibility with any compiled code that might still be using them
  /**
   * @deprecated This methods API is confusing as 1) it works for all fonts,
   * not just missing ones, 2) it supports both async/await and a callback,
   * but the callback is called only if *all* fonts have been loaded. Use
   * `loadFonts` instead.
   */
  async loadMissingFonts(fontSelectors, fontsLoadedCallback) {
    const selectors = fontSelectors.filter((selector) => {
      return !fontStore.loadedSelectors.has(selector);
    });
    if (selectors.length === 0) return;
    await fontStore.loadWebFontsFromSelectors(selectors);
    const isEachFontLoaded = selectors.every((selector) => {
      return fontStore.loadedSelectors.has(selector);
    });
    if (isEachFontLoaded && fontsLoadedCallback) fontsLoadedCallback();
  }
  /**
   * @deprecated This method is misleading as it works with all fonts, not
   * just web fonts. Use `loadFonts` instead. (In Framer, web fonts has a
   * specific meaning: it refers to Google/Fontshare fonts and exludes custom
   * and local fonts. See e.g. `WebFontStore` and the Web/Custom toggle in
   * the font picker in the UI. More context: https://github.com/framer/FramerStudio/pull/15778#discussion_r1395120760)
   */
  async loadWebFontsFromSelectors(selectors) {
    return this.loadFontsFromSelectors(selectors);
  }
  // defaultFont doesnt seem to be used anywhere in our code (except tests),
  // but keeping it for backwards compatibility with any compiled code.
  /** @deprecated This will be removed in the future. Dont use it. */
  get defaultFont() {
    const defaultFont = this.getFontBySelector("Inter");
    assert(defaultFont, "Can\u2019t find Inter font");
    return defaultFont;
  }
};
var fontStore = /* @__PURE__ */ new FontStore();

// ../../library/src/render/presentation/CustomProperties.tsx
import { jsx as jsx80 } from "react/jsx-runtime";
function CustomProperties({
  children,
  customProperties
}) {
  return /* @__PURE__ */ jsx80("div", { style: customProperties, children });
}

// ../../library/src/render/presentation/Forms/FormPlainTextInput.tsx
import { forwardRef as forwardRef13, startTransition as startTransition13, useCallback as useCallback24, useState as useState10 } from "react";
import { jsx as jsx81 } from "react/jsx-runtime";
var passwordManagerIgnoreDataProps = {
  // 1Password
  "data-1p-ignore": true,
  // LastPass
  "data-lpignore": true,
  // Dashlane
  // https://support.dashlane.com/hc/en-us/articles/4420122792594-Optimize-your-web-forms-for-Dashlane-Autofill
  "data-form-type": "other",
  // autocomplete="off" is a generic property that disables autofilling. It
  // is not always respected by some browsers or password managers.
  autocomplete: "off"
};
var PlainTextInput = /* @__PURE__ */ forwardRef13(function FormPlainTextInput(props, ref) {
  const {
    autoFocus,
    className: className2,
    inputName,
    max,
    min,
    placeholder,
    required,
    step: step2,
    style,
    type,
    maxLength,
    // We use a defaultValue instead of a value so that the input remains
    // uncontrolled by React. This is important because we want the user
    // to be able to provide an initial value in the property panel, and for
    // the value to be editable by the user in the preview.
    defaultValue,
    autofillEnabled,
    onChange,
    onBlur,
    onInvalid,
    onFocus,
    onValid,
    ...rest
  } = props;
  const [hasValue, setHasValue] = useState10(!!defaultValue);
  const [prevDefaultValue, setPrevDefaultValue] = useState10();
  if (defaultValue !== prevDefaultValue) {
    setHasValue(!!defaultValue);
    setPrevDefaultValue(defaultValue);
  }
  const handleChange = useCallback24(
    async (e) => {
      await yieldToMain({ continueAfter: "paint" });
      const newValue = e.target.value;
      onChange?.(e);
      startTransition13(() => setHasValue(!!newValue));
    },
    [onChange]
  );
  const eventHandlers = useCustomValidity(onValid, onInvalid, handleChange, onBlur, onFocus);
  if (type === "hidden") {
    return /* @__PURE__ */ jsx81(motion.input, { type: "hidden", name: inputName, defaultValue });
  }
  const dataProps = autofillEnabled === false ? passwordManagerIgnoreDataProps : void 0;
  return /* @__PURE__ */ jsx81(
    motion.div,
    {
      ref,
      style,
      className: cx(textInputWrapperClassName, inputWrapperClassName, className2),
      ...rest,
      children: type === "textarea" ? /* @__PURE__ */ jsx81(
        motion.textarea,
        {
          ...dataProps,
          ...eventHandlers,
          required,
          autoFocus,
          name: inputName,
          placeholder,
          className: inputClassName,
          defaultValue,
          maxLength
        },
        defaultValue
      ) : /* @__PURE__ */ jsx81(
        motion.input,
        {
          ...dataProps,
          ...eventHandlers,
          type,
          required,
          autoFocus,
          name: inputName,
          placeholder,
          className: cx(inputClassName, !hasValue && emptyValueClassName),
          defaultValue,
          min,
          max,
          step: step2,
          maxLength
        },
        defaultValue
      )
    }
  );
});
var iconSize2 = 16;
var textInputWrapperClassName = "framer-form-text-input";
var defaultTextareaResizerIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14"><path d="m1.5 8 7-7M9 5.5l-3 3" stroke="%23999" stroke-width="1.5" stroke-linecap="round"></path></svg>`;
var defaultDateIconMaskImage = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path fill="rgb(153, 153, 153)" d="M3 5a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2H3Z" opacity=".3"/><path fill="transparent" stroke="rgb(153, 153, 153)" stroke-width="1.5" d="M3.25 5.25a2 2 0 0 1 2-2h5.5a2 2 0 0 1 2 2v5.5a2 2 0 0 1-2 2h-5.5a2 2 0 0 1-2-2ZM3 6.75h9.5"/></svg>';
var defaultTimeIconMaskImage = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path fill="transparent" stroke="rgb(153, 153, 153)" stroke-width="1.5" d="M2.5 8a5.5 5.5 0 1 1 11 0 5.5 5.5 0 1 1-11 0Z"/><path fill="transparent" stroke="rgb(153, 153, 153)" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7.75 8.25v-3m0 3h2"/></svg>';
var styles = /* @__PURE__ */ (() => [
  ...sharedInputCSS,
  ...inputBorderCSS,
  ...inputWrapperCSS,
  css(`.${inputWrapperClassName}`, {
    boxShadow: css.variable("--framer-input-box-shadow" /* BoxShadow */),
    borderTopLeftRadius: css.variable("--framer-input-border-radius-top-left" /* BorderRadiusTopLeft */),
    borderTopRightRadius: css.variable("--framer-input-border-radius-top-right" /* BorderRadiusTopRight */),
    borderBottomRightRadius: css.variable("--framer-input-border-radius-bottom-right" /* BorderRadiusBottomRight */),
    borderBottomLeftRadius: css.variable("--framer-input-border-radius-bottom-left" /* BorderRadiusBottomLeft */),
    cornerShape: css.variable("--framer-input-corner-shape" /* CornerShape */),
    background: css.variable("--framer-input-background" /* Background */),
    transition: css.variable("--framer-input-focused-transition" /* FocusedTransition */),
    transitionProperty: "background, box-shadow"
  }),
  css(`.${textInputWrapperClassName} .${inputClassName}::placeholder`, {
    color: css.variable("--framer-input-placeholder-color" /* PlaceholderColor */)
  }),
  css(
    `.${textInputWrapperClassName} .${inputClassName}[type="date"], .${textInputWrapperClassName} .${inputClassName}[type="time"]`,
    {
      "-webkit-appearance": "none",
      appearance: "none"
    }
  ),
  // iOS only fix for centered date & time inputs: https://github.com/tailwindlabs/tailwindcss-forms/pull/144
  css(`.${textInputWrapperClassName} .${inputClassName}::-webkit-date-and-time-value`, {
    textAlign: "start"
  }),
  css(`.${textInputWrapperClassName} textarea`, {
    display: "flex",
    resize: css.variable("--framer-textarea-resize" /* Resize */),
    overflowY: "auto",
    minHeight: "inherit",
    maxHeight: "inherit",
    whiteSpace: "break-spaces"
  }),
  // This targets the resize handle in WebKit browsers. Unfortunately, it is not
  // possible in CSS to target the resize handle in Firefox, so FF will always
  // show the native resize handle.
  css(`.${textInputWrapperClassName} textarea::-webkit-resizer`, {
    background: `no-repeat ${encodeSVGForCSS(defaultTextareaResizerIcon)}`
  }),
  css(`.${textInputWrapperClassName} textarea::-webkit-scrollbar`, {
    cursor: "pointer",
    background: "transparent"
  }),
  css(`.${textInputWrapperClassName} textarea::-webkit-scrollbar-thumb:window-inactive`, {
    opacity: 0
  }),
  css(`.${textInputWrapperClassName} textarea::-webkit-scrollbar-corner`, {
    background: "none",
    backgroundColor: "transparent",
    outline: "none"
  }),
  css(`.${textInputWrapperClassName} .${inputClassName}::-webkit-datetime-edit`, {
    // Prevent browsers from improvising the date/time placeholder height.
    height: css.variable("--framer-input-font-line-height" /* FontLineHeight */)
  }),
  css(`.${textInputWrapperClassName} .${inputClassName}.${emptyValueClassName}::-webkit-datetime-edit`, {
    color: css.variable("--framer-input-placeholder-color" /* PlaceholderColor */),
    // This tells safari to use the color for the shadow dom elements.
    "-webkit-text-fill-color": css.variable("--framer-input-placeholder-color" /* PlaceholderColor */),
    overflow: "visible"
  }),
  css(
    `.${textInputWrapperClassName} .${inputClassName}[type="date"]::before, .${textInputWrapperClassName} .${inputClassName}[type="time"]::before`,
    {
      ...inputIconCSSDeclaration,
      paddingLeft: `${iconSpacing}px`,
      maskPosition: `${iconSpacing}px center`,
      backgroundPosition: `${iconSpacing}px center`
    }
  ),
  css(`.${textInputWrapperClassName} .${inputClassName}[type="date"]::before`, {
    maskImage: css.variable("--framer-input-icon-mask-image" /* IconMaskImage */, encodeSVGForCSS(defaultDateIconMaskImage)),
    backgroundImage: css.variable("--framer-input-icon-image" /* IconBackgroundImage */)
  }),
  css(`.${textInputWrapperClassName} .${inputClassName}[type="time"]::before`, {
    maskImage: css.variable("--framer-input-icon-mask-image" /* IconMaskImage */, encodeSVGForCSS(defaultTimeIconMaskImage)),
    backgroundImage: css.variable("--framer-input-icon-image" /* IconBackgroundImage */)
  }),
  // Hide the native date picker icon, but still align it with the custom icon, allowing user to click it to show the
  // date/time picker.
  css(`.${textInputWrapperClassName} .${inputClassName}::-webkit-calendar-picker-indicator`, {
    opacity: 0,
    position: "absolute",
    right: 0,
    top: 0,
    bottom: 0,
    padding: css.variable("--framer-input-padding" /* Padding */),
    paddingTop: 0,
    paddingBottom: 0,
    width: `${iconSize2}px`,
    // Makes sure the icon hit target covers the entire height of the input.
    height: "100%"
  }),
  css(`.${textInputWrapperClassName}:focus-within, .${textInputWrapperClassName}.${forcedFocusClassName}`, {
    boxShadow: css.variable("--framer-input-focused-box-shadow" /* FocusedBoxShadow */, "--framer-input-box-shadow" /* BoxShadow */),
    background: css.variable("--framer-input-focused-background" /* FocusedBackground */, "--framer-input-background" /* Background */)
  }),
  css(
    `.${textInputWrapperClassName}:focus-within::after, .${textInputWrapperClassName}.${forcedFocusClassName}::after`,
    {
      borderColor: css.variable("--framer-input-focused-border-color" /* FocusedBorderColor */, "--framer-input-border-color" /* BorderColor */),
      borderStyle: css.variable("--framer-input-focused-border-style" /* FocusedBorderStyle */, "--framer-input-border-style" /* BorderStyle */),
      borderWidth: css.variable("--framer-input-focused-border-width" /* FocusedBorderWidth */, inputBorderAllSides)
    }
  )
])();
var FormPlainTextInput2 = /* @__PURE__ */ withCSS(PlainTextInput, styles, "framer-lib-form-plain-text-input");

// ../../library/src/render/presentation/Forms/FormBooleanInput.tsx
import React83 from "react";
import { jsx as jsx82 } from "react/jsx-runtime";
var className = "framer-form-boolean-input";
var BooleanInput = /* @__PURE__ */ React83.forwardRef(function FormPlainTextInput3(props, ref) {
  const { inputName, type = "checkbox", defaultChecked, onValid, ...rest } = props;
  const isCanvas = useIsOnFramerCanvas();
  const attributes = isCanvas ? { checked: defaultChecked } : { defaultChecked };
  const eventHandlers = useCustomValidity(onValid, props.onInvalid, props.onChange, props.onBlur, props.onFocus);
  return /* @__PURE__ */ jsx82(
    motion.input,
    {
      ...rest,
      ...attributes,
      ...eventHandlers,
      readOnly: isCanvas,
      ref,
      type,
      name: inputName,
      className: cx(className, props.className)
    }
  );
});
var defaultCheckedIcon = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path d="M 4 8 L 6.5 10.5 L 11.5 5.5" fill="transparent" stroke-width="2" stroke="rgb(255, 255, 255)" stroke-linecap="round" stroke-linejoin="round"></path></svg>';
var borderRadius = `var(${"--framer-input-border-radius-top-left" /* BorderRadiusTopLeft */}) var(${"--framer-input-border-radius-top-right" /* BorderRadiusTopRight */}) var(${"--framer-input-border-radius-bottom-right" /* BorderRadiusBottomRight */}) var(${"--framer-input-border-radius-bottom-left" /* BorderRadiusBottomLeft */})`;
var styles2 = /* @__PURE__ */ (() => [
  css(`.${className}`, {
    "-webkit-appearance": "none",
    // background-color: #fff; fixes a bug on iOS where the checkbox shows
    // through the appearance: none;
    alignItems: "center",
    appearance: "none",
    backgroundColor: "#fff",
    background: "--framer-input-background" /* Background */,
    borderRadius,
    cornerShape: css.variable("--framer-input-corner-shape" /* CornerShape */),
    boxShadow: "--framer-input-box-shadow" /* BoxShadow */,
    display: "flex",
    justifyContent: "center",
    margin: 0,
    overflow: "hidden",
    position: "relative",
    transition: "--framer-input-boolean-checked-transition" /* BooleanCheckedTransition */,
    transitionProperty: "box-shadow, background"
  }),
  // The after element styles the border of the checkbox to conform to
  // framer's inset border model.
  css(`.${className}::after`, {
    background: "transparent",
    borderColor: css.variable("--framer-input-border-color" /* BorderColor */, "transparent"),
    borderRadius,
    cornerShape: css.variable("--framer-input-corner-shape" /* CornerShape */),
    borderStyle: "--framer-input-border-style" /* BorderStyle */,
    borderWidth: inputBorderAllSides,
    boxSizing: "border-box",
    content: "",
    display: "block",
    inset: 0,
    position: "absolute",
    transition: "--framer-input-boolean-checked-transition" /* BooleanCheckedTransition */,
    transitionProperty: "border-color, border-width, border-style"
  }),
  // The before element is used to display the check mark icon. It is
  // faded in when the input is checked.
  css(`.${className}::before`, {
    ...inputIconCSSDeclaration,
    backgroundPosition: "center",
    backgroundSize: "contain",
    maskPosition: "center",
    maskSize: "contain",
    height: "100%",
    opacity: 0,
    transition: "--framer-input-boolean-checked-transition" /* BooleanCheckedTransition */,
    transitionProperty: "opacity",
    width: "100%"
  }),
  // The BooleanInput component shows an svg check mark icon whenever an
  // image url isn't provided. That's not an intuitive system for radios
  // however, where we never want to show the default check mark.
  css(`.${className}[type="checkbox"]::before`, {
    backgroundImage: css.variable("--framer-input-icon-image" /* IconBackgroundImage */),
    maskImage: css.variable("--framer-input-icon-mask-image" /* IconMaskImage */, `url('${defaultCheckedIcon}')`)
  }),
  css(`.${className}[type="radio"]::before`, {
    backgroundImage: css.variable("--framer-input-icon-image" /* IconBackgroundImage */),
    maskImage: css.variable("--framer-input-icon-mask-image" /* IconMaskImage */)
  }),
  css(`.${className}:checked, .${className}.${forcedCheckedClassName}`, {
    // When not set, the styles when checked shouldn't clear the default
    // styles.
    backgroundColor: css.variable("--framer-input-boolean-checked-background" /* BooleanCheckedBackground */, "--framer-input-background" /* Background */),
    boxShadow: css.variable("--framer-input-boolean-checked-box-shadow" /* BooleanCheckedBoxShadow */, "--framer-input-box-shadow" /* BoxShadow */)
  }),
  css(`.${className}:checked::before, .${className}.${forcedCheckedClassName}::before`, {
    opacity: 1
  }),
  css(`.${className}:checked::after, .${className}.${forcedCheckedClassName}::after`, {
    // When not set, the styles when checked shouldn't clear the default
    // styles.
    borderColor: css.variable("--framer-input-boolean-checked-border-color" /* BooleanCheckedBorderColor */, "--framer-input-border-color" /* BorderColor */, "transparent"),
    borderStyle: css.variable("--framer-input-boolean-checked-border-style" /* BooleanCheckedBorderStyle */, "--framer-input-border-style" /* BorderStyle */, "solid"),
    borderWidth: css.variable("--framer-input-boolean-checked-border-width" /* BooleanCheckedBorderWidth */, inputBorderAllSides)
  }),
  css(`.${className}:focus, .${className}.${forcedFocusClassName}`, {
    backgroundColor: css.variable("--framer-input-focused-background" /* FocusedBackground */, "--framer-input-background" /* Background */),
    boxShadow: css.variable("--framer-input-focused-box-shadow" /* FocusedBoxShadow */, "--framer-input-box-shadow" /* BoxShadow */)
  }),
  css(`.${className}:focus-visible`, { outline: "none" }),
  css(`.${className}:focus::after, .${className}.${forcedFocusClassName}::after`, {
    // When not set, the styles when focused shouldn't clear the checked
    // styles.
    borderColor: css.variable("--framer-input-focused-border-color" /* FocusedBorderColor */, "--framer-input-border-color" /* BorderColor */, "transparent"),
    borderStyle: css.variable("--framer-input-focused-border-style" /* FocusedBorderStyle */, "--framer-input-border-style" /* BorderStyle */, "solid"),
    borderWidth: css.variable("--framer-input-focused-border-width" /* FocusedBorderWidth */, inputBorderAllSides)
  }),
  css(`.${className}:focus:checked`, {
    backgroundColor: css.variable("--framer-input-focused-background" /* FocusedBackground */, "--framer-input-boolean-checked-background" /* BooleanCheckedBackground */, "--framer-input-background" /* Background */),
    boxShadow: css.variable("--framer-input-focused-box-shadow" /* FocusedBoxShadow */, "--framer-input-boolean-checked-box-shadow" /* BooleanCheckedBoxShadow */, "--framer-input-box-shadow" /* BoxShadow */)
  }),
  css(`.${className}:focus:checked::after`, {
    borderStyle: css.variable("--framer-input-focused-border-style" /* FocusedBorderStyle */, "--framer-input-boolean-checked-border-style" /* BooleanCheckedBorderStyle */, "--framer-input-border-style" /* BorderStyle */, "solid"),
    borderWidth: css.variable("--framer-input-focused-border-width" /* FocusedBorderWidth */, "--framer-input-boolean-checked-border-width" /* BooleanCheckedBorderWidth */, inputBorderAllSides)
  })
])();
var FormBooleanInput = /* @__PURE__ */ withCSS(BooleanInput, styles2, "framer-lib-form-boolean-input");

// ../../library/src/render/presentation/Forms/FormSelect.tsx
import React84 from "react";
import { jsx as jsx83 } from "react/jsx-runtime";
var Select = /* @__PURE__ */ React84.forwardRef(function Select2(props, measureRef) {
  const {
    autoFocus,
    className: className2,
    inputName,
    required,
    hidden,
    defaultValue,
    selectOptions,
    style,
    onValid,
    onChange,
    onBlur,
    onInvalid,
    onFocus,
    ...rest
  } = props;
  const eventHandlers = useCustomValidity(onValid, onInvalid, onChange, onBlur, onFocus);
  const key7 = Array.isArray(defaultValue) ? defaultValue[0] : defaultValue;
  if (hidden) {
    return /* @__PURE__ */ jsx83(motion.input, { type: "hidden", name: inputName, defaultValue });
  }
  return /* @__PURE__ */ jsx83(
    motion.div,
    {
      ref: measureRef,
      style,
      className: cx(inputWrapperClassName, selectWrapperClassName, className2),
      ...rest,
      children: /* @__PURE__ */ jsx83(
        motion.select,
        {
          name: inputName,
          autoFocus,
          required,
          className: inputClassName,
          defaultValue,
          ...eventHandlers,
          children: selectOptions?.map((option, index) => {
            switch (option.type) {
              case "divider":
                return /* @__PURE__ */ jsx83("hr", {}, index);
              case "option":
                return (
                  // biome-ignore lint/suspicious/noArrayIndexKey: Values can be duplicated, so we could only use UUIDs here (but that isn't really better)
                  /* @__PURE__ */ jsx83("option", { value: option.value ?? option.title, disabled: option.disabled, children: option.title ?? option.value }, index)
                );
            }
          })
        },
        key7
      )
    }
  );
});
var selectWrapperClassName = "framer-form-select-wrapper";
var selectArrowSize = 16;
var defaultSelectCaretMaskImage = /* @__PURE__ */ (() => `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="${selectArrowSize}" height="${selectArrowSize}"><path d="M 3.5 6 L 8 10.5 L 12.5 6" fill="transparent" stroke-width="1.5" stroke="rgb(153, 153, 153)" stroke-linecap="round" stroke-linejoin="round"></path></svg>`)();
var styles3 = /* @__PURE__ */ (() => [
  ...sharedInputCSS,
  ...inputBorderCSS,
  ...inputWrapperCSS,
  css(`.${selectWrapperClassName}`, {
    // First we use the complete padding string, which may be any valid
    // padding string (10px, 10px 10px, 10px 10px 10px, or 10px 10px
    // 10px 10px), and use it to set only the right padding. This pushes
    // the actual select away from the arrow by 1x.
    padding: css.variable("--framer-input-padding" /* Padding */),
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    background: css.variable("--framer-input-background" /* Background */),
    borderTopLeftRadius: css.variable("--framer-input-border-radius-top-left" /* BorderRadiusTopLeft */),
    borderTopRightRadius: css.variable("--framer-input-border-radius-top-right" /* BorderRadiusTopRight */),
    borderBottomRightRadius: css.variable("--framer-input-border-radius-bottom-right" /* BorderRadiusBottomRight */),
    borderBottomLeftRadius: css.variable("--framer-input-border-radius-bottom-left" /* BorderRadiusBottomLeft */),
    cornerShape: css.variable("--framer-input-corner-shape" /* CornerShape */),
    boxShadow: css.variable("--framer-input-box-shadow" /* BoxShadow */),
    transition: css.variable("--framer-input-focused-transition" /* FocusedTransition */),
    transitionProperty: "background, box-shadow"
  }),
  css(`.${selectWrapperClassName} select`, {
    appearance: "none",
    "-webkit-appearance": "none",
    // Then we use the complete padding string again as the margin for
    // the select. This moves the select 2x the padding right away from
    // the arrow.
    padding: css.variable("--framer-input-padding" /* Padding */),
    // Overwrite the values inherited from .${inputClassName}. On a
    // select, these values are on the wrapper.
    background: "transparent"
  }),
  css(`.${selectWrapperClassName}::before`, {
    ...inputIconCSSDeclaration,
    paddingLeft: `${iconSpacing}px`,
    backgroundPosition: `${iconSpacing}px center`,
    maskPosition: `${iconSpacing}px center`,
    backgroundImage: css.variable("--framer-input-icon-image" /* IconBackgroundImage */),
    maskImage: css.variable("--framer-input-icon-mask-image" /* IconMaskImage */, `url('${defaultSelectCaretMaskImage}')`)
  }),
  css(`.${selectWrapperClassName} select:required:invalid`, {
    color: css.variable("--framer-input-invalid-text-color" /* InvalidTextColor */)
  }),
  css(`.${selectWrapperClassName}:focus-within, .${selectWrapperClassName}.${forcedFocusClassName}`, {
    background: css.variable("--framer-input-focused-background" /* FocusedBackground */, "--framer-input-background" /* Background */),
    boxShadow: css.variable("--framer-input-focused-box-shadow" /* FocusedBoxShadow */, "--framer-input-box-shadow" /* BoxShadow */)
  }),
  css(`.${selectWrapperClassName}:focus-within::after, .${selectWrapperClassName}.${forcedFocusClassName}::after`, {
    borderColor: css.variable("--framer-input-focused-border-color" /* FocusedBorderColor */, "--framer-input-border-color" /* BorderColor */),
    borderStyle: css.variable("--framer-input-focused-border-style" /* FocusedBorderStyle */, "--framer-input-border-style" /* BorderStyle */),
    borderWidth: css.variable("--framer-input-focused-border-width" /* FocusedBorderWidth */, inputBorderAllSides)
  }),
  // Enforcing a color on the native select options. On windows, browsers select options
  // inherit some style properties like color but not others so they might end up in a weird
  // state in which we can't read the options until we hover.
  // These are ignored on mac
  css(`.${selectWrapperClassName} select option`, {
    color: "#000"
  }),
  css(`.${selectWrapperClassName} select option:disabled`, {
    color: "rgba(0, 0, 0, 0.4)"
  })
])();
var FormSelect = /* @__PURE__ */ withCSS(Select, styles3, "framer-lib-form-select");

// ../../library/src/render/presentation/Image.tsx
import React85, { useMemo as useMemo25, useState as useState12 } from "react";

// ../../library/src/render/presentation/withLightbox.tsx
import {
  Fragment as Fragment13,
  forwardRef as forwardRef14,
  startTransition as startTransition14,
  useCallback as useCallback25,
  useContext as useContext31,
  useEffect as useEffect29,
  useId as useId2,
  useMemo as useMemo24,
  useRef as useRef27,
  useState as useState11
} from "react";
import { createPortal } from "react-dom";

// ../../library/src/render/presentation/useEscToClose.ts
import { useEffect as useEffect28 } from "react";
function useEscToClose(isOpen, close) {
  useEffect28(() => {
    function handleKeyDown(e) {
      if (e.key === "Escape" && isOpen) {
        e.preventDefault();
        e.stopPropagation();
        close();
      }
    }
    window.addEventListener("keyup", handleKeyDown);
    return () => window.removeEventListener("keyup", handleKeyDown);
  }, [isOpen, close]);
}

// ../../library/src/render/presentation/withLightbox.tsx
import { Fragment as Fragment14, jsx as jsx84, jsxs as jsxs17 } from "react/jsx-runtime";
function calculateImageWidth(aspectRatio, maxWidth, totalHorizontalPadding, totalVerticalPadding) {
  const availableHeight = window.innerHeight - totalVerticalPadding;
  const availableWidth = Math.min(window.innerWidth - totalHorizontalPadding, maxWidth);
  const maxWidthBasedOnHeight = availableHeight / aspectRatio;
  return Math.min(availableWidth, maxWidthBasedOnHeight);
}
function optimisticallyDecodeImage(image, { width, height }) {
  if (!image.src || !image.srcSet) return;
  const i = new window.Image();
  i.src = image.src;
  i.srcset = image.srcSet;
  i.sizes = image.sizes || "";
  i.width = width;
  i.height = height;
  return i.decode();
}
function getPortalContainer2() {
  return document.getElementById(templateOverlayContainerId) ?? document.getElementById(overlayContainerId) ?? document.body;
}
function getSidePadding(value, padding) {
  if (isNumber(value)) return value;
  return padding ?? 0;
}
function getTotalVerticalPadding(lightbox) {
  return getSidePadding(lightbox?.paddingTop, lightbox?.padding) + getSidePadding(lightbox?.paddingBottom, lightbox?.padding);
}
function getTotalHorizontalPadding(lightbox) {
  return getSidePadding(lightbox?.paddingLeft, lightbox?.padding) + getSidePadding(lightbox?.paddingRight, lightbox?.padding);
}
function useStableCallback(callback) {
  const latest = useRef27(callback);
  latest.current = callback;
  return useCallback25((...args) => latest.current(...args), []);
}
function createImageWithSrcSet(lightbox, background) {
  if (!lightbox || !background || !background.src) return background;
  const base = new URL(background.src);
  base.searchParams.delete("scale-down-to");
  base.searchParams.delete("lossless");
  return {
    ...background,
    sizes: `min(100vw, ${lightbox.maxWidth - getTotalHorizontalPadding(lightbox)}px)`,
    srcSet: getSrcSet(background.nodeFixedSize, background, background.src).srcSet
  };
}
var distortionTransforms = /* @__PURE__ */ (() => ({
  x: void 0,
  y: void 0,
  z: 0,
  translateX: void 0,
  translateY: void 0,
  translateZ: 0,
  rotate: void 0,
  rotateX: 0,
  rotateY: 0,
  rotateZ: void 0,
  scale: 1,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  skew: 0,
  skewX: 0,
  skewY: 0,
  originX: void 0,
  originY: void 0,
  originZ: void 0,
  perspective: 0,
  transformPerspective: 0
}))();
function isDistortionTransform(values) {
  if (!values) return false;
  for (const k in values) {
    if (!(k in distortionTransforms)) continue;
    const identityValue = distortionTransforms[k];
    const value = values[k];
    if (!isNumber(identityValue) || !isNumber(value)) continue;
    if (identityValue === value) continue;
    return true;
  }
  return false;
}
function isDistorted(ref) {
  const element = visualElementStore.get(ref.current);
  if (!element) return false;
  if (isDistortionTransform(element.projection?.latestValues)) return true;
  const path = element.projection?.path;
  if (!path || path.length === 0) return false;
  for (const p of path) {
    if (isDistortionTransform(p.latestValues)) return true;
  }
  return false;
}
var enterExitBackdropAnimation = { opacity: 0 };
var targetBackdropAnimation = { opacity: 1 };
function withLightboxEffect(Component18) {
  return forwardRef14(function LightboxEffect({
    lightbox,
    lightboxClassName,
    onClick,
    ...props
  }, forwardedRef) {
    const config = useContext31(MotionConfigContext);
    const ancestorTickerContext = useContext31(TickerContext2);
    const isInTickerItem = Boolean(ancestorTickerContext);
    const fallbackRef = useRef27(null);
    const ref = forwardedRef ?? fallbackRef;
    const decodePromiseRef = useRef27();
    const image = useMemo24(() => createImageWithSrcSet(lightbox, props.background), [lightbox, props.background]);
    const [open, setOpen] = useState11(false);
    const [openOverrides, setOpenOverrides] = useState11();
    const onOpen = useCallback25(() => {
      if (!lightbox) return;
      if (open) {
        startTransition14(() => {
          setOpen(true);
        });
        return;
      }
      frame.read(() => {
        if (!ref.current) return;
        const style2 = getComputedStyle(ref.current);
        const hasBorder = ref.current.getAttribute("data-border") === "true";
        const borderStyle2 = hasBorder ? getComputedStyle(ref.current, "::after") : void 0;
        const width = ref.current.offsetWidth ?? 1;
        const height = ref.current.offsetHeight ?? 1;
        const transition2 = isDistorted(ref) || isInTickerItem ? { duration: 0 } : lightbox.transition;
        startTransition14(() => {
          setOpenOverrides({
            borderRadius: style2.borderRadius,
            aspectRatio: width / (height || 1),
            borderTop: borderStyle2?.borderTopWidth,
            borderRight: borderStyle2?.borderRightWidth,
            borderBottom: borderStyle2?.borderBottomWidth,
            borderLeft: borderStyle2?.borderLeftWidth,
            borderStyle: borderStyle2?.borderStyle,
            borderColor: borderStyle2?.borderColor,
            transition: transition2,
            imageRendering: style2.imageRendering,
            filter: style2.filter
          });
          setOpen(true);
          ancestorTickerContext?.stop();
        });
      });
    }, [lightbox, open, ref, ancestorTickerContext?.stop, isInTickerItem]);
    const aspectRatio = openOverrides?.aspectRatio ?? 1;
    const decode = useStableCallback(() => {
      if (!lightbox || !image || !image.src) return;
      const srcDecodePromise = decodePromiseRef.current?.[image.src];
      if (srcDecodePromise) return srcDecodePromise;
      const width = calculateImageWidth(
        aspectRatio,
        lightbox.maxWidth,
        getTotalHorizontalPadding(lightbox),
        getTotalVerticalPadding(lightbox)
      );
      const promise = optimisticallyDecodeImage(image, { width, height: width * aspectRatio });
      decodePromiseRef.current = { [image.src]: promise };
      return promise;
    });
    const handleClick = useCallback25(
      async (e) => {
        onClick?.(e);
        if (open || !lightbox || !image) return;
        await decode();
        onOpen();
      },
      [onClick, onOpen, open, image, lightbox, decode]
    );
    const onClose = useCallback25((e) => {
      e?.stopPropagation();
      startTransition14(() => {
        setOpen(false);
      });
    }, []);
    useEscToClose(open, onClose);
    useEffect29(() => {
      if (!lightbox) return;
      let timer;
      function enter() {
        timer = setTimeout(() => {
          void decode();
        }, 50);
      }
      function clear() {
        clearTimeout(timer);
      }
      const currentRef = ref.current;
      currentRef?.addEventListener("mouseenter", enter);
      currentRef?.addEventListener("mouseleave", clear);
      currentRef?.addEventListener("pointerdown", decode);
      return () => {
        clear();
        currentRef?.removeEventListener("mouseenter", enter);
        currentRef?.removeEventListener("mouseleave", clear);
        currentRef?.removeEventListener("pointerdown", decode);
      };
    }, [decode, ref, lightbox]);
    const fallbackLayoutId = useId2();
    const transition = openOverrides?.transition ?? props.transition ?? config.transition;
    const borderRadius2 = openOverrides?.borderRadius;
    const imageRendering = openOverrides?.imageRendering;
    const filter = openOverrides?.filter;
    const borderTop = openOverrides?.borderTop;
    const borderRight = openOverrides?.borderRight;
    const borderBottom = openOverrides?.borderBottom;
    const borderLeft = openOverrides?.borderLeft;
    const borderStyle = openOverrides?.borderStyle;
    const borderColor = openOverrides?.borderColor;
    const hasAnyBorder = Boolean(
      borderTop || borderRight || borderBottom || borderLeft || borderStyle || borderColor
    );
    const border = hasAnyBorder ? {
      "--border-top-width": borderTop,
      "--border-right-width": borderRight,
      "--border-bottom-width": borderBottom,
      "--border-left-width": borderLeft,
      "--border-style": borderStyle,
      "--border-color": borderColor
    } : void 0;
    const portalProps = { [portalIdAttribute]: props.id };
    const paddingTop = getSidePadding(lightbox?.paddingTop, lightbox?.padding);
    const paddingBottom = getSidePadding(lightbox?.paddingBottom, lightbox?.padding);
    const paddingLeft = getSidePadding(lightbox?.paddingLeft, lightbox?.padding);
    const paddingRight = getSidePadding(lightbox?.paddingRight, lightbox?.padding);
    const style = openOverrides?.borderRadius ? { ...props.style, borderRadius: openOverrides.borderRadius } : props.style;
    const layoutDependency = open ? props.layoutDependency ? `${props.layoutDependency}-open` : "open" : props.layoutDependency;
    const layoutId = isInTickerItem ? void 0 : props.layoutId ?? (lightbox ? fallbackLayoutId : void 0);
    return /* @__PURE__ */ jsxs17(Fragment14, { children: [
      /* @__PURE__ */ jsx84(
        Component18,
        {
          ...props,
          style,
          onClick: handleClick,
          layoutId,
          ref,
          layoutDependency,
          transition
        }
      ),
      /* @__PURE__ */ jsx84(
        AnimatePresence,
        {
          onExitComplete: () => {
            startTransition14(() => {
              setOpenOverrides(void 0);
              ancestorTickerContext?.start();
            });
          },
          children: open && lightbox && image && /* @__PURE__ */ jsx84(Fragment13, { children: createPortal(
            /* @__PURE__ */ jsxs17(Fragment14, { children: [
              /* @__PURE__ */ jsx84(
                motion.div,
                {
                  ...portalProps,
                  className: lightboxClassName,
                  onClick: onClose,
                  style: {
                    position: "fixed",
                    inset: 0,
                    zIndex: lightbox.zIndex,
                    backgroundColor: lightbox.backdrop ?? "transparent"
                  },
                  transition,
                  initial: enterExitBackdropAnimation,
                  animate: targetBackdropAnimation,
                  exit: enterExitBackdropAnimation
                }
              ),
              /* @__PURE__ */ jsx84(
                motion.div,
                {
                  ...portalProps,
                  className: lightboxClassName,
                  style: {
                    alignItems: "center",
                    display: "flex",
                    inset: `${paddingTop}px ${paddingRight}px ${paddingBottom}px ${paddingLeft}px`,
                    justifyContent: "center",
                    pointerEvents: "none",
                    position: "fixed",
                    zIndex: lightbox.zIndex
                  },
                  children: /* @__PURE__ */ jsx84(
                    "div",
                    {
                      style: {
                        alignItems: "center",
                        aspectRatio,
                        display: "flex",
                        justifyContent: "center",
                        maxHeight: "100%",
                        position: "relative",
                        width: "100%",
                        maxWidth: lightbox.maxWidth
                      },
                      children: /* @__PURE__ */ jsx84(
                        motion.div,
                        {
                          layoutId,
                          transition,
                          onClick: onOpen,
                          className: "framer-lightbox-container",
                          "data-border": hasAnyBorder,
                          style: {
                            aspectRatio,
                            borderRadius: borderRadius2,
                            bottom: 0,
                            position: "absolute",
                            top: 0,
                            userSelect: "none",
                            imageRendering,
                            filter,
                            ...border
                          },
                          children: /* @__PURE__ */ jsx84(
                            BackgroundImageComponent,
                            {
                              image,
                              alt: image.alt,
                              draggable: props.draggable
                            }
                          )
                        }
                      )
                    }
                  )
                }
              )
            ] }),
            getPortalContainer2()
          ) }, "backdrop")
        }
      )
    ] });
  });
}

// ../../library/src/render/presentation/Image.tsx
import { jsx as jsx85, jsxs as jsxs18 } from "react/jsx-runtime";
var Component16 = /* @__PURE__ */ React85.forwardRef(function Image2(props, ref) {
  const { background, children, alt, draggable, fitImageDimension, style: styleFromProps, ...rest } = props;
  const style = { ...styleFromProps };
  const intrinsicSize = useMemo25(() => getIntrinsicSizeForBackgroundImage(background), [background]);
  const [fallbackIntrinsicSize, setFallbackIntrinsicSize] = useState12();
  React85.useLayoutEffect(() => {
    if (!background?.src) return;
    if (!fitImageDimension) return;
    if (intrinsicSize) return;
    const img = document.createElement("img");
    img.onload = () => {
      if (img.naturalWidth && img.naturalHeight) {
        setFallbackIntrinsicSize({ width: img.naturalWidth, height: img.naturalHeight });
      }
    };
    img.src = background.src;
  }, [background?.src, fitImageDimension, intrinsicSize]);
  const size = intrinsicSize ?? fallbackIntrinsicSize;
  if (fitImageDimension && size) {
    style[fitImageDimension] = "auto";
    style.aspectRatio = size.width / size.height;
  }
  if (background) {
    delete style.background;
  }
  const MotionComponent = htmlElementAsMotionComponent(props.as);
  return /* @__PURE__ */ jsxs18(MotionComponent, { ...rest, style, ref, draggable, children: [
    background && /* @__PURE__ */ jsx85(BackgroundImageComponent, { image: background, alt, draggable }),
    children
  ] });
});
var Image3 = /* @__PURE__ */ withLightboxEffect(Component16);

// ../../library/src/render/presentation/withColumnMasonryLayout.tsx
import React86, { forwardRef as forwardRef15 } from "react";
import { jsx as jsx86 } from "react/jsx-runtime";
var ColumnMasonryLayout = /* @__PURE__ */ React86.memo(function ColumnMasonryLayout2({
  trackCount,
  rowGap,
  parentIsDataRepeater = false,
  itemsOrder,
  children
}) {
  let normalizedChildren = prepareChildrenArrayForMasonry(children, parentIsDataRepeater);
  if (itemsOrder?.length) {
    normalizedChildren = reorderChildrenForItemsOrder(normalizedChildren, itemsOrder);
  }
  const tracks = groupChildrenIntoTracks(trackCount, normalizedChildren);
  const wrapperStyle2 = getMasonryColumnStyle(rowGap);
  return tracks.map((trackChildren, i) => /* @__PURE__ */ jsx86("div", { style: wrapperStyle2, children: trackChildren }, getMasonryColumnKey(i)));
});
function getChildOrderId(child) {
  return React86.isValidElement(child) ? child.props["data-framer-order-id"] : void 0;
}
function reorderChildrenForItemsOrder(children, itemsOrder) {
  const childrenById = /* @__PURE__ */ new Map();
  const remaining = [];
  const orderSet = new Set(itemsOrder);
  for (const child of children) {
    const id = getChildOrderId(child);
    if (id && orderSet.has(id)) {
      childrenById.set(id, child);
    } else {
      remaining.push(child);
    }
  }
  const ordered = [];
  for (const id of itemsOrder) {
    const child = childrenById.get(id);
    if (child) ordered.push(child);
  }
  return [...ordered, ...remaining];
}
function prepareChildrenArrayForMasonry(children, parentIsDataRepeater) {
  const array = React86.Children.toArray(children);
  if (!parentIsDataRepeater) return array;
  return array.flatMap(
    (child) => React86.isValidElement(child) && child.type === React86.Fragment ? React86.Children.toArray(child.props.children) : child
  );
}
function groupChildrenIntoTracks(trackCount, children) {
  const tracks = Array.from({ length: trackCount }, () => []);
  children.forEach((child, idx) => {
    const track = pickMasonryTrack(trackCount, idx);
    tracks[track]?.push(child);
  });
  return tracks;
}
function getMasonryColumnStyle(rowGap) {
  return {
    display: "flex",
    flexDirection: "column",
    rowGap,
    width: "100%"
  };
}
function getMasonryColumnKey(i) {
  return `masonry-stack-${i}`;
}
function pickMasonryTrack(trackCount, childIndex) {
  if (trackCount <= 0) return 0;
  return childIndex % trackCount;
}
var withColumnMasonryLayout = (Component18) => {
  return forwardRef15(function MasonryLayout({
    columnMasonryLayoutEnabled,
    trackCount = 1,
    rowGap,
    parentIsDataRepeater,
    itemsOrder,
    children,
    style: existingStyle,
    ...rest
  }, ref) {
    if (!columnMasonryLayoutEnabled) {
      return /* @__PURE__ */ jsx86(Component18, { ref, style: existingStyle, ...rest, children });
    }
    const mergedStyle = {
      ...existingStyle,
      gridTemplateColumns: `repeat(${trackCount}, 1fr)`
    };
    return /* @__PURE__ */ jsx86(Component18, { ref, style: mergedStyle, ...rest, children: /* @__PURE__ */ jsx86(
      ColumnMasonryLayout,
      {
        trackCount,
        rowGap,
        parentIsDataRepeater,
        itemsOrder,
        children
      }
    ) });
  });
};

// ../../library/src/render/presentation/RelativeDate.tsx
import { memo as memo3, startTransition as startTransition15, useEffect as useEffect30, useState as useState13 } from "react";

// ../../library/src/render/presentation/formatRelativeDate.ts
var formatters = /* @__PURE__ */ new Map();
function getRelativeTimeFormat(style, numeric, locale) {
  const options = { numeric, style };
  const args = [locale, options];
  const key7 = JSON.stringify(args);
  const existing = formatters.get(key7);
  if (existing) return existing;
  const formatter = new Intl.RelativeTimeFormat(...args);
  formatters.set(key7, formatter);
  return formatter;
}
function formatRelativeDate(targetDate, referenceDate, format, style, numeric, capitalize, locale) {
  const unit = getRelativeDateUnit(targetDate, referenceDate, format);
  const value = getRelativeDateValue(targetDate, referenceDate, unit);
  const formatted = getRelativeTimeFormat(style, numeric, locale).format(value, unit);
  if (capitalize) return capitalizeFirstLetter(formatted);
  return formatted;
}
function capitalizeFirstLetter(text) {
  return text.charAt(0).toUpperCase() + text.slice(1);
}
function getRelativeDateUnit(targetDate, referenceDate, format) {
  if (format !== "auto") return format;
  const daysDiff = differenceInCalendarDays(targetDate, referenceDate);
  if (Math.abs(daysDiff) <= 7) return "day";
  const weeksDiff = differenceInCalendarWeeks(targetDate, referenceDate);
  if (Math.abs(weeksDiff) <= 4) return "week";
  const monthsDiff = differenceInCalendarMonths(targetDate, referenceDate);
  if (Math.abs(monthsDiff) <= 12) return "month";
  return "year";
}
var SECOND = 1e3;
var MINUTE = 6e4;
var HOUR = 36e5;
var DAY = 864e5;
var WEEK = 6048e5;
function getRelativeDateValue(targetDate, referenceDate, unit) {
  const delta = targetDate.getTime() - referenceDate.getTime();
  switch (unit) {
    case "second":
      return Math.trunc(delta / SECOND);
    case "minute":
      return Math.trunc(delta / MINUTE);
    case "hour":
      return Math.trunc(delta / HOUR);
    case "day":
      return differenceInCalendarDays(targetDate, referenceDate);
    case "week":
      return differenceInCalendarWeeks(targetDate, referenceDate);
    case "month":
      return differenceInCalendarMonths(targetDate, referenceDate);
    case "quarter":
      return differenceInCalendarQuarters(targetDate, referenceDate);
    case "year":
      return differenceInCalendarYears(targetDate, referenceDate);
  }
  const _ = unit;
}
function getUTCStartOfDay(date) {
  const result = new Date(date);
  result.setUTCHours(0, 0, 0, 0);
  return result;
}
function differenceInCalendarDays(targetDate, referenceDate) {
  const targetTimestamp = getUTCStartOfDay(targetDate).getTime();
  const referenceTimestamp = getUTCStartOfDay(referenceDate).getTime();
  return Math.round((targetTimestamp - referenceTimestamp) / DAY);
}
function getUTCStartOfWeek(date) {
  const result = new Date(date);
  const day = result.getUTCDay();
  const diff = (day < 1 ? 7 : 0) + day - 1;
  result.setUTCDate(result.getUTCDate() - diff);
  result.setUTCHours(0, 0, 0, 0);
  return result;
}
function differenceInCalendarWeeks(targetDate, referenceDate) {
  const targetTimestamp = getUTCStartOfWeek(targetDate).getTime();
  const referenceTimestamp = getUTCStartOfWeek(referenceDate).getTime();
  return Math.round((targetTimestamp - referenceTimestamp) / WEEK);
}
function differenceInCalendarMonths(targetDate, referenceDate) {
  const yearsDiff = targetDate.getUTCFullYear() - referenceDate.getUTCFullYear();
  const monthsDiff = targetDate.getUTCMonth() - referenceDate.getUTCMonth();
  return yearsDiff * 12 + monthsDiff;
}
function getUTCQuarter(date) {
  const month = date.getUTCMonth();
  return Math.trunc(month / 3);
}
function differenceInCalendarQuarters(targetDate, referenceDate) {
  const yearsDiff = targetDate.getUTCFullYear() - referenceDate.getUTCFullYear();
  const quartersDiff = getUTCQuarter(targetDate) - getUTCQuarter(referenceDate);
  return yearsDiff * 4 + quartersDiff;
}
function differenceInCalendarYears(targetDate, referenceDate) {
  return targetDate.getUTCFullYear() - referenceDate.getUTCFullYear();
}

// ../../library/src/render/presentation/RelativeDate.tsx
import { jsx as jsx87, jsxs as jsxs19 } from "react/jsx-runtime";
var RelativeDate = /* @__PURE__ */ memo3(function RelativeDate2({
  date: dateString,
  dateFormat = "auto",
  dateStyle = "long",
  dateNumeric = "auto",
  dateCapitalize = false,
  locale: externalLocale,
  ...props
}) {
  const fallbackLocale = useLocaleCode();
  const locale = externalLocale || fallbackLocale;
  const targetDate = new Date(dateString);
  const [currentDate, setCurrentDate] = useState13(getCurrentDate);
  const interval = dateFormat === "second" ? 1e3 : 6e4;
  useEffect30(() => {
    const timeout = setInterval(() => {
      startTransition15(() => {
        setCurrentDate(getCurrentDate);
      });
    }, interval);
    return () => {
      clearInterval(timeout);
    };
  }, [interval]);
  const formattedDate = targetDate.toLocaleString(locale, {
    timeZone: "UTC",
    dateStyle: "long",
    timeStyle: dateFormat === "second" ? "medium" : dateFormat === "minute" || dateFormat === "hour" ? "short" : void 0
  });
  const formattedRelativeDate = formatRelativeDate(
    targetDate,
    currentDate,
    dateFormat,
    dateStyle,
    dateNumeric,
    dateCapitalize,
    locale
  );
  const formattedIsoDate = targetDate.toISOString();
  return /* @__PURE__ */ jsxs19("time", { suppressHydrationWarning: true, dateTime: formattedIsoDate, title: formattedDate, ...props, children: [
    isWindow ? formattedRelativeDate : formattedDate,
    isWindow ? null : /* @__PURE__ */ jsx87(
      "script",
      {
        "data-relative-date-script": "inline",
        dangerouslySetInnerHTML: {
          __html: createHydrationScript(
            targetDate,
            dateFormat,
            dateStyle,
            dateNumeric,
            dateCapitalize,
            locale
          )
        }
      }
    )
  ] });
});
function getCurrentDate() {
  const date = /* @__PURE__ */ new Date();
  return new Date(
    Date.UTC(
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
      date.getHours(),
      date.getMinutes(),
      date.getSeconds(),
      date.getMilliseconds()
    )
  );
}
function createHydrationScript(date, format, style, numeric, capitalize, locale) {
  const serializedDate = date.getTime();
  const serializedFormat = JSON.stringify(format);
  const serializedStyle = JSON.stringify(style);
  const serializedNumeric = JSON.stringify(numeric);
  const serializedCapitalize = JSON.stringify(capitalize);
  const serializedLocale = JSON.stringify(locale);
  return (
    /* js */
    `document.currentScript.parentElement.textContent = window.__framer_formatRelativeDate(new Date(${serializedDate}), new Date(), ${serializedFormat}, ${serializedStyle}, ${serializedNumeric}, ${serializedCapitalize}, ${serializedLocale})`
  );
}

// ../../library/src/render/presentation/RichText.tsx
import {
  Children as Children5,
  Fragment as Fragment16,
  cloneElement as cloneElement3,
  forwardRef as forwardRef17,
  isValidElement as isValidElement7,
  useContext as useContext33,
  useInsertionEffect as useInsertionEffect7,
  useMemo as useMemo28,
  useRef as useRef30
} from "react";

// ../../library/src/render/presentation/DeprecatedRichText.tsx
import * as React87 from "react";
import { useRef as useRef28 } from "react";

// ../../library/src/render/utils/dom.ts
var frameFromElement = (element) => {
  const frame2 = Rect.fromRect(element.getBoundingClientRect());
  frame2.x = frame2.x + safeWindow.scrollX;
  frame2.y = frame2.y + safeWindow.scrollY;
  return frame2;
};
var frameFromElements = (elements) => {
  return Rect.merge(...elements.map(frameFromElement));
};
var convertToPageFrame = (frame2, element) => {
  const point = convertToPagePoint(frame2, element);
  return {
    x: point.x,
    y: point.y,
    width: frame2.width,
    height: frame2.height
  };
};
var convertFromPageFrame = (frame2, element) => {
  const point = convertFromPagePoint(frame2, element);
  return {
    x: point.x,
    y: point.y,
    width: frame2.width,
    height: frame2.height
  };
};
var getPageFrame = (element) => {
  const rect = element.getBoundingClientRect();
  return {
    x: rect.left + safeWindow.scrollX,
    y: rect.top + safeWindow.scrollY,
    width: rect.width,
    height: rect.height
  };
};
var fromEventForPage = (event) => {
  return {
    x: event.pageX,
    y: event.pageY
  };
};
var fromEventForClient = (event) => {
  return {
    x: event.clientX,
    y: event.clientY
  };
};
var convertToPagePoint = (point, element) => {
  const frame2 = getPageFrame(element);
  return {
    x: point.x + frame2.x,
    y: point.y + frame2.y
  };
};
var convertFromPagePoint = (point, element) => {
  const frame2 = getPageFrame(element);
  return {
    x: point.x - frame2.x,
    y: point.y - frame2.y
  };
};
var dispatchKeyDownEvent = (keyCode, options = {}) => {
  const keyboardEvent = new KeyboardEvent("keydown", {
    bubbles: true,
    keyCode,
    ...options
  });
  const activeElement = document.activeElement;
  if (activeElement) {
    activeElement.dispatchEvent(keyboardEvent);
  }
};
var DOM = {
  frameFromElement,
  frameFromElements,
  convertToPageFrame,
  convertFromPageFrame,
  getPageFrame,
  fromEventForPage,
  fromEventForClient,
  convertToPagePoint,
  convertFromPagePoint
};
var parser;
var supportsNativeParseHTML = /* @__PURE__ */ (() => (
  // Firefox has rare-random issues with the native parser: https://framer-team.slack.com/archives/C01B14R6E22/p1724159313153969
  !isFirefox() && typeof Document !== "undefined" && typeof Document.parseHTMLUnsafe === "function"
))();
function domParser(html, type) {
  if (supportsNativeParseHTML && !type) return Document.parseHTMLUnsafe(html);
  parser ??= new DOMParser();
  return parser.parseFromString(html, type ?? "text/html");
}
function escapeHTML(value) {
  return value.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#39;");
}

// ../../library/src/modules/replaceFramerPageLinks.ts
var regex = /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi;
function replaceFramerPageLinks(rawHTML, getRoute, currentRoute, implicitPathVariables) {
  return rawHTML.replace(
    regex,
    (original, pre1, tag, pre2, value1, value2, post) => {
      if (tag.toLowerCase() !== "a") return original;
      const href = value1 || value2;
      const pageLink = parseFramerPageLink(href.replace(/&amp;/gu, "&"));
      if (!pageLink || !pageLink.target) return original;
      const targetRoute = getRoute(pageLink.target);
      if (!isRoute(targetRoute) || !isRoute(currentRoute)) return original;
      const targetPath = targetRoute.path;
      const currentPath = currentRoute.path;
      if (!targetPath || !currentPath) return original;
      let attributes = ` ${"data-framer-page-link-target" /* Page */}="${pageLink.target}"`;
      const elementId = getRouteElementId(targetRoute, pageLink.element ?? void 0);
      if (elementId) {
        attributes += ` ${"data-framer-page-link-element" /* Element */}="${pageLink.element}"`;
      }
      const link = linkFromFramerPageLink(href);
      if (!link || isString(link)) return original;
      if (linkMatchesRoute(currentRoute, link, implicitPathVariables)) {
        attributes += ` ${"data-framer-page-link-current" /* Current */}`;
      }
      let relativePath = targetPath;
      const pathVariables = Object.assign({}, implicitPathVariables, pageLink.collectionItem?.pathVariables);
      if (Object.keys(pathVariables).length > 0) {
        relativePath = relativePath.replace(pathVariablesRegExp2, (_, key7) => "" + pathVariables[key7]);
      }
      if (pageLink.collectionItem?.pathVariables) {
        const params = new URLSearchParams(pageLink.collectionItem.pathVariables);
        attributes += ` ${"data-framer-page-link-path-variables" /* PathVariables */}="${params}"`;
      }
      relativePath = computeRelativePath(currentPath, relativePath);
      return pre1 + pre2 + `"${escapeHTML(relativePath + (elementId ? `#${elementId}` : ""))}"` + attributes + post;
    }
  );
}

// ../../library/src/render/utils/isShallowEqualArray.ts
function isShallowEqualArray(a, b) {
  return a.length === b.length && a.every((v, i) => v === b[i]);
}

// ../../library/src/render/presentation/DeprecatedRichText.tsx
import { jsx as jsx88 } from "react/jsx-runtime";
var deprecatedRichTextPlaceholder = "{{ text-placeholder }}";
var richTextWrapperClassName = "rich-text-wrapper";
var DeprecatedRichText = /* @__PURE__ */ React87.forwardRef(
  function Text(props, forwardedRef) {
    const {
      id,
      name,
      html,
      htmlFromDesign,
      text,
      textFromDesign,
      fonts = [],
      width,
      height,
      left,
      right,
      top,
      bottom,
      center,
      className: className2,
      stylesPresetsClassName,
      visible = true,
      opacity,
      rotation = 0,
      verticalAlignment = "top",
      isEditable = false,
      environment: environment2 = RenderTarget.current,
      withExternalLayout = false,
      positionSticky,
      positionStickyTop,
      positionStickyRight,
      positionStickyBottom,
      positionStickyLeft,
      __htmlStructure,
      __fromCanvasComponent = false,
      _forwardedOverrideId,
      _forwardedOverrides,
      _usesDOMRect,
      children: _children,
      ...rest
    } = props;
    const parentSize = useParentSize();
    const layoutId = useLayoutId(props);
    const fallbackLayoutRef = useRef28(null);
    const layoutRef = forwardedRef ?? fallbackLayoutRef;
    const { navigate, getRoute } = useRouter();
    const currentRoute = useCurrentRoute();
    useRoutePreloader(props.preload ?? []);
    useMeasureLayout(props, layoutRef);
    const inCodeComponent = React87.useContext(ComponentContainerContext);
    const isOnCanvas = useIsOnFramerCanvas();
    let textOrOverride = text;
    const forwardedOverrideId = _forwardedOverrideId ?? id;
    if (forwardedOverrideId && _forwardedOverrides) {
      const override = _forwardedOverrides[forwardedOverrideId];
      if (typeof override === "string") {
        textOrOverride = override;
      }
    }
    let innerHTML = "";
    if (textOrOverride) {
      const escapedText = escapeHTML(textOrOverride);
      innerHTML = __htmlStructure ? __htmlStructure.replace(deprecatedRichTextPlaceholder, escapedText) : `<p>${escapedText}</p>`;
    } else if (html) {
      innerHTML = html;
    } else if (textFromDesign) {
      const escapedText = escapeHTML(textFromDesign);
      innerHTML = __htmlStructure ? __htmlStructure.replace(deprecatedRichTextPlaceholder, escapedText) : `<p>${escapedText}</p>`;
    } else if (htmlFromDesign) {
      innerHTML = htmlFromDesign;
    }
    const implicitPathVariables = useImplicitPathVariables();
    const innerHTMLWithReplacedFramerPageLinks = React87.useMemo(() => {
      if (isOnCanvas || !getRoute || !currentRoute) return innerHTML;
      return replaceFramerPageLinks(innerHTML, getRoute, currentRoute, implicitPathVariables);
    }, [innerHTML, getRoute, currentRoute, implicitPathVariables]);
    React87.useEffect(() => {
      const container = layoutRef.current;
      if (container === null) return;
      function interceptPageLinks(event) {
        const anchorElement = findAnchorElement(event.target, layoutRef.current);
        if (event.metaKey || !navigate || !anchorElement || anchorElement.getAttribute("target") === "_blank" /* _blank */) {
          return;
        }
        const didNavigate = navigateFromAttributes(navigate, anchorElement, implicitPathVariables);
        if (didNavigate) {
          event.preventDefault();
        }
      }
      container.addEventListener("click", interceptPageLinks);
      return () => {
        container.removeEventListener("click", interceptPageLinks);
      };
    }, [navigate, implicitPathVariables]);
    useLoadFonts(fonts, __fromCanvasComponent, layoutRef);
    React87.useInsertionEffect(() => {
      injectComponentCSSRules();
    }, []);
    if (!visible) return null;
    const isHidden = isEditable && environment2() === RenderTarget.canvas;
    const style = {
      outline: "none",
      display: "flex",
      flexDirection: "column",
      justifyContent: convertVerticalAlignment(verticalAlignment),
      opacity: isHidden ? 0 : opacity,
      flexShrink: 0
    };
    const restrictedRenderTarget = RenderTarget.hasRestrictions();
    const frame2 = calculateRect(props, parentSize || 0 /* Unknown */, false);
    const isAutoSized2 = _usesDOMRect && (width === "auto" || height === "auto");
    const hasTransformTemplate = !!props.transformTemplate || !frame2 || !restrictedRenderTarget || __fromCanvasComponent || isAutoSized2;
    const template = hasTransformTemplate ? props.transformTemplate ?? transformTemplate(center) : void 0;
    if (!withExternalLayout) {
      if (frame2 && restrictedRenderTarget && !isAutoSized2) {
        const rotate = Animatable.getNumber(rotation).toFixed(4);
        style.transform = `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate}deg)`;
        style.width = frame2.width;
        style.minWidth = frame2.width;
        style.height = frame2.height;
      } else {
        style.left = left;
        style.right = right;
        style.top = top;
        style.bottom = bottom;
        style.width = width;
        style.height = height;
        style.rotate = rotation;
      }
      if (positionSticky) {
        if (!isOnCanvas || inCodeComponent) {
          style.position = "sticky";
          style.willChange = "transform";
          style.zIndex = 1;
          style.top = positionStickyTop;
          style.right = positionStickyRight;
          style.bottom = positionStickyBottom;
          style.left = positionStickyLeft;
        }
      } else if (isOnCanvas && (props.positionFixed || props.positionAbsolute)) {
        style.position = "absolute";
      }
    }
    collectFiltersFromProps(props, style);
    collectTextShadowsForProps(props, style);
    Object.assign(style, props.style);
    return /* @__PURE__ */ jsx88(
      motion.div,
      {
        id,
        ref: layoutRef,
        ...rest,
        style,
        layoutId,
        "data-framer-name": name,
        "data-framer-component-type": "DeprecatedRichText",
        "data-center": center,
        className: cx(className2, stylesPresetsClassName, richTextWrapperClassName),
        transformTemplate: template,
        dangerouslySetInnerHTML: { __html: innerHTMLWithReplacedFramerPageLinks }
      }
    );
  }
);
function convertVerticalAlignment(verticalAlignment) {
  switch (verticalAlignment) {
    case "top":
      return "flex-start";
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
  }
}
function useLoadFonts(fonts, fromCanvasComponent, containerRef) {
  const prevFontsRef = useRef28([]);
  if (!isShallowEqualArray(prevFontsRef.current, fonts)) {
    prevFontsRef.current = fonts;
    void fontStore.loadFonts(fonts).then(({ newlyLoadedFontCount }) => {
      if (!fromCanvasComponent || !containerRef.current || RenderTarget.current() !== RenderTarget.canvas) return;
      if (newlyLoadedFontCount > 0) {
        measureClosestComponentContainer(containerRef.current);
      }
    });
  }
}

// ../../library/src/render/presentation/useTextEffect.tsx
import * as React88 from "react";

// ../../library/src/render/utils/patchAndWaitForChild.ts
function newOverrideableRef() {
  return { current: null };
}
async function patchAndWaitForChild(ref, controller) {
  let current = ref.current;
  if (current) return current;
  let refCallbackResolve;
  const refCallbackPromise = new Promise((resolve, reject) => {
    refCallbackResolve = resolve;
    controller.signal.addEventListener("abort", () => reject());
  });
  Object.defineProperty(ref, "current", {
    get() {
      return current;
    },
    set(element) {
      current = element;
      if (element === null) {
        controller.abort();
        return;
      }
      refCallbackResolve(element);
    },
    configurable: true
  });
  return refCallbackPromise;
}

// ../../library/src/render/presentation/useTextEffect.tsx
import { jsx as jsx89, jsxs as jsxs20 } from "react/jsx-runtime";
var defaultValues2 = {
  opacity: 1,
  y: 0,
  x: 0,
  scale: 1,
  rotate: 0,
  rotateX: 0,
  rotateY: 0,
  skewX: 0,
  skewY: 0,
  filter: "none"
};
function isEffectKey(key7) {
  return key7 in defaultValues2;
}
function createKeyframes(effect, shouldReduceMotion) {
  const out = {};
  for (const key7 in effect) {
    if (!isEffectKey(key7)) continue;
    const effectValue = effect[key7];
    const defaultValue = defaultValues2[key7];
    if (isUndefined(effectValue) || isUndefined(defaultValue)) continue;
    if (shouldReduceMotion && key7 !== "opacity") continue;
    out[key7] = [effectValue, defaultValue];
  }
  return out;
}
var emojiSplitRe = /* @__PURE__ */ (() => {
  return new RegExp("\\p{Regional_Indicator}{2}|\\p{Emoji}\\p{Emoji_Modifier}?\\p{Variation_Selector}?(?:\\u{200d}\\p{Emoji}\\p{Emoji_Modifier}?\\p{Variation_Selector}?)*|.", "gu");
})();
function tokenizeText(text, tokenization = "character", elements, shouldReduceMotion, style) {
  if (shouldReduceMotion) {
    const ref = newOverrideableRef();
    elements.add(ref);
    return /* @__PURE__ */ jsx89("span", { ref, style, children: text });
  }
  switch (tokenization) {
    case "character":
    // When we want to animate "lines" that aren't split by newlines, but
    // instead by wrapping, we have to split the text into characters, and
    // then measure the top offset of each character, creating groups of
    // characters every time the top offset changes
    // eslint-disable-next-line no-fallthrough
    case "line": {
      const words = text.split(" ");
      const lastWordIndex = words.length - 1;
      return words.map((word, wordIndex) => {
        const isLastWord = wordIndex === lastWordIndex;
        const short = word.length <= 12;
        return /* @__PURE__ */ jsxs20(React88.Fragment, { children: [
          /* @__PURE__ */ jsx89("span", { style: { whiteSpace: short ? "nowrap" : "unset" }, children: word.match(emojiSplitRe)?.map((char, i) => {
            const ref = newOverrideableRef();
            elements.add(ref);
            return (
              // biome-ignore lint/suspicious/noArrayIndexKey: We are combining index with char.
              /* @__PURE__ */ jsx89("span", { ref, style, children: char }, char + i)
            );
          }) }),
          isLastWord ? null : " "
        ] }, word + wordIndex + isLastWord);
      });
    }
    case "word": {
      const words = text.split(" ");
      const lastWordIndex = words.length - 1;
      return words.map((char, i) => {
        const isLastWord = i === lastWordIndex;
        const ref = newOverrideableRef();
        elements.add(ref);
        return /* @__PURE__ */ jsxs20(React88.Fragment, { children: [
          /* @__PURE__ */ jsx89("span", { ref, style, children: char }),
          isLastWord ? null : " "
        ] }, char + i + isLastWord);
      });
    }
    // Per: Element doesn't require text to be split.
    case "element":
    default:
      return text;
  }
}
function tokenizationForEffect(effect) {
  const type = effect.type;
  switch (type) {
    case "appear":
      return effect.tokenization ?? "character";
    default:
      assertNever(type);
  }
}
function transformString(effect) {
  const transforms = [];
  if (isNumber(effect.x)) transforms.push(`translateX(${effect.x}px)`);
  if (isNumber(effect.y)) transforms.push(`translateY(${effect.y}px)`);
  if (isNumber(effect.scale)) transforms.push(`scale(${effect.scale})`);
  if (isNumber(effect.rotate)) transforms.push(`rotate(${effect.rotate}deg)`);
  if (isNumber(effect.rotateX)) transforms.push(`rotateX(${effect.rotateX}deg)`);
  if (isNumber(effect.rotateY)) transforms.push(`rotateY(${effect.rotateY}deg)`);
  if (isNumber(effect.skewX)) transforms.push(`skewX(${effect.skewX}deg)`);
  if (isNumber(effect.skewY)) transforms.push(`skewY(${effect.skewY}deg)`);
  return transforms.join(" ");
}
function getInitialEffectStyle(canPlay, canAnimate, effect, shouldReduceMotion) {
  if (!effect || !effect.effect) return void 0;
  const type = effect.type;
  switch (type) {
    case "appear":
      switch (effect.tokenization) {
        case "element":
          if (!canPlay || !canAnimate) return void 0;
          return {
            opacity: effect.effect.opacity,
            filter: shouldReduceMotion ? void 0 : effect.effect.filter,
            transform: shouldReduceMotion ? void 0 : transformString(effect.effect)
          };
        case "line":
        case "word":
        case "character":
        default:
          if (!canPlay || !canAnimate) return { display: "inline-block" };
          return {
            display: "inline-block",
            opacity: effect.effect.opacity,
            filter: shouldReduceMotion ? void 0 : effect.effect.filter,
            transform: shouldReduceMotion ? void 0 : transformString(effect.effect)
          };
      }
    default:
      assertNever(type);
  }
}
function useTextEffect(config, ref, preview) {
  const elements = useConstant(() => /* @__PURE__ */ new Set());
  const isRenderingStaticContent = isStaticRenderer();
  const canPlay = preview || !isRenderingStaticContent;
  const shouldReduceMotion = useReducedMotionConfig();
  const state = React88.useRef({
    hasMounted: false,
    hasAnimatedOnce: false,
    isAnimating: false,
    effect: config
  });
  state.current.effect = config;
  const trigger = config?.trigger ?? "onMount";
  const target = config?.target;
  const threshold = config?.threshold;
  React88.useEffect(() => {
    if (!canPlay || preview) return;
    state.current.hasMounted = true;
    function play() {
      const { effect } = state.current;
      if (!canPlay || !effect) return;
      if (effect?.repeat !== true && state.current.hasAnimatedOnce) return;
      if (effect?.type === "appear" && state.current.isAnimating) return;
      Object.assign(state.current, {
        hasAnimatedOnce: true,
        isAnimating: true
      });
      const type = effect.type;
      switch (type) {
        case "appear": {
          const { transition, startDelay, repeat, tokenization: tokenization2 } = effect;
          const cleanupRef = { current: void 0 };
          void runAppearEffect(
            tokenization2,
            effect.effect,
            elements,
            transition,
            startDelay,
            repeat,
            shouldReduceMotion,
            () => {
              Object.assign(state.current, { isAnimating: false });
            },
            cleanupRef
          );
          return () => cleanupRef.current?.();
        }
        default:
          assertNever(type);
      }
    }
    switch (trigger) {
      case "onMount":
        play();
        return;
      case "onInView": {
        const element = ref?.current;
        if (!element) return;
        return inView(element, play, { amount: threshold ?? 0 });
      }
      case "onScrollTarget": {
        const element = target?.ref?.current;
        if (!element) return;
        return inView(element, play, {
          amount: threshold ?? 0,
          root: document,
          margin: target?.offset ? `${target.offset}px 0px 0px 0px` : void 0
        });
      }
      default:
        assertNever(trigger);
    }
  }, [canPlay, elements, preview, ref, target, threshold, trigger]);
  const effectEnabled = !!config;
  const tokenization = config ? tokenizationForEffect(config) : void 0;
  return React88.useMemo(
    () => ({
      // The tokenizer is memoized such that it won't trigger RichText to
      // be rerendered if the effect changes in a way that doesn't effect
      // the tokenization.
      getTokenizer: () => {
        elements.clear();
        if (!effectEnabled) return void 0;
        const { hasMounted, hasAnimatedOnce, effect } = state.current;
        const effectStyle = getInitialEffectStyle(
          canPlay,
          preview || mayAnimate(hasMounted, hasAnimatedOnce, effect),
          state.current.effect,
          shouldReduceMotion
        );
        return {
          text: (text) => tokenizeText(text, tokenization, elements, shouldReduceMotion, effectStyle),
          props: (style) => {
            if (effect?.tokenization !== "element") return void 0;
            const r = newOverrideableRef();
            elements.add(r);
            return {
              ref: r,
              style: { ...style, ...effectStyle }
            };
          }
        };
      },
      play: () => {
        const { effect } = state.current;
        if (!effect) return;
        const type = effect.type;
        switch (type) {
          case "appear": {
            const { transition, startDelay } = effect;
            void runAppearEffect(
              tokenization,
              effect.effect,
              elements,
              transition,
              startDelay,
              false,
              shouldReduceMotion
            );
            break;
          }
          default:
            assertNever(type);
        }
      }
    }),
    [canPlay, effectEnabled, elements, preview, tokenization]
  );
}
function mayAnimate(hasMounted, hasAnimatedOnce, effect) {
  return !// If either the component has mounted and the trigger is
  // onMount, or if the component has run an animation to
  // completion, the effect is not repeatable, and the trigger
  // is one that is impacted by repeated effects, we don't
  // need to set initial style again.
  (hasMounted && effect?.trigger === "onMount" || hasAnimatedOnce && !effect?.repeat && (effect?.trigger === "onInView" || effect?.trigger === "onScrollTarget"));
}
async function runAppearEffect(tokenization = "character", effect, elements, transition, startDelay = 0, repeat = false, shouldReduceMotion, callback, cleanupRef) {
  const enter = createKeyframes(effect, shouldReduceMotion);
  const controller = new AbortController();
  if (cleanupRef) cleanupRef.current = () => controller.abort();
  switch (tokenization) {
    case "character":
    case "element":
    case "word": {
      const list = await createElementList(elements, controller);
      if (list === null) return;
      void animate(list, enter, {
        ...transition,
        restDelta: 1e-3,
        delay: stagger(transition?.delay ?? 0, { startDelay })
      }).then(() => callback?.());
      if (!repeat || !cleanupRef) return;
      cleanupRef.current = () => {
        const actualEffect = shouldReduceMotion ? { opacity: effect.opacity } : effect;
        void animate(list, actualEffect, {
          ...transition,
          restDelta: 1e-3,
          delay: stagger(transition?.delay ?? 0, { startDelay })
        });
      };
      return;
    }
    case "line": {
      try {
        for (const element of elements) {
          await patchAndWaitForChild(element, controller);
        }
      } catch {
        return;
      }
      let list;
      frame.read(() => {
        list = createLineGroups(elements);
        if (list.length === 0) return;
        frame.update(() => {
          const animations2 = list.map((group, i) => {
            return animate(group, enter, {
              ...transition,
              restDelta: 1e-3,
              // Since text tokenized into lines are groups of individual
              // characters where each group is animated at once, we can't use
              // motion's built in `stagger()` function, and have to manage the
              // outer delay ourselves.
              delay: startDelay + i * (transition?.delay ?? 0)
            });
          });
          void Promise.all(animations2).then(() => callback?.());
        });
      });
      if (!repeat || !cleanupRef) return;
      cleanupRef.current = () => {
        if (list.length === 0) return;
        const actualEffect = shouldReduceMotion ? { opacity: effect.opacity } : effect;
        list.forEach((group, i) => {
          void animate(group, actualEffect, {
            ...transition,
            restDelta: 1e-3,
            delay: startDelay + i * (transition?.delay ?? 0)
          });
        });
      };
      return;
    }
    default:
      assertNever(tokenization);
  }
}
async function createElementList(elements, controller) {
  if (elements.size === 0) return null;
  const list = [];
  for (const element of elements) {
    try {
      const node = await patchAndWaitForChild(element, controller);
      if (node) list.push(node);
    } catch {
      return null;
    }
  }
  return list;
}
function createLineGroups(elements) {
  const groups2 = [];
  let currentGroup = [];
  let lastOffset = null;
  for (const element of elements) {
    if (!element.current) continue;
    const top = element.current.offsetTop;
    const height = element.current.offsetHeight;
    if (!height || lastOffset === null || top === lastOffset) {
      currentGroup.push(element.current);
    } else {
      groups2.push(currentGroup);
      currentGroup = [element.current];
    }
    if (height) lastOffset = top;
  }
  groups2.push(currentGroup);
  return groups2;
}

// ../../library/src/render/presentation/RichText.tsx
import { jsx as jsx90 } from "react/jsx-runtime";
var BaseSVG = /* @__PURE__ */ forwardRef17(
  function BaseSVG2(props, forwardedRef) {
    return (
      // biome-ignore lint/a11y/noSvgWithoutTitle: FIXME: FitText might be inaccessible to screen readers because its wrapped in an svg
      /* @__PURE__ */ jsx90("svg", { ...props, ref: forwardedRef, children: props.children })
    );
  }
);
var MotionSVG = /* @__PURE__ */ motion.create(BaseSVG);
var FitText = /* @__PURE__ */ forwardRef17(function FitText2({ viewBoxScale, viewBox, children, ...props }, forwardedRef) {
  return /* @__PURE__ */ jsx90(MotionSVG, { ...props, ref: forwardedRef, viewBox, children: /* @__PURE__ */ jsx90(
    motion.foreignObject,
    {
      width: "100%",
      height: "100%",
      className: "framer-fit-text",
      transform: `scale(${viewBoxScale})`,
      style: { overflow: "visible", transformOrigin: "center center" },
      children
    }
  ) });
});
var defaultFonts = [];
var richTextContainerComponentType = "RichTextContainer";
var RichTextContainer = /* @__PURE__ */ forwardRef17(function RichTextContainer2(props, forwardedRef) {
  const {
    __fromCanvasComponent = false,
    _forwardedOverrideId,
    _forwardedOverrides,
    _usesDOMRect,
    anchorLinkOffsetY,
    as: _as,
    bottom,
    center,
    children,
    environment: environment2 = RenderTarget.current,
    fonts = defaultFonts,
    height,
    isEditable = false,
    left,
    name,
    opacity,
    positionSticky,
    positionStickyBottom,
    positionStickyLeft,
    positionStickyRight,
    positionStickyTop,
    right,
    rotation = 0,
    style,
    _initialStyle,
    stylesPresetsClassNames,
    text: plainText,
    top,
    verticalAlignment = "top",
    visible = true,
    width,
    withExternalLayout = false,
    viewBox,
    viewBoxScale = 1,
    effect,
    ...rest
  } = props;
  const parentSize = useParentSize();
  const isOnCanvas = useIsOnFramerCanvas();
  const inCodeComponent = useContext33(ComponentContainerContext);
  const layoutId = useLayoutId(props);
  const fallbackRef = useRef30(null);
  const containerRef = forwardedRef ?? fallbackRef;
  useMeasureLayout(props, containerRef);
  useLoadFonts(fonts, __fromCanvasComponent, containerRef);
  useInsertionEffect7(() => {
    injectComponentCSSRules();
  }, []);
  const textEffect = useTextEffect(effect, containerRef);
  const processedChildren = useMemo28(() => {
    if (!children) return;
    return processRichTextChildren(
      children,
      stylesPresetsClassNames,
      plainText,
      anchorLinkOffsetY,
      void 0,
      textEffect.getTokenizer()
    );
  }, [children, stylesPresetsClassNames, plainText, anchorLinkOffsetY, textEffect]);
  if (!visible) return null;
  const isHidden = isEditable && environment2() === RenderTarget.canvas;
  const containerStyle2 = {
    opacity: isHidden ? 0 : opacity
  };
  const justifyContent = convertVerticalAlignment(verticalAlignment);
  if (justifyContent !== defaultRichTextContainerStyle.justifyContent) {
    containerStyle2.justifyContent = justifyContent;
  }
  const positionStyle = {};
  const restrictedRenderTarget = RenderTarget.hasRestrictions();
  const frame2 = calculateRect(props, parentSize || 0 /* Unknown */, false);
  const isAutoSized2 = _usesDOMRect && (width === "auto" || height === "auto");
  const hasTransformTemplate = !!props.transformTemplate || !frame2 || !restrictedRenderTarget || __fromCanvasComponent || isAutoSized2;
  const template = hasTransformTemplate ? props.transformTemplate ?? transformTemplate(center) : void 0;
  if (!withExternalLayout) {
    if (frame2 && restrictedRenderTarget && !isAutoSized2) {
      positionStyle.x = frame2.x + (isNumber(style?.x) ? style.x : 0);
      positionStyle.y = frame2.y + (isNumber(style?.y) ? style.y : 0);
      containerStyle2.rotate = Animatable.getNumber(rotation);
      containerStyle2.width = frame2.width;
      containerStyle2.minWidth = frame2.width;
      containerStyle2.height = frame2.height;
    } else {
      containerStyle2.left = left;
      containerStyle2.right = right;
      containerStyle2.top = top;
      containerStyle2.bottom = bottom;
      containerStyle2.width = width;
      containerStyle2.height = height;
      containerStyle2.rotate = rotation;
    }
    if (positionSticky) {
      if (!isOnCanvas || inCodeComponent) {
        containerStyle2.position = "sticky";
        containerStyle2.willChange = "transform";
        containerStyle2.zIndex = 1;
        containerStyle2.top = positionStickyTop;
        containerStyle2.right = positionStickyRight;
        containerStyle2.bottom = positionStickyBottom;
        containerStyle2.left = positionStickyLeft;
      }
    } else if (isOnCanvas && (props.positionFixed || props.positionAbsolute)) {
      containerStyle2.position = "absolute";
    }
  }
  collectFiltersFromProps(props, containerStyle2);
  collectTextShadowsForProps(props, containerStyle2);
  Object.assign(containerStyle2, _initialStyle, style, positionStyle);
  if (layoutId) {
    rest.layout = "preserve-aspect";
  }
  const Component18 = htmlElementAsMotionComponent(props.as);
  const dataFramerName = rest["data-framer-name"] ?? name;
  if (isString(props.viewBox)) {
    if (props.as !== void 0) {
      return /* @__PURE__ */ jsx90(
        Component18,
        {
          ...rest,
          ref: containerRef,
          style: containerStyle2,
          layoutId,
          transformTemplate: template,
          "data-framer-name": dataFramerName,
          "data-framer-component-type": richTextContainerComponentType,
          children: /* @__PURE__ */ jsx90(FitText, { viewBox, viewBoxScale, style: { width: "100%", height: "100%" }, children: processedChildren })
        }
      );
    } else {
      return /* @__PURE__ */ jsx90(
        FitText,
        {
          ...rest,
          ref: containerRef,
          style: containerStyle2,
          layoutId,
          viewBox,
          viewBoxScale,
          transformTemplate: template,
          "data-framer-name": dataFramerName,
          "data-framer-component-type": richTextContainerComponentType,
          children: processedChildren
        }
      );
    }
  }
  return /* @__PURE__ */ jsx90(
    Component18,
    {
      ...rest,
      ref: containerRef,
      style: containerStyle2,
      layoutId,
      transformTemplate: template,
      "data-framer-name": dataFramerName,
      "data-framer-component-type": richTextContainerComponentType,
      children: processedChildren
    }
  );
});
function isFragment(element) {
  return element.type === Fragment16;
}
function isLineBreak(element) {
  return element.type === "br";
}
function processRichTextChildren(element, stylesPresetsClassNames, plainText, anchorLinkOffsetY, slugCounters = {}, tokenizer, depth = isFragment(element) ? -1 : 0) {
  let children = Children5.toArray(element.props.children);
  if (!isUndefined(plainText)) {
    children = children.slice(0, 1);
  }
  let onlyLineBreaks = true;
  children = children.map((child) => {
    if (!isValidElement7(child) || !isLineBreak(child)) onlyLineBreaks = false;
    if (isValidElement7(child)) {
      return processRichTextChildren(
        child,
        stylesPresetsClassNames,
        plainText,
        anchorLinkOffsetY,
        slugCounters,
        tokenizer,
        depth + 1
      );
    }
    const text = !isUndefined(plainText) ? plainText : child;
    return isString(text) && tokenizer ? tokenizer.text(text) : text;
  });
  const { ["data-preset-tag"]: dataPresetTag, ...props } = element.props;
  if (isString(element.type) || isMotionComponent(element.type)) {
    const elementType = unwrapMotionComponent(element.type) || element.type;
    const tag = dataPresetTag || elementType;
    const stylesPresetClassName = isString(tag) ? stylesPresetsClassNames?.[tag] : void 0;
    props.className = cx("framer-text", props.className, stylesPresetClassName);
    if (tokenizer && depth === 0 && !onlyLineBreaks) Object.assign(props, tokenizer.props(props.style));
    const isHeading = elementType === "h1" || elementType === "h2" || elementType === "h3" || elementType === "h4" || elementType === "h5" || elementType === "h6";
    const anchorLinkStylePresetClassName = stylesPresetsClassNames?.["anchor"];
    if (isHeading && anchorLinkStylePresetClassName) {
      const slug = generateHeadingSlug(children, slugCounters);
      props.id = slug;
      const className2 = cx("framer-text", anchorLinkStylePresetClassName);
      const anchorLink = /* @__PURE__ */ jsx90("a", { href: `#${slug}`, className: className2, children });
      props.style = { ...props.style ?? {}, scrollMarginTop: anchorLinkOffsetY };
      children = [anchorLink];
    }
  }
  return cloneElement3(element, props, ...children);
}
function generateHeadingSlug(children, slugCounters) {
  const headingText = children.map(extractTextFromReactNode).join("");
  let slug = slugify(headingText);
  const slugCounter = slugCounters[slug] ?? 0;
  if (slugCounter > 0) {
    slug += `-${slugCounter}`;
  }
  slugCounters[slug] = slugCounter + 1;
  return slug;
}
function extractTextFromReactNode(node) {
  if (isString(node) || isNumber(node)) {
    return node.toString();
  }
  if (isValidElement7(node)) {
    return extractTextFromReactNode(node.props.children);
  }
  if (Array.isArray(node)) {
    return node.map(extractTextFromReactNode).join("");
  }
  return "";
}
var RichText = /* @__PURE__ */ forwardRef17(function RichText2({ children, html, htmlFromDesign, ...props }, forwardedRef) {
  const content = html || children || htmlFromDesign;
  if (isString(content)) {
    if (!props.stylesPresetsClassName && isObject2(props.stylesPresetsClassNames)) {
      props.stylesPresetsClassName = Object.values(props.stylesPresetsClassNames).join(" ");
    }
    const contentProp = {
      // We need to use the original prop name.
      [isString(html) ? "html" : "htmlFromDesign"]: content
    };
    return /* @__PURE__ */ jsx90(
      DeprecatedRichText,
      {
        ...props,
        ...contentProp,
        ref: forwardedRef
      }
    );
  }
  if (!props.stylesPresetsClassNames && isString(props.stylesPresetsClassName)) {
    const [h1, h2, h3, p, a] = props.stylesPresetsClassName.split(" ");
    if (h1 === void 0 || h2 === void 0 || h3 === void 0 || p === void 0 || a === void 0) {
      console.warn(`Encountered invalid stylesPresetsClassNames: ${props.stylesPresetsClassNames}`);
    } else {
      props.stylesPresetsClassNames = { h1, h2, h3, p, a };
    }
  }
  return /* @__PURE__ */ jsx90(RichTextContainer, { ...props, ref: forwardedRef, children: isValidElement7(content) ? content : void 0 });
});

// ../../library/src/render/presentation/SVG.tsx
import React89, { forwardRef as forwardRef18 } from "react";

// ../../library/src/render/utils/elementPropertiesForGradient.ts
function linearGradientLine(angle) {
  const rad = angle * Math.PI / 180;
  const offset = {
    x: -Math.sin(rad) * 100,
    y: Math.cos(rad) * 100
  };
  const anglePoint = Point(offset.x, offset.y);
  const angleLine = Line(Point(0.5, 0.5), anglePoint);
  const points = Rect.points({ x: 0, y: 0, width: 1, height: 1 });
  const sortedPoints = points.map((point) => ({ point, distance: Point.distance(anglePoint, point) })).sort((a2, b2) => a2.distance - b2.distance);
  const a = sortedPoints[0]?.point;
  const b = sortedPoints[1]?.point;
  assert(a && b, "linearGradientLine: Must have 2 closest points.");
  const [c, d] = points.filter((point) => !Point.isEqual(point, a) && !Point.isEqual(point, b));
  assert(c && d, "linearGradientLine: Must have 2 opposing points.");
  const start = Line.intersection(angleLine, Line(a, b));
  const end = Line.intersection(angleLine, Line(c, d));
  assert(start && end, "linearGradientLine: Must have a start and end point.");
  return Line(start, end);
}
function elementPropertiesForLinearGradient(gradient, id) {
  const line = linearGradientLine(gradient.angle);
  const stops = gradientColorStops(gradient);
  const startPosition = stops[0]?.position ?? 0;
  const endPosition = stops[stops.length - 1]?.position ?? 1;
  const startPoint = Line.pointAtPercentDistance(line, startPosition);
  const endPoint = Line.pointAtPercentDistance(line, endPosition);
  const interpolator = interpolate([startPosition, endPosition], [0, 1]);
  return {
    id: `id${id}g${LinearGradient.hash(gradient)}`,
    x1: startPoint.x,
    y1: startPoint.y,
    x2: endPoint.x,
    y2: endPoint.y,
    stops: stops.map((stop) => ({
      color: stop.value,
      alpha: ConvertColor.getAlpha(stop.value) * gradient.alpha,
      position: interpolator(stop.position)
    }))
  };
}
function elementPropertiesForRadialGradient(gradient, id) {
  return {
    id: `id${id}g${RadialGradient.hash(gradient)}`,
    widthFactor: gradient.widthFactor,
    heightFactor: gradient.heightFactor,
    centerAnchorX: gradient.centerAnchorX,
    centerAnchorY: gradient.centerAnchorY,
    stops: gradientColorStops(gradient).map((stop) => ({
      color: stop.value,
      alpha: ConvertColor.getAlpha(stop.value) * gradient.alpha,
      position: stop.position
    }))
  };
}

// ../../library/src/render/types/RelativeNumber.ts
function isRelativeNumber(value) {
  if (!isString(value)) return false;
  const lastChar = value.charAt(value.length - 1);
  if (lastChar !== "%") return false;
  const withoutLastChar = value.slice(0, -1);
  const float = parseFloat(withoutLastChar);
  return isNumber(float);
}
function getRelativeNumberValue(value) {
  const withoutLastChar = value.slice(0, -1);
  const float = parseFloat(withoutLastChar);
  return isNumber(float) ? float : 50;
}

// ../../library/src/render/utils/imagePatternPropsForFill.tsx
function getPositionXFraction(positionX) {
  if (isRelativeNumber(positionX)) return getRelativeNumberValue(positionX) / 100;
  if (positionX === "left") return 0;
  if (positionX === "right") return 1;
  return 0.5;
}
function getPositionYFraction(positionY) {
  if (isRelativeNumber(positionY)) return getRelativeNumberValue(positionY) / 100;
  if (positionY === "top") return 0;
  if (positionY === "bottom") return 1;
  return 0.5;
}
function imagePatternPropsForFill(fill, frame2, id, includeTransform) {
  fill = Animatable.get(fill, "#09F");
  if (!BackgroundImage.isImageObject(fill)) return void 0;
  if (!fill.pixelWidth || !fill.pixelHeight) return void 0;
  const imageWidth = fill.pixelWidth;
  const imageHeight = fill.pixelHeight;
  let transform2;
  const { fit } = fill;
  let width = 1, height = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (fit === "fill" || fit === "fit" || fit === "tile" || !fit) {
    let scaleX = 1;
    let scaleY = 1;
    const imageRatio = imageWidth / imageHeight;
    const realWidth = frame2.height * imageRatio;
    const realHeight = frame2.width / imageRatio;
    const validScaleX = realWidth / frame2.width;
    const validScaleY = realHeight / frame2.height;
    if (fit === "tile") {
      fill.backgroundSize ??= 1;
      width = Math.round(fill.backgroundSize * (imageWidth / 2));
      height = Math.round(fill.backgroundSize * (imageHeight / 2));
      const layerPositionX = frame2.x ?? 0;
      const layerPositionY = frame2.y ?? 0;
      let extraOffsetX = 0;
      let extraOffsetY = 0;
      if (includeTransform) {
        extraOffsetX = layerPositionX;
        extraOffsetY = layerPositionY;
      }
      offsetX = (frame2.width - width) * getPositionXFraction(fill.positionX) + extraOffsetX;
      offsetY = (frame2.height - height) * getPositionYFraction(fill.positionY) + extraOffsetY;
      transform2 = `translate(${offsetX + layerPositionX}, ${offsetY + layerPositionY})`;
    } else {
      if (fit === "fill" || !fit ? validScaleY > validScaleX : validScaleY < validScaleX) {
        scaleY = validScaleY;
        offsetY = (1 - validScaleY) * getPositionYFraction(fill.positionY);
      } else {
        scaleX = validScaleX;
        offsetX = (1 - validScaleX) * getPositionXFraction(fill.positionX);
      }
      transform2 = `translate(${offsetX}, ${offsetY}) scale(${scaleX}, ${scaleY})`;
    }
  }
  const imageId = `id${id}g${"-fillImage"}`;
  return { id: imageId, path: fill.src ?? "", transform: transform2, width, height, offsetX, offsetY };
}

// ../../library/src/render/utils/imageUrlForAsset.ts
var mediaType2 = "framer/asset-reference,";
function isAssetReference2(value) {
  return value.startsWith(`data:${mediaType2}`);
}
function imageUrlForAsset(asset, pixelSize) {
  if (/^\w+:/u.test(asset) && !isAssetReference2(asset)) return asset;
  if (typeof pixelSize !== "number") pixelSize = void 0;
  else if (pixelSize <= 512) pixelSize = 512;
  else if (pixelSize <= 1024) pixelSize = 1024;
  else if (pixelSize <= 2048) pixelSize = 2048;
  else pixelSize = 4096;
  const isExport = RenderTarget.current() === RenderTarget.export;
  return runtime.assetResolver(asset, { pixelSize, isExport }) ?? "";
}

// ../../library/src/render/presentation/ImagePatternElement.tsx
import { jsx as jsx91 } from "react/jsx-runtime";
var ImagePatternElement = ({
  id,
  path,
  transform: transform2,
  repeat,
  width,
  height,
  offsetX,
  offsetY
}) => {
  const href = imageUrlForAsset(path);
  return /* @__PURE__ */ jsx91(
    "pattern",
    {
      id,
      width: repeat ? width : "100%",
      height: repeat ? height : "100%",
      patternContentUnits: repeat ? void 0 : "objectBoundingBox",
      patternUnits: repeat ? "userSpaceOnUse" : void 0,
      x: repeat ? offsetX : void 0,
      y: repeat ? offsetY : void 0,
      children: /* @__PURE__ */ jsx91(
        "image",
        {
          width: repeat ? width : 1,
          height: repeat ? height : 1,
          href,
          preserveAspectRatio: "none",
          transform: repeat ? void 0 : transform2,
          x: repeat ? 0 : void 0,
          y: repeat ? 0 : void 0
        },
        href
      )
    }
  );
};

// ../../library/src/render/presentation/SharedSVGManager.ts
import { useEffect as useEffect33 } from "react";
var useDOM = /* @__PURE__ */ isBrowser2();
var SharedSVGEntry = class {
  constructor(id, svg, innerHTML, viewBox, count = 0) {
    this.id = id;
    this.svg = svg;
    this.innerHTML = innerHTML;
    this.viewBox = viewBox;
    this.count = count;
  }
};
var visuallyHiddenStyle = "position: absolute; overflow: hidden; bottom: 0; left: 0; width: 0; height: 0; z-index: 0; contain: strict";
var SharedSVGManager = class {
  constructor() {
    __publicField(this, "entries", /* @__PURE__ */ new Map());
    __publicField(this, "vectorSetItems", /* @__PURE__ */ new Map());
  }
  debugGetEntries() {
    return this.entries;
  }
  /** Request to render a svg, this will ensure there is a global instance and will return a
   * template referencing the image. Must be balanced with `unsubscribe()` calls using the same
   * svg. If called multiple times while the shared SVG exists, the generateUniqueIds and
   * contentId parameters are ignored. */
  subscribe(svg, generateUniqueIds, contentId, overflowVisible) {
    if (!svg || svg === "") return "";
    let entry = this.entries.get(svg);
    if (!entry) {
      if (!contentId) {
        contentId = `svg${String(hash(svg))}_${String(svg.length)}`;
      }
      let uniqueSVG = svg;
      let svgSize;
      const svgDom = parseSVG(svg);
      if (svgDom) {
        if (generateUniqueIds) {
          prefixIdsInSVG(svgDom, contentId);
        }
        svgDom.id = contentId;
        svgSize = getSVGSize(svgDom);
        svgDom.removeAttribute("xmlns");
        svgDom.removeAttribute("xlink");
        svgDom.removeAttribute("xmlns:xlink");
        uniqueSVG = svgDom.outerHTML;
      }
      entry = this.createDOMElementFor(uniqueSVG, contentId, svgSize, overflowVisible);
      this.entries.set(svg, entry);
    }
    entry.count += 1;
    return entry.innerHTML;
  }
  /** Returns the viewBox for the svg, or undefined if there is no viewBox. */
  getViewBox(svg) {
    if (!svg || svg === "") return;
    const entry = this.entries.get(svg);
    return entry?.viewBox;
  }
  /** When no longer rendering an svg it must be unsubscribed from so resources can be cleaned up.
   * Pass in the same svg as used with `subscribe()`. */
  unsubscribe(svg) {
    if (!svg || svg === "") return;
    const entry = this.entries.get(svg);
    if (!entry) return;
    entry.count -= 1;
    if (entry.count > 0) return;
    setTimeout(() => this.maybeRemoveEntry(svg), 5e3);
  }
  maybeRemoveEntry(svg) {
    const entry = this.entries.get(svg);
    if (!entry) return;
    if (entry.count > 0) return;
    this.entries.delete(svg);
    this.removeDOMElement(entry);
  }
  removeDOMElement(entry) {
    if (useDOM) {
      const container = document?.getElementById(entry.id);
      container?.remove();
    }
  }
  getOrCreateTemplateContainer() {
    const container = document.getElementById("svg-templates");
    if (container) return container;
    const newContainer = document.createElement("div");
    newContainer.id = "svg-templates";
    newContainer.ariaHidden = "true";
    newContainer.style.cssText = visuallyHiddenStyle;
    document.body.appendChild(newContainer);
    return newContainer;
  }
  maybeAppendTemplate(id, svg) {
    if (document.getElementById(id)) return;
    const container = document.createElement("div");
    container.innerHTML = svg;
    const svgElement = container.firstElementChild;
    if (!svgElement) return;
    svgElement.id = id;
    this.getOrCreateTemplateContainer().appendChild(svgElement);
  }
  createDOMElementFor(svg, id, size, overflowVisible) {
    if (useDOM) this.maybeAppendTemplate(id, svg);
    const box = size ? `0 0 ${size.width} ${size.height}` : void 0;
    const viewBox = box ? ` viewBox="${box}"` : "";
    const innerHTML = `<svg style="width:100%;height:100%;${overflowVisible ? "overflow: visible;" : ""}"${viewBox}><use href="#${id}"/></svg>`;
    return new SharedSVGEntry(id, svg, innerHTML, box);
  }
  /**
   * Vectors are serialized in such a way that they don't need to be parsed again, instead they
   * just need to provide their template. The hash is already known.
   *
   * VECTOR @TODO - Unsubscribe from vector set items.
   */
  template(revision, svg) {
    const entry = this.vectorSetItems.get(revision);
    if (entry) return `#${revision}`;
    this.vectorSetItems.set(revision, { svg, count: 0 });
    if (!useDOM) return `#${revision}`;
    this.maybeAppendTemplate(revision, svg);
    return `#${revision}`;
  }
  subscribeToTemplate(revision) {
    const entry = this.vectorSetItems.get(revision);
    if (!entry) return;
    entry.count++;
    return () => {
      const latest = this.vectorSetItems.get(revision);
      if (!latest) return;
      latest.count--;
      if (latest.count > 0) return;
      setTimeout(() => {
        if (this.vectorSetItems.get(revision)?.count) return;
        this.vectorSetItems.delete(revision);
        if (useDOM) document?.getElementById(revision)?.remove();
      }, 5e3);
    };
  }
  clear() {
    this.entries.clear();
  }
  /** Returns a string containing a div#svg-templates and all the current svg templates. Can be
   * used after running `ReactDOMServer.renderToString()` */
  generateTemplates() {
    const output = [];
    output.push(`<div id="svg-templates" style="${visuallyHiddenStyle}" aria-hidden="true">`);
    this.entries.forEach((value) => output.push(value.svg));
    this.vectorSetItems.forEach((value) => output.push(value.svg));
    output.push("</div>");
    return output.join("\n");
  }
};
function useSVGTemplate(revision, svg) {
  useEffect33(() => sharedSVGManager.subscribeToTemplate(revision), [revision]);
  return sharedSVGManager.template(revision, svg);
}
var sharedSVGManager = /* @__PURE__ */ new SharedSVGManager();
function parseSVG(svg) {
  try {
    const doc = domParser(svg);
    const node = doc.getElementsByTagName("svg")[0];
    if (!node) throw Error("no svg element found");
    return node;
  } catch {
    return;
  }
}
function prefixIdsInSVG(svg, prefix3) {
  const sanitizedPrefix = sanitizeString(prefix3);
  recursivelyPrefixId(svg, sanitizedPrefix);
}
function sanitizeString(str) {
  return str.replace(/[^\w\-:.]|^[^a-z]+/gi, "");
}
function recursivelyPrefixId(el, prefix3) {
  prefixId(el, prefix3);
  const childNodes = Array.from(el.children);
  childNodes.forEach((node) => {
    recursivelyPrefixId(node, prefix3);
  });
}
function prefixId(el, prefix3) {
  const attributes = el.getAttributeNames();
  attributes.forEach((attr) => {
    const value = el.getAttribute(attr);
    if (!value) return;
    if (attr === "id") {
      el.setAttribute(attr, `${prefix3}_${value}`);
    }
    if (attr === "href" || attr === "xlink:href") {
      const [base, fragmentIdentifier] = value.split("#");
      if (base) return;
      el.setAttribute(attr, `#${prefix3}_${fragmentIdentifier}`);
      return;
    }
    const URL_REF = "url(#";
    if (value.includes(URL_REF)) {
      const prefixedValue = value.replace(URL_REF, `${URL_REF}${prefix3}_`);
      el.setAttribute(attr, prefixedValue);
    }
  });
}
var unitsToPixels = /* @__PURE__ */ (() => ({
  cm: 96 / 2.54,
  mm: 96 / 2.54 / 10,
  Q: 96 / 2.54 / 40,
  in: 96,
  pc: 96 / 6,
  pt: 96 / 72,
  px: 1,
  // A few assumptions about relative units.
  em: 16,
  ex: 8,
  ch: 8,
  rem: 16
}))();
function parseLength(value) {
  if (!value) return;
  const m2 = /(-?[\d.]+)([a-z%]*)/u.exec(value);
  if (m2?.[1] === void 0 || m2?.[2] === void 0) return;
  if (m2[2]?.startsWith("%")) return;
  return Math.round(parseFloat(m2[1]) * (unitsToPixels[m2[2]] || 1));
}
function getSVGSize(svg) {
  const width = parseLength(svg.getAttribute("width"));
  const height = parseLength(svg.getAttribute("height"));
  if (typeof width !== "number" || typeof height !== "number") return;
  if (width <= 0 || height <= 0) return;
  return { width, height };
}

// ../../library/src/render/presentation/SVG.tsx
import { Fragment as Fragment17, jsx as jsx92, jsxs as jsxs21 } from "react/jsx-runtime";
var SVG = /* @__PURE__ */ forwardRef18(function SVG2(props, forwardedRef) {
  const parentSize = useParentSize();
  const layoutId = useLayoutId(props);
  const layoutRef = React89.useRef(null);
  const ref = forwardedRef ?? layoutRef;
  const providedWindow = useProvidedWindow();
  useMeasureLayout(props, layoutRef);
  return /* @__PURE__ */ jsx92(
    SVGComponent,
    {
      ...props,
      innerRef: ref,
      parentSize,
      layoutId,
      providedWindow
    }
  );
});
var MAX_BACKGROUND_SVG_TEXT_LENGTH = 5e4;
function containsImageReference(svg) {
  return svg.indexOf("image") >= 0;
}
function containsCustomPropertyReference(svg) {
  return svg.indexOf("var(--") >= 0;
}
function hasBorderRadius(style) {
  return !!(style.borderRadius || style.borderBottomLeftRadius || style.borderBottomRightRadius || style.borderTopLeftRadius || style.borderTopRightRadius);
}
function sizeSVG(container, props) {
  const div = container.current;
  if (!div) return;
  const localWindow = props.providedWindow ?? safeWindow;
  const svg = div.firstElementChild;
  if (!svg || !(svg instanceof localWindow.SVGSVGElement)) return;
  if (!svg.getAttribute("viewBox")) {
    const viewBox = sharedSVGManager.getViewBox(props.svg);
    if (viewBox) {
      svg.setAttribute("viewBox", viewBox);
    }
  }
  const { withExternalLayout, parentSize } = props;
  const canUseCalculatedOnCanvasSize = !withExternalLayout && constraintsEnabled(props) && parentSize !== 1 /* Disabled */ && parentSize !== 2 /* DisabledForCurrentLevel */;
  if (canUseCalculatedOnCanvasSize) return;
  const { intrinsicWidth, intrinsicHeight, _constraints } = props;
  if (svg.viewBox.baseVal?.width === 0 && svg.viewBox.baseVal?.height === 0 && isFiniteNumber(intrinsicWidth) && isFiniteNumber(intrinsicHeight)) {
    svg.setAttribute("viewBox", `0 0 ${intrinsicWidth} ${intrinsicHeight}`);
  }
  if (_constraints && _constraints.aspectRatio) {
    svg.setAttribute("preserveAspectRatio", "");
  } else {
    svg.setAttribute("preserveAspectRatio", "none");
  }
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");
}
function SVGStyleSheet() {
  React89.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, []);
  return null;
}
var SVGComponent = /* @__PURE__ */ (() => {
  var _a;
  return _a = class extends Layer {
    constructor() {
      super(...arguments);
      __publicField(this, "container", React89.createRef());
      __publicField(this, "svgElement", null);
      __publicField(this, "setSVGElement", (element) => {
        this.svgElement = element;
        this.setLayerElement(element);
      });
      __publicField(this, "previouslyRenderedSVG", "");
      __publicField(this, "unmountedSVG", "");
    }
    static frame(props) {
      return calculateRect(props, props.parentSize || 0 /* Unknown */);
    }
    get frame() {
      return calculateRect(this.props, this.props.parentSize || 0 /* Unknown */);
    }
    componentDidMount() {
      if (this.unmountedSVG) {
        const { svgContentId } = this.props;
        const contentid = svgContentId ? `svg${svgContentId}` : null;
        sharedSVGManager.subscribe(this.unmountedSVG, !svgContentId, contentid);
        this.previouslyRenderedSVG = this.unmountedSVG;
      }
      if (this.props.svgContentId) return;
      sizeSVG(this.container, this.props);
    }
    componentWillUnmount() {
      sharedSVGManager.unsubscribe(this.previouslyRenderedSVG);
      this.unmountedSVG = this.previouslyRenderedSVG;
      this.previouslyRenderedSVG = "";
    }
    componentDidUpdate(prevProps) {
      super.componentDidUpdate(prevProps);
      if (this.props.svgContentId) return;
      const { fill } = this.props;
      if (BackgroundImage.isImageObject(fill) && BackgroundImage.isImageObject(prevProps.fill) && fill.src !== prevProps.fill.src) {
        resetSetStyle(this.svgElement, "fill", null, false);
      }
      sizeSVG(this.container, this.props);
    }
    collectLayout(style, innerStyle) {
      if (this.props.withExternalLayout) {
        innerStyle.width = "100%";
        innerStyle.height = "100%";
        innerStyle.aspectRatio = "inherit";
        return;
      }
      const frame2 = this.frame;
      const { rotation, intrinsicWidth, intrinsicHeight, width, height } = this.props;
      const rotate = Animatable.getNumber(rotation);
      style.opacity = isFiniteNumber(this.props.opacity) ? this.props.opacity : 1;
      if (RenderTarget.hasRestrictions() && frame2) {
        Object.assign(style, {
          transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4)}deg)`,
          width: `${frame2.width}px`,
          height: `${frame2.height}px`
        });
        if (constraintsEnabled(this.props)) {
          style.position = "absolute";
        }
        const xFactor = frame2.width / (intrinsicWidth || 1);
        const yFactor = frame2.height / (intrinsicHeight || 1);
        innerStyle.transformOrigin = "top left";
        const { zoom, target } = RenderEnvironment;
        if (target === RenderTarget.export) {
          const zoomFactor = zoom > 1 ? zoom : 1;
          innerStyle.transform = `scale(${xFactor * zoomFactor}, ${yFactor * zoomFactor})`;
          innerStyle.zoom = 1 / zoomFactor;
        } else {
          innerStyle.transform = `scale(${xFactor}, ${yFactor})`;
        }
        if (intrinsicWidth && intrinsicHeight) {
          innerStyle.width = intrinsicWidth;
          innerStyle.height = intrinsicHeight;
        }
        return;
      }
      const { left, right, top, bottom } = this.props;
      Object.assign(style, {
        left,
        right,
        top,
        bottom,
        width,
        height,
        rotate
      });
      Object.assign(innerStyle, {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute"
      });
    }
    render() {
      countNodeRender();
      const {
        id,
        visible,
        style,
        fill,
        svg,
        intrinsicHeight,
        intrinsicWidth,
        title,
        description,
        layoutId,
        className: className2,
        variants,
        withExternalLayout,
        innerRef,
        svgContentId,
        height: _height,
        opacity: _opacity,
        width: _width,
        requiresOverflowVisible,
        ...rest
      } = this.props;
      if (!withExternalLayout && (!visible || !id)) return null;
      const identifier = id ?? layoutId ?? "svg";
      const frame2 = this.frame;
      const size = frame2 || { width: intrinsicWidth || 100, height: intrinsicHeight || 100 };
      const outerStyle = { ...style, imageRendering: "pixelated", flexShrink: 0 };
      const innerStyle = {};
      this.collectLayout(outerStyle, innerStyle);
      collectOpacityFromProps(this.props, outerStyle);
      collectFiltersFromProps(this.props, outerStyle);
      Layer.applyWillChange(this.props, outerStyle, false);
      let fillElement = null;
      if (typeof fill === "string" || Color.isColorObject(fill)) {
        const fillColor = Color.isColorObject(fill) ? fill.initialValue || Color.toRgbString(fill) : fill;
        outerStyle.fill = fillColor;
        outerStyle.color = fillColor;
      } else if (LinearGradient.isLinearGradient(fill)) {
        const gradient = fill;
        const gradientId = `${encodeURI(id || "")}g${LinearGradient.hash(gradient)}`;
        outerStyle.fill = `url(#${gradientId})`;
        const { stops, x1, x2, y1, y2 } = elementPropertiesForLinearGradient(gradient, identifier);
        fillElement = /* @__PURE__ */ jsx92(
          "svg",
          {
            ref: this.setSVGElement,
            width: "100%",
            height: "100%",
            style: { position: "absolute" },
            role: "presentation",
            children: /* @__PURE__ */ jsx92("linearGradient", { id: gradientId, x1, x2, y1, y2, children: stops.map((stop, idx) => {
              return /* @__PURE__ */ jsx92(
                "stop",
                {
                  offset: stop.position,
                  stopColor: stop.color,
                  stopOpacity: stop.alpha
                },
                idx
              );
            }) })
          }
        );
      } else if (RadialGradient.isRadialGradient(fill)) {
        const gradient = fill;
        const gradientId = `${encodeURI(id || "")}g${RadialGradient.hash(gradient)}`;
        outerStyle.fill = `url(#${gradientId})`;
        const elementProperties = elementPropertiesForRadialGradient(gradient, identifier);
        fillElement = /* @__PURE__ */ jsx92(
          "svg",
          {
            ref: this.setSVGElement,
            width: "100%",
            height: "100%",
            style: { position: "absolute" },
            role: "presentation",
            children: /* @__PURE__ */ jsx92(
              "radialGradient",
              {
                id: gradientId,
                cy: gradient.centerAnchorY,
                cx: gradient.centerAnchorX,
                r: gradient.widthFactor,
                children: elementProperties.stops.map((stop, idx) => {
                  return /* @__PURE__ */ jsx92(
                    "stop",
                    {
                      offset: stop.position,
                      stopColor: stop.color,
                      stopOpacity: stop.alpha
                    },
                    idx
                  );
                })
              }
            )
          }
        );
      } else if (BackgroundImage.isImageObject(fill)) {
        const imagePattern = imagePatternPropsForFill(fill, size, identifier);
        if (imagePattern) {
          outerStyle.fill = `url(#${imagePattern.id})`;
          fillElement = /* @__PURE__ */ jsx92(
            "svg",
            {
              ref: this.setSVGElement,
              width: "100%",
              height: "100%",
              style: { position: "absolute" },
              role: "presentation",
              children: /* @__PURE__ */ jsx92("defs", { children: /* @__PURE__ */ jsx92(ImagePatternElement, { ...imagePattern }) })
            }
          );
        }
      }
      const dataProps = {
        "data-framer-component-type": "SVG"
      };
      const hasTransformTemplate = !frame2;
      if (hasTransformTemplate) {
        Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center));
      }
      const svgAsBackgroundImage = (
        // If requiresOverflowVisible is true, we cannot safely render the SVG as background
        // images, as it might cropped any centered stroke that exceeds the bounding box.
        !requiresOverflowVisible && !fillElement && !outerStyle.fill && !outerStyle.background && !outerStyle.backgroundImage && svg.length < MAX_BACKGROUND_SVG_TEXT_LENGTH && !containsImageReference(svg) && !containsCustomPropertyReference(svg)
      );
      let content = null;
      if (svgAsBackgroundImage) {
        outerStyle.backgroundSize = "100% 100%";
        outerStyle.backgroundImage = encodeSVGForCSS(svg);
        sharedSVGManager.unsubscribe(this.previouslyRenderedSVG);
        this.previouslyRenderedSVG = "";
      } else {
        const contentid = svgContentId ? `svg${svgContentId}` : null;
        const __html = sharedSVGManager.subscribe(svg, !svgContentId, contentid, requiresOverflowVisible);
        sharedSVGManager.unsubscribe(this.previouslyRenderedSVG);
        this.previouslyRenderedSVG = svg;
        if (hasBorderRadius(outerStyle)) {
          outerStyle.overflow = "hidden";
        }
        content = /* @__PURE__ */ jsxs21(Fragment17, { children: [
          fillElement,
          /* @__PURE__ */ jsx92(
            "div",
            {
              className: "svgContainer",
              style: innerStyle,
              ref: this.container,
              dangerouslySetInnerHTML: { __html }
            },
            BackgroundImage.isImageObject(fill) ? fill.src : ""
          )
        ] });
      }
      const MotionComponent = htmlElementAsMotionComponent(this.props.as);
      const { href, target, rel, onClick, onTap } = this.props;
      const hasTitleOrDescription = title || description;
      return /* @__PURE__ */ jsxs21(
        MotionComponent,
        {
          ...dataProps,
          ...rest,
          layoutId,
          transformTemplate: hasTransformTemplate ? transformTemplate(this.props.center) : void 0,
          id,
          ref: innerRef,
          style: outerStyle,
          className: className2,
          variants,
          tabIndex: this.props.tabIndex,
          role: hasTitleOrDescription ? "img" : void 0,
          "aria-label": title,
          "aria-description": description,
          "aria-hidden": hasTitleOrDescription ? void 0 : "true",
          onTap,
          onClick,
          ...{ href, target, rel },
          children: [
            content,
            /* @__PURE__ */ jsx92(SVGStyleSheet, {})
          ]
        }
      );
    }
  }, __publicField(_a, "supportsConstraints", true), __publicField(_a, "defaultSVGProps", {
    left: void 0,
    right: void 0,
    top: void 0,
    bottom: void 0,
    style: void 0,
    _constraints: {
      enabled: true,
      aspectRatio: null
    },
    parentSize: 0 /* Unknown */,
    rotation: 0,
    visible: true,
    svg: "",
    shadows: []
  }), __publicField(_a, "defaultProps", {
    ...Layer.defaultProps,
    ..._a.defaultSVGProps
  }), _a;
})();

// ../../library/src/render/presentation/Text.tsx
import React91, { useEffect as useEffect34, useRef as useRef31 } from "react";

// ../../library/src/render/fonts/useFontLoadStatus.tsx
import React90 from "react";
function useFontLoadStatus(fontSelectors = [], timeout = 5e3) {
  const missingFontSelectors = fontSelectors.filter((s) => !fontStore.isSelectorLoaded(s));
  const [fontLoadStatus, setFontLoadStatus] = React90.useState(
    missingFontSelectors.length ? "loading" : "done"
  );
  React90.useEffect(() => {
    if (!missingFontSelectors.length) return;
    setFontLoadStatus("loading");
    const timer = setTimeout(() => {
      setFontLoadStatus("timeout");
    }, timeout);
    fontStore.loadFonts(missingFontSelectors).then(() => {
      clearTimeout(timer);
      setFontLoadStatus("done");
    });
  }, [fontSelectors.join(", "), missingFontSelectors.join(", ")]);
  return fontLoadStatus;
}

// ../../library/src/render/presentation/Text.tsx
import { Fragment as Fragment18, jsx as jsx93, jsxs as jsxs22 } from "react/jsx-runtime";
function TextStyleSheet() {
  React91.useInsertionEffect(() => {
    injectComponentCSSRules();
  }, []);
  return null;
}
var Text2 = /* @__PURE__ */ React91.forwardRef(function Text3(props, forwardedRef) {
  const parentSize = useParentSize();
  const layoutId = useLayoutId(props);
  const fallbackLayoutRef = useRef31(null);
  const layoutRef = forwardedRef ?? fallbackLayoutRef;
  const { navigate, getRoute } = useRouter();
  const currentRoute = useCurrentRoute();
  useRoutePreloader(props.preload ?? []);
  const onCanvas = useIsOnFramerCanvas();
  const matchesCurrentRoute = useLinkMatchesRoute(props.__link);
  const fontLoadStatus = useFontLoadStatus(props.fonts);
  useMeasureLayout(props, layoutRef);
  const { fonts, __fromCanvasComponent } = props;
  const prevFontsRef = useRef31([]);
  const fontsDidChange = !isShallowEqualArray(prevFontsRef.current ?? [], fonts ?? []);
  prevFontsRef.current = fonts;
  useEffect34(() => {
    if (!fontsDidChange || !fonts) return;
    void fontStore.loadFonts(fonts).then(({ newlyLoadedFontCount }) => {
      if (!__fromCanvasComponent || !layoutRef.current || RenderTarget.current() !== RenderTarget.canvas) return;
      if (newlyLoadedFontCount === 0) return;
      measureClosestComponentContainer(layoutRef.current);
    });
  }, [fonts]);
  const implicitPathVariables = useImplicitPathVariables();
  const interceptPageLinks = React91.useCallback(
    (event) => {
      const anchorElement = findAnchorElement(event.target, layoutRef.current);
      if (event.metaKey || !navigate || !anchorElement) return;
      const didNavigate = navigateFromAttributes(navigate, anchorElement, implicitPathVariables);
      if (didNavigate) {
        event.preventDefault();
      }
    },
    [navigate, implicitPathVariables]
  );
  useEffect34(() => {
    const ref = layoutRef.current;
    if (!ref) return;
    ref.addEventListener("click", interceptPageLinks);
    return () => ref.removeEventListener("click", interceptPageLinks);
  }, [interceptPageLinks]);
  const rawHTML = React91.useMemo(() => {
    if (!props.rawHTML || onCanvas || !getRoute || !currentRoute) return props.rawHTML;
    return replaceFramerPageLinks(props.rawHTML, getRoute, currentRoute, implicitPathVariables);
  }, [props.rawHTML, getRoute, currentRoute, implicitPathVariables]);
  return /* @__PURE__ */ jsx93(
    TextComponent,
    {
      ...props,
      innerRef: layoutRef,
      layoutId,
      parentSize,
      fontLoadStatus,
      rawHTML,
      matchesCurrentRoute
    }
  );
});
var TextComponent = /* @__PURE__ */ (() => {
  var _a;
  return _a = class extends Layer {
    constructor() {
      super(...arguments);
      __publicField(this, "editorText");
      __publicField(this, "setElement", (element) => {
        if (this.props.innerRef) {
          this.props.innerRef.current = element;
        }
        this.setLayerElement(element);
      });
      /** Used by the ComponentContainerContext */
      __publicField(this, "renderMain", (inCodeComponent) => {
        countNodeRender();
        const {
          font,
          visible,
          alignment,
          opacity,
          id,
          layoutId,
          className: className2,
          transition,
          variants,
          name,
          __fromCanvasComponent,
          _initialStyle,
          widthType: _widthType,
          heightType: _heightType,
          _usesDOMRect,
          autoSize,
          style: styleProp,
          fontLoadStatus,
          matchesCurrentRoute,
          preload: _preload,
          tabIndex,
          ...rest
        } = this.props;
        if (!visible) {
          return null;
        }
        const isHidden = this.props.isEditable && this.props.environment() === RenderTarget.canvas;
        const justifyContent = convertVerticalAlignment2(this.props.verticalAlignment);
        const style = {
          outline: "none",
          display: "flex",
          flexDirection: "column",
          justifyContent,
          opacity: isHidden ? 0 : opacity,
          flexShrink: 0
        };
        if (_initialStyle) {
          for (const key7 in _initialStyle) {
            if (key7.startsWith("--framer")) {
              asRecord(style)[key7] = asRecord(_initialStyle)[key7];
            }
          }
        }
        const dataProps = {
          "data-framer-component-type": "Text",
          "data-framer-name": rest["data-framer-name"] ?? name
        };
        if (autoSize) {
          asRecord(dataProps)["data-framer-component-text-autosized"] = "true";
        }
        this.collectLayout(style, inCodeComponent);
        collectFiltersFromProps(this.props, style);
        collectTextShadowsForProps(this.props, style);
        if (style.opacity === 1 || style.opacity === void 0) {
          delete style.opacity;
        }
        let rawHTML = this.props.rawHTML;
        const text = this.getOverrideText() || this.props.text;
        if (isString(text)) {
          if (rawHTML) {
            rawHTML = replaceDraftHTMLWithText(rawHTML, text);
          } else {
            rawHTML = `<p style="font: ${font}">${text}</p>`;
          }
        }
        if (this.props.style) {
          Object.assign(style, this.props.style);
        }
        const centeringTransformTemplate = this.transformTemplate;
        if (centeringTransformTemplate) Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center));
        if (rawHTML) {
          style.lineHeight = "1px";
          style.fontSize = "0px";
          if (RenderTarget.current() === RenderTarget.canvas && fontLoadStatus === "loading") {
            style.visibility = "hidden";
          }
          if (RenderTarget.current() === RenderTarget.canvas && fontLoadStatus === "timeout") {
            style.backgroundColor = "rgba(255, 0, 0, 0.3)";
          }
          Object.assign(style, styleProp);
          if (alignment) asRecord(style)["--framer-text-alignment"] = alignment;
          const tabIndexProps = getTabIndexProps(tabIndex);
          return /* @__PURE__ */ jsx93(
            motion.div,
            {
              layoutId,
              id,
              ...tabIndexProps,
              ...dataProps,
              ...rest,
              style,
              transformTemplate: centeringTransformTemplate,
              dangerouslySetInnerHTML: { __html: rawHTML },
              "data-center": this.props.center,
              className: cx(className2, matchesCurrentRoute && "isCurrent"),
              transition,
              variants,
              ref: this.setElement
            }
          );
        }
      });
    }
    get frame() {
      return calculateRect(this.props, this.props.parentSize || 0 /* Unknown */, false);
    }
    getOverrideText() {
      const { _forwardedOverrideId, _forwardedOverrides, id } = this.props;
      const forwardedOverrideId = _forwardedOverrideId ?? id;
      if (forwardedOverrideId && _forwardedOverrides) {
        const text = _forwardedOverrides[forwardedOverrideId];
        if (isString(text)) {
          return text;
        }
      }
    }
    render() {
      return /* @__PURE__ */ jsxs22(Fragment18, { children: [
        /* @__PURE__ */ jsx93(ComponentContainerContext.Consumer, { children: this.renderMain }),
        /* @__PURE__ */ jsx93(TextStyleSheet, {})
      ] });
    }
    collectLayout(style, inCodeComponent) {
      if (this.props.withExternalLayout) return;
      const frame2 = this.frame;
      const {
        rotation,
        autoSize,
        positionSticky,
        positionStickyTop,
        positionStickyRight,
        positionStickyBottom,
        positionStickyLeft,
        width: externalWidth,
        height: externalHeight,
        _usesDOMRect,
        positionFixed,
        positionAbsolute
      } = this.props;
      const rotate = Animatable.getNumber(rotation);
      const isDOMLayoutAutoSized = _usesDOMRect && (externalWidth === "auto" || externalHeight === "auto");
      if (frame2 && !isDOMLayoutAutoSized && RenderTarget.hasRestrictions()) {
        Object.assign(style, {
          transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4)}deg)`,
          // Using auto fixes wrapping problems where our size calculation does not work out well when zooming the
          // text (due to rendering differences).
          // TODO: When the `autoSize` prop is removed, it's safe to leave
          // this at `${frame.width}px`, because all auto cases will be
          // handled by DOM layout in the `else` side of the conditional
          width: autoSize ? "auto" : `${frame2.width}px`,
          minWidth: `${frame2.width}px`,
          height: `${frame2.height}px`
        });
      } else {
        const { left, right, top, bottom } = this.props;
        let width;
        let height;
        if (autoSize) {
          width = "auto";
          height = "auto";
        } else {
          if (!isFiniteNumber(left) || !isFiniteNumber(right)) {
            width = externalWidth;
          }
          if (!isFiniteNumber(top) || !isFiniteNumber(bottom)) {
            height = externalHeight;
          }
        }
        Object.assign(style, {
          left,
          right,
          top,
          bottom,
          width,
          height,
          rotate
        });
      }
      const onCanvas = RenderTarget.current() === RenderTarget.canvas;
      if (positionSticky) {
        if (!onCanvas || inCodeComponent) {
          style.position = "sticky";
          style.willChange = "transform";
          style.zIndex = 1;
          style.top = positionStickyTop;
          style.right = positionStickyRight;
          style.bottom = positionStickyBottom;
          style.left = positionStickyLeft;
        }
      } else if (onCanvas && (positionFixed || positionAbsolute)) {
        style.position = "absolute";
      }
    }
    // biome-ignore lint/suspicious/useGetterReturn: legacy text component
    get transformTemplate() {
      const { _usesDOMRect, widthType, heightType, __fromCanvasComponent } = this.props;
      if (this.props.transformTemplate) return this.props.transformTemplate;
      const frame2 = this.frame;
      const isDOMLayoutAutoSized = _usesDOMRect && (isAutoDimensionType(widthType) || isAutoDimensionType(heightType));
      const hasTransformTemplate = !frame2 || !RenderTarget.hasRestrictions() || __fromCanvasComponent || isDOMLayoutAutoSized;
      if (hasTransformTemplate) return transformTemplate(this.props.center);
    }
  }, __publicField(_a, "supportsConstraints", true), __publicField(_a, "defaultTextProps", {
    opacity: void 0,
    left: void 0,
    right: void 0,
    top: void 0,
    bottom: void 0,
    _constraints: {
      enabled: true,
      aspectRatio: null
    },
    rotation: 0,
    visible: true,
    alignment: void 0,
    verticalAlignment: "top",
    shadows: [],
    font: "16px " + deviceFont()
  }), __publicField(_a, "defaultProps", {
    ...Layer.defaultProps,
    ..._a.defaultTextProps,
    isEditable: false,
    environment: RenderTarget.current,
    withExternalLayout: false,
    fontLoadStatus: "loading"
  }), _a;
})();
var linkTag = "(?:<a[^>]*>)?";
var linkClosingTag = "(?:</a>)?";
var outerTag = "<[^>]+>";
var outerClosingTag = "</[^>]+>";
var blockTag = "<(?:div|span)[^>]*>";
var blockClosingTag = "</(?:div|span)>";
var inlineTag = "<[^>]+>";
var inlineClosingTag = "</[^>]+>";
var textContentRegex = /* @__PURE__ */ (() => new RegExp(
  `^(${linkTag}${outerTag}${blockTag}${inlineTag}).*?(${inlineClosingTag}).*?(${blockClosingTag}${outerClosingTag}${linkClosingTag})$`,
  //                                              ^^^ this is the content we want to replace
  //                                                                      ^^^ this is the content we want to discard
  "su"
  // let the "." also match newlines
))();
function replaceDraftHTMLWithText(rawHTML, text) {
  return rawHTML.replace(
    textContentRegex,
    (_, openingTags, inlineClosingTag2, closingTags) => openingTags + text + inlineClosingTag2 + "<br>" + closingTags
  );
}
function convertVerticalAlignment2(verticalAlignment) {
  switch (verticalAlignment) {
    case "top":
      return "flex-start";
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
  }
}
function getTabIndexProps(tabIndex) {
  if (tabIndex === void 0) return {};
  return { tabIndex };
}

// ../../library/src/render/presentation/TickerItem.tsx
import { jsx as jsx94 } from "react/jsx-runtime";
function TickerItem({ height, width, children }) {
  const itemProps = useSafeTickerItem();
  if (!itemProps || !children) return children;
  const { props } = itemProps;
  return /* @__PURE__ */ jsx94(
    motion.li,
    {
      ...props,
      style: { ...props.style, width: width ?? "fit-content", height: height ?? "fit-content" },
      children
    }
  );
}
function useSafeTickerItem() {
  try {
    const value = useTickerItem();
    return value;
  } catch {
    return void 0;
  }
}

// ../../library/src/utils/internalId.ts
var keys2 = /* @__PURE__ */ new Map();
var InternalID = class _InternalID {
  constructor(id) {
    this.id = id;
    __publicField(this, "_link", null);
    __publicField(this, "_urllink", null);
  }
  add(str) {
    return _InternalID.forKey(this.id + str);
  }
  toString() {
    return this.id;
  }
  get link() {
    const res = this._link;
    if (res) return res;
    return this._link = "#" + this.id;
  }
  get urlLink() {
    const res = this._urllink;
    if (res) return res;
    return this._urllink = "url(#" + this.id + ")";
  }
  static forKey(key7) {
    let res = keys2.get(key7);
    if (res) return res;
    res = new _InternalID("a" + (1e3 + keys2.size) + "z");
    keys2.set(key7, res);
    return res;
  }
};

// ../../library/src/render/types/PathSegment.ts
var PathSegmentOuter = /* @__PURE__ */ (() => {
  const _PathSegment = class _PathSegment {
    constructor(value) {
      // #region withClassDiscriminator
      // NOTE: this implementation carefully copies the implementation of `withClassDiscriminator`
      // from Vekter. If making changes here, make sure to sync them to `withClassDiscriminator` as well.
      __publicField(this, "__class", "PathSegment");
      // #endregion
      __publicField(this, "x", 0);
      // The anchor point of the segment.
      __publicField(this, "y", 0);
      __publicField(this, "handleMirroring", "straight");
      __publicField(this, "handleOutX", 0);
      // Describes the out tangent of the segment.
      __publicField(this, "handleOutY", 0);
      __publicField(this, "handleInX", 0);
      // Describes the in tangent of the segment.
      __publicField(this, "handleInY", 0);
      __publicField(this, "radius", 0);
      if (value) {
        Object.assign(this, value);
      }
    }
    merge(value) {
      return Object.assign(Object.create(Object.getPrototypeOf(this)), this, value);
    }
  };
  __publicField(_PathSegment, "displayName", "WithClassDiscriminatorMixin(PathSegment)");
  __publicField(_PathSegment, "point", (pathSegment) => {
    return { x: pathSegment.x, y: pathSegment.y };
  });
  __publicField(_PathSegment, "handleOut", (pathSegment) => {
    return { x: pathSegment.handleOutX, y: pathSegment.handleOutY };
  });
  __publicField(_PathSegment, "handleIn", (pathSegment) => {
    return { x: pathSegment.handleInX, y: pathSegment.handleInY };
  });
  __publicField(_PathSegment, "calculatedHandleOut", (pathSegment) => {
    switch (pathSegment.handleMirroring) {
      case "symmetric":
      case "disconnected":
      case "asymmetric":
        return Point.add(_PathSegment.point(pathSegment), _PathSegment.handleOut(pathSegment));
      default:
        return { x: pathSegment.x, y: pathSegment.y };
    }
  });
  __publicField(_PathSegment, "calculatedHandleIn", (pathSegment) => {
    switch (pathSegment.handleMirroring) {
      case "symmetric":
        return Point.subtract(_PathSegment.point(pathSegment), _PathSegment.handleOut(pathSegment));
      case "disconnected":
      case "asymmetric":
        return Point.add(_PathSegment.point(pathSegment), _PathSegment.handleIn(pathSegment));
      default:
        return _PathSegment.point(pathSegment);
    }
  });
  __publicField(_PathSegment, "curveDefault", (points, index) => {
    if (points.length > 2) {
      let pointBefore;
      let pointAfter;
      if (index === 0) {
        pointBefore = points[points.length - 1];
      } else {
        pointBefore = points[index - 1];
      }
      if (index === points.length - 1) {
        pointAfter = points[0];
      } else {
        pointAfter = points[index + 1];
      }
      assert(pointBefore, "pointBefore should be defined");
      assert(pointAfter, "pointAfter should be defined");
      const delta = Point.subtract(_PathSegment.point(pointAfter), _PathSegment.point(pointBefore));
      return { x: delta.x / 4, y: delta.y / 4 };
    }
    return { x: 10, y: 10 };
  });
  let PathSegment2 = _PathSegment;
  ;
  PathSegment2.prototype.__class = "PathSegment";
  return PathSegment2;
})();
var PathSegment = PathSegmentOuter;

// ../../library/src/render/traits/Path.ts
var key5 = "pathSegments";
function withPath(target) {
  return key5 in target;
}
var pathDefaults = {
  pathSegments: [],
  pathClosed: false
};
function toSVGPath(withPaths, translate = { x: 0, y: 0 }, canvasMode = RenderTarget.canvas) {
  let pathElements = [];
  let paths = [];
  if (Array.isArray(withPaths)) {
    paths = withPaths;
  } else {
    paths = [withPaths];
  }
  paths.forEach((path) => {
    const { pathClosed, pathSegments } = path;
    const segmentCount = pathSegments.length;
    if (segmentCount === 0) return "";
    for (let i = 0; i < segmentCount; i++) {
      const segment = pathSegments[i];
      assert(segment, "Path segment must be defined");
      let nextSegment;
      let prevSegment;
      const isFirstSegment = i === 0;
      const isLastSegment = i === segmentCount - 1;
      if (!isLastSegment) {
        nextSegment = pathSegments[i + 1];
      } else if (pathClosed) {
        nextSegment = pathSegments[0];
      }
      if (!isFirstSegment) {
        prevSegment = pathSegments[i - 1];
      } else if (pathClosed) {
        prevSegment = pathSegments[segmentCount - 1];
      }
      if (i === 0) {
        pathElements.push("M");
      } else if (prevSegment && isStraightCurve(prevSegment, segment)) {
        pathElements.push("L");
      }
      pathElements.push(segment.x + translate.x, segment.y + translate.y);
      if (nextSegment && !isStraightCurve(segment, nextSegment)) {
        const handleOut = PathSegment.calculatedHandleOut(segment);
        const handleIn = PathSegment.calculatedHandleIn(nextSegment);
        pathElements.push(
          "C",
          handleOut.x + translate.x,
          handleOut.y + translate.y,
          handleIn.x + translate.x,
          handleIn.y + translate.y
        );
      }
      if (isLastSegment && nextSegment) {
        if (isStraightCurve(segment, nextSegment)) {
          pathElements.push("Z");
        } else {
          pathElements.push(nextSegment.x + translate.x, nextSegment.y + translate.y, "Z");
        }
      }
    }
  });
  if (canvasMode === RenderTarget.export || canvasMode === RenderTarget.preview) {
    pathElements = pathElements.map((value) => isFiniteNumber(value) ? roundedNumberString(value, 3) : value);
  }
  return pathElements.join(" ");
}
function isStraightCurve(fromSegment, toSegment) {
  const fromStraight = fromSegment.handleMirroring === "straight" || fromSegment.handleOutX === 0 && fromSegment.handleOutY === 0;
  const toStraight = toSegment.handleMirroring === "straight" || toSegment.handleInX === 0 && toSegment.handleInY === 0;
  return fromStraight && toStraight;
}

// ../../library/src/render/types/svgElementAttributeDefaults.ts
var svgElementAttributeDefaults = {
  stroke: "none",
  strokeWidth: 1,
  strokeLinecap: "butt",
  strokeLinejoin: "miter",
  strokeMiterlimit: 4,
  strokeDasharray: "0",
  strokeDashoffset: 0,
  strokeOpacity: 1,
  fill: "black",
  fillRule: "nonzero",
  fillOpacity: 1
};

// ../../library/src/render/utils/createTransformValues.ts
function createTransformValues(baseTransform, mode) {
  let { x, y } = baseTransform;
  const { width, height, rotation } = baseTransform;
  if (mode === "resetXY") {
    x = 0;
    y = 0;
  }
  return { x, y, width, height, rotation };
}
function getTransformMode(isRootVectorNode, includeTransform) {
  if (includeTransform !== void 0) {
    if (includeTransform) {
      return "asIs";
    }
  } else {
    if (!isRootVectorNode) {
      return "asIs";
    }
  }
  return "resetXY";
}
function transformValues(rect, rotation, isRootVectorNode, includeTransform) {
  const transformMode = getTransformMode(isRootVectorNode, includeTransform);
  const baseTransform = { ...rect, rotation: includeTransform === false ? 0 : rotation };
  const transform2 = createTransformValues(baseTransform, transformMode);
  return transform2;
}

// ../../library/src/render/utils/transformString.ts
function transformString2(transform2) {
  if (transform2 === void 0) {
    return void 0;
  }
  const { x, y, rotation, width, height } = transform2;
  let result;
  if (x !== 0 || y !== 0) {
    result = `translate(${roundedNumberString(x, 3)} ${roundedNumberString(y, 3)})`;
  }
  if (rotation !== 0) {
    const roundedRotation = roundedNumberString(rotation, 4);
    const roundedWidth = roundedNumberString(width / 2, 3);
    const roundedHeight = roundedNumberString(height / 2, 3);
    const rotationString = `rotate(${roundedRotation} ${roundedWidth} ${roundedHeight})`;
    result = result ? `${result} ${rotationString}` : rotationString;
  }
  return result;
}

// ../../library/src/render/presentation/GradientElement.tsx
import { Component as Component17 } from "react";
import { jsx as jsx95 } from "react/jsx-runtime";
var LinearGradientElement = class extends Component17 {
  render() {
    const { id, stops, x1, x2, y1, y2 } = this.props;
    return /* @__PURE__ */ jsx95("linearGradient", { id, x1, x2, y1, y2, children: stops.map((stop, idx) => {
      return /* @__PURE__ */ jsx95("stop", { offset: stop.position, stopColor: stop.color, stopOpacity: stop.alpha }, idx);
    }) });
  }
};
var RadialGradientElement = class extends Component17 {
  render() {
    const { centerAnchorX, centerAnchorY, id, widthFactor, heightFactor, stops } = this.props;
    return /* @__PURE__ */ jsx95(
      "radialGradient",
      {
        id,
        cy: centerAnchorY,
        cx: centerAnchorX,
        r: widthFactor,
        gradientTransform: getRadialGradientTransform(heightFactor, widthFactor, centerAnchorX, centerAnchorY),
        children: stops.map((stop, idx) => {
          return /* @__PURE__ */ jsx95("stop", { offset: stop.position, stopColor: stop.color, stopOpacity: stop.alpha }, idx);
        })
      }
    );
  }
};
function getRadialGradientTransform(heightFactor, widthFactor, centerAnchorX, centerAnchorY) {
  const scaleWidth = widthFactor ? heightFactor / widthFactor : 1e3;
  return `translate(${centerAnchorX}, ${centerAnchorY}) scale(1 ${scaleWidth}) translate(-${centerAnchorX}, -${centerAnchorY})`;
}

// ../../library/src/render/presentation/SVGRoot.tsx
import React92 from "react";
import { jsx as jsx96 } from "react/jsx-runtime";
var SVGRoot = (props) => {
  const { id, children, left, width, height, top, style, _needsMeasure } = props;
  const inCodeComponent = React92.useContext(ComponentContainerContext);
  const ref = React92.useRef(null);
  useMeasureLayout(
    {
      id,
      // SVGRoot won't be rendered if the node is invisible.
      visible: true,
      _needsMeasure
    },
    ref
  );
  const svgStyle = {
    position: "absolute",
    width,
    height,
    left,
    top,
    overflow: "visible",
    display: "block",
    ...style
  };
  const svgProps = {
    // Avoid duplicating IDs when the SVG is rendered through slots. We only need the ID for
    // measurement so code component descendants don't matter.
    id: inCodeComponent ? void 0 : id,
    viewBox: `0 0 ${width} ${height}`,
    ref
  };
  const needsScale = isSafari() ? window.devicePixelRatio !== 1 : window.devicePixelRatio === 1;
  const needsTranslate = window.devicePixelRatio === 1;
  if (!needsScale && !needsTranslate) {
    return /* @__PURE__ */ jsx96("svg", { role: "presentation", ...svgProps, style: svgStyle, children });
  }
  const svgTransform = needsScale ? { transform: "scale(2)" } : void 0;
  return /* @__PURE__ */ jsx96("svg", { role: "presentation", ...svgProps, style: { ...svgStyle, ...svgTransform }, children: /* @__PURE__ */ jsx96(
    "g",
    {
      style: {
        // The default value of transform-origin is 0 0 for all SVG elements except
        // for root <svg> elements:
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/transform-origin
        transformOrigin: "center",
        transform: getShapeTransform(needsScale, needsTranslate, left, top)
      },
      children
    }
  ) });
};
function getShapeTransform(needsScale, needsTranslate, left, top) {
  const l = Math.floor(left) - left;
  const t = Math.floor(top) - top;
  const transforms = [];
  if (needsScale) transforms.push("scale(0.5)");
  if (needsTranslate && (l || t)) transforms.push(`translate(${l}px, ${t}px)`);
  return transforms.length ? transforms.join(" ") : void 0;
}

// ../../library/src/render/presentation/Vector.tsx
import { jsx as jsx97, jsxs as jsxs23 } from "react/jsx-runtime";
var Vector = /* @__PURE__ */ (() => {
  var _a;
  return _a = class extends Layer {
    render() {
      countNodeRender();
      const {
        opacity,
        calculatedPath,
        calculatedPathBoundingBox,
        d,
        insideStroke,
        strokeEnabled,
        strokeClipId,
        strokeWidth,
        idAttribute,
        shadows,
        name,
        includeTransform,
        isRootVectorNode,
        rotation,
        id,
        lineCap,
        lineJoin,
        strokeColor,
        strokeMiterLimit,
        strokeDashArray,
        strokeDashOffset,
        fill,
        variants,
        transition,
        fillOpacity,
        visible,
        x,
        y,
        width,
        height
      } = this.props;
      if (!visible) return null;
      if (!id || !strokeClipId) return null;
      const rotate = this.props.rotate ?? rotation ?? 0;
      const { target } = RenderEnvironment;
      const rect = { x, y, width, height };
      const transform2 = transformValues(rect, rotate, isRootVectorNode, includeTransform);
      let vectorFill;
      let fillAlpha = 0;
      let imagePattern;
      let linearGradient;
      let radialGradient;
      if (isString(fill) || Color.isColorObject(fill)) {
        const fillColor = Color.isColorObject(fill) ? fill.initialValue || Color.toRgbString(fill) : fill;
        if (fillColor !== "transparent") {
          vectorFill = fillColor;
          fillAlpha = ConvertColor.getAlpha(vectorFill);
        }
      } else if (LinearGradient.isLinearGradient(fill)) {
        linearGradient = elementPropertiesForLinearGradient(fill, id);
        vectorFill = `url(#${linearGradient.id})`;
        fillAlpha = 1;
      } else if (RadialGradient.isRadialGradient(fill)) {
        radialGradient = elementPropertiesForRadialGradient(fill, id);
        vectorFill = `url(#${radialGradient.id})`;
        fillAlpha = 1;
      } else if (BackgroundImage.isImageObject(fill)) {
        imagePattern = imagePatternPropsForFill(fill, transform2, id, includeTransform);
        if (imagePattern) {
          vectorFill = `url(#${imagePattern.id})`;
          fillAlpha = 1;
        }
      }
      if (vectorFill === svgElementAttributeDefaults.fill) {
        vectorFill = void 0;
      }
      if (vectorFill === void 0) {
        vectorFill = "transparent";
      }
      const fillEnabled = vectorFill !== void 0 && vectorFill !== "transparent" && fillAlpha !== 0;
      if (!fillEnabled && !strokeEnabled) {
        fillAlpha = 1;
      }
      let mainElement;
      let strokeClipPath = null;
      let shapeReference = null;
      let strokeElement = null;
      let pathTranslate;
      let elementTransform;
      const translatePaths = target === RenderTarget.export;
      if (transform2.rotation === 0 && translatePaths) {
        pathTranslate = transform2;
      } else {
        pathTranslate = { x: 0, y: 0 };
        elementTransform = transformString2(transform2);
      }
      const pathAttributes = {
        d: d ?? toSVGPath(calculatedPath, pathTranslate, target),
        transform: elementTransform
      };
      const svgStrokeAttributes = {};
      if (strokeEnabled && strokeWidth !== 0) {
        svgStrokeAttributes.strokeWidth = strokeWidth;
        svgStrokeAttributes.stroke = strokeColor;
        svgStrokeAttributes.strokeLinecap = lineCap;
        svgStrokeAttributes.strokeLinejoin = lineJoin;
        if (lineJoin === "miter") {
          svgStrokeAttributes.strokeMiterlimit = strokeMiterLimit;
        }
        svgStrokeAttributes.strokeDasharray = strokeDashArray;
        if (strokeDashOffset !== 0) {
          svgStrokeAttributes.strokeDashoffset = strokeDashOffset;
        }
      }
      for (const key7 in svgElementAttributeDefaults) {
        if (asRecord(svgStrokeAttributes)[key7] === asRecord(svgElementAttributeDefaults)[key7]) {
          asRecord(svgStrokeAttributes)[key7] = void 0;
        }
      }
      const internalShapeId = InternalID.forKey(id);
      const internalStrokeClipId = InternalID.forKey(strokeClipId);
      const shadow = shadowForShape(
        shadows,
        // Shadow filter uses 'objectBoundingBox' as filter units, so calculations should be
        // relative to the referenced object itself (path), instead of the node rect, which
        // can be larger than the path bounding box.
        calculatedPathBoundingBox,
        internalShapeId,
        Boolean(fill),
        strokeEnabled,
        strokeWidth,
        internalStrokeClipId,
        svgStrokeAttributes
      );
      const currentName = target === RenderTarget.preview ? name || void 0 : void 0;
      if (shadow.insetElement !== null || shadow.outsetElement !== null || insideStroke) {
        pathAttributes.id = internalShapeId.id;
        shapeReference = /* @__PURE__ */ jsx97(motion.path, { ...{ ...pathAttributes }, variants, transition });
        if (shadow.needsStrokeClip || insideStroke) {
          strokeClipPath = /* @__PURE__ */ jsx97("clipPath", { id: internalStrokeClipId.id, children: /* @__PURE__ */ jsx97("use", { xlinkHref: internalShapeId.link }) });
        }
        if (shadow.insetElement !== null && strokeEnabled && strokeWidth && strokeWidth > 0) {
          mainElement = /* @__PURE__ */ jsx97(
            "use",
            {
              xlinkHref: internalShapeId.link,
              fill: vectorFill,
              fillOpacity,
              strokeOpacity: "0",
              name: currentName
            }
          );
          strokeElement = /* @__PURE__ */ jsx97(
            "use",
            {
              xlinkHref: internalShapeId.link,
              clipPath: internalStrokeClipId.urlLink,
              fill: "transparent",
              ...svgStrokeAttributes,
              strokeWidth
            }
          );
        } else {
          mainElement = /* @__PURE__ */ jsx97(
            "use",
            {
              xlinkHref: internalShapeId.link,
              fill: vectorFill,
              fillOpacity,
              clipPath: internalStrokeClipId.urlLink,
              ...svgStrokeAttributes,
              strokeWidth,
              name: currentName
            }
          );
        }
      } else {
        pathAttributes.id = idAttribute;
        mainElement = /* @__PURE__ */ jsx97(
          motion.path,
          {
            ...{
              ...pathAttributes,
              fill: vectorFill,
              ...svgStrokeAttributes
            },
            name: currentName,
            fillOpacity,
            variants,
            transition
          }
        );
      }
      const imagePatternElement = imagePattern ? /* @__PURE__ */ jsx97(
        ImagePatternElement,
        {
          ...imagePattern,
          repeat: BackgroundImage.isImageObject(fill) && fill.fit === "tile"
        }
      ) : void 0;
      let gradient;
      if (linearGradient) {
        gradient = /* @__PURE__ */ jsx97(LinearGradientElement, { ...linearGradient });
      } else if (radialGradient) {
        gradient = /* @__PURE__ */ jsx97(RadialGradientElement, { ...radialGradient });
      }
      let defs = null;
      if (shapeReference || strokeClipPath || shadow.definition && shadow.definition.length || gradient || imagePatternElement) {
        defs = /* @__PURE__ */ jsxs23("defs", { children: [
          shapeReference,
          strokeClipPath,
          shadow.definition,
          gradient,
          imagePatternElement
        ] });
      }
      const opacityValue = opacity ?? (variants ? 1 : void 0);
      if (defs === null && shadow.outsetElement === null && shadow.insetElement === null && strokeElement === null) {
        mainElement = /* @__PURE__ */ jsx97(
          motion.path,
          {
            ...{
              ...pathAttributes,
              fill: vectorFill,
              ...svgStrokeAttributes
            },
            fillOpacity,
            opacity: opacityValue,
            variants,
            transition,
            name: currentName
          }
        );
        return this.renderElement(mainElement);
      }
      return this.renderElement(
        /* @__PURE__ */ jsxs23(motion.g, { opacity: opacityValue, variants, transition, children: [
          defs,
          shadow.maskElement,
          shadow.outsetElement,
          mainElement,
          shadow.insetElement,
          strokeElement
        ] })
      );
    }
    renderElement(element) {
      const { id, isRootVectorNode, width, height, includeTransform, left, top, style, _needsMeasure } = this.props;
      if (!isRootVectorNode) return element;
      if (includeTransform) return element;
      return /* @__PURE__ */ jsx97(
        SVGRoot,
        {
          id,
          width,
          height,
          left,
          top,
          style,
          _needsMeasure,
          children: element
        }
      );
    }
  }, __publicField(_a, "defaultVectorProps", {
    isRootVectorNode: false,
    name: null,
    includeTransform: void 0,
    defaultFillColor: void 0,
    defaultStrokeColor: void 0,
    defaultStrokeWidth: void 0,
    defaultStrokeAlignment: "center",
    width: 100,
    height: 100,
    x: 0,
    y: 0,
    left: 0,
    top: 0,
    rotation: 0,
    rotate: void 0,
    opacity: void 0,
    calculatedPath: [],
    calculatedPathBoundingBox: { x: 0, y: 0, width: 0, height: 0 },
    d: void 0,
    insideStroke: false,
    strokeEnabled: true,
    strokeClipId: void 0,
    strokeWidth: void 0,
    idAttribute: void 0,
    transition: void 0,
    shadows: [],
    strokeAlpha: 1,
    lineCap: "butt",
    strokeColor: "#0AF",
    lineJoin: "miter",
    strokeMiterLimit: 4,
    strokeDashArray: "0",
    strokeDashOffset: 0,
    fill: "rgba(0,170,255,0.5)",
    visible: void 0
  }), __publicField(_a, "defaultProps", {
    ...Layer.defaultProps,
    ..._a.defaultVectorProps
  }), _a;
})();

// ../../library/src/render/presentation/VectorGroup.tsx
import { jsx as jsx98 } from "react/jsx-runtime";
var VectorGroup = /* @__PURE__ */ (() => {
  var _a;
  return _a = class extends Layer {
    render() {
      countNodeRender();
      const {
        name: nameProp,
        opacity,
        visible,
        targetName,
        defaultName,
        children,
        includeTransform,
        x,
        y,
        width,
        height,
        rotation,
        isRootVectorNode
      } = this.props;
      if (!visible) return null;
      const { target } = RenderEnvironment;
      const rect = { x, y, width, height };
      const transform2 = transformValues(rect, rotation, isRootVectorNode, includeTransform);
      const addNames = target === RenderTarget.preview;
      let name = void 0;
      if (addNames) {
        if (targetName) {
          name = targetName;
        } else if (nameProp) {
          name = nameProp;
        } else {
          name = defaultName;
        }
      }
      return this.renderElement(
        /* @__PURE__ */ jsx98("g", { transform: transformString2(transform2), ...{ name, opacity }, children })
      );
    }
    renderElement(element) {
      const { id, isRootVectorNode, width, height, includeTransform, left, top, style, _needsMeasure } = this.props;
      if (!isRootVectorNode) return element;
      if (includeTransform) return element;
      return /* @__PURE__ */ jsx98(
        SVGRoot,
        {
          id,
          left,
          top,
          width,
          height,
          style,
          _needsMeasure,
          children: element
        }
      );
    }
  }, __publicField(_a, "defaultVectorGroupProps", {
    name: void 0,
    opacity: void 0,
    visible: true,
    x: 0,
    y: 0,
    left: 0,
    top: 0,
    rotation: 0,
    width: 100,
    height: 100,
    targetName: void 0,
    defaultName: "",
    isRootVectorNode: false,
    includeTransform: void 0
  }), __publicField(_a, "defaultProps", {
    ...Layer.defaultProps,
    ..._a.defaultVectorGroupProps
  }), _a;
})();

// ../../library/src/render/traits/Shape.ts
var key6 = "calculatedPaths";
function withShape(target) {
  if (!isObject2(target)) return false;
  return key6 in target;
}

// ../../library/src/render/types/Size.ts
var Size = /* @__PURE__ */ (() => {
  function Size2(width, height) {
    return { width, height };
  }
  Size2.equals = (sizeA, sizeB) => {
    if (sizeA === sizeB) return true;
    if (!sizeA || !sizeB) return false;
    return sizeA.width === sizeB.width && sizeA.height === sizeB.height;
  };
  Size2.update = (fromSize, toSize, keepAspectRatio = false) => {
    let { width, height } = fromSize;
    const sizeRatio = width / height;
    width = toSize.width !== void 0 ? toSize.width : width;
    height = toSize.height !== void 0 ? toSize.height : height;
    if (keepAspectRatio) {
      if (toSize.width === void 0 && toSize.height !== void 0) {
        width = toSize.height * sizeRatio;
      }
      if (toSize.width !== void 0 && toSize.height === void 0 && sizeRatio !== 0) {
        height = toSize.width / sizeRatio;
      }
    }
    return { width, height };
  };
  Size2.subtract = (sizeA, sizeB) => {
    return {
      width: Math.max(0, sizeA.width - sizeB.width),
      height: Math.max(0, sizeA.height - sizeB.height)
    };
  };
  Size2.zero = Size2(0, 0);
  Size2.isZero = function(size) {
    return size === Size2.zero || size.width === 0 && size.height === 0;
  };
  Size2.defaultIfZero = function(width, height, size) {
    if (Size2.isZero(size)) {
      return Size2(width, height);
    }
    return size;
  };
  return Size2;
})();

// ../../library/src/render/utils/annotateTypeOnStringify.ts
function annotateTypeOnStringify(ctor, typeName) {
  const existingToJSON = ctor.prototype.toJSON;
  ctor.prototype.toJSON = function() {
    const base = existingToJSON ? existingToJSON.apply(this) : this;
    return Object.assign({}, base, { __type__: typeName });
  };
  return ctor;
}
function isOfAnnotatedType(object, typeName) {
  return object && object.__type__ && object.__type__ === typeName;
}

// ../../library/src/render/utils/getLoadingLazyAtYPosition.ts
var LOADING_LAZY_THRESHOLD = 1e3;
function getLoadingLazyAtYPosition(offset) {
  return offset > LOADING_LAZY_THRESHOLD ? "lazy" : void 0;
}

// ../../library/src/render/utils/gradientForShape.tsx
function gradientForShape(nodeId, node) {
  if (LinearGradient.isLinearGradient(node.fill)) {
    return elementPropertiesForLinearGradient(node.fill, nodeId);
  }
  if (RadialGradient.isRadialGradient(node.fill)) {
    return elementPropertiesForRadialGradient(node.fill, nodeId);
  }
  return void 0;
}

// ../../library/src/render/utils/throttle.ts
function throttle(fn, time2) {
  let previous = 0;
  let timeout;
  const later = (...args) => {
    previous = Date.now();
    timeout = void 0;
    fn(...args);
  };
  return (...args) => {
    const now = Date.now();
    const remaining = time2 - (now - previous);
    if (remaining <= 0 || remaining > time2) {
      if (timeout) {
        safeWindow.clearTimeout(timeout);
        timeout = void 0;
      }
      previous = now;
      fn(...args);
    } else if (!timeout) {
      timeout = safeWindow.setTimeout(later, remaining, ...args);
    }
  };
}

// ../../library/src/utils/addActionControls.ts
function addActionControls(action, title, controls) {
  runtime.addActionControls(action, title, controls);
}

// ../../library/src/utils/addFonts.ts
function addFonts(component, fontsOrBundles, flags) {
  const bundles = upgradeFontBundlesAsNeeded(fontsOrBundles);
  if (!flags?.supportsExplicitInterCodegen && // Only emit an `explicitInter: false` bundle if we dont already have one.
  !bundles.some((font) => font.explicitInter === false)) {
    bundles.push({ explicitInter: false, fonts: [] });
  }
  Object.assign(component, { fonts: bundles });
}
function getFonts(component) {
  if (!component) return emptyArray();
  const fonts = component.fonts;
  return fonts ?? emptyArray();
}
function getFontsFromSharedStyle(fontsOrBundles) {
  if (fontsOrBundles.length === 0) return [{ explicitInter: false, fonts: [] }];
  return upgradeFontBundlesAsNeeded(fontsOrBundles);
}
function getFontsFromComponentPreset(fonts) {
  if (fonts.length === 0) return [{ explicitInter: false, fonts: [] }];
  return upgradeFontBundlesAsNeeded(fonts);
}
function upgradeFontBundlesAsNeeded(fonts) {
  const oldFontBundle = { explicitInter: false, fonts: [] };
  const fontBundles = [];
  for (const fontOrBundle of fonts) {
    if (isComponentFontBundle(fontOrBundle)) {
      fontBundles.push({
        explicitInter: fontOrBundle.explicitInter,
        fonts: fontOrBundle.fonts.map(upgradeComponentFont)
      });
    } else {
      oldFontBundle.fonts.push(upgradeComponentFont(fontOrBundle));
    }
  }
  if (oldFontBundle.fonts.length > 0) fontBundles.push(oldFontBundle);
  return fontBundles;
}
var componentFontBundleKey = "explicitInter";
function isComponentFontBundle(font) {
  return componentFontBundleKey in font;
}
function upgradeComponentFont(font) {
  const fontV2 = hasComponentFontV2(font) || hasComponentFontV3(font) ? font : upgradeToComponentFontV2(font);
  const fontV3 = hasComponentFontV3(fontV2) ? fontV2 : upgradeToComponentFontV3(fontV2);
  return fontV3;
}
function hasComponentFontV2(font) {
  const key7 = "source";
  return key7 in font;
}
function hasComponentFontV3(font) {
  const key7 = "cssFamilyName";
  return key7 in font;
}
function upgradeToComponentFontV2(font) {
  let source;
  if (font.url.startsWith("https://fonts.gstatic.com/s/")) {
    source = "google" /* Google */;
  } else if (font.url.startsWith("https://framerusercontent.com/third-party-assets/fontshare/")) {
    source = "fontshare" /* Fontshare */;
  } else {
    source = "custom" /* Custom */;
  }
  return {
    ...font,
    source
  };
}
function upgradeToComponentFontV3(font) {
  const { family, ...rest } = font;
  const cssFamilyName = (
    // `font.source !== FontSourceNames.Custom` mimics the pre-ComponentFontV3 Vekter logic.
    // Without this, CSS font families used in `style={{ fontFamily: ... }}` wont match
    // `ComponentFont.cssFontFamily`s
    font.variationAxes && font.source !== "custom" /* Custom */ ? `${family} ${FRAMER_VARIABLE_FONT_SUFFIX}` : family
  );
  return {
    ...rest,
    uiFamilyName: family,
    cssFamilyName
  };
}

// ../../library/src/utils/withPerformanceMarks.ts
function withPerformanceMarks(prefix3, callback) {
  const markStart = `${prefix3}-start`;
  performance.mark(markStart);
  callback();
  const markEnd = `${prefix3}-end`;
  performance.mark(markEnd);
  performance.measure(prefix3, markStart, markEnd);
}

// ../../library/src/utils/network.ts
function loadJSON(url) {
  return fetch(url, { mode: "cors" }).then((res) => res.json());
}

// ../../library/src/utils/inspectObjectType.ts
function inspectObjectType(item) {
  let className2;
  if ((item.constructor !== null ? item.constructor.name : void 0) !== null && (item.constructor !== null ? item.constructor.name : void 0) !== "Object") {
    return item.constructor.name;
  }
  const extract = function(str) {
    if (!str) {
      return null;
    }
    const regex2 = /\[object (\w+)\]/u;
    const match = regex2.exec(str);
    if (match) {
      return match[1];
    }
    return null;
  };
  if (item.toString) {
    className2 = extract(item.toString());
    if (className2) {
      return className2;
    }
  }
  if (item.constructor !== null ? item.constructor.toString : void 0) {
    className2 = extract(item.constructor !== null ? item.constructor.toString() : void 0);
    if (className2) {
      return className2.replace("Constructor", "");
    }
  }
  return "Object";
}

// ../../library/src/utils/inspect.ts
function inspect(item, max, l) {
  if (max === void 0) {
    max = 5;
  }
  if (l === void 0) {
    l = 0;
  }
  if (item === null) {
    return "null";
  }
  if (item === void 0) {
    return "undefined";
  }
  if (isObject2(item) && isFunction(item.toInspect)) {
    return item.toInspect();
  }
  if (isString(item)) {
    return `"${item}"`;
  }
  if (isNumber(item)) {
    return `${item}`;
  }
  if (isFunction(item)) {
    let code = item.toString().slice("function ".length).replace(/\n/gu, "").replace(/\s+/gu, " ");
    const limit = 50;
    if (code.length > limit && l > 0) {
      code = `${code.slice(0, limit + 1).trim()}\u2026 }`;
    }
    return `<Function ${code}>`;
  }
  if (isArray(item)) {
    if (l > max) {
      return "[...]";
    }
    return `[${item.map((i) => inspect(i, max, (l || 0) + 1)).join(", ")}]`;
  }
  if (isObject2(item)) {
    let objectInfo;
    const objectType = inspectObjectType(item);
    if (/HTML\w+?Element/u.test(objectType)) {
      return `<${objectType}>`;
    }
    if (l > max) {
      objectInfo = "{...}";
    } else {
      const itemKeys = Object.keys(item);
      objectInfo = `{${itemKeys.map((k) => `${k}:${inspect(item[k], max, (l || 0) + 1)}`).join(", ")}}`;
    }
    if (objectType === "Object") {
      return objectInfo;
    }
    return `<${objectType} ${objectInfo}>`;
  }
  return `${item}`;
}

// ../../library/src/utils/print.ts
function print(...args) {
  const line = args.map((arg) => {
    return inspect(arg);
  }).join(", ");
  console.log(line);
}

// ../../library/src/utils/useInitialRouteComponent.ts
import { useEffect as useEffect35, useState as useState14 } from "react";
function initialRouteComponent(component) {
  if (!component) return null;
  if (withPreload(component)) return null;
  return component;
}
function useInitialRouteComponent(routes, homeNodeId) {
  const InitialRouteComponent = routes[homeNodeId]?.page;
  const [RouteComponent, setRouteComponent] = useState14(
    () => initialRouteComponent(InitialRouteComponent)
  );
  useEffect35(() => {
    if (withPreload(InitialRouteComponent)) {
      void (async () => {
        await InitialRouteComponent.preload();
        setRouteComponent(InitialRouteComponent);
      })();
    }
  }, []);
  return RouteComponent;
}

// ../../library/package.json
var package_default = {
  name: "framer",
  version: "2.4.1",
  private: true,
  type: "module",
  author: "Framer",
  license: "MIT",
  scripts: {
    coverage: "jest --coverage",
    lint: "eslint ./src --ext .ts,.tsx --format gha-codeframe --quiet --cache",
    "lint:ci": "yarn lint --cache-strategy content --cache-location $HOME/.cache/eslint/framer-library",
    "lint:fix": "yarn lint --fix",
    test: "jest",
    watch: "jest --watch",
    postinstall: "node postinstall.cjs"
  },
  dependencies: {
    devalue: "^5.4.2",
    eventemitter3: "^5.0.1",
    fontfaceobserver: "2.2.0",
    "hoist-non-react-statics": "^3.3.2",
    hsluv: "^1.0.1"
  },
  devDependencies: {
    "@juggle/resize-observer": "^3.4.0",
    "@microsoft/api-extractor": "^7.52.3",
    "@testing-library/dom": "^8.19.1",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^14.4.3",
    "@types/dom-navigation": "^1.0.6",
    "@types/fontfaceobserver": "2.1",
    "@types/google.fonts": "1.0",
    "@types/node": "22.18",
    "@types/react": "18.2",
    "@types/react-dom": "18.2",
    "@types/yargs": "^17.0.33",
    "@typescript-eslint/eslint-plugin": "^8.40.0",
    "@typescript-eslint/parser": "^8.40.0",
    chalk: "^4.1.2",
    eslint: "^8.57.1",
    "eslint-plugin-framer-studio": "workspace:*",
    immutable: "^3.8.2",
    jest: "29.4.1",
    "jest-diff": "^29.3.1",
    "jest-environment-jsdom": "^29.3.1",
    "jest-environment-jsdom-global": "^4.0.0",
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    semver: "^7.7.1",
    typescript: "^5.9.2",
    yargs: "^17.7.2"
  },
  peerDependencies: {
    "framer-motion": "12.20.2",
    react: "^18.2.0",
    "react-dom": "^18.2.0"
  },
  tsdoc: {
    tsdocFlavor: "AEDoc"
  },
  browserslist: [
    "extends @framer/browserslist-config/sites"
  ]
};

// ../../library/src/version.ts
var version = /* @__PURE__ */ (() => package_default.version)();

// ../../library/src/animation/Motion/addChildHack.ts
MotionValue.prototype.addChild = function({ transformer = (v) => v }) {
  const child = motionValue(transformer(this.get()));
  this.onChange((v) => child.set(transformer(v)));
  return child;
};

// ../../library/src/indexInternal.ts
if (false) {
  MainLoop2.start();
}
export {
  AnchorLinkTarget,
  Animatable,
  AnimatePresence,
  AnimateSharedLayout,
  AnyInterpolation,
  AsyncMotionValueAnimation,
  AutomaticLayoutIds,
  BackgroundImage,
  BezierAnimator,
  BoxShadow,
  ChildrenCanSuspend,
  CollectionUtilsCache,
  Color,
  ColorFormat,
  ColorMixModelType,
  ComponentContainerContext,
  ComponentPresetsConsumer,
  ComponentPresetsProvider,
  ComponentViewportProvider,
  ConstraintMask,
  ConstraintValues,
  Container,
  ControlType,
  ConvertColor,
  CustomCursorHost,
  CustomProperties,
  CycleVariantState,
  DOM,
  DOMKeyframesResolver,
  Data,
  DataContext,
  DataObserver,
  DataObserverContext,
  DeprecatedFrameWithEvents,
  DeprecatedLayoutGroupContext,
  Device,
  DeviceCodeComponent,
  DimensionType,
  DragControls,
  Draggable,
  EmptyState,
  ErrorPlaceholder,
  Fetcher,
  Floating,
  FontSourceNames,
  FormBooleanInput,
  FormContainer,
  FormPlainTextInput2 as FormPlainTextInput,
  FormSelect,
  Frame,
  FrameWithMotion,
  FramerAnimation,
  FramerEvent,
  FramerEventListener,
  FramerEventSession,
  GamepadContext,
  GeneratedComponentContext,
  GracefullyDegradingErrorBoundary,
  GroupAnimation,
  GroupAnimationWithThen,
  Image3 as Image,
  InjectSelectionStyle,
  Instance,
  InternalID,
  JSAnimation,
  KeyframeResolver,
  Layer,
  LayoutGroup,
  DeprecatedLayoutGroupContext as LayoutGroupContext,
  LayoutIdContext,
  LazyMotion,
  LazyValue,
  LibraryFeaturesProvider,
  Line,
  LinearGradient,
  Link,
  MainLoop,
  MotionConfig,
  MotionConfigContext,
  MotionContext,
  MotionGlobalConfig,
  MotionSetup,
  MotionValue,
  NativeAnimation,
  NativeAnimationExtended,
  NativeAnimationWrapper,
  NavigateTo,
  NavigationWrapper as Navigation,
  NavigationCallbackProvider,
  NavigationConsumer,
  NavigationTransitionType,
  NotFoundError,
  ObservableObject,
  Page3 as Page,
  PageEffectsProvider,
  PageRoot,
  ParentSizeState,
  PathSegment,
  PathVariablesContext,
  Point,
  Polygon,
  PopChild,
  PresenceChild,
  PresenceContext,
  PropertyOverrides2 as PropertyOverrides,
  PropertyStore,
  QueryCache,
  QueryEngine,
  RadialGradient,
  Rect,
  RelativeDate,
  RenderTarget,
  namespace_exports as Reorder,
  ResetOuterLinkContext,
  ResolveLinks,
  RichText,
  SSRVariants,
  SVG,
  Scroll,
  Shadow,
  Size,
  SmartComponentScopedContainer,
  SpringAnimator,
  Stack,
  StyleSheetContext,
  SubscriptionManager,
  SwitchLayoutGroupContext,
  Text2 as Text,
  TickerItem,
  ValueInterpolation,
  VariantSelector,
  Vector,
  VectorGroup,
  ViewTransitionBuilder,
  VisualElement,
  WillChangeMotionValue,
  WindowContext,
  WithNavigator,
  WithOverride,
  _injectRuntime,
  acceleratedValues,
  activeAnimations,
  addActionControls,
  addAttrValue,
  addFonts,
  addPointerEvent,
  addPointerInfo,
  addPropertyControls,
  addScaleCorrector,
  addStyleValue,
  addUniqueItem,
  alpha,
  analyseComplexValue,
  animate2 as animate,
  animateMini,
  animateValue,
  animateView,
  animateVisualElement,
  animationControls,
  animationMapKey,
  animations,
  annotateTypeOnStringify,
  anticipate,
  applyGeneratorOptions,
  applyPxDefaults,
  attachSpring,
  attrEffect,
  backIn,
  backInOut,
  backOut,
  backgroundImageFromProps,
  buildTransform,
  calcGeneratorDuration,
  calcLength,
  calculateRect,
  callEach,
  cancelFrame,
  cancelMicrotask,
  cancelSync,
  circIn,
  circInOut,
  circOut,
  clamp,
  clampRGB,
  collectMotionValues,
  collectVisualStyleFromProps,
  color,
  combinedCSSRulesForPreview,
  complex,
  constraintsEnabled,
  convertOffsetToTimes,
  convertPropsToDeviceOptions,
  createBox,
  createData,
  createFramerPageLink,
  createGeneratorEasing,
  createRenderBatcher,
  createScopedAnimate,
  cssBackgroundSize,
  cssCollector,
  cubicBezier,
  cubicBezierAsString,
  cx,
  debounce2 as debounce,
  defaultDeviceProps,
  defaultEasing,
  defaultOffset,
  defaultTransformValue,
  defaultValueTypes,
  degrees,
  degreesToRadians,
  delay,
  devicePresets,
  dimensionValueTypes,
  disableInstantTransitions,
  dispatchKeyDownEvent,
  distance,
  distance2D,
  domAnimation,
  domMax,
  domMin,
  easeIn,
  easeInOut,
  easeOut,
  easingDefinitionToFunction,
  environment,
  executeInRenderEnvironment,
  fillOffset,
  fillWildcards,
  filterProps,
  findDimensionValueType,
  findValueType,
  finiteNumber,
  flushKeyframeResolvers,
  fontStore,
  forceLayerBackingWithCSSProperties,
  fraction,
  frame,
  frameData,
  frameFromElement,
  frameFromElements,
  frameSteps,
  framerAppearAnimationScriptKey,
  framerAppearEffects,
  framerAppearIdKey,
  framerAppearTransformTemplateToken,
  framerCSSMarker,
  generateLinearEasing,
  getAnimatableNone,
  getAnimationMap,
  getComponentSize,
  getComputedStyle2 as getComputedStyle,
  getDefaultValueType,
  getDevicePreset,
  getEasingForSegment,
  getFonts,
  getFontsFromComponentPreset,
  getFontsFromSharedStyle,
  getLoadingLazyAtYPosition,
  getMeasurableCodeComponentChildren,
  getMixer,
  getOriginIndex,
  getPropertyControls,
  getValueAsType,
  getValueTransition,
  getVariableValue,
  getViewAnimationLayerInfo,
  getViewAnimations,
  getWhereExpressionFromPathVariables,
  gradientForShape,
  handoverCollector,
  hasWarned,
  hex,
  hover,
  hsla,
  hslaToRgba,
  imagePatternPropsForFill,
  imageUrlForAsset,
  inView,
  inertia,
  inferInitialRouteFromPath,
  initLazyModulesCache,
  injectComponentCSSRules,
  installFlexboxGapWorkaroundIfNeeded,
  interpolate,
  invariant,
  invisibleValues,
  isAnimatable,
  isBezierDefinition,
  isBrowser,
  isCSSVariableName,
  isCSSVariableToken,
  isDragActive,
  isDragging,
  isEasingArray,
  isEqual,
  isFiniteNumber,
  isFractionDimension,
  isFramerGamepadKeydownData,
  isFramerPageLink,
  isGapEnabled,
  isGenerator,
  isHTMLElement,
  isMotionComponent,
  isMotionValue2 as isMotionValue,
  isNodeOrChild,
  isNumericalString,
  isObject,
  isOfAnnotatedType,
  isPrimaryPointer,
  isRelativeNumber,
  isSVGElement,
  isSVGSVGElement,
  isShallowEqualArray,
  isStaticRenderer,
  isStraightCurve,
  isValidMotionProp,
  isWaapiSupportedEasing,
  isZeroValueString,
  keyframes,
  lazy,
  lazyModulesCollector,
  loadFont,
  loadJSON,
  localShadowFrame,
  m,
  makeAnimationInstant,
  makePaddingString,
  makeUseVisualState,
  mapEasingToNativeEasing,
  mapValue,
  markHydrationStart,
  maxGeneratorDuration,
  memo,
  memoize2 as memoize,
  microtask,
  millisecondsToSeconds,
  mirrorEasing,
  mix,
  mixArray,
  mixColor,
  mixComplex,
  mixImmediate,
  mixLinearColor,
  mixNumber,
  mixObject,
  mixVisibility,
  modulate,
  motion,
  motionValue,
  moveItem,
  nestedLinksCollector,
  noop,
  number,
  numberValueTypes,
  observeTimeline,
  optimizeAppear,
  optimizeAppearTransformTemplate,
  optimizedAppearDataAttribute,
  paddingFromProps,
  parseCSSVariable,
  parseFramerPageLink,
  parseValueFromTransform,
  patchRoutesForABTesting,
  pathDefaults,
  percent,
  pipe,
  positionalKeys,
  preloadImage,
  press,
  print,
  progress,
  progressPercentage,
  propEffect,
  propsForLink,
  pushLoadMoreHistory,
  px,
  readTransformValue,
  recordStats,
  removeHiddenBreakpointLayers,
  removeHiddenBreakpointLayersV2,
  removeItem,
  resize,
  resolveElements,
  resolveLink,
  resolveMotionValue,
  resolvePageScope,
  reverseEasing,
  rgbUnit,
  rgba,
  roundWithOffset,
  roundedNumber,
  roundedNumberString,
  safeCSSValue,
  scale,
  scroll,
  scrollInfo,
  secondsToMilliseconds,
  setDragLock,
  setGlobalRenderEnvironment,
  setStyle,
  sharedSVGManager,
  shouldOpenLinkInNewTab,
  spring,
  springValue,
  stagger,
  startAnimation,
  startOptimizedAppearAnimation,
  startWaapiAnimation,
  statsBuffer,
  steps,
  styleEffect,
  supportedWaapiEasing,
  supportsBrowserAnimation,
  supportsFlags,
  supportsLinearEasing,
  supportsPartialKeyframes,
  supportsScrollTimeline,
  svgEffect,
  sync,
  systemFontFamilyName,
  testValueType,
  throttle,
  time,
  toFlexDirection,
  toJustifyOrAlignment,
  toSVGPath,
  transform,
  transformPropOrder,
  transformProps,
  transformString2 as transformString,
  transformTemplate,
  transformValue,
  transformValueTypes,
  turnOffReactEventHandling,
  unwrapMotionComponent,
  useActiveTargetCallback,
  useActiveVariantCallback,
  useAddVariantProps,
  useAnimate,
  useAnimateMini,
  useAnimatedState,
  useAnimation,
  useAnimationControls,
  useAnimationFrame,
  useBreakpointVariants,
  useCollectionReferenceQueryParam,
  useComponentViewport,
  useComposedRefs,
  useConstant,
  useCurrentPathVariables,
  useCurrentRoute,
  useCurrentRouteId,
  useCustomCursors,
  useCycle,
  useDataRecord,
  useAnimatedState as useDeprecatedAnimatedState,
  useInvertedScale as useDeprecatedInvertedScale,
  useDomEvent,
  useDragControls,
  useDynamicRefs,
  useElementScroll,
  useForceUpdate,
  useGamepad,
  useHotkey,
  useHydratedBreakpointVariants,
  useInView,
  useInitialRouteComponent,
  useInstantLayoutTransition,
  useInstantTransition,
  useInvertedScale,
  useIsInCurrentNavigationTarget,
  useIsOnFramerCanvas,
  useIsPresent,
  useIsStaticRenderer,
  useIsomorphicLayoutEffect,
  useLayoutDirection,
  useLoadMorePaginatedQuery,
  useLoadMorePagination,
  useLocale,
  useLocaleCode,
  useLocaleInfo,
  useLocalesForCurrentRoute,
  useLocalizationInfo,
  useMeasureLayout,
  useMetadata,
  useMotionTemplate,
  useMotionValue,
  useMotionValueEvent,
  useMultiCollectionReferenceQueryParam,
  useNavigate,
  useNavigation,
  useObserveData,
  useOnAppear,
  useOnCurrentTargetChange,
  useOnVariantChange,
  useOverlayState,
  usePageEffects,
  usePageInView,
  usePrefetch,
  usePreloadQuery,
  usePresence,
  usePresenceData,
  usePrototypeNavigate,
  useProvidedWindow,
  useQueryData,
  useReducedMotion,
  useReducedMotionConfig,
  useRenderEnvironment,
  useResetProjection,
  useRoute,
  useRouteAnchor,
  useRouteElementId,
  useRouteHandler,
  useRouter,
  useSVGTemplate,
  useScroll,
  useSiteRefs,
  useSpring,
  useStringQueryParam,
  useTime,
  useTracking,
  useTransform,
  useUnmountEffect,
  useVariantState,
  useVelocity,
  useViewportScroll,
  useWillChange,
  valueToDimensionType,
  velocityPerSecond,
  version,
  vh,
  visualElementStore,
  vw,
  warnOnce,
  warning,
  withCSS,
  withCodeBoundaryForOverrides,
  withColumnMasonryLayout,
  withFX,
  withGeneratedLayoutId,
  withInfiniteScroll,
  withMappedReactProps,
  withMeasuredSize,
  withOpacity,
  withOptimizedAppearEffect,
  withParallaxTransform,
  withPath,
  withPerformanceMarks,
  withShape,
  withStyleAppearEffect,
  withTickerFX,
  withV1StrokeFX,
  withVariantAppearEffect,
  withVariantFX,
  wrap,
  yieldToMain
};
//! Credit to Astro | MIT License
/**
 * @license Emotion v11.0.0
 * MIT License
 *
 * Copyright (c) Emotion team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/*! Bundled license information:

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=framer.WATQBN32.mjs.map
